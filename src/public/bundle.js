(function () {
  'use strict';

  /**
   * @license Angular v7.2.8
   * (c) 2010-2019 Google LLC. https://angular.io/
   * License: MIT
   */

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TagContentType;
  (function (TagContentType) {
      TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
      TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
      TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
  })(TagContentType || (TagContentType = {}));
  function splitNsName(elementName) {
      if (elementName[0] != ':') {
          return [null, elementName];
      }
      const colonIndex = elementName.indexOf(':', 1);
      if (colonIndex == -1) {
          throw new Error(`Unsupported format "${elementName}" expecting ":namespace:name"`);
      }
      return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
  }
  // `<ng-container>` tags work the same regardless the namespace
  function isNgContainer(tagName) {
      return splitNsName(tagName)[1] === 'ng-container';
  }
  // `<ng-content>` tags work the same regardless the namespace
  function isNgContent(tagName) {
      return splitNsName(tagName)[1] === 'ng-content';
  }
  // `<ng-template>` tags work the same regardless the namespace
  function isNgTemplate(tagName) {
      return splitNsName(tagName)[1] === 'ng-template';
  }
  function getNsPrefix(fullName) {
      return fullName === null ? null : splitNsName(fullName)[0];
  }
  function mergeNsAndName(prefix, localName) {
      return prefix ? `:${prefix}:${localName}` : localName;
  }
  // see http://www.w3.org/TR/html51/syntax.html#named-character-references
  // see https://html.spec.whatwg.org/multipage/entities.json
  // This list is not exhaustive to keep the compiler footprint low.
  // The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not
  // exist.
  const NAMED_ENTITIES = {
      'Aacute': '\u00C1',
      'aacute': '\u00E1',
      'Acirc': '\u00C2',
      'acirc': '\u00E2',
      'acute': '\u00B4',
      'AElig': '\u00C6',
      'aelig': '\u00E6',
      'Agrave': '\u00C0',
      'agrave': '\u00E0',
      'alefsym': '\u2135',
      'Alpha': '\u0391',
      'alpha': '\u03B1',
      'amp': '&',
      'and': '\u2227',
      'ang': '\u2220',
      'apos': '\u0027',
      'Aring': '\u00C5',
      'aring': '\u00E5',
      'asymp': '\u2248',
      'Atilde': '\u00C3',
      'atilde': '\u00E3',
      'Auml': '\u00C4',
      'auml': '\u00E4',
      'bdquo': '\u201E',
      'Beta': '\u0392',
      'beta': '\u03B2',
      'brvbar': '\u00A6',
      'bull': '\u2022',
      'cap': '\u2229',
      'Ccedil': '\u00C7',
      'ccedil': '\u00E7',
      'cedil': '\u00B8',
      'cent': '\u00A2',
      'Chi': '\u03A7',
      'chi': '\u03C7',
      'circ': '\u02C6',
      'clubs': '\u2663',
      'cong': '\u2245',
      'copy': '\u00A9',
      'crarr': '\u21B5',
      'cup': '\u222A',
      'curren': '\u00A4',
      'dagger': '\u2020',
      'Dagger': '\u2021',
      'darr': '\u2193',
      'dArr': '\u21D3',
      'deg': '\u00B0',
      'Delta': '\u0394',
      'delta': '\u03B4',
      'diams': '\u2666',
      'divide': '\u00F7',
      'Eacute': '\u00C9',
      'eacute': '\u00E9',
      'Ecirc': '\u00CA',
      'ecirc': '\u00EA',
      'Egrave': '\u00C8',
      'egrave': '\u00E8',
      'empty': '\u2205',
      'emsp': '\u2003',
      'ensp': '\u2002',
      'Epsilon': '\u0395',
      'epsilon': '\u03B5',
      'equiv': '\u2261',
      'Eta': '\u0397',
      'eta': '\u03B7',
      'ETH': '\u00D0',
      'eth': '\u00F0',
      'Euml': '\u00CB',
      'euml': '\u00EB',
      'euro': '\u20AC',
      'exist': '\u2203',
      'fnof': '\u0192',
      'forall': '\u2200',
      'frac12': '\u00BD',
      'frac14': '\u00BC',
      'frac34': '\u00BE',
      'frasl': '\u2044',
      'Gamma': '\u0393',
      'gamma': '\u03B3',
      'ge': '\u2265',
      'gt': '>',
      'harr': '\u2194',
      'hArr': '\u21D4',
      'hearts': '\u2665',
      'hellip': '\u2026',
      'Iacute': '\u00CD',
      'iacute': '\u00ED',
      'Icirc': '\u00CE',
      'icirc': '\u00EE',
      'iexcl': '\u00A1',
      'Igrave': '\u00CC',
      'igrave': '\u00EC',
      'image': '\u2111',
      'infin': '\u221E',
      'int': '\u222B',
      'Iota': '\u0399',
      'iota': '\u03B9',
      'iquest': '\u00BF',
      'isin': '\u2208',
      'Iuml': '\u00CF',
      'iuml': '\u00EF',
      'Kappa': '\u039A',
      'kappa': '\u03BA',
      'Lambda': '\u039B',
      'lambda': '\u03BB',
      'lang': '\u27E8',
      'laquo': '\u00AB',
      'larr': '\u2190',
      'lArr': '\u21D0',
      'lceil': '\u2308',
      'ldquo': '\u201C',
      'le': '\u2264',
      'lfloor': '\u230A',
      'lowast': '\u2217',
      'loz': '\u25CA',
      'lrm': '\u200E',
      'lsaquo': '\u2039',
      'lsquo': '\u2018',
      'lt': '<',
      'macr': '\u00AF',
      'mdash': '\u2014',
      'micro': '\u00B5',
      'middot': '\u00B7',
      'minus': '\u2212',
      'Mu': '\u039C',
      'mu': '\u03BC',
      'nabla': '\u2207',
      'nbsp': '\u00A0',
      'ndash': '\u2013',
      'ne': '\u2260',
      'ni': '\u220B',
      'not': '\u00AC',
      'notin': '\u2209',
      'nsub': '\u2284',
      'Ntilde': '\u00D1',
      'ntilde': '\u00F1',
      'Nu': '\u039D',
      'nu': '\u03BD',
      'Oacute': '\u00D3',
      'oacute': '\u00F3',
      'Ocirc': '\u00D4',
      'ocirc': '\u00F4',
      'OElig': '\u0152',
      'oelig': '\u0153',
      'Ograve': '\u00D2',
      'ograve': '\u00F2',
      'oline': '\u203E',
      'Omega': '\u03A9',
      'omega': '\u03C9',
      'Omicron': '\u039F',
      'omicron': '\u03BF',
      'oplus': '\u2295',
      'or': '\u2228',
      'ordf': '\u00AA',
      'ordm': '\u00BA',
      'Oslash': '\u00D8',
      'oslash': '\u00F8',
      'Otilde': '\u00D5',
      'otilde': '\u00F5',
      'otimes': '\u2297',
      'Ouml': '\u00D6',
      'ouml': '\u00F6',
      'para': '\u00B6',
      'permil': '\u2030',
      'perp': '\u22A5',
      'Phi': '\u03A6',
      'phi': '\u03C6',
      'Pi': '\u03A0',
      'pi': '\u03C0',
      'piv': '\u03D6',
      'plusmn': '\u00B1',
      'pound': '\u00A3',
      'prime': '\u2032',
      'Prime': '\u2033',
      'prod': '\u220F',
      'prop': '\u221D',
      'Psi': '\u03A8',
      'psi': '\u03C8',
      'quot': '\u0022',
      'radic': '\u221A',
      'rang': '\u27E9',
      'raquo': '\u00BB',
      'rarr': '\u2192',
      'rArr': '\u21D2',
      'rceil': '\u2309',
      'rdquo': '\u201D',
      'real': '\u211C',
      'reg': '\u00AE',
      'rfloor': '\u230B',
      'Rho': '\u03A1',
      'rho': '\u03C1',
      'rlm': '\u200F',
      'rsaquo': '\u203A',
      'rsquo': '\u2019',
      'sbquo': '\u201A',
      'Scaron': '\u0160',
      'scaron': '\u0161',
      'sdot': '\u22C5',
      'sect': '\u00A7',
      'shy': '\u00AD',
      'Sigma': '\u03A3',
      'sigma': '\u03C3',
      'sigmaf': '\u03C2',
      'sim': '\u223C',
      'spades': '\u2660',
      'sub': '\u2282',
      'sube': '\u2286',
      'sum': '\u2211',
      'sup': '\u2283',
      'sup1': '\u00B9',
      'sup2': '\u00B2',
      'sup3': '\u00B3',
      'supe': '\u2287',
      'szlig': '\u00DF',
      'Tau': '\u03A4',
      'tau': '\u03C4',
      'there4': '\u2234',
      'Theta': '\u0398',
      'theta': '\u03B8',
      'thetasym': '\u03D1',
      'thinsp': '\u2009',
      'THORN': '\u00DE',
      'thorn': '\u00FE',
      'tilde': '\u02DC',
      'times': '\u00D7',
      'trade': '\u2122',
      'Uacute': '\u00DA',
      'uacute': '\u00FA',
      'uarr': '\u2191',
      'uArr': '\u21D1',
      'Ucirc': '\u00DB',
      'ucirc': '\u00FB',
      'Ugrave': '\u00D9',
      'ugrave': '\u00F9',
      'uml': '\u00A8',
      'upsih': '\u03D2',
      'Upsilon': '\u03A5',
      'upsilon': '\u03C5',
      'Uuml': '\u00DC',
      'uuml': '\u00FC',
      'weierp': '\u2118',
      'Xi': '\u039E',
      'xi': '\u03BE',
      'Yacute': '\u00DD',
      'yacute': '\u00FD',
      'yen': '\u00A5',
      'yuml': '\u00FF',
      'Yuml': '\u0178',
      'Zeta': '\u0396',
      'zeta': '\u03B6',
      'zwj': '\u200D',
      'zwnj': '\u200C',
  };
  // The &ngsp; pseudo-entity is denoting a space. see:
  // https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart
  const NGSP_UNICODE = '\uE500';
  NAMED_ENTITIES['ngsp'] = NGSP_UNICODE;

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class HtmlTagDefinition {
      constructor({ closedByChildren, requiredParents, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false } = {}) {
          this.closedByChildren = {};
          this.closedByParent = false;
          this.canSelfClose = false;
          if (closedByChildren && closedByChildren.length > 0) {
              closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);
          }
          this.isVoid = isVoid;
          this.closedByParent = closedByParent || isVoid;
          if (requiredParents && requiredParents.length > 0) {
              this.requiredParents = {};
              // The first parent is the list is automatically when none of the listed parents are present
              this.parentToAdd = requiredParents[0];
              requiredParents.forEach(tagName => this.requiredParents[tagName] = true);
          }
          this.implicitNamespacePrefix = implicitNamespacePrefix || null;
          this.contentType = contentType;
          this.ignoreFirstLf = ignoreFirstLf;
      }
      requireExtraParent(currentParent) {
          if (!this.requiredParents) {
              return false;
          }
          if (!currentParent) {
              return true;
          }
          const lcParent = currentParent.toLowerCase();
          const isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';
          return !isParentTemplate && this.requiredParents[lcParent] != true;
      }
      isClosedByChild(name) {
          return this.isVoid || name.toLowerCase() in this.closedByChildren;
      }
  }
  let _DEFAULT_TAG_DEFINITION;
  // see http://www.w3.org/TR/html51/syntax.html#optional-tags
  // This implementation does not fully conform to the HTML5 spec.
  let TAG_DEFINITIONS;
  function getHtmlTagDefinition(tagName) {
      if (!TAG_DEFINITIONS) {
          _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
          TAG_DEFINITIONS = {
              'base': new HtmlTagDefinition({ isVoid: true }),
              'meta': new HtmlTagDefinition({ isVoid: true }),
              'area': new HtmlTagDefinition({ isVoid: true }),
              'embed': new HtmlTagDefinition({ isVoid: true }),
              'link': new HtmlTagDefinition({ isVoid: true }),
              'img': new HtmlTagDefinition({ isVoid: true }),
              'input': new HtmlTagDefinition({ isVoid: true }),
              'param': new HtmlTagDefinition({ isVoid: true }),
              'hr': new HtmlTagDefinition({ isVoid: true }),
              'br': new HtmlTagDefinition({ isVoid: true }),
              'source': new HtmlTagDefinition({ isVoid: true }),
              'track': new HtmlTagDefinition({ isVoid: true }),
              'wbr': new HtmlTagDefinition({ isVoid: true }),
              'p': new HtmlTagDefinition({
                  closedByChildren: [
                      'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',
                      'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',
                      'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',
                      'p', 'pre', 'section', 'table', 'ul'
                  ],
                  closedByParent: true
              }),
              'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),
              'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),
              'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),
              'tr': new HtmlTagDefinition({
                  closedByChildren: ['tr'],
                  requiredParents: ['tbody', 'tfoot', 'thead'],
                  closedByParent: true
              }),
              'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
              'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),
              'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),
              'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),
              'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),
              'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),
              'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),
              'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),
              'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
              'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
              'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),
              'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),
              'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),
              'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),
              'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),
              'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),
              'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
              'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),
              'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),
              'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),
          };
      }
      return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' + //":not("
      '([-\\w]+)|' + // "tag"
      '(?:\\.([-\\w]+))|' + // ".class"
      // "-" should appear first in the regexp below as FF31 parses "[.-\w]" as a range
      '(?:\\[([-.\\w*]+)(?:=([\"\']?)([^\\]\"\']*)\\5)?\\])|' + // "[name]", "[name=value]",
      // "[name="value"]",
      // "[name='value']"
      '(\\))|' + // ")"
      '(\\s*,\\s*)', // ","
  'g');
  /**
   * A css selector contains an element name,
   * css classes and attribute/value pairs with the purpose
   * of selecting subsets out of them.
   */
  class CssSelector {
      constructor() {
          this.element = null;
          this.classNames = [];
          /**
           * The selectors are encoded in pairs where:
           * - even locations are attribute names
           * - odd locations are attribute values.
           *
           * Example:
           * Selector: `[key1=value1][key2]` would parse to:
           * ```
           * ['key1', 'value1', 'key2', '']
           * ```
           */
          this.attrs = [];
          this.notSelectors = [];
      }
      static parse(selector) {
          const results = [];
          const _addResult = (res, cssSel) => {
              if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&
                  cssSel.attrs.length == 0) {
                  cssSel.element = '*';
              }
              res.push(cssSel);
          };
          let cssSelector = new CssSelector();
          let match;
          let current = cssSelector;
          let inNot = false;
          _SELECTOR_REGEXP.lastIndex = 0;
          while (match = _SELECTOR_REGEXP.exec(selector)) {
              if (match[1]) {
                  if (inNot) {
                      throw new Error('Nesting :not is not allowed in a selector');
                  }
                  inNot = true;
                  current = new CssSelector();
                  cssSelector.notSelectors.push(current);
              }
              if (match[2]) {
                  current.setElement(match[2]);
              }
              if (match[3]) {
                  current.addClassName(match[3]);
              }
              if (match[4]) {
                  current.addAttribute(match[4], match[6]);
              }
              if (match[7]) {
                  inNot = false;
                  current = cssSelector;
              }
              if (match[8]) {
                  if (inNot) {
                      throw new Error('Multiple selectors in :not are not supported');
                  }
                  _addResult(results, cssSelector);
                  cssSelector = current = new CssSelector();
              }
          }
          _addResult(results, cssSelector);
          return results;
      }
      isElementSelector() {
          return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&
              this.notSelectors.length === 0;
      }
      hasElementSelector() { return !!this.element; }
      setElement(element = null) { this.element = element; }
      /** Gets a template string for an element that matches the selector. */
      getMatchingElementTemplate() {
          const tagName = this.element || 'div';
          const classAttr = this.classNames.length > 0 ? ` class="${this.classNames.join(' ')}"` : '';
          let attrs = '';
          for (let i = 0; i < this.attrs.length; i += 2) {
              const attrName = this.attrs[i];
              const attrValue = this.attrs[i + 1] !== '' ? `="${this.attrs[i + 1]}"` : '';
              attrs += ` ${attrName}${attrValue}`;
          }
          return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :
              `<${tagName}${classAttr}${attrs}></${tagName}>`;
      }
      getAttrs() {
          const result = [];
          if (this.classNames.length > 0) {
              result.push('class', this.classNames.join(' '));
          }
          return result.concat(this.attrs);
      }
      addAttribute(name, value = '') {
          this.attrs.push(name, value && value.toLowerCase() || '');
      }
      addClassName(name) { this.classNames.push(name.toLowerCase()); }
      toString() {
          let res = this.element || '';
          if (this.classNames) {
              this.classNames.forEach(klass => res += `.${klass}`);
          }
          if (this.attrs) {
              for (let i = 0; i < this.attrs.length; i += 2) {
                  const name = this.attrs[i];
                  const value = this.attrs[i + 1];
                  res += `[${name}${value ? '=' + value : ''}]`;
              }
          }
          this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);
          return res;
      }
  }
  /**
   * Reads a list of CssSelectors and allows to calculate which ones
   * are contained in a given CssSelector.
   */
  class SelectorMatcher {
      constructor() {
          this._elementMap = new Map();
          this._elementPartialMap = new Map();
          this._classMap = new Map();
          this._classPartialMap = new Map();
          this._attrValueMap = new Map();
          this._attrValuePartialMap = new Map();
          this._listContexts = [];
      }
      static createNotMatcher(notSelectors) {
          const notMatcher = new SelectorMatcher();
          notMatcher.addSelectables(notSelectors, null);
          return notMatcher;
      }
      addSelectables(cssSelectors, callbackCtxt) {
          let listContext = null;
          if (cssSelectors.length > 1) {
              listContext = new SelectorListContext(cssSelectors);
              this._listContexts.push(listContext);
          }
          for (let i = 0; i < cssSelectors.length; i++) {
              this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
          }
      }
      /**
       * Add an object that can be found later on by calling `match`.
       * @param cssSelector A css selector
       * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
       */
      _addSelectable(cssSelector, callbackCtxt, listContext) {
          let matcher = this;
          const element = cssSelector.element;
          const classNames = cssSelector.classNames;
          const attrs = cssSelector.attrs;
          const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
          if (element) {
              const isTerminal = attrs.length === 0 && classNames.length === 0;
              if (isTerminal) {
                  this._addTerminal(matcher._elementMap, element, selectable);
              }
              else {
                  matcher = this._addPartial(matcher._elementPartialMap, element);
              }
          }
          if (classNames) {
              for (let i = 0; i < classNames.length; i++) {
                  const isTerminal = attrs.length === 0 && i === classNames.length - 1;
                  const className = classNames[i];
                  if (isTerminal) {
                      this._addTerminal(matcher._classMap, className, selectable);
                  }
                  else {
                      matcher = this._addPartial(matcher._classPartialMap, className);
                  }
              }
          }
          if (attrs) {
              for (let i = 0; i < attrs.length; i += 2) {
                  const isTerminal = i === attrs.length - 2;
                  const name = attrs[i];
                  const value = attrs[i + 1];
                  if (isTerminal) {
                      const terminalMap = matcher._attrValueMap;
                      let terminalValuesMap = terminalMap.get(name);
                      if (!terminalValuesMap) {
                          terminalValuesMap = new Map();
                          terminalMap.set(name, terminalValuesMap);
                      }
                      this._addTerminal(terminalValuesMap, value, selectable);
                  }
                  else {
                      const partialMap = matcher._attrValuePartialMap;
                      let partialValuesMap = partialMap.get(name);
                      if (!partialValuesMap) {
                          partialValuesMap = new Map();
                          partialMap.set(name, partialValuesMap);
                      }
                      matcher = this._addPartial(partialValuesMap, value);
                  }
              }
          }
      }
      _addTerminal(map, name, selectable) {
          let terminalList = map.get(name);
          if (!terminalList) {
              terminalList = [];
              map.set(name, terminalList);
          }
          terminalList.push(selectable);
      }
      _addPartial(map, name) {
          let matcher = map.get(name);
          if (!matcher) {
              matcher = new SelectorMatcher();
              map.set(name, matcher);
          }
          return matcher;
      }
      /**
       * Find the objects that have been added via `addSelectable`
       * whose css selector is contained in the given css selector.
       * @param cssSelector A css selector
       * @param matchedCallback This callback will be called with the object handed into `addSelectable`
       * @return boolean true if a match was found
      */
      match(cssSelector, matchedCallback) {
          let result = false;
          const element = cssSelector.element;
          const classNames = cssSelector.classNames;
          const attrs = cssSelector.attrs;
          for (let i = 0; i < this._listContexts.length; i++) {
              this._listContexts[i].alreadyMatched = false;
          }
          result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
              result;
          if (classNames) {
              for (let i = 0; i < classNames.length; i++) {
                  const className = classNames[i];
                  result =
                      this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
                  result =
                      this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
                          result;
              }
          }
          if (attrs) {
              for (let i = 0; i < attrs.length; i += 2) {
                  const name = attrs[i];
                  const value = attrs[i + 1];
                  const terminalValuesMap = this._attrValueMap.get(name);
                  if (value) {
                      result =
                          this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
                  }
                  result =
                      this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;
                  const partialValuesMap = this._attrValuePartialMap.get(name);
                  if (value) {
                      result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
                  }
                  result =
                      this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
              }
          }
          return result;
      }
      /** @internal */
      _matchTerminal(map, name, cssSelector, matchedCallback) {
          if (!map || typeof name !== 'string') {
              return false;
          }
          let selectables = map.get(name) || [];
          const starSelectables = map.get('*');
          if (starSelectables) {
              selectables = selectables.concat(starSelectables);
          }
          if (selectables.length === 0) {
              return false;
          }
          let selectable;
          let result = false;
          for (let i = 0; i < selectables.length; i++) {
              selectable = selectables[i];
              result = selectable.finalize(cssSelector, matchedCallback) || result;
          }
          return result;
      }
      /** @internal */
      _matchPartial(map, name, cssSelector, matchedCallback) {
          if (!map || typeof name !== 'string') {
              return false;
          }
          const nestedSelector = map.get(name);
          if (!nestedSelector) {
              return false;
          }
          // TODO(perf): get rid of recursion and measure again
          // TODO(perf): don't pass the whole selector into the recursion,
          // but only the not processed parts
          return nestedSelector.match(cssSelector, matchedCallback);
      }
  }
  class SelectorListContext {
      constructor(selectors) {
          this.selectors = selectors;
          this.alreadyMatched = false;
      }
  }
  // Store context to pass back selector and context when a selector is matched
  class SelectorContext {
      constructor(selector, cbContext, listContext) {
          this.selector = selector;
          this.cbContext = cbContext;
          this.listContext = listContext;
          this.notSelectors = selector.notSelectors;
      }
      finalize(cssSelector, callback) {
          let result = true;
          if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
              const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
              result = !notMatcher.match(cssSelector, null);
          }
          if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
              if (this.listContext) {
                  this.listContext.alreadyMatched = true;
              }
              callback(this.selector, this.cbContext);
          }
          return result;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const createInject = makeMetadataFactory('Inject', (token) => ({ token }));
  const createInjectionToken = makeMetadataFactory('InjectionToken', (desc) => ({ _desc: desc, ngInjectableDef: undefined }));
  const createAttribute = makeMetadataFactory('Attribute', (attributeName) => ({ attributeName }));
  const createContentChildren = makeMetadataFactory('ContentChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: false, descendants: false }, data)));
  const createContentChild = makeMetadataFactory('ContentChild', (selector, data = {}) => (Object.assign({ selector, first: true, isViewQuery: false, descendants: true }, data)));
  const createViewChildren = makeMetadataFactory('ViewChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: true, descendants: true }, data)));
  const createViewChild = makeMetadataFactory('ViewChild', (selector, data) => (Object.assign({ selector, first: true, isViewQuery: true, descendants: true }, data)));
  const createDirective = makeMetadataFactory('Directive', (dir = {}) => dir);
  var ViewEncapsulation;
  (function (ViewEncapsulation) {
      ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
      ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
      ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
      ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
  })(ViewEncapsulation || (ViewEncapsulation = {}));
  var ChangeDetectionStrategy;
  (function (ChangeDetectionStrategy) {
      ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
      ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
  })(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));
  const createComponent = makeMetadataFactory('Component', (c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy.Default }, c)));
  const createPipe = makeMetadataFactory('Pipe', (p) => (Object.assign({ pure: true }, p)));
  const createInput = makeMetadataFactory('Input', (bindingPropertyName) => ({ bindingPropertyName }));
  const createOutput = makeMetadataFactory('Output', (bindingPropertyName) => ({ bindingPropertyName }));
  const createHostBinding = makeMetadataFactory('HostBinding', (hostPropertyName) => ({ hostPropertyName }));
  const createHostListener = makeMetadataFactory('HostListener', (eventName, args) => ({ eventName, args }));
  const createNgModule = makeMetadataFactory('NgModule', (ngModule) => ngModule);
  const createInjectable = makeMetadataFactory('Injectable', (injectable = {}) => injectable);
  const CUSTOM_ELEMENTS_SCHEMA = {
      name: 'custom-elements'
  };
  const NO_ERRORS_SCHEMA = {
      name: 'no-errors-schema'
  };
  const createOptional = makeMetadataFactory('Optional');
  const createSelf = makeMetadataFactory('Self');
  const createSkipSelf = makeMetadataFactory('SkipSelf');
  const createHost = makeMetadataFactory('Host');
  const Type = Function;
  var SecurityContext;
  (function (SecurityContext) {
      SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
      SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
      SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
      SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
      SecurityContext[SecurityContext["URL"] = 4] = "URL";
      SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
  })(SecurityContext || (SecurityContext = {}));
  var MissingTranslationStrategy;
  (function (MissingTranslationStrategy) {
      MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
      MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
      MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
  })(MissingTranslationStrategy || (MissingTranslationStrategy = {}));
  function makeMetadataFactory(name, props) {
      // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code
      // that works with the static_reflector.ts in the ViewEngine compiler.
      // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be
      // new'ed.
      function factory(...args) {
          const values = props ? props(...args) : {};
          return Object.assign({ ngMetadataName: name }, values);
      }
      factory.isTypeOf = (obj) => obj && obj.ngMetadataName === name;
      factory.ngMetadataName = name;
      return factory;
  }
  function parserSelectorToSimpleSelector(selector) {
      const classes = selector.classNames && selector.classNames.length ?
          [8 /* CLASS */, ...selector.classNames] :
          [];
      const elementName = selector.element && selector.element !== '*' ? selector.element : '';
      return [elementName, ...selector.attrs, ...classes];
  }
  function parserSelectorToNegativeSelector(selector) {
      const classes = selector.classNames && selector.classNames.length ?
          [8 /* CLASS */, ...selector.classNames] :
          [];
      if (selector.element) {
          return [
              1 /* NOT */ | 4 /* ELEMENT */, selector.element, ...selector.attrs, ...classes
          ];
      }
      else if (selector.attrs.length) {
          return [1 /* NOT */ | 2 /* ATTRIBUTE */, ...selector.attrs, ...classes];
      }
      else {
          return selector.classNames && selector.classNames.length ?
              [1 /* NOT */ | 8 /* CLASS */, ...selector.classNames] :
              [];
      }
  }
  function parserSelectorToR3Selector(selector) {
      const positive = parserSelectorToSimpleSelector(selector);
      const negative = selector.notSelectors && selector.notSelectors.length ?
          selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :
          [];
      return positive.concat(...negative);
  }
  function parseSelectorToR3Selector(selector) {
      return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
  }

  var core = /*#__PURE__*/Object.freeze({
      createInject: createInject,
      createInjectionToken: createInjectionToken,
      createAttribute: createAttribute,
      createContentChildren: createContentChildren,
      createContentChild: createContentChild,
      createViewChildren: createViewChildren,
      createViewChild: createViewChild,
      createDirective: createDirective,
      get ViewEncapsulation () { return ViewEncapsulation; },
      get ChangeDetectionStrategy () { return ChangeDetectionStrategy; },
      createComponent: createComponent,
      createPipe: createPipe,
      createInput: createInput,
      createOutput: createOutput,
      createHostBinding: createHostBinding,
      createHostListener: createHostListener,
      createNgModule: createNgModule,
      createInjectable: createInjectable,
      CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,
      NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,
      createOptional: createOptional,
      createSelf: createSelf,
      createSkipSelf: createSkipSelf,
      createHost: createHost,
      Type: Type,
      get SecurityContext () { return SecurityContext; },
      get MissingTranslationStrategy () { return MissingTranslationStrategy; },
      parseSelectorToR3Selector: parseSelectorToR3Selector
  });

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  //// Types
  var TypeModifier;
  (function (TypeModifier) {
      TypeModifier[TypeModifier["Const"] = 0] = "Const";
  })(TypeModifier || (TypeModifier = {}));
  class Type$1 {
      constructor(modifiers = null) {
          this.modifiers = modifiers;
          if (!modifiers) {
              this.modifiers = [];
          }
      }
      hasModifier(modifier) { return this.modifiers.indexOf(modifier) !== -1; }
  }
  var BuiltinTypeName;
  (function (BuiltinTypeName) {
      BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
      BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
      BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
      BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
      BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
      BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
      BuiltinTypeName[BuiltinTypeName["Inferred"] = 6] = "Inferred";
      BuiltinTypeName[BuiltinTypeName["None"] = 7] = "None";
  })(BuiltinTypeName || (BuiltinTypeName = {}));
  class BuiltinType extends Type$1 {
      constructor(name, modifiers = null) {
          super(modifiers);
          this.name = name;
      }
      visitType(visitor, context) {
          return visitor.visitBuiltinType(this, context);
      }
  }
  class ExpressionType extends Type$1 {
      constructor(value, modifiers = null, typeParams = null) {
          super(modifiers);
          this.value = value;
          this.typeParams = typeParams;
      }
      visitType(visitor, context) {
          return visitor.visitExpressionType(this, context);
      }
  }
  class ArrayType extends Type$1 {
      constructor(of, modifiers = null) {
          super(modifiers);
          this.of = of;
      }
      visitType(visitor, context) {
          return visitor.visitArrayType(this, context);
      }
  }
  class MapType extends Type$1 {
      constructor(valueType, modifiers = null) {
          super(modifiers);
          this.valueType = valueType || null;
      }
      visitType(visitor, context) { return visitor.visitMapType(this, context); }
  }
  const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
  const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
  const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
  const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
  const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
  const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
  const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
  const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);
  ///// Expressions
  var BinaryOperator;
  (function (BinaryOperator) {
      BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
      BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
      BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
      BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
      BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
      BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
      BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
      BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
      BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
      BinaryOperator[BinaryOperator["And"] = 9] = "And";
      BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
      BinaryOperator[BinaryOperator["BitwiseAnd"] = 11] = "BitwiseAnd";
      BinaryOperator[BinaryOperator["Lower"] = 12] = "Lower";
      BinaryOperator[BinaryOperator["LowerEquals"] = 13] = "LowerEquals";
      BinaryOperator[BinaryOperator["Bigger"] = 14] = "Bigger";
      BinaryOperator[BinaryOperator["BiggerEquals"] = 15] = "BiggerEquals";
  })(BinaryOperator || (BinaryOperator = {}));
  function nullSafeIsEquivalent(base, other) {
      if (base == null || other == null) {
          return base == other;
      }
      return base.isEquivalent(other);
  }
  function areAllEquivalent(base, other) {
      const len = base.length;
      if (len !== other.length) {
          return false;
      }
      for (let i = 0; i < len; i++) {
          if (!base[i].isEquivalent(other[i])) {
              return false;
          }
      }
      return true;
  }
  class Expression {
      constructor(type, sourceSpan) {
          this.type = type || null;
          this.sourceSpan = sourceSpan || null;
      }
      prop(name, sourceSpan) {
          return new ReadPropExpr(this, name, null, sourceSpan);
      }
      key(index, type, sourceSpan) {
          return new ReadKeyExpr(this, index, type, sourceSpan);
      }
      callMethod(name, params, sourceSpan) {
          return new InvokeMethodExpr(this, name, params, null, sourceSpan);
      }
      callFn(params, sourceSpan) {
          return new InvokeFunctionExpr(this, params, null, sourceSpan);
      }
      instantiate(params, type, sourceSpan) {
          return new InstantiateExpr(this, params, type, sourceSpan);
      }
      conditional(trueCase, falseCase = null, sourceSpan) {
          return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
      }
      equals(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
      }
      notEquals(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
      }
      identical(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
      }
      notIdentical(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
      }
      minus(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
      }
      plus(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
      }
      divide(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
      }
      multiply(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
      }
      modulo(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
      }
      and(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
      }
      bitwiseAnd(rhs, sourceSpan, parens = true) {
          return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
      }
      or(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
      }
      lower(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
      }
      lowerEquals(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
      }
      bigger(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
      }
      biggerEquals(rhs, sourceSpan) {
          return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
      }
      isBlank(sourceSpan) {
          // Note: We use equals by purpose here to compare to null and undefined in JS.
          // We use the typed null to allow strictNullChecks to narrow types.
          return this.equals(TYPED_NULL_EXPR, sourceSpan);
      }
      cast(type, sourceSpan) {
          return new CastExpr(this, type, sourceSpan);
      }
      toStmt() { return new ExpressionStatement(this, null); }
  }
  var BuiltinVar;
  (function (BuiltinVar) {
      BuiltinVar[BuiltinVar["This"] = 0] = "This";
      BuiltinVar[BuiltinVar["Super"] = 1] = "Super";
      BuiltinVar[BuiltinVar["CatchError"] = 2] = "CatchError";
      BuiltinVar[BuiltinVar["CatchStack"] = 3] = "CatchStack";
  })(BuiltinVar || (BuiltinVar = {}));
  class ReadVarExpr extends Expression {
      constructor(name, type, sourceSpan) {
          super(type, sourceSpan);
          if (typeof name === 'string') {
              this.name = name;
              this.builtin = null;
          }
          else {
              this.name = null;
              this.builtin = name;
          }
      }
      isEquivalent(e) {
          return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitReadVarExpr(this, context);
      }
      set(value) {
          if (!this.name) {
              throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);
          }
          return new WriteVarExpr(this.name, value, null, this.sourceSpan);
      }
  }
  class TypeofExpr extends Expression {
      constructor(expr, type, sourceSpan) {
          super(type, sourceSpan);
          this.expr = expr;
      }
      visitExpression(visitor, context) {
          return visitor.visitTypeofExpr(this, context);
      }
      isEquivalent(e) {
          return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
      }
      isConstant() { return this.expr.isConstant(); }
  }
  class WrappedNodeExpr extends Expression {
      constructor(node, type, sourceSpan) {
          super(type, sourceSpan);
          this.node = node;
      }
      isEquivalent(e) {
          return e instanceof WrappedNodeExpr && this.node === e.node;
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitWrappedNodeExpr(this, context);
      }
  }
  class WriteVarExpr extends Expression {
      constructor(name, value, type, sourceSpan) {
          super(type || value.type, sourceSpan);
          this.name = name;
          this.value = value;
      }
      isEquivalent(e) {
          return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitWriteVarExpr(this, context);
      }
      toDeclStmt(type, modifiers) {
          return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
      }
      toConstDecl() { return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]); }
  }
  class WriteKeyExpr extends Expression {
      constructor(receiver, index, value, type, sourceSpan) {
          super(type || value.type, sourceSpan);
          this.receiver = receiver;
          this.index = index;
          this.value = value;
      }
      isEquivalent(e) {
          return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&
              this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitWriteKeyExpr(this, context);
      }
  }
  class WritePropExpr extends Expression {
      constructor(receiver, name, value, type, sourceSpan) {
          super(type || value.type, sourceSpan);
          this.receiver = receiver;
          this.name = name;
          this.value = value;
      }
      isEquivalent(e) {
          return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&
              this.name === e.name && this.value.isEquivalent(e.value);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitWritePropExpr(this, context);
      }
  }
  var BuiltinMethod;
  (function (BuiltinMethod) {
      BuiltinMethod[BuiltinMethod["ConcatArray"] = 0] = "ConcatArray";
      BuiltinMethod[BuiltinMethod["SubscribeObservable"] = 1] = "SubscribeObservable";
      BuiltinMethod[BuiltinMethod["Bind"] = 2] = "Bind";
  })(BuiltinMethod || (BuiltinMethod = {}));
  class InvokeMethodExpr extends Expression {
      constructor(receiver, method, args, type, sourceSpan) {
          super(type, sourceSpan);
          this.receiver = receiver;
          this.args = args;
          if (typeof method === 'string') {
              this.name = method;
              this.builtin = null;
          }
          else {
              this.name = null;
              this.builtin = method;
          }
      }
      isEquivalent(e) {
          return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&
              this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitInvokeMethodExpr(this, context);
      }
  }
  class InvokeFunctionExpr extends Expression {
      constructor(fn, args, type, sourceSpan, pure = false) {
          super(type, sourceSpan);
          this.fn = fn;
          this.args = args;
          this.pure = pure;
      }
      isEquivalent(e) {
          return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&
              areAllEquivalent(this.args, e.args) && this.pure === e.pure;
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitInvokeFunctionExpr(this, context);
      }
  }
  class InstantiateExpr extends Expression {
      constructor(classExpr, args, type, sourceSpan) {
          super(type, sourceSpan);
          this.classExpr = classExpr;
          this.args = args;
      }
      isEquivalent(e) {
          return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&
              areAllEquivalent(this.args, e.args);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitInstantiateExpr(this, context);
      }
  }
  class LiteralExpr extends Expression {
      constructor(value, type, sourceSpan) {
          super(type, sourceSpan);
          this.value = value;
      }
      isEquivalent(e) {
          return e instanceof LiteralExpr && this.value === e.value;
      }
      isConstant() { return true; }
      visitExpression(visitor, context) {
          return visitor.visitLiteralExpr(this, context);
      }
  }
  class ExternalExpr extends Expression {
      constructor(value, type, typeParams = null, sourceSpan) {
          super(type, sourceSpan);
          this.value = value;
          this.typeParams = typeParams;
      }
      isEquivalent(e) {
          return e instanceof ExternalExpr && this.value.name === e.value.name &&
              this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitExternalExpr(this, context);
      }
  }
  class ConditionalExpr extends Expression {
      constructor(condition, trueCase, falseCase = null, type, sourceSpan) {
          super(type || trueCase.type, sourceSpan);
          this.condition = condition;
          this.falseCase = falseCase;
          this.trueCase = trueCase;
      }
      isEquivalent(e) {
          return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&
              this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitConditionalExpr(this, context);
      }
  }
  class NotExpr extends Expression {
      constructor(condition, sourceSpan) {
          super(BOOL_TYPE, sourceSpan);
          this.condition = condition;
      }
      isEquivalent(e) {
          return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitNotExpr(this, context);
      }
  }
  class AssertNotNull extends Expression {
      constructor(condition, sourceSpan) {
          super(condition.type, sourceSpan);
          this.condition = condition;
      }
      isEquivalent(e) {
          return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitAssertNotNullExpr(this, context);
      }
  }
  class CastExpr extends Expression {
      constructor(value, type, sourceSpan) {
          super(type, sourceSpan);
          this.value = value;
      }
      isEquivalent(e) {
          return e instanceof CastExpr && this.value.isEquivalent(e.value);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitCastExpr(this, context);
      }
  }
  class FnParam {
      constructor(name, type = null) {
          this.name = name;
          this.type = type;
      }
      isEquivalent(param) { return this.name === param.name; }
  }
  class FunctionExpr extends Expression {
      constructor(params, statements, type, sourceSpan, name) {
          super(type, sourceSpan);
          this.params = params;
          this.statements = statements;
          this.name = name;
      }
      isEquivalent(e) {
          return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&
              areAllEquivalent(this.statements, e.statements);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitFunctionExpr(this, context);
      }
      toDeclStmt(name, modifiers = null) {
          return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
      }
  }
  class BinaryOperatorExpr extends Expression {
      constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {
          super(type || lhs.type, sourceSpan);
          this.operator = operator;
          this.rhs = rhs;
          this.parens = parens;
          this.lhs = lhs;
      }
      isEquivalent(e) {
          return e instanceof BinaryOperatorExpr && this.operator === e.operator &&
              this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitBinaryOperatorExpr(this, context);
      }
  }
  class ReadPropExpr extends Expression {
      constructor(receiver, name, type, sourceSpan) {
          super(type, sourceSpan);
          this.receiver = receiver;
          this.name = name;
      }
      isEquivalent(e) {
          return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&
              this.name === e.name;
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitReadPropExpr(this, context);
      }
      set(value) {
          return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
      }
  }
  class ReadKeyExpr extends Expression {
      constructor(receiver, index, type, sourceSpan) {
          super(type, sourceSpan);
          this.receiver = receiver;
          this.index = index;
      }
      isEquivalent(e) {
          return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&
              this.index.isEquivalent(e.index);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitReadKeyExpr(this, context);
      }
      set(value) {
          return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
      }
  }
  class LiteralArrayExpr extends Expression {
      constructor(entries, type, sourceSpan) {
          super(type, sourceSpan);
          this.entries = entries;
      }
      isConstant() { return this.entries.every(e => e.isConstant()); }
      isEquivalent(e) {
          return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
      }
      visitExpression(visitor, context) {
          return visitor.visitLiteralArrayExpr(this, context);
      }
  }
  class LiteralMapEntry {
      constructor(key, value, quoted) {
          this.key = key;
          this.value = value;
          this.quoted = quoted;
      }
      isEquivalent(e) {
          return this.key === e.key && this.value.isEquivalent(e.value);
      }
  }
  class LiteralMapExpr extends Expression {
      constructor(entries, type, sourceSpan) {
          super(type, sourceSpan);
          this.entries = entries;
          this.valueType = null;
          if (type) {
              this.valueType = type.valueType;
          }
      }
      isEquivalent(e) {
          return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
      }
      isConstant() { return this.entries.every(e => e.value.isConstant()); }
      visitExpression(visitor, context) {
          return visitor.visitLiteralMapExpr(this, context);
      }
  }
  class CommaExpr extends Expression {
      constructor(parts, sourceSpan) {
          super(parts[parts.length - 1].type, sourceSpan);
          this.parts = parts;
      }
      isEquivalent(e) {
          return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);
      }
      isConstant() { return false; }
      visitExpression(visitor, context) {
          return visitor.visitCommaExpr(this, context);
      }
  }
  const THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);
  const SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);
  const CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);
  const CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);
  const NULL_EXPR = new LiteralExpr(null, null, null);
  const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);
  //// Statements
  var StmtModifier;
  (function (StmtModifier) {
      StmtModifier[StmtModifier["Final"] = 0] = "Final";
      StmtModifier[StmtModifier["Private"] = 1] = "Private";
      StmtModifier[StmtModifier["Exported"] = 2] = "Exported";
      StmtModifier[StmtModifier["Static"] = 3] = "Static";
  })(StmtModifier || (StmtModifier = {}));
  class Statement {
      constructor(modifiers, sourceSpan) {
          this.modifiers = modifiers || [];
          this.sourceSpan = sourceSpan || null;
      }
      hasModifier(modifier) { return this.modifiers.indexOf(modifier) !== -1; }
  }
  class DeclareVarStmt extends Statement {
      constructor(name, value, type, modifiers = null, sourceSpan) {
          super(modifiers, sourceSpan);
          this.name = name;
          this.value = value;
          this.type = type || (value && value.type) || null;
      }
      isEquivalent(stmt) {
          return stmt instanceof DeclareVarStmt && this.name === stmt.name &&
              (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
      }
      visitStatement(visitor, context) {
          return visitor.visitDeclareVarStmt(this, context);
      }
  }
  class DeclareFunctionStmt extends Statement {
      constructor(name, params, statements, type, modifiers = null, sourceSpan) {
          super(modifiers, sourceSpan);
          this.name = name;
          this.params = params;
          this.statements = statements;
          this.type = type || null;
      }
      isEquivalent(stmt) {
          return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&
              areAllEquivalent(this.statements, stmt.statements);
      }
      visitStatement(visitor, context) {
          return visitor.visitDeclareFunctionStmt(this, context);
      }
  }
  class ExpressionStatement extends Statement {
      constructor(expr, sourceSpan) {
          super(null, sourceSpan);
          this.expr = expr;
      }
      isEquivalent(stmt) {
          return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
      }
      visitStatement(visitor, context) {
          return visitor.visitExpressionStmt(this, context);
      }
  }
  class ReturnStatement extends Statement {
      constructor(value, sourceSpan) {
          super(null, sourceSpan);
          this.value = value;
      }
      isEquivalent(stmt) {
          return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
      }
      visitStatement(visitor, context) {
          return visitor.visitReturnStmt(this, context);
      }
  }
  class AbstractClassPart {
      constructor(type, modifiers) {
          this.modifiers = modifiers;
          if (!modifiers) {
              this.modifiers = [];
          }
          this.type = type || null;
      }
      hasModifier(modifier) { return this.modifiers.indexOf(modifier) !== -1; }
  }
  class ClassMethod extends AbstractClassPart {
      constructor(name, params, body, type, modifiers = null) {
          super(type, modifiers);
          this.name = name;
          this.params = params;
          this.body = body;
      }
      isEquivalent(m) {
          return this.name === m.name && areAllEquivalent(this.body, m.body);
      }
  }
  class ClassGetter extends AbstractClassPart {
      constructor(name, body, type, modifiers = null) {
          super(type, modifiers);
          this.name = name;
          this.body = body;
      }
      isEquivalent(m) {
          return this.name === m.name && areAllEquivalent(this.body, m.body);
      }
  }
  class ClassStmt extends Statement {
      constructor(name, parent, fields, getters, constructorMethod, methods, modifiers = null, sourceSpan) {
          super(modifiers, sourceSpan);
          this.name = name;
          this.parent = parent;
          this.fields = fields;
          this.getters = getters;
          this.constructorMethod = constructorMethod;
          this.methods = methods;
      }
      isEquivalent(stmt) {
          return stmt instanceof ClassStmt && this.name === stmt.name &&
              nullSafeIsEquivalent(this.parent, stmt.parent) &&
              areAllEquivalent(this.fields, stmt.fields) &&
              areAllEquivalent(this.getters, stmt.getters) &&
              this.constructorMethod.isEquivalent(stmt.constructorMethod) &&
              areAllEquivalent(this.methods, stmt.methods);
      }
      visitStatement(visitor, context) {
          return visitor.visitDeclareClassStmt(this, context);
      }
  }
  class IfStmt extends Statement {
      constructor(condition, trueCase, falseCase = [], sourceSpan) {
          super(null, sourceSpan);
          this.condition = condition;
          this.trueCase = trueCase;
          this.falseCase = falseCase;
      }
      isEquivalent(stmt) {
          return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&
              areAllEquivalent(this.trueCase, stmt.trueCase) &&
              areAllEquivalent(this.falseCase, stmt.falseCase);
      }
      visitStatement(visitor, context) {
          return visitor.visitIfStmt(this, context);
      }
  }
  class JSDocCommentStmt extends Statement {
      constructor(tags = [], sourceSpan) {
          super(null, sourceSpan);
          this.tags = tags;
      }
      isEquivalent(stmt) {
          return stmt instanceof JSDocCommentStmt && this.toString() === stmt.toString();
      }
      visitStatement(visitor, context) {
          return visitor.visitJSDocCommentStmt(this, context);
      }
      toString() { return serializeTags(this.tags); }
  }
  class TryCatchStmt extends Statement {
      constructor(bodyStmts, catchStmts, sourceSpan) {
          super(null, sourceSpan);
          this.bodyStmts = bodyStmts;
          this.catchStmts = catchStmts;
      }
      isEquivalent(stmt) {
          return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) &&
              areAllEquivalent(this.catchStmts, stmt.catchStmts);
      }
      visitStatement(visitor, context) {
          return visitor.visitTryCatchStmt(this, context);
      }
  }
  class ThrowStmt extends Statement {
      constructor(error, sourceSpan) {
          super(null, sourceSpan);
          this.error = error;
      }
      isEquivalent(stmt) {
          return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);
      }
      visitStatement(visitor, context) {
          return visitor.visitThrowStmt(this, context);
      }
  }
  class AstTransformer {
      transformExpr(expr, context) { return expr; }
      transformStmt(stmt, context) { return stmt; }
      visitReadVarExpr(ast, context) { return this.transformExpr(ast, context); }
      visitWrappedNodeExpr(ast, context) {
          return this.transformExpr(ast, context);
      }
      visitTypeofExpr(expr, context) {
          return this.transformExpr(new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan), context);
      }
      visitWriteVarExpr(expr, context) {
          return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
      }
      visitWriteKeyExpr(expr, context) {
          return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
      }
      visitWritePropExpr(expr, context) {
          return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);
      }
      visitInvokeMethodExpr(ast, context) {
          const method = ast.builtin || ast.name;
          return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
      }
      visitInvokeFunctionExpr(ast, context) {
          return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
      }
      visitInstantiateExpr(ast, context) {
          return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);
      }
      visitLiteralExpr(ast, context) { return this.transformExpr(ast, context); }
      visitExternalExpr(ast, context) {
          return this.transformExpr(ast, context);
      }
      visitConditionalExpr(ast, context) {
          return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);
      }
      visitNotExpr(ast, context) {
          return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);
      }
      visitAssertNotNullExpr(ast, context) {
          return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);
      }
      visitCastExpr(ast, context) {
          return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);
      }
      visitFunctionExpr(ast, context) {
          return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);
      }
      visitBinaryOperatorExpr(ast, context) {
          return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);
      }
      visitReadPropExpr(ast, context) {
          return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);
      }
      visitReadKeyExpr(ast, context) {
          return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);
      }
      visitLiteralArrayExpr(ast, context) {
          return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);
      }
      visitLiteralMapExpr(ast, context) {
          const entries = ast.entries.map((entry) => new LiteralMapEntry(entry.key, entry.value.visitExpression(this, context), entry.quoted));
          const mapType = new MapType(ast.valueType, null);
          return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);
      }
      visitCommaExpr(ast, context) {
          return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);
      }
      visitAllExpressions(exprs, context) {
          return exprs.map(expr => expr.visitExpression(this, context));
      }
      visitDeclareVarStmt(stmt, context) {
          const value = stmt.value && stmt.value.visitExpression(this, context);
          return this.transformStmt(new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan), context);
      }
      visitDeclareFunctionStmt(stmt, context) {
          return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);
      }
      visitExpressionStmt(stmt, context) {
          return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);
      }
      visitReturnStmt(stmt, context) {
          return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);
      }
      visitDeclareClassStmt(stmt, context) {
          const parent = stmt.parent.visitExpression(this, context);
          const getters = stmt.getters.map(getter => new ClassGetter(getter.name, this.visitAllStatements(getter.body, context), getter.type, getter.modifiers));
          const ctorMethod = stmt.constructorMethod &&
              new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);
          const methods = stmt.methods.map(method => new ClassMethod(method.name, method.params, this.visitAllStatements(method.body, context), method.type, method.modifiers));
          return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);
      }
      visitIfStmt(stmt, context) {
          return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);
      }
      visitTryCatchStmt(stmt, context) {
          return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);
      }
      visitThrowStmt(stmt, context) {
          return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);
      }
      visitCommentStmt(stmt, context) {
          return this.transformStmt(stmt, context);
      }
      visitJSDocCommentStmt(stmt, context) {
          return this.transformStmt(stmt, context);
      }
      visitAllStatements(stmts, context) {
          return stmts.map(stmt => stmt.visitStatement(this, context));
      }
  }
  class RecursiveAstVisitor {
      visitType(ast, context) { return ast; }
      visitExpression(ast, context) {
          if (ast.type) {
              ast.type.visitType(this, context);
          }
          return ast;
      }
      visitBuiltinType(type, context) { return this.visitType(type, context); }
      visitExpressionType(type, context) {
          type.value.visitExpression(this, context);
          if (type.typeParams !== null) {
              type.typeParams.forEach(param => this.visitType(param, context));
          }
          return this.visitType(type, context);
      }
      visitArrayType(type, context) { return this.visitType(type, context); }
      visitMapType(type, context) { return this.visitType(type, context); }
      visitWrappedNodeExpr(ast, context) { return ast; }
      visitTypeofExpr(ast, context) { return this.visitExpression(ast, context); }
      visitReadVarExpr(ast, context) {
          return this.visitExpression(ast, context);
      }
      visitWriteVarExpr(ast, context) {
          ast.value.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitWriteKeyExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          ast.index.visitExpression(this, context);
          ast.value.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitWritePropExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          ast.value.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitInvokeMethodExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return this.visitExpression(ast, context);
      }
      visitInvokeFunctionExpr(ast, context) {
          ast.fn.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return this.visitExpression(ast, context);
      }
      visitInstantiateExpr(ast, context) {
          ast.classExpr.visitExpression(this, context);
          this.visitAllExpressions(ast.args, context);
          return this.visitExpression(ast, context);
      }
      visitLiteralExpr(ast, context) {
          return this.visitExpression(ast, context);
      }
      visitExternalExpr(ast, context) {
          if (ast.typeParams) {
              ast.typeParams.forEach(type => type.visitType(this, context));
          }
          return this.visitExpression(ast, context);
      }
      visitConditionalExpr(ast, context) {
          ast.condition.visitExpression(this, context);
          ast.trueCase.visitExpression(this, context);
          ast.falseCase.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitNotExpr(ast, context) {
          ast.condition.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitAssertNotNullExpr(ast, context) {
          ast.condition.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitCastExpr(ast, context) {
          ast.value.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitFunctionExpr(ast, context) {
          this.visitAllStatements(ast.statements, context);
          return this.visitExpression(ast, context);
      }
      visitBinaryOperatorExpr(ast, context) {
          ast.lhs.visitExpression(this, context);
          ast.rhs.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitReadPropExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitReadKeyExpr(ast, context) {
          ast.receiver.visitExpression(this, context);
          ast.index.visitExpression(this, context);
          return this.visitExpression(ast, context);
      }
      visitLiteralArrayExpr(ast, context) {
          this.visitAllExpressions(ast.entries, context);
          return this.visitExpression(ast, context);
      }
      visitLiteralMapExpr(ast, context) {
          ast.entries.forEach((entry) => entry.value.visitExpression(this, context));
          return this.visitExpression(ast, context);
      }
      visitCommaExpr(ast, context) {
          this.visitAllExpressions(ast.parts, context);
          return this.visitExpression(ast, context);
      }
      visitAllExpressions(exprs, context) {
          exprs.forEach(expr => expr.visitExpression(this, context));
      }
      visitDeclareVarStmt(stmt, context) {
          if (stmt.value) {
              stmt.value.visitExpression(this, context);
          }
          if (stmt.type) {
              stmt.type.visitType(this, context);
          }
          return stmt;
      }
      visitDeclareFunctionStmt(stmt, context) {
          this.visitAllStatements(stmt.statements, context);
          if (stmt.type) {
              stmt.type.visitType(this, context);
          }
          return stmt;
      }
      visitExpressionStmt(stmt, context) {
          stmt.expr.visitExpression(this, context);
          return stmt;
      }
      visitReturnStmt(stmt, context) {
          stmt.value.visitExpression(this, context);
          return stmt;
      }
      visitDeclareClassStmt(stmt, context) {
          stmt.parent.visitExpression(this, context);
          stmt.getters.forEach(getter => this.visitAllStatements(getter.body, context));
          if (stmt.constructorMethod) {
              this.visitAllStatements(stmt.constructorMethod.body, context);
          }
          stmt.methods.forEach(method => this.visitAllStatements(method.body, context));
          return stmt;
      }
      visitIfStmt(stmt, context) {
          stmt.condition.visitExpression(this, context);
          this.visitAllStatements(stmt.trueCase, context);
          this.visitAllStatements(stmt.falseCase, context);
          return stmt;
      }
      visitTryCatchStmt(stmt, context) {
          this.visitAllStatements(stmt.bodyStmts, context);
          this.visitAllStatements(stmt.catchStmts, context);
          return stmt;
      }
      visitThrowStmt(stmt, context) {
          stmt.error.visitExpression(this, context);
          return stmt;
      }
      visitCommentStmt(stmt, context) { return stmt; }
      visitJSDocCommentStmt(stmt, context) { return stmt; }
      visitAllStatements(stmts, context) {
          stmts.forEach(stmt => stmt.visitStatement(this, context));
      }
  }
  function findReadVarNames(stmts) {
      const visitor = new _ReadVarVisitor();
      visitor.visitAllStatements(stmts, null);
      return visitor.varNames;
  }
  class _ReadVarVisitor extends RecursiveAstVisitor {
      constructor() {
          super(...arguments);
          this.varNames = new Set();
      }
      visitDeclareFunctionStmt(stmt, context) {
          // Don't descend into nested functions
          return stmt;
      }
      visitDeclareClassStmt(stmt, context) {
          // Don't descend into nested classes
          return stmt;
      }
      visitReadVarExpr(ast, context) {
          if (ast.name) {
              this.varNames.add(ast.name);
          }
          return null;
      }
  }
  function applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {
      if (!sourceSpan) {
          return stmt;
      }
      const transformer = new _ApplySourceSpanTransformer(sourceSpan);
      return stmt.visitStatement(transformer, null);
  }
  function applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {
      if (!sourceSpan) {
          return expr;
      }
      const transformer = new _ApplySourceSpanTransformer(sourceSpan);
      return expr.visitExpression(transformer, null);
  }
  class _ApplySourceSpanTransformer extends AstTransformer {
      constructor(sourceSpan) {
          super();
          this.sourceSpan = sourceSpan;
      }
      _clone(obj) {
          const clone = Object.create(obj.constructor.prototype);
          for (let prop in obj) {
              clone[prop] = obj[prop];
          }
          return clone;
      }
      transformExpr(expr, context) {
          if (!expr.sourceSpan) {
              expr = this._clone(expr);
              expr.sourceSpan = this.sourceSpan;
          }
          return expr;
      }
      transformStmt(stmt, context) {
          if (!stmt.sourceSpan) {
              stmt = this._clone(stmt);
              stmt.sourceSpan = this.sourceSpan;
          }
          return stmt;
      }
  }
  function variable(name, type, sourceSpan) {
      return new ReadVarExpr(name, type, sourceSpan);
  }
  function importExpr(id, typeParams = null, sourceSpan) {
      return new ExternalExpr(id, null, typeParams, sourceSpan);
  }
  function importType(id, typeParams = null, typeModifiers = null) {
      return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;
  }
  function expressionType(expr, typeModifiers = null, typeParams = null) {
      return new ExpressionType(expr, typeModifiers, typeParams);
  }
  function typeofExpr(expr) {
      return new TypeofExpr(expr);
  }
  function literalArr(values, type, sourceSpan) {
      return new LiteralArrayExpr(values, type, sourceSpan);
  }
  function literalMap(values, type = null) {
      return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);
  }
  function not(expr, sourceSpan) {
      return new NotExpr(expr, sourceSpan);
  }
  function assertNotNull(expr, sourceSpan) {
      return new AssertNotNull(expr, sourceSpan);
  }
  function fn(params, body, type, sourceSpan, name) {
      return new FunctionExpr(params, body, type, sourceSpan, name);
  }
  function ifStmt(condition, thenClause, elseClause) {
      return new IfStmt(condition, thenClause, elseClause);
  }
  function literal(value, type, sourceSpan) {
      return new LiteralExpr(value, type, sourceSpan);
  }
  function isNull(exp) {
      return exp instanceof LiteralExpr && exp.value === null;
  }
  /*
   * Serializes a `Tag` into a string.
   * Returns a string like " @foo {bar} baz" (note the leading whitespace before `@foo`).
   */
  function tagToString(tag) {
      let out = '';
      if (tag.tagName) {
          out += ` @${tag.tagName}`;
      }
      if (tag.text) {
          if (tag.text.match(/\/\*|\*\//)) {
              throw new Error('JSDoc text cannot contain "/*" and "*/"');
          }
          out += ' ' + tag.text.replace(/@/g, '\\@');
      }
      return out;
  }
  function serializeTags(tags) {
      if (tags.length === 0)
          return '';
      let out = '*\n';
      for (const tag of tags) {
          out += ' *';
          // If the tagToString is multi-line, insert " * " prefixes on subsequent lines.
          out += tagToString(tag).replace(/\n/g, '\n * ');
          out += '\n';
      }
      out += ' ';
      return out;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const DASH_CASE_REGEXP = /-+([a-z0-9])/g;
  function dashCaseToCamelCase(input) {
      return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
  }
  function splitAtColon(input, defaultValues) {
      return _splitAt(input, ':', defaultValues);
  }
  function splitAtPeriod(input, defaultValues) {
      return _splitAt(input, '.', defaultValues);
  }
  function _splitAt(input, character, defaultValues) {
      const characterIndex = input.indexOf(character);
      if (characterIndex == -1)
          return defaultValues;
      return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
  }
  function visitValue(value, visitor, context) {
      if (Array.isArray(value)) {
          return visitor.visitArray(value, context);
      }
      if (isStrictStringMap(value)) {
          return visitor.visitStringMap(value, context);
      }
      if (value == null || typeof value == 'string' || typeof value == 'number' ||
          typeof value == 'boolean') {
          return visitor.visitPrimitive(value, context);
      }
      return visitor.visitOther(value, context);
  }
  function isDefined(val) {
      return val !== null && val !== undefined;
  }
  function noUndefined(val) {
      return val === undefined ? null : val;
  }
  class ValueTransformer {
      visitArray(arr, context) {
          return arr.map(value => visitValue(value, this, context));
      }
      visitStringMap(map, context) {
          const result = {};
          Object.keys(map).forEach(key => { result[key] = visitValue(map[key], this, context); });
          return result;
      }
      visitPrimitive(value, context) { return value; }
      visitOther(value, context) { return value; }
  }
  const SyncAsync = {
      assertSync: (value) => {
          if (isPromise(value)) {
              throw new Error(`Illegal state: value cannot be a promise`);
          }
          return value;
      },
      then: (value, cb) => { return isPromise(value) ? value.then(cb) : cb(value); },
      all: (syncAsyncValues) => {
          return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;
      }
  };
  function error(msg) {
      throw new Error(`Internal Error: ${msg}`);
  }
  function syntaxError(msg, parseErrors) {
      const error = Error(msg);
      error[ERROR_SYNTAX_ERROR] = true;
      if (parseErrors)
          error[ERROR_PARSE_ERRORS] = parseErrors;
      return error;
  }
  const ERROR_SYNTAX_ERROR = 'ngSyntaxError';
  const ERROR_PARSE_ERRORS = 'ngParseErrors';
  // Escape characters that have a special meaning in Regular Expressions
  function escapeRegExp(s) {
      return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }
  const STRING_MAP_PROTO = Object.getPrototypeOf({});
  function isStrictStringMap(obj) {
      return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;
  }
  function utf8Encode(str) {
      let encoded = '';
      for (let index = 0; index < str.length; index++) {
          let codePoint = str.charCodeAt(index);
          // decode surrogate
          // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {
              const low = str.charCodeAt(index + 1);
              if (low >= 0xdc00 && low <= 0xdfff) {
                  index++;
                  codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;
              }
          }
          if (codePoint <= 0x7f) {
              encoded += String.fromCharCode(codePoint);
          }
          else if (codePoint <= 0x7ff) {
              encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);
          }
          else if (codePoint <= 0xffff) {
              encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
          }
          else if (codePoint <= 0x1fffff) {
              encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);
          }
      }
      return encoded;
  }
  function stringify(token) {
      if (typeof token === 'string') {
          return token;
      }
      if (token instanceof Array) {
          return '[' + token.map(stringify).join(', ') + ']';
      }
      if (token == null) {
          return '' + token;
      }
      if (token.overriddenName) {
          return `${token.overriddenName}`;
      }
      if (token.name) {
          return `${token.name}`;
      }
      // WARNING: do not try to `JSON.stringify(token)` here
      // see https://github.com/angular/angular/issues/23440
      const res = token.toString();
      if (res == null) {
          return '' + res;
      }
      const newLineIndex = res.indexOf('\n');
      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }
  /**
   * Lazily retrieves the reference value from a forwardRef.
   */
  function resolveForwardRef(type) {
      if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {
          return type();
      }
      else {
          return type;
      }
  }
  /**
   * Determine if the argument is shaped like a Promise
   */
  function isPromise(obj) {
      // allow any Promise/A+ compliant thenable.
      // It's up to the caller to ensure that obj.then conforms to the spec
      return !!obj && typeof obj.then === 'function';
  }
  class Version {
      constructor(full) {
          this.full = full;
          const splits = full.split('.');
          this.major = splits[0];
          this.minor = splits[1];
          this.patch = splits.slice(2).join('.');
      }
  }
  const __window = typeof window !== 'undefined' && window;
  const __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
      self instanceof WorkerGlobalScope && self;
  const __global = typeof global !== 'undefined' && global;
  // Check __global first, because in Node tests both __global and __window may be defined and _global
  // should be __global in that case.
  const _global = __global || __window || __self;

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const CONSTANT_PREFIX = '_c';
  /**
   * Context to use when producing a key.
   *
   * This ensures we see the constant not the reference variable when producing
   * a key.
   */
  const KEY_CONTEXT = {};
  /**
   * A node that is a place-holder that allows the node to be replaced when the actual
   * node is known.
   *
   * This allows the constant pool to change an expression from a direct reference to
   * a constant to a shared constant. It returns a fix-up node that is later allowed to
   * change the referenced expression.
   */
  class FixupExpression extends Expression {
      constructor(resolved) {
          super(resolved.type);
          this.resolved = resolved;
          this.original = resolved;
      }
      visitExpression(visitor, context) {
          if (context === KEY_CONTEXT) {
              // When producing a key we want to traverse the constant not the
              // variable used to refer to it.
              return this.original.visitExpression(visitor, context);
          }
          else {
              return this.resolved.visitExpression(visitor, context);
          }
      }
      isEquivalent(e) {
          return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
      }
      isConstant() { return true; }
      fixup(expression) {
          this.resolved = expression;
          this.shared = true;
      }
  }
  /**
   * A constant pool allows a code emitter to share constant in an output context.
   *
   * The constant pool also supports sharing access to ivy definitions references.
   */
  class ConstantPool {
      constructor() {
          this.statements = [];
          this.literals = new Map();
          this.literalFactories = new Map();
          this.injectorDefinitions = new Map();
          this.directiveDefinitions = new Map();
          this.componentDefinitions = new Map();
          this.pipeDefinitions = new Map();
          this.nextNameIndex = 0;
      }
      getConstLiteral(literal$$1, forceShared) {
          if (literal$$1 instanceof LiteralExpr || literal$$1 instanceof FixupExpression) {
              // Do no put simple literals into the constant pool or try to produce a constant for a
              // reference to a constant.
              return literal$$1;
          }
          const key = this.keyOf(literal$$1);
          let fixup = this.literals.get(key);
          let newValue = false;
          if (!fixup) {
              fixup = new FixupExpression(literal$$1);
              this.literals.set(key, fixup);
              newValue = true;
          }
          if ((!newValue && !fixup.shared) || (newValue && forceShared)) {
              // Replace the expression with a variable
              const name = this.freshName();
              this.statements.push(variable(name).set(literal$$1).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
              fixup.fixup(variable(name));
          }
          return fixup;
      }
      getDefinition(type, kind, ctx, forceShared = false) {
          const definitions = this.definitionsOf(kind);
          let fixup = definitions.get(type);
          let newValue = false;
          if (!fixup) {
              const property = this.propertyNameOf(kind);
              fixup = new FixupExpression(ctx.importExpr(type).prop(property));
              definitions.set(type, fixup);
              newValue = true;
          }
          if ((!newValue && !fixup.shared) || (newValue && forceShared)) {
              const name = this.freshName();
              this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
              fixup.fixup(variable(name));
          }
          return fixup;
      }
      getLiteralFactory(literal$$1) {
          // Create a pure function that builds an array of a mix of constant  and variable expressions
          if (literal$$1 instanceof LiteralArrayExpr) {
              const argumentsForKey = literal$$1.entries.map(e => e.isConstant() ? e : literal(null));
              const key = this.keyOf(literalArr(argumentsForKey));
              return this._getLiteralFactory(key, literal$$1.entries, entries => literalArr(entries));
          }
          else {
              const expressionForKey = literalMap(literal$$1.entries.map(e => ({
                  key: e.key,
                  value: e.value.isConstant() ? e.value : literal(null),
                  quoted: e.quoted
              })));
              const key = this.keyOf(expressionForKey);
              return this._getLiteralFactory(key, literal$$1.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({
                  key: literal$$1.entries[index].key,
                  value,
                  quoted: literal$$1.entries[index].quoted
              }))));
          }
      }
      _getLiteralFactory(key, values, resultMap) {
          let literalFactory = this.literalFactories.get(key);
          const literalFactoryArguments = values.filter((e => !e.isConstant()));
          if (!literalFactory) {
              const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));
              const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));
              const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
              const name = this.freshName();
              this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [
                  StmtModifier.Final
              ]));
              literalFactory = variable(name);
              this.literalFactories.set(key, literalFactory);
          }
          return { literalFactory, literalFactoryArguments };
      }
      /**
       * Produce a unique name.
       *
       * The name might be unique among different prefixes if any of the prefixes end in
       * a digit so the prefix should be a constant string (not based on user input) and
       * must not end in a digit.
       */
      uniqueName(prefix) { return `${prefix}${this.nextNameIndex++}`; }
      definitionsOf(kind) {
          switch (kind) {
              case 2 /* Component */:
                  return this.componentDefinitions;
              case 1 /* Directive */:
                  return this.directiveDefinitions;
              case 0 /* Injector */:
                  return this.injectorDefinitions;
              case 3 /* Pipe */:
                  return this.pipeDefinitions;
          }
          error(`Unknown definition kind ${kind}`);
          return this.componentDefinitions;
      }
      propertyNameOf(kind) {
          switch (kind) {
              case 2 /* Component */:
                  return 'ngComponentDef';
              case 1 /* Directive */:
                  return 'ngDirectiveDef';
              case 0 /* Injector */:
                  return 'ngInjectorDef';
              case 3 /* Pipe */:
                  return 'ngPipeDef';
          }
          error(`Unknown definition kind ${kind}`);
          return '<unknown>';
      }
      freshName() { return this.uniqueName(CONSTANT_PREFIX); }
      keyOf(expression) {
          return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
      }
  }
  /**
   * Visitor used to determine if 2 expressions are equivalent and can be shared in the
   * `ConstantPool`.
   *
   * When the id (string) generated by the visitor is equal, expressions are considered equivalent.
   */
  class KeyVisitor {
      constructor() {
          this.visitWrappedNodeExpr = invalid;
          this.visitWriteVarExpr = invalid;
          this.visitWriteKeyExpr = invalid;
          this.visitWritePropExpr = invalid;
          this.visitInvokeMethodExpr = invalid;
          this.visitInvokeFunctionExpr = invalid;
          this.visitInstantiateExpr = invalid;
          this.visitConditionalExpr = invalid;
          this.visitNotExpr = invalid;
          this.visitAssertNotNullExpr = invalid;
          this.visitCastExpr = invalid;
          this.visitFunctionExpr = invalid;
          this.visitBinaryOperatorExpr = invalid;
          this.visitReadPropExpr = invalid;
          this.visitReadKeyExpr = invalid;
          this.visitCommaExpr = invalid;
      }
      visitLiteralExpr(ast) {
          return `${typeof ast.value === 'string' ? '"' + ast.value + '"' : ast.value}`;
      }
      visitLiteralArrayExpr(ast, context) {
          return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;
      }
      visitLiteralMapExpr(ast, context) {
          const mapKey = (entry) => {
              const quote = entry.quoted ? '"' : '';
              return `${quote}${entry.key}${quote}`;
          };
          const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;
          return `{${ast.entries.map(mapEntry).join(',')}`;
      }
      visitExternalExpr(ast) {
          return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :
              `EX:${ast.value.runtime.name}`;
      }
      visitReadVarExpr(node) { return `VAR:${node.name}`; }
      visitTypeofExpr(node, context) {
          return `TYPEOF:${node.expr.visitExpression(this, context)}`;
      }
  }
  function invalid(arg) {
      throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);
  }
  function isVariable(e) {
      return e instanceof ReadVarExpr;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const CORE = '@angular/core';
  class Identifiers {
  }
  Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {
      name: 'ANALYZE_FOR_ENTRY_COMPONENTS',
      moduleName: CORE,
  };
  Identifiers.ElementRef = { name: 'ElementRef', moduleName: CORE };
  Identifiers.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE };
  Identifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE };
  Identifiers.ChangeDetectorRef = {
      name: 'ChangeDetectorRef',
      moduleName: CORE,
  };
  Identifiers.QueryList = { name: 'QueryList', moduleName: CORE };
  Identifiers.TemplateRef = { name: 'TemplateRef', moduleName: CORE };
  Identifiers.Renderer2 = { name: 'Renderer2', moduleName: CORE };
  Identifiers.CodegenComponentFactoryResolver = {
      name: 'ɵCodegenComponentFactoryResolver',
      moduleName: CORE,
  };
  Identifiers.ComponentFactoryResolver = {
      name: 'ComponentFactoryResolver',
      moduleName: CORE,
  };
  Identifiers.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE };
  Identifiers.ComponentRef = { name: 'ComponentRef', moduleName: CORE };
  Identifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE };
  Identifiers.createModuleFactory = {
      name: 'ɵcmf',
      moduleName: CORE,
  };
  Identifiers.moduleDef = {
      name: 'ɵmod',
      moduleName: CORE,
  };
  Identifiers.moduleProviderDef = {
      name: 'ɵmpd',
      moduleName: CORE,
  };
  Identifiers.RegisterModuleFactoryFn = {
      name: 'ɵregisterModuleFactory',
      moduleName: CORE,
  };
  Identifiers.inject = { name: 'inject', moduleName: CORE };
  Identifiers.INJECTOR = { name: 'INJECTOR', moduleName: CORE };
  Identifiers.Injector = { name: 'Injector', moduleName: CORE };
  Identifiers.defineInjectable = { name: 'defineInjectable', moduleName: CORE };
  Identifiers.InjectableDef = { name: 'ɵInjectableDef', moduleName: CORE };
  Identifiers.ViewEncapsulation = {
      name: 'ViewEncapsulation',
      moduleName: CORE,
  };
  Identifiers.ChangeDetectionStrategy = {
      name: 'ChangeDetectionStrategy',
      moduleName: CORE,
  };
  Identifiers.SecurityContext = {
      name: 'SecurityContext',
      moduleName: CORE,
  };
  Identifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE };
  Identifiers.TRANSLATIONS_FORMAT = {
      name: 'TRANSLATIONS_FORMAT',
      moduleName: CORE,
  };
  Identifiers.inlineInterpolate = {
      name: 'ɵinlineInterpolate',
      moduleName: CORE,
  };
  Identifiers.interpolate = { name: 'ɵinterpolate', moduleName: CORE };
  Identifiers.EMPTY_ARRAY = { name: 'ɵEMPTY_ARRAY', moduleName: CORE };
  Identifiers.EMPTY_MAP = { name: 'ɵEMPTY_MAP', moduleName: CORE };
  Identifiers.Renderer = { name: 'Renderer', moduleName: CORE };
  Identifiers.viewDef = { name: 'ɵvid', moduleName: CORE };
  Identifiers.elementDef = { name: 'ɵeld', moduleName: CORE };
  Identifiers.anchorDef = { name: 'ɵand', moduleName: CORE };
  Identifiers.textDef = { name: 'ɵted', moduleName: CORE };
  Identifiers.directiveDef = { name: 'ɵdid', moduleName: CORE };
  Identifiers.providerDef = { name: 'ɵprd', moduleName: CORE };
  Identifiers.queryDef = { name: 'ɵqud', moduleName: CORE };
  Identifiers.pureArrayDef = { name: 'ɵpad', moduleName: CORE };
  Identifiers.pureObjectDef = { name: 'ɵpod', moduleName: CORE };
  Identifiers.purePipeDef = { name: 'ɵppd', moduleName: CORE };
  Identifiers.pipeDef = { name: 'ɵpid', moduleName: CORE };
  Identifiers.nodeValue = { name: 'ɵnov', moduleName: CORE };
  Identifiers.ngContentDef = { name: 'ɵncd', moduleName: CORE };
  Identifiers.unwrapValue = { name: 'ɵunv', moduleName: CORE };
  Identifiers.createRendererType2 = { name: 'ɵcrt', moduleName: CORE };
  // type only
  Identifiers.RendererType2 = {
      name: 'RendererType2',
      moduleName: CORE,
  };
  // type only
  Identifiers.ViewDefinition = {
      name: 'ɵViewDefinition',
      moduleName: CORE,
  };
  Identifiers.createComponentFactory = { name: 'ɵccf', moduleName: CORE };
  Identifiers.setClassMetadata = { name: 'ɵsetClassMetadata', moduleName: CORE };
  function createTokenForReference(reference) {
      return { identifier: { reference: reference } };
  }
  function createTokenForExternalReference(reflector, reference) {
      return createTokenForReference(reflector.resolveExternalReference(reference));
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * A token representing the a reference to a static type.
   *
   * This token is unique for a filePath and name and can be used as a hash table key.
   */
  class StaticSymbol {
      constructor(filePath, name, members) {
          this.filePath = filePath;
          this.name = name;
          this.members = members;
      }
      assertNoMembers() {
          if (this.members.length) {
              throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
          }
      }
  }
  /**
   * A cache of static symbol used by the StaticReflector to return the same symbol for the
   * same symbol values.
   */
  class StaticSymbolCache {
      constructor() {
          this.cache = new Map();
      }
      get(declarationFile, name, members) {
          members = members || [];
          const memberSuffix = members.length ? `.${members.join('.')}` : '';
          const key = `"${declarationFile}".${name}${memberSuffix}`;
          let result = this.cache.get(key);
          if (!result) {
              result = new StaticSymbol(declarationFile, name, members);
              this.cache.set(key, result);
          }
          return result;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // group 0: "[prop] or (event) or @trigger"
  // group 1: "prop" from "[prop]"
  // group 2: "event" from "(event)"
  // group 3: "@trigger" from "@trigger"
  const HOST_REG_EXP = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function sanitizeIdentifier(name) {
      return name.replace(/\W/g, '_');
  }
  let _anonymousTypeIndex = 0;
  function identifierName(compileIdentifier) {
      if (!compileIdentifier || !compileIdentifier.reference) {
          return null;
      }
      const ref = compileIdentifier.reference;
      if (ref instanceof StaticSymbol) {
          return ref.name;
      }
      if (ref['__anonymousType']) {
          return ref['__anonymousType'];
      }
      let identifier = stringify(ref);
      if (identifier.indexOf('(') >= 0) {
          // case: anonymous functions!
          identifier = `anonymous_${_anonymousTypeIndex++}`;
          ref['__anonymousType'] = identifier;
      }
      else {
          identifier = sanitizeIdentifier(identifier);
      }
      return identifier;
  }
  function identifierModuleUrl(compileIdentifier) {
      const ref = compileIdentifier.reference;
      if (ref instanceof StaticSymbol) {
          return ref.filePath;
      }
      // Runtime type
      return `./${stringify(ref)}`;
  }
  function viewClassName(compType, embeddedTemplateIndex) {
      return `View_${identifierName({ reference: compType })}_${embeddedTemplateIndex}`;
  }
  function rendererTypeName(compType) {
      return `RenderType_${identifierName({ reference: compType })}`;
  }
  function hostViewClassName(compType) {
      return `HostView_${identifierName({ reference: compType })}`;
  }
  function componentFactoryName(compType) {
      return `${identifierName({ reference: compType })}NgFactory`;
  }
  var CompileSummaryKind;
  (function (CompileSummaryKind) {
      CompileSummaryKind[CompileSummaryKind["Pipe"] = 0] = "Pipe";
      CompileSummaryKind[CompileSummaryKind["Directive"] = 1] = "Directive";
      CompileSummaryKind[CompileSummaryKind["NgModule"] = 2] = "NgModule";
      CompileSummaryKind[CompileSummaryKind["Injectable"] = 3] = "Injectable";
  })(CompileSummaryKind || (CompileSummaryKind = {}));
  function tokenName(token) {
      return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);
  }
  function tokenReference(token) {
      if (token.identifier != null) {
          return token.identifier.reference;
      }
      else {
          return token.value;
      }
  }
  /**
   * Metadata about a stylesheet
   */
  class CompileStylesheetMetadata {
      constructor({ moduleUrl, styles, styleUrls } = {}) {
          this.moduleUrl = moduleUrl || null;
          this.styles = _normalizeArray(styles);
          this.styleUrls = _normalizeArray(styleUrls);
      }
  }
  /**
   * Metadata regarding compilation of a template.
   */
  class CompileTemplateMetadata {
      constructor({ encapsulation, template, templateUrl, htmlAst, styles, styleUrls, externalStylesheets, animations, ngContentSelectors, interpolation, isInline, preserveWhitespaces }) {
          this.encapsulation = encapsulation;
          this.template = template;
          this.templateUrl = templateUrl;
          this.htmlAst = htmlAst;
          this.styles = _normalizeArray(styles);
          this.styleUrls = _normalizeArray(styleUrls);
          this.externalStylesheets = _normalizeArray(externalStylesheets);
          this.animations = animations ? flatten(animations) : [];
          this.ngContentSelectors = ngContentSelectors || [];
          if (interpolation && interpolation.length != 2) {
              throw new Error(`'interpolation' should have a start and an end symbol.`);
          }
          this.interpolation = interpolation;
          this.isInline = isInline;
          this.preserveWhitespaces = preserveWhitespaces;
      }
      toSummary() {
          return {
              ngContentSelectors: this.ngContentSelectors,
              encapsulation: this.encapsulation,
              styles: this.styles,
              animations: this.animations
          };
      }
  }
  /**
   * Metadata regarding compilation of a directive.
   */
  class CompileDirectiveMetadata {
      static create({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, host, providers, viewProviders, queries, guards, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }) {
          const hostListeners = {};
          const hostProperties = {};
          const hostAttributes = {};
          if (host != null) {
              Object.keys(host).forEach(key => {
                  const value = host[key];
                  const matches = key.match(HOST_REG_EXP);
                  if (matches === null) {
                      hostAttributes[key] = value;
                  }
                  else if (matches[1] != null) {
                      hostProperties[matches[1]] = value;
                  }
                  else if (matches[2] != null) {
                      hostListeners[matches[2]] = value;
                  }
              });
          }
          const inputsMap = {};
          if (inputs != null) {
              inputs.forEach((bindConfig) => {
                  // canonical syntax: `dirProp: elProp`
                  // if there is no `:`, use dirProp = elProp
                  const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
                  inputsMap[parts[0]] = parts[1];
              });
          }
          const outputsMap = {};
          if (outputs != null) {
              outputs.forEach((bindConfig) => {
                  // canonical syntax: `dirProp: elProp`
                  // if there is no `:`, use dirProp = elProp
                  const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);
                  outputsMap[parts[0]] = parts[1];
              });
          }
          return new CompileDirectiveMetadata({
              isHost,
              type,
              isComponent: !!isComponent, selector, exportAs, changeDetection,
              inputs: inputsMap,
              outputs: outputsMap,
              hostListeners,
              hostProperties,
              hostAttributes,
              providers,
              viewProviders,
              queries,
              guards,
              viewQueries,
              entryComponents,
              template,
              componentViewType,
              rendererType,
              componentFactory,
          });
      }
      constructor({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, providers, viewProviders, queries, guards, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }) {
          this.isHost = !!isHost;
          this.type = type;
          this.isComponent = isComponent;
          this.selector = selector;
          this.exportAs = exportAs;
          this.changeDetection = changeDetection;
          this.inputs = inputs;
          this.outputs = outputs;
          this.hostListeners = hostListeners;
          this.hostProperties = hostProperties;
          this.hostAttributes = hostAttributes;
          this.providers = _normalizeArray(providers);
          this.viewProviders = _normalizeArray(viewProviders);
          this.queries = _normalizeArray(queries);
          this.guards = guards;
          this.viewQueries = _normalizeArray(viewQueries);
          this.entryComponents = _normalizeArray(entryComponents);
          this.template = template;
          this.componentViewType = componentViewType;
          this.rendererType = rendererType;
          this.componentFactory = componentFactory;
      }
      toSummary() {
          return {
              summaryKind: CompileSummaryKind.Directive,
              type: this.type,
              isComponent: this.isComponent,
              selector: this.selector,
              exportAs: this.exportAs,
              inputs: this.inputs,
              outputs: this.outputs,
              hostListeners: this.hostListeners,
              hostProperties: this.hostProperties,
              hostAttributes: this.hostAttributes,
              providers: this.providers,
              viewProviders: this.viewProviders,
              queries: this.queries,
              guards: this.guards,
              viewQueries: this.viewQueries,
              entryComponents: this.entryComponents,
              changeDetection: this.changeDetection,
              template: this.template && this.template.toSummary(),
              componentViewType: this.componentViewType,
              rendererType: this.rendererType,
              componentFactory: this.componentFactory
          };
      }
  }
  class CompilePipeMetadata {
      constructor({ type, name, pure }) {
          this.type = type;
          this.name = name;
          this.pure = !!pure;
      }
      toSummary() {
          return {
              summaryKind: CompileSummaryKind.Pipe,
              type: this.type,
              name: this.name,
              pure: this.pure
          };
      }
  }
  /**
   * Metadata regarding compilation of a module.
   */
  class CompileNgModuleMetadata {
      constructor({ type, providers, declaredDirectives, exportedDirectives, declaredPipes, exportedPipes, entryComponents, bootstrapComponents, importedModules, exportedModules, schemas, transitiveModule, id }) {
          this.type = type || null;
          this.declaredDirectives = _normalizeArray(declaredDirectives);
          this.exportedDirectives = _normalizeArray(exportedDirectives);
          this.declaredPipes = _normalizeArray(declaredPipes);
          this.exportedPipes = _normalizeArray(exportedPipes);
          this.providers = _normalizeArray(providers);
          this.entryComponents = _normalizeArray(entryComponents);
          this.bootstrapComponents = _normalizeArray(bootstrapComponents);
          this.importedModules = _normalizeArray(importedModules);
          this.exportedModules = _normalizeArray(exportedModules);
          this.schemas = _normalizeArray(schemas);
          this.id = id || null;
          this.transitiveModule = transitiveModule || null;
      }
      toSummary() {
          const module = this.transitiveModule;
          return {
              summaryKind: CompileSummaryKind.NgModule,
              type: this.type,
              entryComponents: module.entryComponents,
              providers: module.providers,
              modules: module.modules,
              exportedDirectives: module.exportedDirectives,
              exportedPipes: module.exportedPipes
          };
      }
  }
  class TransitiveCompileNgModuleMetadata {
      constructor() {
          this.directivesSet = new Set();
          this.directives = [];
          this.exportedDirectivesSet = new Set();
          this.exportedDirectives = [];
          this.pipesSet = new Set();
          this.pipes = [];
          this.exportedPipesSet = new Set();
          this.exportedPipes = [];
          this.modulesSet = new Set();
          this.modules = [];
          this.entryComponentsSet = new Set();
          this.entryComponents = [];
          this.providers = [];
      }
      addProvider(provider, module) {
          this.providers.push({ provider: provider, module: module });
      }
      addDirective(id) {
          if (!this.directivesSet.has(id.reference)) {
              this.directivesSet.add(id.reference);
              this.directives.push(id);
          }
      }
      addExportedDirective(id) {
          if (!this.exportedDirectivesSet.has(id.reference)) {
              this.exportedDirectivesSet.add(id.reference);
              this.exportedDirectives.push(id);
          }
      }
      addPipe(id) {
          if (!this.pipesSet.has(id.reference)) {
              this.pipesSet.add(id.reference);
              this.pipes.push(id);
          }
      }
      addExportedPipe(id) {
          if (!this.exportedPipesSet.has(id.reference)) {
              this.exportedPipesSet.add(id.reference);
              this.exportedPipes.push(id);
          }
      }
      addModule(id) {
          if (!this.modulesSet.has(id.reference)) {
              this.modulesSet.add(id.reference);
              this.modules.push(id);
          }
      }
      addEntryComponent(ec) {
          if (!this.entryComponentsSet.has(ec.componentType)) {
              this.entryComponentsSet.add(ec.componentType);
              this.entryComponents.push(ec);
          }
      }
  }
  function _normalizeArray(obj) {
      return obj || [];
  }
  class ProviderMeta {
      constructor(token, { useClass, useValue, useExisting, useFactory, deps, multi }) {
          this.token = token;
          this.useClass = useClass || null;
          this.useValue = useValue;
          this.useExisting = useExisting;
          this.useFactory = useFactory || null;
          this.dependencies = deps || null;
          this.multi = !!multi;
      }
  }
  function flatten(list) {
      return list.reduce((flat, item) => {
          const flatItem = Array.isArray(item) ? flatten(item) : item;
          return flat.concat(flatItem);
      }, []);
  }
  function jitSourceUrl(url) {
      // Note: We need 3 "/" so that ng shows up as a separate domain
      // in the chrome dev tools.
      return url.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, 'ng:///');
  }
  function templateSourceUrl(ngModuleType, compMeta, templateMeta) {
      let url;
      if (templateMeta.isInline) {
          if (compMeta.type.reference instanceof StaticSymbol) {
              // Note: a .ts file might contain multiple components with inline templates,
              // so we need to give them unique urls, as these will be used for sourcemaps.
              url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;
          }
          else {
              url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;
          }
      }
      else {
          url = templateMeta.templateUrl;
      }
      return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);
  }
  function sharedStylesheetJitUrl(meta, id) {
      const pathParts = meta.moduleUrl.split(/\/\\/g);
      const baseName = pathParts[pathParts.length - 1];
      return jitSourceUrl(`css/${id}${baseName}.ngstyle.js`);
  }
  function ngModuleJitUrl(moduleMeta) {
      return jitSourceUrl(`${identifierName(moduleMeta.type)}/module.ngfactory.js`);
  }
  function templateJitUrl(ngModuleType, compMeta) {
      return jitSourceUrl(`${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.ngfactory.js`);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const CORE$1 = '@angular/core';
  class Identifiers$1 {
  }
  /* Methods */
  Identifiers$1.NEW_METHOD = 'factory';
  Identifiers$1.TRANSFORM_METHOD = 'transform';
  Identifiers$1.PATCH_DEPS = 'patchedDeps';
  /* Instructions */
  Identifiers$1.namespaceHTML = { name: 'ɵnamespaceHTML', moduleName: CORE$1 };
  Identifiers$1.namespaceMathML = { name: 'ɵnamespaceMathML', moduleName: CORE$1 };
  Identifiers$1.namespaceSVG = { name: 'ɵnamespaceSVG', moduleName: CORE$1 };
  Identifiers$1.element = { name: 'ɵelement', moduleName: CORE$1 };
  Identifiers$1.elementStart = { name: 'ɵelementStart', moduleName: CORE$1 };
  Identifiers$1.elementEnd = { name: 'ɵelementEnd', moduleName: CORE$1 };
  Identifiers$1.elementProperty = { name: 'ɵelementProperty', moduleName: CORE$1 };
  Identifiers$1.componentHostSyntheticProperty = { name: 'ɵcomponentHostSyntheticProperty', moduleName: CORE$1 };
  Identifiers$1.elementAttribute = { name: 'ɵelementAttribute', moduleName: CORE$1 };
  Identifiers$1.elementClassProp = { name: 'ɵelementClassProp', moduleName: CORE$1 };
  Identifiers$1.elementContainerStart = { name: 'ɵelementContainerStart', moduleName: CORE$1 };
  Identifiers$1.elementContainerEnd = { name: 'ɵelementContainerEnd', moduleName: CORE$1 };
  Identifiers$1.elementStyling = { name: 'ɵelementStyling', moduleName: CORE$1 };
  Identifiers$1.elementHostAttrs = { name: 'ɵelementHostAttrs', moduleName: CORE$1 };
  Identifiers$1.elementStylingMap = { name: 'ɵelementStylingMap', moduleName: CORE$1 };
  Identifiers$1.elementStyleProp = { name: 'ɵelementStyleProp', moduleName: CORE$1 };
  Identifiers$1.elementStylingApply = { name: 'ɵelementStylingApply', moduleName: CORE$1 };
  Identifiers$1.containerCreate = { name: 'ɵcontainer', moduleName: CORE$1 };
  Identifiers$1.nextContext = { name: 'ɵnextContext', moduleName: CORE$1 };
  Identifiers$1.templateCreate = { name: 'ɵtemplate', moduleName: CORE$1 };
  Identifiers$1.text = { name: 'ɵtext', moduleName: CORE$1 };
  Identifiers$1.textBinding = { name: 'ɵtextBinding', moduleName: CORE$1 };
  Identifiers$1.bind = { name: 'ɵbind', moduleName: CORE$1 };
  Identifiers$1.enableBindings = { name: 'ɵenableBindings', moduleName: CORE$1 };
  Identifiers$1.disableBindings = { name: 'ɵdisableBindings', moduleName: CORE$1 };
  Identifiers$1.allocHostVars = { name: 'ɵallocHostVars', moduleName: CORE$1 };
  Identifiers$1.getCurrentView = { name: 'ɵgetCurrentView', moduleName: CORE$1 };
  Identifiers$1.restoreView = { name: 'ɵrestoreView', moduleName: CORE$1 };
  Identifiers$1.interpolation1 = { name: 'ɵinterpolation1', moduleName: CORE$1 };
  Identifiers$1.interpolation2 = { name: 'ɵinterpolation2', moduleName: CORE$1 };
  Identifiers$1.interpolation3 = { name: 'ɵinterpolation3', moduleName: CORE$1 };
  Identifiers$1.interpolation4 = { name: 'ɵinterpolation4', moduleName: CORE$1 };
  Identifiers$1.interpolation5 = { name: 'ɵinterpolation5', moduleName: CORE$1 };
  Identifiers$1.interpolation6 = { name: 'ɵinterpolation6', moduleName: CORE$1 };
  Identifiers$1.interpolation7 = { name: 'ɵinterpolation7', moduleName: CORE$1 };
  Identifiers$1.interpolation8 = { name: 'ɵinterpolation8', moduleName: CORE$1 };
  Identifiers$1.interpolationV = { name: 'ɵinterpolationV', moduleName: CORE$1 };
  Identifiers$1.pureFunction0 = { name: 'ɵpureFunction0', moduleName: CORE$1 };
  Identifiers$1.pureFunction1 = { name: 'ɵpureFunction1', moduleName: CORE$1 };
  Identifiers$1.pureFunction2 = { name: 'ɵpureFunction2', moduleName: CORE$1 };
  Identifiers$1.pureFunction3 = { name: 'ɵpureFunction3', moduleName: CORE$1 };
  Identifiers$1.pureFunction4 = { name: 'ɵpureFunction4', moduleName: CORE$1 };
  Identifiers$1.pureFunction5 = { name: 'ɵpureFunction5', moduleName: CORE$1 };
  Identifiers$1.pureFunction6 = { name: 'ɵpureFunction6', moduleName: CORE$1 };
  Identifiers$1.pureFunction7 = { name: 'ɵpureFunction7', moduleName: CORE$1 };
  Identifiers$1.pureFunction8 = { name: 'ɵpureFunction8', moduleName: CORE$1 };
  Identifiers$1.pureFunctionV = { name: 'ɵpureFunctionV', moduleName: CORE$1 };
  Identifiers$1.pipeBind1 = { name: 'ɵpipeBind1', moduleName: CORE$1 };
  Identifiers$1.pipeBind2 = { name: 'ɵpipeBind2', moduleName: CORE$1 };
  Identifiers$1.pipeBind3 = { name: 'ɵpipeBind3', moduleName: CORE$1 };
  Identifiers$1.pipeBind4 = { name: 'ɵpipeBind4', moduleName: CORE$1 };
  Identifiers$1.pipeBindV = { name: 'ɵpipeBindV', moduleName: CORE$1 };
  Identifiers$1.i18n = { name: 'ɵi18n', moduleName: CORE$1 };
  Identifiers$1.i18nAttributes = { name: 'ɵi18nAttributes', moduleName: CORE$1 };
  Identifiers$1.i18nExp = { name: 'ɵi18nExp', moduleName: CORE$1 };
  Identifiers$1.i18nStart = { name: 'ɵi18nStart', moduleName: CORE$1 };
  Identifiers$1.i18nEnd = { name: 'ɵi18nEnd', moduleName: CORE$1 };
  Identifiers$1.i18nApply = { name: 'ɵi18nApply', moduleName: CORE$1 };
  Identifiers$1.i18nPostprocess = { name: 'ɵi18nPostprocess', moduleName: CORE$1 };
  Identifiers$1.load = { name: 'ɵload', moduleName: CORE$1 };
  Identifiers$1.loadQueryList = { name: 'ɵloadQueryList', moduleName: CORE$1 };
  Identifiers$1.pipe = { name: 'ɵpipe', moduleName: CORE$1 };
  Identifiers$1.projection = { name: 'ɵprojection', moduleName: CORE$1 };
  Identifiers$1.projectionDef = { name: 'ɵprojectionDef', moduleName: CORE$1 };
  Identifiers$1.reference = { name: 'ɵreference', moduleName: CORE$1 };
  Identifiers$1.inject = { name: 'inject', moduleName: CORE$1 };
  Identifiers$1.injectAttribute = { name: 'ɵinjectAttribute', moduleName: CORE$1 };
  Identifiers$1.directiveInject = { name: 'ɵdirectiveInject', moduleName: CORE$1 };
  Identifiers$1.templateRefExtractor = { name: 'ɵtemplateRefExtractor', moduleName: CORE$1 };
  Identifiers$1.defineBase = { name: 'ɵdefineBase', moduleName: CORE$1 };
  Identifiers$1.BaseDef = {
      name: 'ɵBaseDef',
      moduleName: CORE$1,
  };
  Identifiers$1.defineComponent = { name: 'ɵdefineComponent', moduleName: CORE$1 };
  Identifiers$1.ComponentDefWithMeta = {
      name: 'ɵComponentDefWithMeta',
      moduleName: CORE$1,
  };
  Identifiers$1.defineDirective = {
      name: 'ɵdefineDirective',
      moduleName: CORE$1,
  };
  Identifiers$1.DirectiveDefWithMeta = {
      name: 'ɵDirectiveDefWithMeta',
      moduleName: CORE$1,
  };
  Identifiers$1.InjectorDef = {
      name: 'ɵInjectorDef',
      moduleName: CORE$1,
  };
  Identifiers$1.defineInjector = {
      name: 'defineInjector',
      moduleName: CORE$1,
  };
  Identifiers$1.NgModuleDefWithMeta = {
      name: 'ɵNgModuleDefWithMeta',
      moduleName: CORE$1,
  };
  Identifiers$1.defineNgModule = { name: 'ɵdefineNgModule', moduleName: CORE$1 };
  Identifiers$1.PipeDefWithMeta = { name: 'ɵPipeDefWithMeta', moduleName: CORE$1 };
  Identifiers$1.definePipe = { name: 'ɵdefinePipe', moduleName: CORE$1 };
  Identifiers$1.query = { name: 'ɵquery', moduleName: CORE$1 };
  Identifiers$1.queryRefresh = { name: 'ɵqueryRefresh', moduleName: CORE$1 };
  Identifiers$1.registerContentQuery = { name: 'ɵregisterContentQuery', moduleName: CORE$1 };
  Identifiers$1.NgOnChangesFeature = { name: 'ɵNgOnChangesFeature', moduleName: CORE$1 };
  Identifiers$1.InheritDefinitionFeature = { name: 'ɵInheritDefinitionFeature', moduleName: CORE$1 };
  Identifiers$1.ProvidersFeature = { name: 'ɵProvidersFeature', moduleName: CORE$1 };
  Identifiers$1.listener = { name: 'ɵlistener', moduleName: CORE$1 };
  Identifiers$1.getFactoryOf = {
      name: 'ɵgetFactoryOf',
      moduleName: CORE$1,
  };
  Identifiers$1.getInheritedFactory = {
      name: 'ɵgetInheritedFactory',
      moduleName: CORE$1,
  };
  // sanitization-related functions
  Identifiers$1.sanitizeHtml = { name: 'ɵsanitizeHtml', moduleName: CORE$1 };
  Identifiers$1.sanitizeStyle = { name: 'ɵsanitizeStyle', moduleName: CORE$1 };
  Identifiers$1.defaultStyleSanitizer = { name: 'ɵdefaultStyleSanitizer', moduleName: CORE$1 };
  Identifiers$1.sanitizeResourceUrl = { name: 'ɵsanitizeResourceUrl', moduleName: CORE$1 };
  Identifiers$1.sanitizeScript = { name: 'ɵsanitizeScript', moduleName: CORE$1 };
  Identifiers$1.sanitizeUrl = { name: 'ɵsanitizeUrl', moduleName: CORE$1 };

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class Message {
      /**
       * @param nodes message AST
       * @param placeholders maps placeholder names to static content
       * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
       * @param meaning
       * @param description
       * @param id
       */
      constructor(nodes, placeholders, placeholderToMessage, meaning, description, id) {
          this.nodes = nodes;
          this.placeholders = placeholders;
          this.placeholderToMessage = placeholderToMessage;
          this.meaning = meaning;
          this.description = description;
          this.id = id;
          if (nodes.length) {
              this.sources = [{
                      filePath: nodes[0].sourceSpan.start.file.url,
                      startLine: nodes[0].sourceSpan.start.line + 1,
                      startCol: nodes[0].sourceSpan.start.col + 1,
                      endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
                      endCol: nodes[0].sourceSpan.start.col + 1
                  }];
          }
          else {
              this.sources = [];
          }
      }
  }
  class Text {
      constructor(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitText(this, context); }
  }
  // TODO(vicb): do we really need this node (vs an array) ?
  class Container {
      constructor(children, sourceSpan) {
          this.children = children;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitContainer(this, context); }
  }
  class Icu {
      constructor(expression, type, cases, sourceSpan) {
          this.expression = expression;
          this.type = type;
          this.cases = cases;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitIcu(this, context); }
  }
  class TagPlaceholder {
      constructor(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {
          this.tag = tag;
          this.attrs = attrs;
          this.startName = startName;
          this.closeName = closeName;
          this.children = children;
          this.isVoid = isVoid;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitTagPlaceholder(this, context); }
  }
  class Placeholder {
      constructor(value, name, sourceSpan) {
          this.value = value;
          this.name = name;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitPlaceholder(this, context); }
  }
  class IcuPlaceholder {
      constructor(value, name, sourceSpan) {
          this.value = value;
          this.name = name;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitIcuPlaceholder(this, context); }
  }
  // Visit all the nodes recursively
  class RecurseVisitor {
      visitText(text, context) { }
      visitContainer(container, context) {
          container.children.forEach(child => child.visit(this));
      }
      visitIcu(icu, context) {
          Object.keys(icu.cases).forEach(k => { icu.cases[k].visit(this); });
      }
      visitTagPlaceholder(ph, context) {
          ph.children.forEach(child => child.visit(this));
      }
      visitPlaceholder(ph, context) { }
      visitIcuPlaceholder(ph, context) { }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function digest(message) {
      return message.id || sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);
  }
  function decimalDigest(message) {
      if (message.id) {
          return message.id;
      }
      const visitor = new _SerializerIgnoreIcuExpVisitor();
      const parts = message.nodes.map(a => a.visit(visitor, null));
      return computeMsgId(parts.join(''), message.meaning);
  }
  /**
   * Serialize the i18n ast to something xml-like in order to generate an UID.
   *
   * The visitor is also used in the i18n parser tests
   *
   * @internal
   */
  class _SerializerVisitor {
      visitText(text, context) { return text.value; }
      visitContainer(container, context) {
          return `[${container.children.map(child => child.visit(this)).join(', ')}]`;
      }
      visitIcu(icu, context) {
          const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
          return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;
      }
      visitTagPlaceholder(ph, context) {
          return ph.isVoid ?
              `<ph tag name="${ph.startName}"/>` :
              `<ph tag name="${ph.startName}">${ph.children.map(child => child.visit(this)).join(', ')}</ph name="${ph.closeName}">`;
      }
      visitPlaceholder(ph, context) {
          return ph.value ? `<ph name="${ph.name}">${ph.value}</ph>` : `<ph name="${ph.name}"/>`;
      }
      visitIcuPlaceholder(ph, context) {
          return `<ph icu name="${ph.name}">${ph.value.visit(this)}</ph>`;
      }
  }
  const serializerVisitor = new _SerializerVisitor();
  function serializeNodes(nodes) {
      return nodes.map(a => a.visit(serializerVisitor, null));
  }
  /**
   * Serialize the i18n ast to something xml-like in order to generate an UID.
   *
   * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.
   *
   * @internal
   */
  class _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {
      visitIcu(icu, context) {
          let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
          // Do not take the expression into account
          return `{${icu.type}, ${strCases.join(', ')}}`;
      }
  }
  /**
   * Compute the SHA1 of the given string
   *
   * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
   *
   * WARNING: this function has not been designed not tested with security in mind.
   *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
   */
  function sha1(str) {
      const utf8 = utf8Encode(str);
      const words32 = stringToWords32(utf8, Endian.Big);
      const len = utf8.length * 8;
      const w = new Array(80);
      let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
      words32[len >> 5] |= 0x80 << (24 - len % 32);
      words32[((len + 64 >> 9) << 4) + 15] = len;
      for (let i = 0; i < words32.length; i += 16) {
          const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
          for (let j = 0; j < 80; j++) {
              if (j < 16) {
                  w[j] = words32[i + j];
              }
              else {
                  w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
              }
              const [f, k] = fk(j, b, c, d);
              const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
              [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
          }
          [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
      }
      return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
  }
  function fk(index, b, c, d) {
      if (index < 20) {
          return [(b & c) | (~b & d), 0x5a827999];
      }
      if (index < 40) {
          return [b ^ c ^ d, 0x6ed9eba1];
      }
      if (index < 60) {
          return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];
      }
      return [b ^ c ^ d, 0xca62c1d6];
  }
  /**
   * Compute the fingerprint of the given string
   *
   * The output is 64 bit number encoded as a decimal string
   *
   * based on:
   * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java
   */
  function fingerprint(str) {
      const utf8 = utf8Encode(str);
      let [hi, lo] = [hash32(utf8, 0), hash32(utf8, 102072)];
      if (hi == 0 && (lo == 0 || lo == 1)) {
          hi = hi ^ 0x130f9bef;
          lo = lo ^ -0x6b5f56d8;
      }
      return [hi, lo];
  }
  function computeMsgId(msg, meaning) {
      let [hi, lo] = fingerprint(msg);
      if (meaning) {
          const [him, lom] = fingerprint(meaning);
          [hi, lo] = add64(rol64([hi, lo], 1), [him, lom]);
      }
      return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));
  }
  function hash32(str, c) {
      let [a, b] = [0x9e3779b9, 0x9e3779b9];
      let i;
      const len = str.length;
      for (i = 0; i + 12 <= len; i += 12) {
          a = add32(a, wordAt(str, i, Endian.Little));
          b = add32(b, wordAt(str, i + 4, Endian.Little));
          c = add32(c, wordAt(str, i + 8, Endian.Little));
          [a, b, c] = mix([a, b, c]);
      }
      a = add32(a, wordAt(str, i, Endian.Little));
      b = add32(b, wordAt(str, i + 4, Endian.Little));
      // the first byte of c is reserved for the length
      c = add32(c, len);
      c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);
      return mix([a, b, c])[2];
  }
  // clang-format off
  function mix([a, b, c]) {
      a = sub32(a, b);
      a = sub32(a, c);
      a ^= c >>> 13;
      b = sub32(b, c);
      b = sub32(b, a);
      b ^= a << 8;
      c = sub32(c, a);
      c = sub32(c, b);
      c ^= b >>> 13;
      a = sub32(a, b);
      a = sub32(a, c);
      a ^= c >>> 12;
      b = sub32(b, c);
      b = sub32(b, a);
      b ^= a << 16;
      c = sub32(c, a);
      c = sub32(c, b);
      c ^= b >>> 5;
      a = sub32(a, b);
      a = sub32(a, c);
      a ^= c >>> 3;
      b = sub32(b, c);
      b = sub32(b, a);
      b ^= a << 10;
      c = sub32(c, a);
      c = sub32(c, b);
      c ^= b >>> 15;
      return [a, b, c];
  }
  // clang-format on
  // Utils
  var Endian;
  (function (Endian) {
      Endian[Endian["Little"] = 0] = "Little";
      Endian[Endian["Big"] = 1] = "Big";
  })(Endian || (Endian = {}));
  function add32(a, b) {
      return add32to64(a, b)[1];
  }
  function add32to64(a, b) {
      const low = (a & 0xffff) + (b & 0xffff);
      const high = (a >>> 16) + (b >>> 16) + (low >>> 16);
      return [high >>> 16, (high << 16) | (low & 0xffff)];
  }
  function add64([ah, al], [bh, bl]) {
      const [carry, l] = add32to64(al, bl);
      const h = add32(add32(ah, bh), carry);
      return [h, l];
  }
  function sub32(a, b) {
      const low = (a & 0xffff) - (b & 0xffff);
      const high = (a >> 16) - (b >> 16) + (low >> 16);
      return (high << 16) | (low & 0xffff);
  }
  // Rotate a 32b number left `count` position
  function rol32(a, count) {
      return (a << count) | (a >>> (32 - count));
  }
  // Rotate a 64b number left `count` position
  function rol64([hi, lo], count) {
      const h = (hi << count) | (lo >>> (32 - count));
      const l = (lo << count) | (hi >>> (32 - count));
      return [h, l];
  }
  function stringToWords32(str, endian) {
      const words32 = Array((str.length + 3) >>> 2);
      for (let i = 0; i < words32.length; i++) {
          words32[i] = wordAt(str, i * 4, endian);
      }
      return words32;
  }
  function byteAt(str, index) {
      return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;
  }
  function wordAt(str, index, endian) {
      let word = 0;
      if (endian === Endian.Big) {
          for (let i = 0; i < 4; i++) {
              word += byteAt(str, index + i) << (24 - 8 * i);
          }
      }
      else {
          for (let i = 0; i < 4; i++) {
              word += byteAt(str, index + i) << 8 * i;
          }
      }
      return word;
  }
  function words32ToByteString(words32) {
      return words32.reduce((str, word) => str + word32ToByteString(word), '');
  }
  function word32ToByteString(word) {
      let str = '';
      for (let i = 0; i < 4; i++) {
          str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);
      }
      return str;
  }
  function byteStringToHexString(str) {
      let hex = '';
      for (let i = 0; i < str.length; i++) {
          const b = byteAt(str, i);
          hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);
      }
      return hex.toLowerCase();
  }
  // based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)
  function byteStringToDecString(str) {
      let decimal = '';
      let toThePower = '1';
      for (let i = str.length - 1; i >= 0; i--) {
          decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));
          toThePower = numberTimesBigInt(256, toThePower);
      }
      return decimal.split('').reverse().join('');
  }
  // x and y decimal, lowest significant digit first
  function addBigInt(x, y) {
      let sum = '';
      const len = Math.max(x.length, y.length);
      for (let i = 0, carry = 0; i < len || carry; i++) {
          const tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);
          if (tmpSum >= 10) {
              carry = 1;
              sum += tmpSum - 10;
          }
          else {
              carry = 0;
              sum += tmpSum;
          }
      }
      return sum;
  }
  function numberTimesBigInt(num, b) {
      let product = '';
      let bToThePower = b;
      for (; num !== 0; num = num >>> 1) {
          if (num & 1)
              product = addBigInt(product, bToThePower);
          bToThePower = addBigInt(bToThePower, bToThePower);
      }
      return product;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class Serializer {
      // Creates a name mapper, see `PlaceholderMapper`
      // Returning `null` means that no name mapping is used.
      createNameMapper(message) { return null; }
  }
  /**
   * A simple mapper that take a function to transform an internal name to a public name
   */
  class SimplePlaceholderMapper extends RecurseVisitor {
      // create a mapping from the message
      constructor(message, mapName) {
          super();
          this.mapName = mapName;
          this.internalToPublic = {};
          this.publicToNextId = {};
          this.publicToInternal = {};
          message.nodes.forEach(node => node.visit(this));
      }
      toPublicName(internalName) {
          return this.internalToPublic.hasOwnProperty(internalName) ?
              this.internalToPublic[internalName] :
              null;
      }
      toInternalName(publicName) {
          return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :
              null;
      }
      visitText(text, context) { return null; }
      visitTagPlaceholder(ph, context) {
          this.visitPlaceholderName(ph.startName);
          super.visitTagPlaceholder(ph, context);
          this.visitPlaceholderName(ph.closeName);
      }
      visitPlaceholder(ph, context) { this.visitPlaceholderName(ph.name); }
      visitIcuPlaceholder(ph, context) {
          this.visitPlaceholderName(ph.name);
      }
      // XMB placeholders could only contains A-Z, 0-9 and _
      visitPlaceholderName(internalName) {
          if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {
              return;
          }
          let publicName = this.mapName(internalName);
          if (this.publicToInternal.hasOwnProperty(publicName)) {
              // Create a new XMB when it has already been used
              const nextId = this.publicToNextId[publicName];
              this.publicToNextId[publicName] = nextId + 1;
              publicName = `${publicName}_${nextId}`;
          }
          else {
              this.publicToNextId[publicName] = 1;
          }
          this.internalToPublic[internalName] = publicName;
          this.publicToInternal[publicName] = internalName;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class _Visitor {
      visitTag(tag) {
          const strAttrs = this._serializeAttributes(tag.attrs);
          if (tag.children.length == 0) {
              return `<${tag.name}${strAttrs}/>`;
          }
          const strChildren = tag.children.map(node => node.visit(this));
          return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;
      }
      visitText(text) { return text.value; }
      visitDeclaration(decl) {
          return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;
      }
      _serializeAttributes(attrs) {
          const strAttrs = Object.keys(attrs).map((name) => `${name}="${attrs[name]}"`).join(' ');
          return strAttrs.length > 0 ? ' ' + strAttrs : '';
      }
      visitDoctype(doctype) {
          return `<!DOCTYPE ${doctype.rootTag} [\n${doctype.dtd}\n]>`;
      }
  }
  const _visitor = new _Visitor();
  function serialize(nodes) {
      return nodes.map((node) => node.visit(_visitor)).join('');
  }
  class Declaration {
      constructor(unescapedAttrs) {
          this.attrs = {};
          Object.keys(unescapedAttrs).forEach((k) => {
              this.attrs[k] = escapeXml(unescapedAttrs[k]);
          });
      }
      visit(visitor) { return visitor.visitDeclaration(this); }
  }
  class Doctype {
      constructor(rootTag, dtd) {
          this.rootTag = rootTag;
          this.dtd = dtd;
      }
      visit(visitor) { return visitor.visitDoctype(this); }
  }
  class Tag {
      constructor(name, unescapedAttrs = {}, children = []) {
          this.name = name;
          this.children = children;
          this.attrs = {};
          Object.keys(unescapedAttrs).forEach((k) => {
              this.attrs[k] = escapeXml(unescapedAttrs[k]);
          });
      }
      visit(visitor) { return visitor.visitTag(this); }
  }
  class Text$1 {
      constructor(unescapedValue) { this.value = escapeXml(unescapedValue); }
      visit(visitor) { return visitor.visitText(this); }
  }
  class CR extends Text$1 {
      constructor(ws = 0) { super(`\n${new Array(ws + 1).join(' ')}`); }
  }
  const _ESCAPED_CHARS = [
      [/&/g, '&amp;'],
      [/"/g, '&quot;'],
      [/'/g, '&apos;'],
      [/</g, '&lt;'],
      [/>/g, '&gt;'],
  ];
  // Escape `_ESCAPED_CHARS` characters in the given text with encoded entities
  function escapeXml(text) {
      return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const _MESSAGES_TAG = 'messagebundle';
  const _MESSAGE_TAG = 'msg';
  const _PLACEHOLDER_TAG = 'ph';
  const _EXAMPLE_TAG = 'ex';
  const _SOURCE_TAG = 'source';
  const _DOCTYPE = `<!ELEMENT messagebundle (msg)*>
<!ATTLIST messagebundle class CDATA #IMPLIED>

<!ELEMENT msg (#PCDATA|ph|source)*>
<!ATTLIST msg id CDATA #IMPLIED>
<!ATTLIST msg seq CDATA #IMPLIED>
<!ATTLIST msg name CDATA #IMPLIED>
<!ATTLIST msg desc CDATA #IMPLIED>
<!ATTLIST msg meaning CDATA #IMPLIED>
<!ATTLIST msg obsolete (obsolete) #IMPLIED>
<!ATTLIST msg xml:space (default|preserve) "default">
<!ATTLIST msg is_hidden CDATA #IMPLIED>

<!ELEMENT source (#PCDATA)>

<!ELEMENT ph (#PCDATA|ex)*>
<!ATTLIST ph name CDATA #REQUIRED>

<!ELEMENT ex (#PCDATA)>`;
  class Xmb extends Serializer {
      write(messages, locale) {
          const exampleVisitor = new ExampleVisitor();
          const visitor = new _Visitor$1();
          let rootNode = new Tag(_MESSAGES_TAG);
          messages.forEach(message => {
              const attrs = { id: message.id };
              if (message.description) {
                  attrs['desc'] = message.description;
              }
              if (message.meaning) {
                  attrs['meaning'] = message.meaning;
              }
              let sourceTags = [];
              message.sources.forEach((source) => {
                  sourceTags.push(new Tag(_SOURCE_TAG, {}, [
                      new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)
                  ]));
              });
              rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));
          });
          rootNode.children.push(new CR());
          return serialize([
              new Declaration({ version: '1.0', encoding: 'UTF-8' }),
              new CR(),
              new Doctype(_MESSAGES_TAG, _DOCTYPE),
              new CR(),
              exampleVisitor.addDefaultExamples(rootNode),
              new CR(),
          ]);
      }
      load(content, url) {
          throw new Error('Unsupported');
      }
      digest(message) { return digest$1(message); }
      createNameMapper(message) {
          return new SimplePlaceholderMapper(message, toPublicName);
      }
  }
  class _Visitor$1 {
      visitText(text, context) { return [new Text$1(text.value)]; }
      visitContainer(container, context) {
          const nodes = [];
          container.children.forEach((node) => nodes.push(...node.visit(this)));
          return nodes;
      }
      visitIcu(icu, context) {
          const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];
          Object.keys(icu.cases).forEach((c) => {
              nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));
          });
          nodes.push(new Text$1(`}`));
          return nodes;
      }
      visitTagPlaceholder(ph, context) {
          const startTagAsText = new Text$1(`<${ph.tag}>`);
          const startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);
          // TC requires PH to have a non empty EX, and uses the text node to show the "original" value.
          const startTagPh = new Tag(_PLACEHOLDER_TAG, { name: ph.startName }, [startEx, startTagAsText]);
          if (ph.isVoid) {
              // void tags have no children nor closing tags
              return [startTagPh];
          }
          const closeTagAsText = new Text$1(`</${ph.tag}>`);
          const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);
          // TC requires PH to have a non empty EX, and uses the text node to show the "original" value.
          const closeTagPh = new Tag(_PLACEHOLDER_TAG, { name: ph.closeName }, [closeEx, closeTagAsText]);
          return [startTagPh, ...this.serialize(ph.children), closeTagPh];
      }
      visitPlaceholder(ph, context) {
          const interpolationAsText = new Text$1(`{{${ph.value}}}`);
          // Example tag needs to be not-empty for TC.
          const exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);
          return [
              // TC requires PH to have a non empty EX, and uses the text node to show the "original" value.
              new Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag, interpolationAsText])
          ];
      }
      visitIcuPlaceholder(ph, context) {
          const icuExpression = ph.value.expression;
          const icuType = ph.value.type;
          const icuCases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');
          const icuAsText = new Text$1(`{${icuExpression}, ${icuType}, ${icuCases}}`);
          const exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);
          return [
              // TC requires PH to have a non empty EX, and uses the text node to show the "original" value.
              new Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag, icuAsText])
          ];
      }
      serialize(nodes) {
          return [].concat(...nodes.map(node => node.visit(this)));
      }
  }
  function digest$1(message) {
      return decimalDigest(message);
  }
  // TC requires at least one non-empty example on placeholders
  class ExampleVisitor {
      addDefaultExamples(node) {
          node.visit(this);
          return node;
      }
      visitTag(tag) {
          if (tag.name === _PLACEHOLDER_TAG) {
              if (!tag.children || tag.children.length == 0) {
                  const exText = new Text$1(tag.attrs['name'] || '...');
                  tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];
              }
          }
          else if (tag.children) {
              tag.children.forEach(node => node.visit(this));
          }
      }
      visitText(text) { }
      visitDeclaration(decl) { }
      visitDoctype(doctype) { }
  }
  // XMB/XTB placeholders can only contain A-Z, 0-9 and _
  function toPublicName(internalName) {
      return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function mapLiteral(obj, quoted = false) {
      return literalMap(Object.keys(obj).map(key => ({
          key,
          quoted,
          value: obj[key],
      })));
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */
  const CLOSURE_TRANSLATION_PREFIX = 'MSG_';
  const CLOSURE_TRANSLATION_MATCHER_REGEXP = new RegExp(`^${CLOSURE_TRANSLATION_PREFIX}`);
  /* Prefix for non-`goog.getMsg` i18n-related vars */
  const TRANSLATION_PREFIX = 'I18N_';
  /** Closure uses `goog.getMsg(message)` to lookup translations */
  const GOOG_GET_MSG = 'goog.getMsg';
  /** I18n separators for metadata **/
  const I18N_MEANING_SEPARATOR = '|';
  const I18N_ID_SEPARATOR = '@@';
  /** Name of the i18n attributes **/
  const I18N_ATTR = 'i18n';
  const I18N_ATTR_PREFIX = 'i18n-';
  /** Prefix of var expressions used in ICUs */
  const I18N_ICU_VAR_PREFIX = 'VAR_';
  /** Prefix of ICU expressions for post processing */
  const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';
  /** Placeholder wrapper for i18n expressions **/
  const I18N_PLACEHOLDER_SYMBOL = '�';
  function i18nTranslationToDeclStmt(variable$$1, message, params) {
      const args = [literal(message)];
      if (params && Object.keys(params).length) {
          args.push(mapLiteral(params, true));
      }
      const fnCall = variable(GOOG_GET_MSG).callFn(args);
      return variable$$1.set(fnCall).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);
  }
  // Converts i18n meta informations for a message (id, description, meaning)
  // to a JsDoc statement formatted as expected by the Closure compiler.
  function i18nMetaToDocStmt(meta) {
      const tags = [];
      if (meta.description) {
          tags.push({ tagName: "desc" /* Desc */, text: meta.description });
      }
      if (meta.meaning) {
          tags.push({ tagName: "meaning" /* Meaning */, text: meta.meaning });
      }
      return tags.length == 0 ? null : new JSDocCommentStmt(tags);
  }
  function isI18nAttribute(name) {
      return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
  }
  function isI18nRootNode(meta) {
      return meta instanceof Message;
  }
  function isSingleI18nIcu(meta) {
      return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;
  }
  function hasI18nAttrs(element) {
      return element.attrs.some((attr) => isI18nAttribute(attr.name));
  }
  function metaFromI18nMessage(message, id = null) {
      return {
          id: typeof id === 'string' ? id : message.id || '',
          meaning: message.meaning || '',
          description: message.description || ''
      };
  }
  function icuFromI18nMessage(message) {
      return message.nodes[0];
  }
  function wrapI18nPlaceholder(content, contextId = 0) {
      const blockId = contextId > 0 ? `:${contextId}` : '';
      return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;
  }
  function assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {
      if (!strings.length)
          return '';
      let acc = '';
      const lastIdx = strings.length - 1;
      for (let i = 0; i < lastIdx; i++) {
          acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;
      }
      acc += strings[lastIdx];
      return acc;
  }
  function getSeqNumberGenerator(startsAt = 0) {
      let current = startsAt;
      return () => current++;
  }
  function placeholdersToParams(placeholders) {
      const params = {};
      placeholders.forEach((values, key) => {
          params[key] = literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);
      });
      return params;
  }
  function updatePlaceholderMap(map, name, ...values) {
      const current = map.get(name) || [];
      current.push(...values);
      map.set(name, current);
  }
  function assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {
      const startIdx = bindingStartIndex;
      const placeholders = new Map();
      const node = meta instanceof Message ? meta.nodes.find(node => node instanceof Container) : meta;
      if (node) {
          node
              .children.filter((child) => child instanceof Placeholder)
              .forEach((child, idx) => {
              const content = wrapI18nPlaceholder(startIdx + idx, contextId);
              updatePlaceholderMap(placeholders, child.name, content);
          });
      }
      return placeholders;
  }
  function findIndex(items, callback) {
      for (let i = 0; i < items.length; i++) {
          if (callback(items[i])) {
              return i;
          }
      }
      return -1;
  }
  /**
   * Parses i18n metas like:
   *  - "@@id",
   *  - "description[@@id]",
   *  - "meaning|description[@@id]"
   * and returns an object with parsed output.
   *
   * @param meta String that represents i18n meta
   * @returns Object with id, meaning and description fields
   */
  function parseI18nMeta(meta) {
      let id;
      let meaning;
      let description;
      if (meta) {
          const idIndex = meta.indexOf(I18N_ID_SEPARATOR);
          const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
          let meaningAndDesc;
          [meaningAndDesc, id] =
              (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];
          [meaning, description] = (descIndex > -1) ?
              [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :
              ['', meaningAndDesc];
      }
      return { id, meaning, description };
  }
  /**
   * Converts internal placeholder names to public-facing format
   * (for example to use in goog.getMsg call).
   * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.
   *
   * @param name The placeholder name that should be formatted
   * @returns Formatted placeholder name
   */
  function formatI18nPlaceholderName(name) {
      const chunks = toPublicName(name).split('_');
      if (chunks.length === 1) {
          // if no "_" found - just lowercase the value
          return name.toLowerCase();
      }
      let postfix;
      // eject last element if it's a number
      if (/^\d+$/.test(chunks[chunks.length - 1])) {
          postfix = chunks.pop();
      }
      let raw = chunks.shift().toLowerCase();
      if (chunks.length) {
          raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');
      }
      return postfix ? `${raw}_${postfix}` : raw;
  }
  /**
   * Generates a prefix for translation const name.
   *
   * @param extra Additional local prefix that should be injected into translation var name
   * @returns Complete translation const prefix
   */
  function getTranslationConstPrefix(extra) {
      return `${CLOSURE_TRANSLATION_PREFIX}${extra}`.toUpperCase();
  }
  /**
   * Generates translation declaration statements.
   *
   * @param variable Translation value reference
   * @param message Text message to be translated
   * @param meta Object that contains meta information (id, meaning and description)
   * @param params Object with placeholders key-value pairs
   * @param transformFn Optional transformation (post processing) function reference
   * @returns Array of Statements that represent a given translation
   */
  function getTranslationDeclStmts(variable$$1, message, meta, params = {}, transformFn) {
      const statements = [];
      const docStatements = i18nMetaToDocStmt(meta);
      if (docStatements) {
          statements.push(docStatements);
      }
      if (transformFn) {
          statements.push(i18nTranslationToDeclStmt(variable$$1, message, params));
          // Closure Compiler doesn't allow non-goo.getMsg const names to start with `MSG_`,
          // so we update variable name prefix in case post processing is required, so we can
          // assign the result of post-processing function to the var that starts with `I18N_`
          const raw = variable(variable$$1.name);
          variable$$1.name = variable$$1.name.replace(CLOSURE_TRANSLATION_MATCHER_REGEXP, TRANSLATION_PREFIX);
          statements.push(variable$$1.set(transformFn(raw)).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
      }
      else {
          statements.push(i18nTranslationToDeclStmt(variable$$1, message, params));
      }
      return statements;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** Name of the temporary to use during data binding */
  const TEMPORARY_NAME = '_t';
  /** Name of the context parameter passed into a template function */
  const CONTEXT_NAME = 'ctx';
  /** Name of the RenderFlag passed into a template function */
  const RENDER_FLAGS = 'rf';
  /** The prefix reference variables */
  const REFERENCE_PREFIX = '_r';
  /** The name of the implicit context reference */
  const IMPLICIT_REFERENCE = '$implicit';
  /** Non bindable attribute name **/
  const NON_BINDABLE_ATTR = 'ngNonBindable';
  /**
   * Creates an allocator for a temporary variable.
   *
   * A variable declaration is added to the statements the first time the allocator is invoked.
   */
  function temporaryAllocator(statements, name) {
      let temp = null;
      return () => {
          if (!temp) {
              statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));
              temp = variable(name);
          }
          return temp;
      };
  }
  function unsupported(feature) {
      if (this) {
          throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);
      }
      throw new Error(`Feature ${feature} is not supported yet`);
  }
  function invalid$1(arg) {
      throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${undefined}`);
  }
  function asLiteral(value) {
      if (Array.isArray(value)) {
          return literalArr(value.map(asLiteral));
      }
      return literal(value, INFERRED_TYPE);
  }
  function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
      if (Object.getOwnPropertyNames(keys).length > 0) {
          return mapToExpression(keys, keepDeclared);
      }
      return null;
  }
  function mapToExpression(map, keepDeclared) {
      return literalMap(Object.getOwnPropertyNames(map).map(key => {
          // canonical syntax: `dirProp: publicProp`
          // if there is no `:`, use dirProp = elProp
          const value = map[key];
          let declaredName;
          let publicName;
          let minifiedName;
          if (Array.isArray(value)) {
              [publicName, declaredName] = value;
          }
          else {
              [declaredName, publicName] = splitAtColon(key, [key, value]);
          }
          minifiedName = declaredName;
          return {
              key: minifiedName,
              quoted: false,
              value: (keepDeclared && publicName !== declaredName) ?
                  literalArr([asLiteral(publicName), asLiteral(declaredName)]) :
                  asLiteral(publicName)
          };
      }));
  }
  /**
   *  Remove trailing null nodes as they are implied.
   */
  function trimTrailingNulls(parameters) {
      while (isNull(parameters[parameters.length - 1])) {
          parameters.pop();
      }
      return parameters;
  }
  function getQueryPredicate(query, constantPool) {
      if (Array.isArray(query.predicate)) {
          let predicate = [];
          query.predicate.forEach((selector) => {
              // Each item in predicates array may contain strings with comma-separated refs
              // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them
              // as separate array entities
              const selectors = selector.split(',').map(token => literal(token.trim()));
              predicate.push(...selectors);
          });
          return constantPool.getConstLiteral(literalArr(predicate), true);
      }
      else {
          return query.predicate;
      }
  }
  class DefinitionMap {
      constructor() {
          this.values = [];
      }
      set(key, value) {
          if (value) {
              this.values.push({ key, value, quoted: false });
          }
      }
      toLiteralMap() { return literalMap(this.values); }
  }
  /**
   * Extract a map of properties to values for a given element or template node, which can be used
   * by the directive matching machinery.
   *
   * @param elOrTpl the element or template in question
   * @return an object set up for directive matching. For attributes on the element/template, this
   * object maps a property name to its (static) value. For any bindings, this map simply maps the
   * property name to an empty string.
   */
  function getAttrsForDirectiveMatching(elOrTpl) {
      const attributesMap = {};
      elOrTpl.attributes.forEach(a => {
          if (!isI18nAttribute(a.name)) {
              attributesMap[a.name] = a.value;
          }
      });
      elOrTpl.inputs.forEach(i => { attributesMap[i.name] = ''; });
      elOrTpl.outputs.forEach(o => { attributesMap[o.name] = ''; });
      return attributesMap;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var R3FactoryDelegateType;
  (function (R3FactoryDelegateType) {
      R3FactoryDelegateType[R3FactoryDelegateType["Class"] = 0] = "Class";
      R3FactoryDelegateType[R3FactoryDelegateType["Function"] = 1] = "Function";
      R3FactoryDelegateType[R3FactoryDelegateType["Factory"] = 2] = "Factory";
  })(R3FactoryDelegateType || (R3FactoryDelegateType = {}));
  /**
   * Resolved type of a dependency.
   *
   * Occasionally, dependencies will have special significance which is known statically. In that
   * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency
   * should be generated specially (usually by calling a special injection function instead of the
   * standard one).
   */
  var R3ResolvedDependencyType;
  (function (R3ResolvedDependencyType) {
      /**
       * A normal token dependency.
       */
      R3ResolvedDependencyType[R3ResolvedDependencyType["Token"] = 0] = "Token";
      /**
       * The dependency is for an attribute.
       *
       * The token expression is a string representing the attribute name.
       */
      R3ResolvedDependencyType[R3ResolvedDependencyType["Attribute"] = 1] = "Attribute";
  })(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));
  /**
   * Construct a factory function expression for the given `R3FactoryMetadata`.
   */
  function compileFactoryFunction(meta) {
      const t = variable('t');
      const statements = [];
      // The type to instantiate via constructor invocation. If there is no delegated factory, meaning
      // this type is always created by constructor invocation, then this is the type-to-create
      // parameter provided by the user (t) if specified, or the current type if not. If there is a
      // delegated factory (which is used to create the current type) then this is only the type-to-
      // create parameter (t).
      const typeForCtor = !isDelegatedMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.type) : t;
      let ctorExpr = null;
      if (meta.deps !== null) {
          // There is a constructor (either explicitly or implicitly defined).
          ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.injectFn));
      }
      else {
          const baseFactory = variable(`ɵ${meta.name}_BaseFactory`);
          const getInheritedFactory = importExpr(Identifiers$1.getInheritedFactory);
          const baseFactoryStmt = baseFactory.set(getInheritedFactory.callFn([meta.type])).toDeclStmt(INFERRED_TYPE, [
              StmtModifier.Exported, StmtModifier.Final
          ]);
          statements.push(baseFactoryStmt);
          // There is no constructor, use the base class' factory to construct typeForCtor.
          ctorExpr = baseFactory.callFn([typeForCtor]);
      }
      const ctorExprFinal = ctorExpr;
      const body = [];
      let retExpr = null;
      function makeConditionalFactory(nonCtorExpr) {
          const r = variable('r');
          body.push(r.set(NULL_EXPR).toDeclStmt());
          body.push(ifStmt(t, [r.set(ctorExprFinal).toStmt()], [r.set(nonCtorExpr).toStmt()]));
          return r;
      }
      if (isDelegatedMetadata(meta) && meta.delegateType === R3FactoryDelegateType.Factory) {
          const delegateFactory = variable(`ɵ${meta.name}_BaseFactory`);
          const getFactoryOf = importExpr(Identifiers$1.getFactoryOf);
          if (meta.delegate.isEquivalent(meta.type)) {
              throw new Error(`Illegal state: compiling factory that delegates to itself`);
          }
          const delegateFactoryStmt = delegateFactory.set(getFactoryOf.callFn([meta.delegate])).toDeclStmt(INFERRED_TYPE, [
              StmtModifier.Exported, StmtModifier.Final
          ]);
          statements.push(delegateFactoryStmt);
          retExpr = makeConditionalFactory(delegateFactory.callFn([]));
      }
      else if (isDelegatedMetadata(meta)) {
          // This type is created with a delegated factory. If a type parameter is not specified, call
          // the factory instead.
          const delegateArgs = injectDependencies(meta.delegateDeps, meta.injectFn);
          // Either call `new delegate(...)` or `delegate(...)` depending on meta.useNewForDelegate.
          const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?
              InstantiateExpr :
              InvokeFunctionExpr)(meta.delegate, delegateArgs);
          retExpr = makeConditionalFactory(factoryExpr);
      }
      else if (isExpressionFactoryMetadata(meta)) {
          // TODO(alxhub): decide whether to lower the value here or in the caller
          retExpr = makeConditionalFactory(meta.expression);
      }
      else {
          retExpr = ctorExpr;
      }
      return {
          factory: fn([new FnParam('t', DYNAMIC_TYPE)], [...body, new ReturnStatement(retExpr)], INFERRED_TYPE, undefined, `${meta.name}_Factory`),
          statements,
      };
  }
  function injectDependencies(deps, injectFn) {
      return deps.map(dep => compileInjectDependency(dep, injectFn));
  }
  function compileInjectDependency(dep, injectFn) {
      // Interpret the dependency according to its resolved type.
      switch (dep.resolved) {
          case R3ResolvedDependencyType.Token: {
              // Build up the injection flags according to the metadata.
              const flags = 0 /* Default */ | (dep.self ? 2 /* Self */ : 0) |
                  (dep.skipSelf ? 4 /* SkipSelf */ : 0) | (dep.host ? 1 /* Host */ : 0) |
                  (dep.optional ? 8 /* Optional */ : 0);
              // Build up the arguments to the injectFn call.
              const injectArgs = [dep.token];
              // If this dependency is optional or otherwise has non-default flags, then additional
              // parameters describing how to inject the dependency must be passed to the inject function
              // that's being used.
              if (flags !== 0 /* Default */ || dep.optional) {
                  injectArgs.push(literal(flags));
              }
              return importExpr(injectFn).callFn(injectArgs);
          }
          case R3ResolvedDependencyType.Attribute:
              // In the case of attributes, the attribute name in question is given as the token.
              return importExpr(Identifiers$1.injectAttribute).callFn([dep.token]);
          default:
              return unsupported(`Unknown R3ResolvedDependencyType: ${R3ResolvedDependencyType[dep.resolved]}`);
      }
  }
  function isDelegatedMetadata(meta) {
      return meta.delegateType !== undefined;
  }
  function isExpressionFactoryMetadata(meta) {
      return meta.expression !== undefined;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Convert an object map with `Expression` values into a `LiteralMapExpr`.
   */
  function mapToMapExpression(map) {
      const result = Object.keys(map).map(key => ({ key, value: map[key], quoted: false }));
      return literalMap(result);
  }
  function typeWithParameters(type, numParams) {
      let params = null;
      if (numParams > 0) {
          params = [];
          for (let i = 0; i < numParams; i++) {
              params.push(DYNAMIC_TYPE);
          }
      }
      return expressionType(type, null, params);
  }
  const ANIMATE_SYMBOL_PREFIX = '@';
  function prepareSyntheticPropertyName(name) {
      return `${ANIMATE_SYMBOL_PREFIX}${name}`;
  }
  function prepareSyntheticListenerName(name, phase) {
      return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;
  }
  function getSyntheticPropertyName(name) {
      // this will strip out listener phase values...
      // @foo.start => @foo
      const i = name.indexOf('.');
      name = i > 0 ? name.substring(0, i) : name;
      if (name.charAt(0) !== ANIMATE_SYMBOL_PREFIX) {
          name = ANIMATE_SYMBOL_PREFIX + name;
      }
      return name;
  }
  function prepareSyntheticListenerFunctionName(name, phase) {
      return `animation_${name}_${phase}`;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function compileInjectable(meta) {
      let result = null;
      const factoryMeta = {
          name: meta.name,
          type: meta.type,
          deps: meta.ctorDeps,
          injectFn: Identifiers.inject,
      };
      if (meta.useClass !== undefined) {
          // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is
          // used to instantiate the class with dependencies injected, or deps are not specified and
          // the factory of the class is used to instantiate it.
          //
          // A special case exists for useClass: Type where Type is the injectable type itself, in which
          // case omitting deps just uses the constructor dependencies instead.
          const useClassOnSelf = meta.useClass.isEquivalent(meta.type);
          const deps = meta.userDeps || (useClassOnSelf && meta.ctorDeps) || undefined;
          if (deps !== undefined) {
              // factory: () => new meta.useClass(...deps)
              result = compileFactoryFunction(Object.assign({}, factoryMeta, { delegate: meta.useClass, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));
          }
          else {
              result = compileFactoryFunction(Object.assign({}, factoryMeta, { delegate: meta.useClass, delegateType: R3FactoryDelegateType.Factory }));
          }
      }
      else if (meta.useFactory !== undefined) {
          result = compileFactoryFunction(Object.assign({}, factoryMeta, { delegate: meta.useFactory, delegateDeps: meta.userDeps || [], delegateType: R3FactoryDelegateType.Function }));
      }
      else if (meta.useValue !== undefined) {
          // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for
          // client code because meta.useValue is an Expression which will be defined even if the actual
          // value is undefined.
          result = compileFactoryFunction(Object.assign({}, factoryMeta, { expression: meta.useValue }));
      }
      else if (meta.useExisting !== undefined) {
          // useExisting is an `inject` call on the existing token.
          result = compileFactoryFunction(Object.assign({}, factoryMeta, { expression: importExpr(Identifiers.inject).callFn([meta.useExisting]) }));
      }
      else {
          result = compileFactoryFunction(factoryMeta);
      }
      const token = meta.type;
      const providedIn = meta.providedIn;
      const expression = importExpr(Identifiers.defineInjectable).callFn([mapToMapExpression({ token, factory: result.factory, providedIn })]);
      const type = new ExpressionType(importExpr(Identifiers.InjectableDef, [typeWithParameters(meta.type, meta.typeArgumentCount)]));
      return {
          expression,
          type,
          statements: result.statements,
      };
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function assertArrayOfStrings(identifier, value) {
      if (value == null) {
          return;
      }
      if (!Array.isArray(value)) {
          throw new Error(`Expected '${identifier}' to be an array of strings.`);
      }
      for (let i = 0; i < value.length; i += 1) {
          if (typeof value[i] !== 'string') {
              throw new Error(`Expected '${identifier}' to be an array of strings.`);
          }
      }
  }
  const INTERPOLATION_BLACKLIST_REGEXPS = [
      /^\s*$/,
      /[<>]/,
      /^[{}]$/,
      /&(#|[a-z])/i,
      /^\/\//,
  ];
  function assertInterpolationSymbols(identifier, value) {
      if (value != null && !(Array.isArray(value) && value.length == 2)) {
          throw new Error(`Expected '${identifier}' to be an array, [start, end].`);
      }
      else if (value != null) {
          const start = value[0];
          const end = value[1];
          // black list checking
          INTERPOLATION_BLACKLIST_REGEXPS.forEach(regexp => {
              if (regexp.test(start) || regexp.test(end)) {
                  throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);
              }
          });
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class InterpolationConfig {
      constructor(start, end) {
          this.start = start;
          this.end = end;
      }
      static fromArray(markers) {
          if (!markers) {
              return DEFAULT_INTERPOLATION_CONFIG;
          }
          assertInterpolationSymbols('interpolation', markers);
          return new InterpolationConfig(markers[0], markers[1]);
      }
  }
  const DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
  const VERSION = 3;
  const JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';
  class SourceMapGenerator {
      constructor(file = null) {
          this.file = file;
          this.sourcesContent = new Map();
          this.lines = [];
          this.lastCol0 = 0;
          this.hasMappings = false;
      }
      // The content is `null` when the content is expected to be loaded using the URL
      addSource(url, content = null) {
          if (!this.sourcesContent.has(url)) {
              this.sourcesContent.set(url, content);
          }
          return this;
      }
      addLine() {
          this.lines.push([]);
          this.lastCol0 = 0;
          return this;
      }
      addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
          if (!this.currentLine) {
              throw new Error(`A line must be added before mappings can be added`);
          }
          if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
              throw new Error(`Unknown source file "${sourceUrl}"`);
          }
          if (col0 == null) {
              throw new Error(`The column in the generated code must be provided`);
          }
          if (col0 < this.lastCol0) {
              throw new Error(`Mapping should be added in output order`);
          }
          if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
              throw new Error(`The source location must be provided when a source url is provided`);
          }
          this.hasMappings = true;
          this.lastCol0 = col0;
          this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });
          return this;
      }
      get currentLine() { return this.lines.slice(-1)[0]; }
      toJSON() {
          if (!this.hasMappings) {
              return null;
          }
          const sourcesIndex = new Map();
          const sources = [];
          const sourcesContent = [];
          Array.from(this.sourcesContent.keys()).forEach((url, i) => {
              sourcesIndex.set(url, i);
              sources.push(url);
              sourcesContent.push(this.sourcesContent.get(url) || null);
          });
          let mappings = '';
          let lastCol0 = 0;
          let lastSourceIndex = 0;
          let lastSourceLine0 = 0;
          let lastSourceCol0 = 0;
          this.lines.forEach(segments => {
              lastCol0 = 0;
              mappings += segments
                  .map(segment => {
                  // zero-based starting column of the line in the generated code
                  let segAsStr = toBase64VLQ(segment.col0 - lastCol0);
                  lastCol0 = segment.col0;
                  if (segment.sourceUrl != null) {
                      // zero-based index into the “sources” list
                      segAsStr +=
                          toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
                      lastSourceIndex = sourcesIndex.get(segment.sourceUrl);
                      // the zero-based starting line in the original source
                      segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
                      lastSourceLine0 = segment.sourceLine0;
                      // the zero-based starting column in the original source
                      segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
                      lastSourceCol0 = segment.sourceCol0;
                  }
                  return segAsStr;
              })
                  .join(',');
              mappings += ';';
          });
          mappings = mappings.slice(0, -1);
          return {
              'file': this.file || '',
              'version': VERSION,
              'sourceRoot': '',
              'sources': sources,
              'sourcesContent': sourcesContent,
              'mappings': mappings,
          };
      }
      toJsComment() {
          return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :
              '';
      }
  }
  function toBase64String(value) {
      let b64 = '';
      value = utf8Encode(value);
      for (let i = 0; i < value.length;) {
          const i1 = value.charCodeAt(i++);
          const i2 = value.charCodeAt(i++);
          const i3 = value.charCodeAt(i++);
          b64 += toBase64Digit(i1 >> 2);
          b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));
          b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));
          b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);
      }
      return b64;
  }
  function toBase64VLQ(value) {
      value = value < 0 ? ((-value) << 1) + 1 : value << 1;
      let out = '';
      do {
          let digit = value & 31;
          value = value >> 5;
          if (value > 0) {
              digit = digit | 32;
          }
          out += toBase64Digit(digit);
      } while (value > 0);
      return out;
  }
  const B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  function toBase64Digit(value) {
      if (value < 0 || value >= 64) {
          throw new Error(`Can only encode value in the range [0, 63]`);
      }
      return B64_DIGITS[value];
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
  const _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
  const _INDENT_WITH = '  ';
  const CATCH_ERROR_VAR$1 = variable('error', null, null);
  const CATCH_STACK_VAR$1 = variable('stack', null, null);
  class _EmittedLine {
      constructor(indent) {
          this.indent = indent;
          this.partsLength = 0;
          this.parts = [];
          this.srcSpans = [];
      }
  }
  class EmitterVisitorContext {
      constructor(_indent) {
          this._indent = _indent;
          this._classes = [];
          this._preambleLineCount = 0;
          this._lines = [new _EmittedLine(_indent)];
      }
      static createRoot() { return new EmitterVisitorContext(0); }
      get _currentLine() { return this._lines[this._lines.length - 1]; }
      println(from, lastPart = '') {
          this.print(from || null, lastPart, true);
      }
      lineIsEmpty() { return this._currentLine.parts.length === 0; }
      lineLength() {
          return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
      }
      print(from, part, newLine = false) {
          if (part.length > 0) {
              this._currentLine.parts.push(part);
              this._currentLine.partsLength += part.length;
              this._currentLine.srcSpans.push(from && from.sourceSpan || null);
          }
          if (newLine) {
              this._lines.push(new _EmittedLine(this._indent));
          }
      }
      removeEmptyLastLine() {
          if (this.lineIsEmpty()) {
              this._lines.pop();
          }
      }
      incIndent() {
          this._indent++;
          if (this.lineIsEmpty()) {
              this._currentLine.indent = this._indent;
          }
      }
      decIndent() {
          this._indent--;
          if (this.lineIsEmpty()) {
              this._currentLine.indent = this._indent;
          }
      }
      pushClass(clazz) { this._classes.push(clazz); }
      popClass() { return this._classes.pop(); }
      get currentClass() {
          return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;
      }
      toSource() {
          return this.sourceLines
              .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')
              .join('\n');
      }
      toSourceMapGenerator(genFilePath, startsAtLine = 0) {
          const map = new SourceMapGenerator(genFilePath);
          let firstOffsetMapped = false;
          const mapFirstOffsetIfNeeded = () => {
              if (!firstOffsetMapped) {
                  // Add a single space so that tools won't try to load the file from disk.
                  // Note: We are using virtual urls like `ng:///`, so we have to
                  // provide a content here.
                  map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);
                  firstOffsetMapped = true;
              }
          };
          for (let i = 0; i < startsAtLine; i++) {
              map.addLine();
              mapFirstOffsetIfNeeded();
          }
          this.sourceLines.forEach((line, lineIdx) => {
              map.addLine();
              const spans = line.srcSpans;
              const parts = line.parts;
              let col0 = line.indent * _INDENT_WITH.length;
              let spanIdx = 0;
              // skip leading parts without source spans
              while (spanIdx < spans.length && !spans[spanIdx]) {
                  col0 += parts[spanIdx].length;
                  spanIdx++;
              }
              if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
                  firstOffsetMapped = true;
              }
              else {
                  mapFirstOffsetIfNeeded();
              }
              while (spanIdx < spans.length) {
                  const span = spans[spanIdx];
                  const source = span.start.file;
                  const sourceLine = span.start.line;
                  const sourceCol = span.start.col;
                  map.addSource(source.url, source.content)
                      .addMapping(col0, source.url, sourceLine, sourceCol);
                  col0 += parts[spanIdx].length;
                  spanIdx++;
                  // assign parts without span or the same span to the previous segment
                  while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
                      col0 += parts[spanIdx].length;
                      spanIdx++;
                  }
              }
          });
          return map;
      }
      setPreambleLineCount(count) { return this._preambleLineCount = count; }
      spanOf(line, column) {
          const emittedLine = this._lines[line - this._preambleLineCount];
          if (emittedLine) {
              let columnsLeft = column - _createIndent(emittedLine.indent).length;
              for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
                  const part = emittedLine.parts[partIndex];
                  if (part.length > columnsLeft) {
                      return emittedLine.srcSpans[partIndex];
                  }
                  columnsLeft -= part.length;
              }
          }
          return null;
      }
      get sourceLines() {
          if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
              return this._lines.slice(0, -1);
          }
          return this._lines;
      }
  }
  class AbstractEmitterVisitor {
      constructor(_escapeDollarInStrings) {
          this._escapeDollarInStrings = _escapeDollarInStrings;
      }
      visitExpressionStmt(stmt, ctx) {
          stmt.expr.visitExpression(this, ctx);
          ctx.println(stmt, ';');
          return null;
      }
      visitReturnStmt(stmt, ctx) {
          ctx.print(stmt, `return `);
          stmt.value.visitExpression(this, ctx);
          ctx.println(stmt, ';');
          return null;
      }
      visitIfStmt(stmt, ctx) {
          ctx.print(stmt, `if (`);
          stmt.condition.visitExpression(this, ctx);
          ctx.print(stmt, `) {`);
          const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;
          if (stmt.trueCase.length <= 1 && !hasElseCase) {
              ctx.print(stmt, ` `);
              this.visitAllStatements(stmt.trueCase, ctx);
              ctx.removeEmptyLastLine();
              ctx.print(stmt, ` `);
          }
          else {
              ctx.println();
              ctx.incIndent();
              this.visitAllStatements(stmt.trueCase, ctx);
              ctx.decIndent();
              if (hasElseCase) {
                  ctx.println(stmt, `} else {`);
                  ctx.incIndent();
                  this.visitAllStatements(stmt.falseCase, ctx);
                  ctx.decIndent();
              }
          }
          ctx.println(stmt, `}`);
          return null;
      }
      visitThrowStmt(stmt, ctx) {
          ctx.print(stmt, `throw `);
          stmt.error.visitExpression(this, ctx);
          ctx.println(stmt, `;`);
          return null;
      }
      visitCommentStmt(stmt, ctx) {
          if (stmt.multiline) {
              ctx.println(stmt, `/* ${stmt.comment} */`);
          }
          else {
              stmt.comment.split('\n').forEach((line) => { ctx.println(stmt, `// ${line}`); });
          }
          return null;
      }
      visitJSDocCommentStmt(stmt, ctx) {
          ctx.println(stmt, `/*${stmt.toString()}*/`);
          return null;
      }
      visitWriteVarExpr(expr, ctx) {
          const lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print(expr, '(');
          }
          ctx.print(expr, `${expr.name} = `);
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(expr, ')');
          }
          return null;
      }
      visitWriteKeyExpr(expr, ctx) {
          const lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print(expr, '(');
          }
          expr.receiver.visitExpression(this, ctx);
          ctx.print(expr, `[`);
          expr.index.visitExpression(this, ctx);
          ctx.print(expr, `] = `);
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(expr, ')');
          }
          return null;
      }
      visitWritePropExpr(expr, ctx) {
          const lineWasEmpty = ctx.lineIsEmpty();
          if (!lineWasEmpty) {
              ctx.print(expr, '(');
          }
          expr.receiver.visitExpression(this, ctx);
          ctx.print(expr, `.${expr.name} = `);
          expr.value.visitExpression(this, ctx);
          if (!lineWasEmpty) {
              ctx.print(expr, ')');
          }
          return null;
      }
      visitInvokeMethodExpr(expr, ctx) {
          expr.receiver.visitExpression(this, ctx);
          let name = expr.name;
          if (expr.builtin != null) {
              name = this.getBuiltinMethodName(expr.builtin);
              if (name == null) {
                  // some builtins just mean to skip the call.
                  return null;
              }
          }
          ctx.print(expr, `.${name}(`);
          this.visitAllExpressions(expr.args, ctx, `,`);
          ctx.print(expr, `)`);
          return null;
      }
      visitInvokeFunctionExpr(expr, ctx) {
          expr.fn.visitExpression(this, ctx);
          ctx.print(expr, `(`);
          this.visitAllExpressions(expr.args, ctx, ',');
          ctx.print(expr, `)`);
          return null;
      }
      visitWrappedNodeExpr(ast, ctx) {
          throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');
      }
      visitTypeofExpr(expr, ctx) {
          ctx.print(expr, 'typeof ');
          expr.expr.visitExpression(this, ctx);
      }
      visitReadVarExpr(ast, ctx) {
          let varName = ast.name;
          if (ast.builtin != null) {
              switch (ast.builtin) {
                  case BuiltinVar.Super:
                      varName = 'super';
                      break;
                  case BuiltinVar.This:
                      varName = 'this';
                      break;
                  case BuiltinVar.CatchError:
                      varName = CATCH_ERROR_VAR$1.name;
                      break;
                  case BuiltinVar.CatchStack:
                      varName = CATCH_STACK_VAR$1.name;
                      break;
                  default:
                      throw new Error(`Unknown builtin variable ${ast.builtin}`);
              }
          }
          ctx.print(ast, varName);
          return null;
      }
      visitInstantiateExpr(ast, ctx) {
          ctx.print(ast, `new `);
          ast.classExpr.visitExpression(this, ctx);
          ctx.print(ast, `(`);
          this.visitAllExpressions(ast.args, ctx, ',');
          ctx.print(ast, `)`);
          return null;
      }
      visitLiteralExpr(ast, ctx) {
          const value = ast.value;
          if (typeof value === 'string') {
              ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
          }
          else {
              ctx.print(ast, `${value}`);
          }
          return null;
      }
      visitConditionalExpr(ast, ctx) {
          ctx.print(ast, `(`);
          ast.condition.visitExpression(this, ctx);
          ctx.print(ast, '? ');
          ast.trueCase.visitExpression(this, ctx);
          ctx.print(ast, ': ');
          ast.falseCase.visitExpression(this, ctx);
          ctx.print(ast, `)`);
          return null;
      }
      visitNotExpr(ast, ctx) {
          ctx.print(ast, '!');
          ast.condition.visitExpression(this, ctx);
          return null;
      }
      visitAssertNotNullExpr(ast, ctx) {
          ast.condition.visitExpression(this, ctx);
          return null;
      }
      visitBinaryOperatorExpr(ast, ctx) {
          let opStr;
          switch (ast.operator) {
              case BinaryOperator.Equals:
                  opStr = '==';
                  break;
              case BinaryOperator.Identical:
                  opStr = '===';
                  break;
              case BinaryOperator.NotEquals:
                  opStr = '!=';
                  break;
              case BinaryOperator.NotIdentical:
                  opStr = '!==';
                  break;
              case BinaryOperator.And:
                  opStr = '&&';
                  break;
              case BinaryOperator.BitwiseAnd:
                  opStr = '&';
                  break;
              case BinaryOperator.Or:
                  opStr = '||';
                  break;
              case BinaryOperator.Plus:
                  opStr = '+';
                  break;
              case BinaryOperator.Minus:
                  opStr = '-';
                  break;
              case BinaryOperator.Divide:
                  opStr = '/';
                  break;
              case BinaryOperator.Multiply:
                  opStr = '*';
                  break;
              case BinaryOperator.Modulo:
                  opStr = '%';
                  break;
              case BinaryOperator.Lower:
                  opStr = '<';
                  break;
              case BinaryOperator.LowerEquals:
                  opStr = '<=';
                  break;
              case BinaryOperator.Bigger:
                  opStr = '>';
                  break;
              case BinaryOperator.BiggerEquals:
                  opStr = '>=';
                  break;
              default:
                  throw new Error(`Unknown operator ${ast.operator}`);
          }
          if (ast.parens)
              ctx.print(ast, `(`);
          ast.lhs.visitExpression(this, ctx);
          ctx.print(ast, ` ${opStr} `);
          ast.rhs.visitExpression(this, ctx);
          if (ast.parens)
              ctx.print(ast, `)`);
          return null;
      }
      visitReadPropExpr(ast, ctx) {
          ast.receiver.visitExpression(this, ctx);
          ctx.print(ast, `.`);
          ctx.print(ast, ast.name);
          return null;
      }
      visitReadKeyExpr(ast, ctx) {
          ast.receiver.visitExpression(this, ctx);
          ctx.print(ast, `[`);
          ast.index.visitExpression(this, ctx);
          ctx.print(ast, `]`);
          return null;
      }
      visitLiteralArrayExpr(ast, ctx) {
          ctx.print(ast, `[`);
          this.visitAllExpressions(ast.entries, ctx, ',');
          ctx.print(ast, `]`);
          return null;
      }
      visitLiteralMapExpr(ast, ctx) {
          ctx.print(ast, `{`);
          this.visitAllObjects(entry => {
              ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);
              entry.value.visitExpression(this, ctx);
          }, ast.entries, ctx, ',');
          ctx.print(ast, `}`);
          return null;
      }
      visitCommaExpr(ast, ctx) {
          ctx.print(ast, '(');
          this.visitAllExpressions(ast.parts, ctx, ',');
          ctx.print(ast, ')');
          return null;
      }
      visitAllExpressions(expressions, ctx, separator) {
          this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);
      }
      visitAllObjects(handler, expressions, ctx, separator) {
          let incrementedIndent = false;
          for (let i = 0; i < expressions.length; i++) {
              if (i > 0) {
                  if (ctx.lineLength() > 80) {
                      ctx.print(null, separator, true);
                      if (!incrementedIndent) {
                          // continuation are marked with double indent.
                          ctx.incIndent();
                          ctx.incIndent();
                          incrementedIndent = true;
                      }
                  }
                  else {
                      ctx.print(null, separator, false);
                  }
              }
              handler(expressions[i]);
          }
          if (incrementedIndent) {
              // continuation are marked with double indent.
              ctx.decIndent();
              ctx.decIndent();
          }
      }
      visitAllStatements(statements, ctx) {
          statements.forEach((stmt) => stmt.visitStatement(this, ctx));
      }
  }
  function escapeIdentifier(input, escapeDollar, alwaysQuote = true) {
      if (input == null) {
          return null;
      }
      const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {
          if (match[0] == '$') {
              return escapeDollar ? '\\$' : '$';
          }
          else if (match[0] == '\n') {
              return '\\n';
          }
          else if (match[0] == '\r') {
              return '\\r';
          }
          else {
              return `\\${match[0]}`;
          }
      });
      const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
      return requiresQuotes ? `'${body}'` : body;
  }
  function _createIndent(count) {
      let res = '';
      for (let i = 0; i < count; i++) {
          res += _INDENT_WITH;
      }
      return res;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {
      constructor() { super(false); }
      visitDeclareClassStmt(stmt, ctx) {
          ctx.pushClass(stmt);
          this._visitClassConstructor(stmt, ctx);
          if (stmt.parent != null) {
              ctx.print(stmt, `${stmt.name}.prototype = Object.create(`);
              stmt.parent.visitExpression(this, ctx);
              ctx.println(stmt, `.prototype);`);
          }
          stmt.getters.forEach((getter) => this._visitClassGetter(stmt, getter, ctx));
          stmt.methods.forEach((method) => this._visitClassMethod(stmt, method, ctx));
          ctx.popClass();
          return null;
      }
      _visitClassConstructor(stmt, ctx) {
          ctx.print(stmt, `function ${stmt.name}(`);
          if (stmt.constructorMethod != null) {
              this._visitParams(stmt.constructorMethod.params, ctx);
          }
          ctx.println(stmt, `) {`);
          ctx.incIndent();
          if (stmt.constructorMethod != null) {
              if (stmt.constructorMethod.body.length > 0) {
                  ctx.println(stmt, `var self = this;`);
                  this.visitAllStatements(stmt.constructorMethod.body, ctx);
              }
          }
          ctx.decIndent();
          ctx.println(stmt, `}`);
      }
      _visitClassGetter(stmt, getter, ctx) {
          ctx.println(stmt, `Object.defineProperty(${stmt.name}.prototype, '${getter.name}', { get: function() {`);
          ctx.incIndent();
          if (getter.body.length > 0) {
              ctx.println(stmt, `var self = this;`);
              this.visitAllStatements(getter.body, ctx);
          }
          ctx.decIndent();
          ctx.println(stmt, `}});`);
      }
      _visitClassMethod(stmt, method, ctx) {
          ctx.print(stmt, `${stmt.name}.prototype.${method.name} = function(`);
          this._visitParams(method.params, ctx);
          ctx.println(stmt, `) {`);
          ctx.incIndent();
          if (method.body.length > 0) {
              ctx.println(stmt, `var self = this;`);
              this.visitAllStatements(method.body, ctx);
          }
          ctx.decIndent();
          ctx.println(stmt, `};`);
      }
      visitWrappedNodeExpr(ast, ctx) {
          throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');
      }
      visitReadVarExpr(ast, ctx) {
          if (ast.builtin === BuiltinVar.This) {
              ctx.print(ast, 'self');
          }
          else if (ast.builtin === BuiltinVar.Super) {
              throw new Error(`'super' needs to be handled at a parent ast node, not at the variable level!`);
          }
          else {
              super.visitReadVarExpr(ast, ctx);
          }
          return null;
      }
      visitDeclareVarStmt(stmt, ctx) {
          ctx.print(stmt, `var ${stmt.name}`);
          if (stmt.value) {
              ctx.print(stmt, ' = ');
              stmt.value.visitExpression(this, ctx);
          }
          ctx.println(stmt, `;`);
          return null;
      }
      visitCastExpr(ast, ctx) {
          ast.value.visitExpression(this, ctx);
          return null;
      }
      visitInvokeFunctionExpr(expr, ctx) {
          const fnExpr = expr.fn;
          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
              ctx.currentClass.parent.visitExpression(this, ctx);
              ctx.print(expr, `.call(this`);
              if (expr.args.length > 0) {
                  ctx.print(expr, `, `);
                  this.visitAllExpressions(expr.args, ctx, ',');
              }
              ctx.print(expr, `)`);
          }
          else {
              super.visitInvokeFunctionExpr(expr, ctx);
          }
          return null;
      }
      visitFunctionExpr(ast, ctx) {
          ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);
          this._visitParams(ast.params, ctx);
          ctx.println(ast, `) {`);
          ctx.incIndent();
          this.visitAllStatements(ast.statements, ctx);
          ctx.decIndent();
          ctx.print(ast, `}`);
          return null;
      }
      visitDeclareFunctionStmt(stmt, ctx) {
          ctx.print(stmt, `function ${stmt.name}(`);
          this._visitParams(stmt.params, ctx);
          ctx.println(stmt, `) {`);
          ctx.incIndent();
          this.visitAllStatements(stmt.statements, ctx);
          ctx.decIndent();
          ctx.println(stmt, `}`);
          return null;
      }
      visitTryCatchStmt(stmt, ctx) {
          ctx.println(stmt, `try {`);
          ctx.incIndent();
          this.visitAllStatements(stmt.bodyStmts, ctx);
          ctx.decIndent();
          ctx.println(stmt, `} catch (${CATCH_ERROR_VAR$1.name}) {`);
          ctx.incIndent();
          const catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [
                  StmtModifier.Final
              ])].concat(stmt.catchStmts);
          this.visitAllStatements(catchStmts, ctx);
          ctx.decIndent();
          ctx.println(stmt, `}`);
          return null;
      }
      _visitParams(params, ctx) {
          this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');
      }
      getBuiltinMethodName(method) {
          let name;
          switch (method) {
              case BuiltinMethod.ConcatArray:
                  name = 'concat';
                  break;
              case BuiltinMethod.SubscribeObservable:
                  name = 'subscribe';
                  break;
              case BuiltinMethod.Bind:
                  name = 'bind';
                  break;
              default:
                  throw new Error(`Unknown builtin method: ${method}`);
          }
          return name;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function evalExpression(sourceUrl, ctx, vars, createSourceMap) {
      let fnBody = `${ctx.toSource()}\n//# sourceURL=${sourceUrl}`;
      const fnArgNames = [];
      const fnArgValues = [];
      for (const argName in vars) {
          fnArgNames.push(argName);
          fnArgValues.push(vars[argName]);
      }
      if (createSourceMap) {
          // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise
          // E.g. ```
          // function anonymous(a,b,c
          // /**/) { ... }```
          // We don't want to hard code this fact, so we auto detect it via an empty function first.
          const emptyFn = new Function(...fnArgNames.concat('return null;')).toString();
          const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\n').length - 1;
          fnBody += `\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;
      }
      return new Function(...fnArgNames.concat(fnBody))(...fnArgValues);
  }
  function jitStatements(sourceUrl, statements, reflector, createSourceMaps) {
      const converter = new JitEmitterVisitor(reflector);
      const ctx = EmitterVisitorContext.createRoot();
      converter.visitAllStatements(statements, ctx);
      converter.createReturnStmt(ctx);
      return evalExpression(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
  }
  class JitEmitterVisitor extends AbstractJsEmitterVisitor {
      constructor(reflector) {
          super();
          this.reflector = reflector;
          this._evalArgNames = [];
          this._evalArgValues = [];
          this._evalExportedVars = [];
      }
      createReturnStmt(ctx) {
          const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));
          stmt.visitStatement(this, ctx);
      }
      getArgs() {
          const result = {};
          for (let i = 0; i < this._evalArgNames.length; i++) {
              result[this._evalArgNames[i]] = this._evalArgValues[i];
          }
          return result;
      }
      visitExternalExpr(ast, ctx) {
          this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);
          return null;
      }
      visitWrappedNodeExpr(ast, ctx) {
          this._emitReferenceToExternal(ast, ast.node, ctx);
          return null;
      }
      visitDeclareVarStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported)) {
              this._evalExportedVars.push(stmt.name);
          }
          return super.visitDeclareVarStmt(stmt, ctx);
      }
      visitDeclareFunctionStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported)) {
              this._evalExportedVars.push(stmt.name);
          }
          return super.visitDeclareFunctionStmt(stmt, ctx);
      }
      visitDeclareClassStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported)) {
              this._evalExportedVars.push(stmt.name);
          }
          return super.visitDeclareClassStmt(stmt, ctx);
      }
      _emitReferenceToExternal(ast, value, ctx) {
          let id = this._evalArgValues.indexOf(value);
          if (id === -1) {
              id = this._evalArgValues.length;
              this._evalArgValues.push(value);
              const name = identifierName({ reference: value }) || 'val';
              this._evalArgNames.push(`jit_${name}_${id}`);
          }
          ctx.print(ast, this._evalArgNames[id]);
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Implementation of `CompileReflector` which resolves references to @angular/core
   * symbols at runtime, according to a consumer-provided mapping.
   *
   * Only supports `resolveExternalReference`, all other methods throw.
   */
  class R3JitReflector {
      constructor(context) {
          this.context = context;
      }
      resolveExternalReference(ref) {
          // This reflector only handles @angular/core imports.
          if (ref.moduleName !== '@angular/core') {
              throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);
          }
          if (!this.context.hasOwnProperty(ref.name)) {
              throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);
          }
          return this.context[ref.name];
      }
      parameters(typeOrFunc) { throw new Error('Not implemented.'); }
      annotations(typeOrFunc) { throw new Error('Not implemented.'); }
      shallowAnnotations(typeOrFunc) { throw new Error('Not implemented.'); }
      tryAnnotations(typeOrFunc) { throw new Error('Not implemented.'); }
      propMetadata(typeOrFunc) { throw new Error('Not implemented.'); }
      hasLifecycleHook(type, lcProperty) { throw new Error('Not implemented.'); }
      guards(typeOrFunc) { throw new Error('Not implemented.'); }
      componentModuleUrl(type, cmpMetadata) { throw new Error('Not implemented.'); }
  }
  /**
   * JIT compiles an expression and returns the result of executing that expression.
   *
   * @param def the definition which will be compiled and executed to get the value to patch
   * @param context an object map of @angular/core symbol names to symbols which will be available in
   * the context of the compiled expression
   * @param sourceUrl a URL to use for the source map of the compiled expression
   * @param constantPool an optional `ConstantPool` which contains constants used in the expression
   */
  function jitExpression(def, context, sourceUrl, preStatements) {
      // The ConstantPool may contain Statements which declare variables used in the final expression.
      // Therefore, its statements need to precede the actual JIT operation. The final statement is a
      // declaration of $def which is set to the expression being compiled.
      const statements = [
          ...preStatements,
          new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported]),
      ];
      const res = jitStatements(sourceUrl, statements, new R3JitReflector(context), false);
      return res['$def'];
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.
   */
  function compileNgModule(meta) {
      const { type: moduleType, bootstrap, declarations, imports, exports } = meta;
      const expression = importExpr(Identifiers$1.defineNgModule).callFn([mapToMapExpression({
              type: moduleType,
              bootstrap: literalArr(bootstrap.map(ref => ref.value)),
              declarations: literalArr(declarations.map(ref => ref.value)),
              imports: literalArr(imports.map(ref => ref.value)),
              exports: literalArr(exports.map(ref => ref.value)),
          })]);
      const type = new ExpressionType(importExpr(Identifiers$1.NgModuleDefWithMeta, [
          new ExpressionType(moduleType), tupleTypeOf(declarations), tupleTypeOf(imports),
          tupleTypeOf(exports)
      ]));
      const additionalStatements = [];
      return { expression, type, additionalStatements };
  }
  function compileInjector(meta) {
      const result = compileFactoryFunction({
          name: meta.name,
          type: meta.type,
          deps: meta.deps,
          injectFn: Identifiers$1.inject,
      });
      const expression = importExpr(Identifiers$1.defineInjector).callFn([mapToMapExpression({
              factory: result.factory,
              providers: meta.providers,
              imports: meta.imports,
          })]);
      const type = new ExpressionType(importExpr(Identifiers$1.InjectorDef, [new ExpressionType(meta.type)]));
      return { expression, type, statements: result.statements };
  }
  function tupleTypeOf(exp) {
      const types = exp.map(ref => typeofExpr(ref.type));
      return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function compilePipeFromMetadata(metadata) {
      const definitionMapValues = [];
      // e.g. `name: 'myPipe'`
      definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });
      // e.g. `type: MyPipe`
      definitionMapValues.push({ key: 'type', value: metadata.type, quoted: false });
      const templateFactory = compileFactoryFunction({
          name: metadata.name,
          type: metadata.type,
          deps: metadata.deps,
          injectFn: Identifiers$1.directiveInject,
      });
      definitionMapValues.push({ key: 'factory', value: templateFactory.factory, quoted: false });
      // e.g. `pure: true`
      definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });
      const expression = importExpr(Identifiers$1.definePipe).callFn([literalMap(definitionMapValues)]);
      const type = new ExpressionType(importExpr(Identifiers$1.PipeDefWithMeta, [
          new ExpressionType(metadata.type),
          new ExpressionType(new LiteralExpr(metadata.pipeName)),
      ]));
      return { expression, type, statements: templateFactory.statements };
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class ParserError {
      constructor(message, input, errLocation, ctxLocation) {
          this.input = input;
          this.errLocation = errLocation;
          this.ctxLocation = ctxLocation;
          this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;
      }
  }
  class ParseSpan {
      constructor(start, end) {
          this.start = start;
          this.end = end;
      }
  }
  class AST {
      constructor(span) {
          this.span = span;
      }
      visit(visitor, context = null) { return null; }
      toString() { return 'AST'; }
  }
  /**
   * Represents a quoted expression of the form:
   *
   * quote = prefix `:` uninterpretedExpression
   * prefix = identifier
   * uninterpretedExpression = arbitrary string
   *
   * A quoted expression is meant to be pre-processed by an AST transformer that
   * converts it into another AST that no longer contains quoted expressions.
   * It is meant to allow third-party developers to extend Angular template
   * expression language. The `uninterpretedExpression` part of the quote is
   * therefore not interpreted by the Angular's own expression parser.
   */
  class Quote extends AST {
      constructor(span, prefix, uninterpretedExpression, location) {
          super(span);
          this.prefix = prefix;
          this.uninterpretedExpression = uninterpretedExpression;
          this.location = location;
      }
      visit(visitor, context = null) { return visitor.visitQuote(this, context); }
      toString() { return 'Quote'; }
  }
  class EmptyExpr extends AST {
      visit(visitor, context = null) {
          // do nothing
      }
  }
  class ImplicitReceiver extends AST {
      visit(visitor, context = null) {
          return visitor.visitImplicitReceiver(this, context);
      }
  }
  /**
   * Multiple expressions separated by a semicolon.
   */
  class Chain extends AST {
      constructor(span, expressions) {
          super(span);
          this.expressions = expressions;
      }
      visit(visitor, context = null) { return visitor.visitChain(this, context); }
  }
  class Conditional extends AST {
      constructor(span, condition, trueExp, falseExp) {
          super(span);
          this.condition = condition;
          this.trueExp = trueExp;
          this.falseExp = falseExp;
      }
      visit(visitor, context = null) {
          return visitor.visitConditional(this, context);
      }
  }
  class PropertyRead extends AST {
      constructor(span, receiver, name) {
          super(span);
          this.receiver = receiver;
          this.name = name;
      }
      visit(visitor, context = null) {
          return visitor.visitPropertyRead(this, context);
      }
  }
  class PropertyWrite extends AST {
      constructor(span, receiver, name, value) {
          super(span);
          this.receiver = receiver;
          this.name = name;
          this.value = value;
      }
      visit(visitor, context = null) {
          return visitor.visitPropertyWrite(this, context);
      }
  }
  class SafePropertyRead extends AST {
      constructor(span, receiver, name) {
          super(span);
          this.receiver = receiver;
          this.name = name;
      }
      visit(visitor, context = null) {
          return visitor.visitSafePropertyRead(this, context);
      }
  }
  class KeyedRead extends AST {
      constructor(span, obj, key) {
          super(span);
          this.obj = obj;
          this.key = key;
      }
      visit(visitor, context = null) {
          return visitor.visitKeyedRead(this, context);
      }
  }
  class KeyedWrite extends AST {
      constructor(span, obj, key, value) {
          super(span);
          this.obj = obj;
          this.key = key;
          this.value = value;
      }
      visit(visitor, context = null) {
          return visitor.visitKeyedWrite(this, context);
      }
  }
  class BindingPipe extends AST {
      constructor(span, exp, name, args) {
          super(span);
          this.exp = exp;
          this.name = name;
          this.args = args;
      }
      visit(visitor, context = null) { return visitor.visitPipe(this, context); }
  }
  class LiteralPrimitive extends AST {
      constructor(span, value) {
          super(span);
          this.value = value;
      }
      visit(visitor, context = null) {
          return visitor.visitLiteralPrimitive(this, context);
      }
  }
  class LiteralArray extends AST {
      constructor(span, expressions) {
          super(span);
          this.expressions = expressions;
      }
      visit(visitor, context = null) {
          return visitor.visitLiteralArray(this, context);
      }
  }
  class LiteralMap extends AST {
      constructor(span, keys, values) {
          super(span);
          this.keys = keys;
          this.values = values;
      }
      visit(visitor, context = null) {
          return visitor.visitLiteralMap(this, context);
      }
  }
  class Interpolation extends AST {
      constructor(span, strings, expressions) {
          super(span);
          this.strings = strings;
          this.expressions = expressions;
      }
      visit(visitor, context = null) {
          return visitor.visitInterpolation(this, context);
      }
  }
  class Binary extends AST {
      constructor(span, operation, left, right) {
          super(span);
          this.operation = operation;
          this.left = left;
          this.right = right;
      }
      visit(visitor, context = null) {
          return visitor.visitBinary(this, context);
      }
  }
  class PrefixNot extends AST {
      constructor(span, expression) {
          super(span);
          this.expression = expression;
      }
      visit(visitor, context = null) {
          return visitor.visitPrefixNot(this, context);
      }
  }
  class NonNullAssert extends AST {
      constructor(span, expression) {
          super(span);
          this.expression = expression;
      }
      visit(visitor, context = null) {
          return visitor.visitNonNullAssert(this, context);
      }
  }
  class MethodCall extends AST {
      constructor(span, receiver, name, args) {
          super(span);
          this.receiver = receiver;
          this.name = name;
          this.args = args;
      }
      visit(visitor, context = null) {
          return visitor.visitMethodCall(this, context);
      }
  }
  class SafeMethodCall extends AST {
      constructor(span, receiver, name, args) {
          super(span);
          this.receiver = receiver;
          this.name = name;
          this.args = args;
      }
      visit(visitor, context = null) {
          return visitor.visitSafeMethodCall(this, context);
      }
  }
  class FunctionCall extends AST {
      constructor(span, target, args) {
          super(span);
          this.target = target;
          this.args = args;
      }
      visit(visitor, context = null) {
          return visitor.visitFunctionCall(this, context);
      }
  }
  class ASTWithSource extends AST {
      constructor(ast, source, location, errors) {
          super(new ParseSpan(0, source == null ? 0 : source.length));
          this.ast = ast;
          this.source = source;
          this.location = location;
          this.errors = errors;
      }
      visit(visitor, context = null) { return this.ast.visit(visitor, context); }
      toString() { return `${this.source} in ${this.location}`; }
  }
  class TemplateBinding {
      constructor(span, key, keyIsVar, name, expression) {
          this.span = span;
          this.key = key;
          this.keyIsVar = keyIsVar;
          this.name = name;
          this.expression = expression;
      }
  }
  class RecursiveAstVisitor$1 {
      visitBinary(ast, context) {
          ast.left.visit(this);
          ast.right.visit(this);
          return null;
      }
      visitChain(ast, context) { return this.visitAll(ast.expressions, context); }
      visitConditional(ast, context) {
          ast.condition.visit(this);
          ast.trueExp.visit(this);
          ast.falseExp.visit(this);
          return null;
      }
      visitPipe(ast, context) {
          ast.exp.visit(this);
          this.visitAll(ast.args, context);
          return null;
      }
      visitFunctionCall(ast, context) {
          ast.target.visit(this);
          this.visitAll(ast.args, context);
          return null;
      }
      visitImplicitReceiver(ast, context) { return null; }
      visitInterpolation(ast, context) {
          return this.visitAll(ast.expressions, context);
      }
      visitKeyedRead(ast, context) {
          ast.obj.visit(this);
          ast.key.visit(this);
          return null;
      }
      visitKeyedWrite(ast, context) {
          ast.obj.visit(this);
          ast.key.visit(this);
          ast.value.visit(this);
          return null;
      }
      visitLiteralArray(ast, context) {
          return this.visitAll(ast.expressions, context);
      }
      visitLiteralMap(ast, context) { return this.visitAll(ast.values, context); }
      visitLiteralPrimitive(ast, context) { return null; }
      visitMethodCall(ast, context) {
          ast.receiver.visit(this);
          return this.visitAll(ast.args, context);
      }
      visitPrefixNot(ast, context) {
          ast.expression.visit(this);
          return null;
      }
      visitNonNullAssert(ast, context) {
          ast.expression.visit(this);
          return null;
      }
      visitPropertyRead(ast, context) {
          ast.receiver.visit(this);
          return null;
      }
      visitPropertyWrite(ast, context) {
          ast.receiver.visit(this);
          ast.value.visit(this);
          return null;
      }
      visitSafePropertyRead(ast, context) {
          ast.receiver.visit(this);
          return null;
      }
      visitSafeMethodCall(ast, context) {
          ast.receiver.visit(this);
          return this.visitAll(ast.args, context);
      }
      visitAll(asts, context) {
          asts.forEach(ast => ast.visit(this, context));
          return null;
      }
      visitQuote(ast, context) { return null; }
  }
  class AstTransformer$1 {
      visitImplicitReceiver(ast, context) { return ast; }
      visitInterpolation(ast, context) {
          return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));
      }
      visitLiteralPrimitive(ast, context) {
          return new LiteralPrimitive(ast.span, ast.value);
      }
      visitPropertyRead(ast, context) {
          return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);
      }
      visitPropertyWrite(ast, context) {
          return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));
      }
      visitSafePropertyRead(ast, context) {
          return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);
      }
      visitMethodCall(ast, context) {
          return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
      }
      visitSafeMethodCall(ast, context) {
          return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));
      }
      visitFunctionCall(ast, context) {
          return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));
      }
      visitLiteralArray(ast, context) {
          return new LiteralArray(ast.span, this.visitAll(ast.expressions));
      }
      visitLiteralMap(ast, context) {
          return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));
      }
      visitBinary(ast, context) {
          return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));
      }
      visitPrefixNot(ast, context) {
          return new PrefixNot(ast.span, ast.expression.visit(this));
      }
      visitNonNullAssert(ast, context) {
          return new NonNullAssert(ast.span, ast.expression.visit(this));
      }
      visitConditional(ast, context) {
          return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
      }
      visitPipe(ast, context) {
          return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));
      }
      visitKeyedRead(ast, context) {
          return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));
      }
      visitKeyedWrite(ast, context) {
          return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
      }
      visitAll(asts) {
          const res = new Array(asts.length);
          for (let i = 0; i < asts.length; ++i) {
              res[i] = asts[i].visit(this);
          }
          return res;
      }
      visitChain(ast, context) {
          return new Chain(ast.span, this.visitAll(ast.expressions));
      }
      visitQuote(ast, context) {
          return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);
      }
  }
  // A transformer that only creates new nodes if the transformer makes a change or
  // a change is made a child node.
  class AstMemoryEfficientTransformer {
      visitImplicitReceiver(ast, context) { return ast; }
      visitInterpolation(ast, context) {
          const expressions = this.visitAll(ast.expressions);
          if (expressions !== ast.expressions)
              return new Interpolation(ast.span, ast.strings, expressions);
          return ast;
      }
      visitLiteralPrimitive(ast, context) { return ast; }
      visitPropertyRead(ast, context) {
          const receiver = ast.receiver.visit(this);
          if (receiver !== ast.receiver) {
              return new PropertyRead(ast.span, receiver, ast.name);
          }
          return ast;
      }
      visitPropertyWrite(ast, context) {
          const receiver = ast.receiver.visit(this);
          const value = ast.value.visit(this);
          if (receiver !== ast.receiver || value !== ast.value) {
              return new PropertyWrite(ast.span, receiver, ast.name, value);
          }
          return ast;
      }
      visitSafePropertyRead(ast, context) {
          const receiver = ast.receiver.visit(this);
          if (receiver !== ast.receiver) {
              return new SafePropertyRead(ast.span, receiver, ast.name);
          }
          return ast;
      }
      visitMethodCall(ast, context) {
          const receiver = ast.receiver.visit(this);
          if (receiver !== ast.receiver) {
              return new MethodCall(ast.span, receiver, ast.name, this.visitAll(ast.args));
          }
          return ast;
      }
      visitSafeMethodCall(ast, context) {
          const receiver = ast.receiver.visit(this);
          const args = this.visitAll(ast.args);
          if (receiver !== ast.receiver || args !== ast.args) {
              return new SafeMethodCall(ast.span, receiver, ast.name, args);
          }
          return ast;
      }
      visitFunctionCall(ast, context) {
          const target = ast.target && ast.target.visit(this);
          const args = this.visitAll(ast.args);
          if (target !== ast.target || args !== ast.args) {
              return new FunctionCall(ast.span, target, args);
          }
          return ast;
      }
      visitLiteralArray(ast, context) {
          const expressions = this.visitAll(ast.expressions);
          if (expressions !== ast.expressions) {
              return new LiteralArray(ast.span, expressions);
          }
          return ast;
      }
      visitLiteralMap(ast, context) {
          const values = this.visitAll(ast.values);
          if (values !== ast.values) {
              return new LiteralMap(ast.span, ast.keys, values);
          }
          return ast;
      }
      visitBinary(ast, context) {
          const left = ast.left.visit(this);
          const right = ast.right.visit(this);
          if (left !== ast.left || right !== ast.right) {
              return new Binary(ast.span, ast.operation, left, right);
          }
          return ast;
      }
      visitPrefixNot(ast, context) {
          const expression = ast.expression.visit(this);
          if (expression !== ast.expression) {
              return new PrefixNot(ast.span, expression);
          }
          return ast;
      }
      visitNonNullAssert(ast, context) {
          const expression = ast.expression.visit(this);
          if (expression !== ast.expression) {
              return new NonNullAssert(ast.span, expression);
          }
          return ast;
      }
      visitConditional(ast, context) {
          const condition = ast.condition.visit(this);
          const trueExp = ast.trueExp.visit(this);
          const falseExp = ast.falseExp.visit(this);
          if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== falseExp) {
              return new Conditional(ast.span, condition, trueExp, falseExp);
          }
          return ast;
      }
      visitPipe(ast, context) {
          const exp = ast.exp.visit(this);
          const args = this.visitAll(ast.args);
          if (exp !== ast.exp || args !== ast.args) {
              return new BindingPipe(ast.span, exp, ast.name, args);
          }
          return ast;
      }
      visitKeyedRead(ast, context) {
          const obj = ast.obj.visit(this);
          const key = ast.key.visit(this);
          if (obj !== ast.obj || key !== ast.key) {
              return new KeyedRead(ast.span, obj, key);
          }
          return ast;
      }
      visitKeyedWrite(ast, context) {
          const obj = ast.obj.visit(this);
          const key = ast.key.visit(this);
          const value = ast.value.visit(this);
          if (obj !== ast.obj || key !== ast.key || value !== ast.value) {
              return new KeyedWrite(ast.span, obj, key, value);
          }
          return ast;
      }
      visitAll(asts) {
          const res = new Array(asts.length);
          let modified = false;
          for (let i = 0; i < asts.length; ++i) {
              const original = asts[i];
              const value = original.visit(this);
              res[i] = value;
              modified = modified || value !== original;
          }
          return modified ? res : asts;
      }
      visitChain(ast, context) {
          const expressions = this.visitAll(ast.expressions);
          if (expressions !== ast.expressions) {
              return new Chain(ast.span, expressions);
          }
          return ast;
      }
      visitQuote(ast, context) { return ast; }
  }
  // Bindings
  class ParsedProperty {
      constructor(name, expression, type, sourceSpan) {
          this.name = name;
          this.expression = expression;
          this.type = type;
          this.sourceSpan = sourceSpan;
          this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
          this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
      }
  }
  var ParsedPropertyType;
  (function (ParsedPropertyType) {
      ParsedPropertyType[ParsedPropertyType["DEFAULT"] = 0] = "DEFAULT";
      ParsedPropertyType[ParsedPropertyType["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
      ParsedPropertyType[ParsedPropertyType["ANIMATION"] = 2] = "ANIMATION";
  })(ParsedPropertyType || (ParsedPropertyType = {}));
  class ParsedEvent {
      // Regular events have a target
      // Animation events have a phase
      constructor(name, targetOrPhase, type, handler, sourceSpan) {
          this.name = name;
          this.targetOrPhase = targetOrPhase;
          this.type = type;
          this.handler = handler;
          this.sourceSpan = sourceSpan;
      }
  }
  class ParsedVariable {
      constructor(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
  }
  class BoundElementProperty {
      constructor(name, type, securityContext, value, unit, sourceSpan) {
          this.name = name;
          this.type = type;
          this.securityContext = securityContext;
          this.value = value;
          this.unit = unit;
          this.sourceSpan = sourceSpan;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class EventHandlerVars {
  }
  EventHandlerVars.event = variable('$event');
  class ConvertActionBindingResult {
      constructor(
      /**
       * Render2 compatible statements,
       */
      stmts, 
      /**
       * Variable name used with render2 compatible statements.
       */
      allowDefault) {
          this.stmts = stmts;
          this.allowDefault = allowDefault;
          /**
           * This is bit of a hack. It converts statements which render2 expects to statements which are
           * expected by render3.
           *
           * Example: `<div click="doSomething($event)">` will generate:
           *
           * Render3:
           * ```
           * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);
           * return pd_b;
           * ```
           *
           * but render2 expects:
           * ```
           * return ctx.doSomething($event);
           * ```
           */
          // TODO(misko): remove this hack once we no longer support ViewEngine.
          this.render3Stmts = stmts.map((statement) => {
              if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name &&
                  statement.value instanceof BinaryOperatorExpr) {
                  const lhs = statement.value.lhs;
                  return new ReturnStatement(lhs.value);
              }
              return statement;
          });
      }
  }
  /**
   * Converts the given expression AST into an executable output AST, assuming the expression is
   * used in an action binding (e.g. an event handler).
   */
  function convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction) {
      if (!localResolver) {
          localResolver = new DefaultLocalResolver();
      }
      const actionWithoutBuiltins = convertPropertyBindingBuiltins({
          createLiteralArrayConverter: (argCount) => {
              // Note: no caching for literal arrays in actions.
              return (args) => literalArr(args);
          },
          createLiteralMapConverter: (keys) => {
              // Note: no caching for literal maps in actions.
              return (values) => {
                  const entries = keys.map((k, i) => ({
                      key: k.key,
                      value: values[i],
                      quoted: k.quoted,
                  }));
                  return literalMap(entries);
              };
          },
          createPipeConverter: (name) => {
              throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);
          }
      }, action);
      const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);
      const actionStmts = [];
      flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
      prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);
      const lastIndex = actionStmts.length - 1;
      let preventDefaultVar = null;
      if (lastIndex >= 0) {
          const lastStatement = actionStmts[lastIndex];
          const returnExpr = convertStmtIntoExpression(lastStatement);
          if (returnExpr) {
              // Note: We need to cast the result of the method call to dynamic,
              // as it might be a void method!
              preventDefaultVar = createPreventDefaultVar(bindingId);
              actionStmts[lastIndex] =
                  preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))
                      .toDeclStmt(null, [StmtModifier.Final]);
          }
      }
      return new ConvertActionBindingResult(actionStmts, preventDefaultVar);
  }
  function convertPropertyBindingBuiltins(converterFactory, ast) {
      return convertBuiltins(converterFactory, ast);
  }
  class ConvertPropertyBindingResult {
      constructor(stmts, currValExpr) {
          this.stmts = stmts;
          this.currValExpr = currValExpr;
      }
  }
  var BindingForm;
  (function (BindingForm) {
      // The general form of binding expression, supports all expressions.
      BindingForm[BindingForm["General"] = 0] = "General";
      // Try to generate a simple binding (no temporaries or statements)
      // otherwise generate a general binding
      BindingForm[BindingForm["TrySimple"] = 1] = "TrySimple";
  })(BindingForm || (BindingForm = {}));
  /**
   * Converts the given expression AST into an executable output AST, assuming the expression
   * is used in property binding. The expression has to be preprocessed via
   * `convertPropertyBindingBuiltins`.
   */
  function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {
      if (!localResolver) {
          localResolver = new DefaultLocalResolver();
      }
      const currValExpr = createCurrValueExpr(bindingId);
      const stmts = [];
      const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);
      const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
      if (visitor.temporaryCount) {
          for (let i = 0; i < visitor.temporaryCount; i++) {
              stmts.push(temporaryDeclaration(bindingId, i));
          }
      }
      else if (form == BindingForm.TrySimple) {
          return new ConvertPropertyBindingResult([], outputExpr);
      }
      stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));
      return new ConvertPropertyBindingResult(stmts, currValExpr);
  }
  function convertBuiltins(converterFactory, ast) {
      const visitor = new _BuiltinAstConverter(converterFactory);
      return ast.visit(visitor);
  }
  function temporaryName(bindingId, temporaryNumber) {
      return `tmp_${bindingId}_${temporaryNumber}`;
  }
  function temporaryDeclaration(bindingId, temporaryNumber) {
      return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);
  }
  function prependTemporaryDecls(temporaryCount, bindingId, statements) {
      for (let i = temporaryCount - 1; i >= 0; i--) {
          statements.unshift(temporaryDeclaration(bindingId, i));
      }
  }
  var _Mode;
  (function (_Mode) {
      _Mode[_Mode["Statement"] = 0] = "Statement";
      _Mode[_Mode["Expression"] = 1] = "Expression";
  })(_Mode || (_Mode = {}));
  function ensureStatementMode(mode, ast) {
      if (mode !== _Mode.Statement) {
          throw new Error(`Expected a statement, but saw ${ast}`);
      }
  }
  function ensureExpressionMode(mode, ast) {
      if (mode !== _Mode.Expression) {
          throw new Error(`Expected an expression, but saw ${ast}`);
      }
  }
  function convertToStatementIfNeeded(mode, expr) {
      if (mode === _Mode.Statement) {
          return expr.toStmt();
      }
      else {
          return expr;
      }
  }
  class _BuiltinAstConverter extends AstTransformer$1 {
      constructor(_converterFactory) {
          super();
          this._converterFactory = _converterFactory;
      }
      visitPipe(ast, context) {
          const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));
          return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));
      }
      visitLiteralArray(ast, context) {
          const args = ast.expressions.map(ast => ast.visit(this, context));
          return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
      }
      visitLiteralMap(ast, context) {
          const args = ast.values.map(ast => ast.visit(this, context));
          return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));
      }
  }
  class _AstToIrVisitor {
      constructor(_localResolver, _implicitReceiver, bindingId, interpolationFunction) {
          this._localResolver = _localResolver;
          this._implicitReceiver = _implicitReceiver;
          this.bindingId = bindingId;
          this.interpolationFunction = interpolationFunction;
          this._nodeMap = new Map();
          this._resultMap = new Map();
          this._currentTemporary = 0;
          this.temporaryCount = 0;
      }
      visitBinary(ast, mode) {
          let op;
          switch (ast.operation) {
              case '+':
                  op = BinaryOperator.Plus;
                  break;
              case '-':
                  op = BinaryOperator.Minus;
                  break;
              case '*':
                  op = BinaryOperator.Multiply;
                  break;
              case '/':
                  op = BinaryOperator.Divide;
                  break;
              case '%':
                  op = BinaryOperator.Modulo;
                  break;
              case '&&':
                  op = BinaryOperator.And;
                  break;
              case '||':
                  op = BinaryOperator.Or;
                  break;
              case '==':
                  op = BinaryOperator.Equals;
                  break;
              case '!=':
                  op = BinaryOperator.NotEquals;
                  break;
              case '===':
                  op = BinaryOperator.Identical;
                  break;
              case '!==':
                  op = BinaryOperator.NotIdentical;
                  break;
              case '<':
                  op = BinaryOperator.Lower;
                  break;
              case '>':
                  op = BinaryOperator.Bigger;
                  break;
              case '<=':
                  op = BinaryOperator.LowerEquals;
                  break;
              case '>=':
                  op = BinaryOperator.BiggerEquals;
                  break;
              default:
                  throw new Error(`Unsupported operation ${ast.operation}`);
          }
          return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression)));
      }
      visitChain(ast, mode) {
          ensureStatementMode(mode, ast);
          return this.visitAll(ast.expressions, mode);
      }
      visitConditional(ast, mode) {
          const value = this._visit(ast.condition, _Mode.Expression);
          return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression)));
      }
      visitPipe(ast, mode) {
          throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);
      }
      visitFunctionCall(ast, mode) {
          const convertedArgs = this.visitAll(ast.args, _Mode.Expression);
          let fnResult;
          if (ast instanceof BuiltinFunctionCall) {
              fnResult = ast.converter(convertedArgs);
          }
          else {
              fnResult = this._visit(ast.target, _Mode.Expression).callFn(convertedArgs);
          }
          return convertToStatementIfNeeded(mode, fnResult);
      }
      visitImplicitReceiver(ast, mode) {
          ensureExpressionMode(mode, ast);
          return this._implicitReceiver;
      }
      visitInterpolation(ast, mode) {
          ensureExpressionMode(mode, ast);
          const args = [literal(ast.expressions.length)];
          for (let i = 0; i < ast.strings.length - 1; i++) {
              args.push(literal(ast.strings[i]));
              args.push(this._visit(ast.expressions[i], _Mode.Expression));
          }
          args.push(literal(ast.strings[ast.strings.length - 1]));
          if (this.interpolationFunction) {
              return this.interpolationFunction(args);
          }
          return ast.expressions.length <= 9 ?
              importExpr(Identifiers.inlineInterpolate).callFn(args) :
              importExpr(Identifiers.interpolate).callFn([args[0], literalArr(args.slice(1))]);
      }
      visitKeyedRead(ast, mode) {
          const leftMostSafe = this.leftMostSafeNode(ast);
          if (leftMostSafe) {
              return this.convertSafeAccess(ast, leftMostSafe, mode);
          }
          else {
              return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
          }
      }
      visitKeyedWrite(ast, mode) {
          const obj = this._visit(ast.obj, _Mode.Expression);
          const key = this._visit(ast.key, _Mode.Expression);
          const value = this._visit(ast.value, _Mode.Expression);
          return convertToStatementIfNeeded(mode, obj.key(key).set(value));
      }
      visitLiteralArray(ast, mode) {
          throw new Error(`Illegal State: literal arrays should have been converted into functions`);
      }
      visitLiteralMap(ast, mode) {
          throw new Error(`Illegal State: literal maps should have been converted into functions`);
      }
      visitLiteralPrimitive(ast, mode) {
          // For literal values of null, undefined, true, or false allow type interference
          // to infer the type.
          const type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?
              INFERRED_TYPE :
              undefined;
          return convertToStatementIfNeeded(mode, literal(ast.value, type));
      }
      _getLocal(name) { return this._localResolver.getLocal(name); }
      visitMethodCall(ast, mode) {
          if (ast.receiver instanceof ImplicitReceiver && ast.name == '$any') {
              const args = this.visitAll(ast.args, _Mode.Expression);
              if (args.length != 1) {
                  throw new Error(`Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);
              }
              return args[0].cast(DYNAMIC_TYPE);
          }
          const leftMostSafe = this.leftMostSafeNode(ast);
          if (leftMostSafe) {
              return this.convertSafeAccess(ast, leftMostSafe, mode);
          }
          else {
              const args = this.visitAll(ast.args, _Mode.Expression);
              let result = null;
              const receiver = this._visit(ast.receiver, _Mode.Expression);
              if (receiver === this._implicitReceiver) {
                  const varExpr = this._getLocal(ast.name);
                  if (varExpr) {
                      result = varExpr.callFn(args);
                  }
              }
              if (result == null) {
                  result = receiver.callMethod(ast.name, args);
              }
              return convertToStatementIfNeeded(mode, result);
          }
      }
      visitPrefixNot(ast, mode) {
          return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
      }
      visitNonNullAssert(ast, mode) {
          return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));
      }
      visitPropertyRead(ast, mode) {
          const leftMostSafe = this.leftMostSafeNode(ast);
          if (leftMostSafe) {
              return this.convertSafeAccess(ast, leftMostSafe, mode);
          }
          else {
              let result = null;
              const receiver = this._visit(ast.receiver, _Mode.Expression);
              if (receiver === this._implicitReceiver) {
                  result = this._getLocal(ast.name);
              }
              if (result == null) {
                  result = receiver.prop(ast.name);
              }
              return convertToStatementIfNeeded(mode, result);
          }
      }
      visitPropertyWrite(ast, mode) {
          const receiver = this._visit(ast.receiver, _Mode.Expression);
          let varExpr = null;
          if (receiver === this._implicitReceiver) {
              const localExpr = this._getLocal(ast.name);
              if (localExpr) {
                  if (localExpr instanceof ReadPropExpr) {
                      // If the local variable is a property read expression, it's a reference
                      // to a 'context.property' value and will be used as the target of the
                      // write expression.
                      varExpr = localExpr;
                  }
                  else {
                      // Otherwise it's an error.
                      throw new Error('Cannot assign to a reference or variable!');
                  }
              }
          }
          // If no local expression could be produced, use the original receiver's
          // property as the target.
          if (varExpr === null) {
              varExpr = receiver.prop(ast.name);
          }
          return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
      }
      visitSafePropertyRead(ast, mode) {
          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      }
      visitSafeMethodCall(ast, mode) {
          return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
      }
      visitAll(asts, mode) { return asts.map(ast => this._visit(ast, mode)); }
      visitQuote(ast, mode) {
          throw new Error(`Quotes are not supported for evaluation!
        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);
      }
      _visit(ast, mode) {
          const result = this._resultMap.get(ast);
          if (result)
              return result;
          return (this._nodeMap.get(ast) || ast).visit(this, mode);
      }
      convertSafeAccess(ast, leftMostSafe, mode) {
          // If the expression contains a safe access node on the left it needs to be converted to
          // an expression that guards the access to the member by checking the receiver for blank. As
          // execution proceeds from left to right, the left most part of the expression must be guarded
          // first but, because member access is left associative, the right side of the expression is at
          // the top of the AST. The desired result requires lifting a copy of the the left part of the
          // expression up to test it for blank before generating the unguarded version.
          // Consider, for example the following expression: a?.b.c?.d.e
          // This results in the ast:
          //         .
          //        / \
          //       ?.   e
          //      /  \
          //     .    d
          //    / \
          //   ?.  c
          //  /  \
          // a    b
          // The following tree should be generated:
          //
          //        /---- ? ----\
          //       /      |      \
          //     a   /--- ? ---\  null
          //        /     |     \
          //       .      .     null
          //      / \    / \
          //     .  c   .   e
          //    / \    / \
          //   a   b  ,   d
          //         / \
          //        .   c
          //       / \
          //      a   b
          //
          // Notice that the first guard condition is the left hand of the left most safe access node
          // which comes in as leftMostSafe to this routine.
          let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);
          let temporary = undefined;
          if (this.needsTemporary(leftMostSafe.receiver)) {
              // If the expression has method calls or pipes then we need to save the result into a
              // temporary variable to avoid calling stateful or impure code more than once.
              temporary = this.allocateTemporary();
              // Preserve the result in the temporary variable
              guardedExpression = temporary.set(guardedExpression);
              // Ensure all further references to the guarded expression refer to the temporary instead.
              this._resultMap.set(leftMostSafe.receiver, temporary);
          }
          const condition = guardedExpression.isBlank();
          // Convert the ast to an unguarded access to the receiver's member. The map will substitute
          // leftMostNode with its unguarded version in the call to `this.visit()`.
          if (leftMostSafe instanceof SafeMethodCall) {
              this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));
          }
          else {
              this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));
          }
          // Recursively convert the node now without the guarded member access.
          const access = this._visit(ast, _Mode.Expression);
          // Remove the mapping. This is not strictly required as the converter only traverses each node
          // once but is safer if the conversion is changed to traverse the nodes more than once.
          this._nodeMap.delete(leftMostSafe);
          // If we allocated a temporary, release it.
          if (temporary) {
              this.releaseTemporary(temporary);
          }
          // Produce the conditional
          return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));
      }
      // Given a expression of the form a?.b.c?.d.e the the left most safe node is
      // the (a?.b). The . and ?. are left associative thus can be rewritten as:
      // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
      // safe method call as this needs be transform initially to:
      //   a == null ? null : a.c.b.c?.d.e
      // then to:
      //   a == null ? null : a.b.c == null ? null : a.b.c.d.e
      leftMostSafeNode(ast) {
          const visit = (visitor, ast) => {
              return (this._nodeMap.get(ast) || ast).visit(visitor);
          };
          return ast.visit({
              visitBinary(ast) { return null; },
              visitChain(ast) { return null; },
              visitConditional(ast) { return null; },
              visitFunctionCall(ast) { return null; },
              visitImplicitReceiver(ast) { return null; },
              visitInterpolation(ast) { return null; },
              visitKeyedRead(ast) { return visit(this, ast.obj); },
              visitKeyedWrite(ast) { return null; },
              visitLiteralArray(ast) { return null; },
              visitLiteralMap(ast) { return null; },
              visitLiteralPrimitive(ast) { return null; },
              visitMethodCall(ast) { return visit(this, ast.receiver); },
              visitPipe(ast) { return null; },
              visitPrefixNot(ast) { return null; },
              visitNonNullAssert(ast) { return null; },
              visitPropertyRead(ast) { return visit(this, ast.receiver); },
              visitPropertyWrite(ast) { return null; },
              visitQuote(ast) { return null; },
              visitSafeMethodCall(ast) { return visit(this, ast.receiver) || ast; },
              visitSafePropertyRead(ast) {
                  return visit(this, ast.receiver) || ast;
              }
          });
      }
      // Returns true of the AST includes a method or a pipe indicating that, if the
      // expression is used as the target of a safe property or method access then
      // the expression should be stored into a temporary variable.
      needsTemporary(ast) {
          const visit = (visitor, ast) => {
              return ast && (this._nodeMap.get(ast) || ast).visit(visitor);
          };
          const visitSome = (visitor, ast) => {
              return ast.some(ast => visit(visitor, ast));
          };
          return ast.visit({
              visitBinary(ast) { return visit(this, ast.left) || visit(this, ast.right); },
              visitChain(ast) { return false; },
              visitConditional(ast) {
                  return visit(this, ast.condition) || visit(this, ast.trueExp) ||
                      visit(this, ast.falseExp);
              },
              visitFunctionCall(ast) { return true; },
              visitImplicitReceiver(ast) { return false; },
              visitInterpolation(ast) { return visitSome(this, ast.expressions); },
              visitKeyedRead(ast) { return false; },
              visitKeyedWrite(ast) { return false; },
              visitLiteralArray(ast) { return true; },
              visitLiteralMap(ast) { return true; },
              visitLiteralPrimitive(ast) { return false; },
              visitMethodCall(ast) { return true; },
              visitPipe(ast) { return true; },
              visitPrefixNot(ast) { return visit(this, ast.expression); },
              visitNonNullAssert(ast) { return visit(this, ast.expression); },
              visitPropertyRead(ast) { return false; },
              visitPropertyWrite(ast) { return false; },
              visitQuote(ast) { return false; },
              visitSafeMethodCall(ast) { return true; },
              visitSafePropertyRead(ast) { return false; }
          });
      }
      allocateTemporary() {
          const tempNumber = this._currentTemporary++;
          this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
          return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
      }
      releaseTemporary(temporary) {
          this._currentTemporary--;
          if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
              throw new Error(`Temporary ${temporary.name} released out of order`);
          }
      }
  }
  function flattenStatements(arg, output) {
      if (Array.isArray(arg)) {
          arg.forEach((entry) => flattenStatements(entry, output));
      }
      else {
          output.push(arg);
      }
  }
  class DefaultLocalResolver {
      getLocal(name) {
          if (name === EventHandlerVars.event.name) {
              return EventHandlerVars.event;
          }
          return null;
      }
  }
  function createCurrValueExpr(bindingId) {
      return variable(`currVal_${bindingId}`); // fix syntax highlighting: `
  }
  function createPreventDefaultVar(bindingId) {
      return variable(`pd_${bindingId}`);
  }
  function convertStmtIntoExpression(stmt) {
      if (stmt instanceof ExpressionStatement) {
          return stmt.expr;
      }
      else if (stmt instanceof ReturnStatement) {
          return stmt.value;
      }
      return null;
  }
  class BuiltinFunctionCall extends FunctionCall {
      constructor(span, args, converter) {
          super(span, null, args);
          this.args = args;
          this.converter = converter;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var LifecycleHooks;
  (function (LifecycleHooks) {
      LifecycleHooks[LifecycleHooks["OnInit"] = 0] = "OnInit";
      LifecycleHooks[LifecycleHooks["OnDestroy"] = 1] = "OnDestroy";
      LifecycleHooks[LifecycleHooks["DoCheck"] = 2] = "DoCheck";
      LifecycleHooks[LifecycleHooks["OnChanges"] = 3] = "OnChanges";
      LifecycleHooks[LifecycleHooks["AfterContentInit"] = 4] = "AfterContentInit";
      LifecycleHooks[LifecycleHooks["AfterContentChecked"] = 5] = "AfterContentChecked";
      LifecycleHooks[LifecycleHooks["AfterViewInit"] = 6] = "AfterViewInit";
      LifecycleHooks[LifecycleHooks["AfterViewChecked"] = 7] = "AfterViewChecked";
  })(LifecycleHooks || (LifecycleHooks = {}));
  const LIFECYCLE_HOOKS_VALUES = [
      LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
      LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
      LifecycleHooks.AfterViewChecked
  ];
  function hasLifecycleHook(reflector, hook, token) {
      return reflector.hasLifecycleHook(token, getHookName(hook));
  }
  function getAllLifecycleHooks(reflector, token) {
      return LIFECYCLE_HOOKS_VALUES.filter(hook => hasLifecycleHook(reflector, hook, token));
  }
  function getHookName(hook) {
      switch (hook) {
          case LifecycleHooks.OnInit:
              return 'ngOnInit';
          case LifecycleHooks.OnDestroy:
              return 'ngOnDestroy';
          case LifecycleHooks.DoCheck:
              return 'ngDoCheck';
          case LifecycleHooks.OnChanges:
              return 'ngOnChanges';
          case LifecycleHooks.AfterContentInit:
              return 'ngAfterContentInit';
          case LifecycleHooks.AfterContentChecked:
              return 'ngAfterContentChecked';
          case LifecycleHooks.AfterViewInit:
              return 'ngAfterViewInit';
          case LifecycleHooks.AfterViewChecked:
              return 'ngAfterViewChecked';
          default:
              // This default case is not needed by TypeScript compiler, as the switch is exhaustive.
              // However Closure Compiler does not understand that and reports an error in typed mode.
              // The `throw new Error` below works around the problem, and the unexpected: never variable
              // makes sure tsc still checks this code is unreachable.
              const unexpected = hook;
              throw new Error(`unexpected ${unexpected}`);
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const $EOF = 0;
  const $TAB = 9;
  const $LF = 10;
  const $VTAB = 11;
  const $FF = 12;
  const $CR = 13;
  const $SPACE = 32;
  const $BANG = 33;
  const $DQ = 34;
  const $HASH = 35;
  const $$ = 36;
  const $PERCENT = 37;
  const $AMPERSAND = 38;
  const $SQ = 39;
  const $LPAREN = 40;
  const $RPAREN = 41;
  const $STAR = 42;
  const $PLUS = 43;
  const $COMMA = 44;
  const $MINUS = 45;
  const $PERIOD = 46;
  const $SLASH = 47;
  const $COLON = 58;
  const $SEMICOLON = 59;
  const $LT = 60;
  const $EQ = 61;
  const $GT = 62;
  const $QUESTION = 63;
  const $0 = 48;
  const $9 = 57;
  const $A = 65;
  const $E = 69;
  const $F = 70;
  const $X = 88;
  const $Z = 90;
  const $LBRACKET = 91;
  const $BACKSLASH = 92;
  const $RBRACKET = 93;
  const $CARET = 94;
  const $_ = 95;
  const $a = 97;
  const $e = 101;
  const $f = 102;
  const $n = 110;
  const $r = 114;
  const $t = 116;
  const $u = 117;
  const $v = 118;
  const $x = 120;
  const $z = 122;
  const $LBRACE = 123;
  const $BAR = 124;
  const $RBRACE = 125;
  const $NBSP = 160;
  const $BT = 96;
  function isWhitespace(code) {
      return (code >= $TAB && code <= $SPACE) || (code == $NBSP);
  }
  function isDigit(code) {
      return $0 <= code && code <= $9;
  }
  function isAsciiLetter(code) {
      return code >= $a && code <= $z || code >= $A && code <= $Z;
  }
  function isAsciiHexDigit(code) {
      return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class ParseLocation {
      constructor(file, offset, line, col) {
          this.file = file;
          this.offset = offset;
          this.line = line;
          this.col = col;
      }
      toString() {
          return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
      }
      moveBy(delta) {
          const source = this.file.content;
          const len = source.length;
          let offset = this.offset;
          let line = this.line;
          let col = this.col;
          while (offset > 0 && delta < 0) {
              offset--;
              delta++;
              const ch = source.charCodeAt(offset);
              if (ch == $LF) {
                  line--;
                  const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
                  col = priorLine > 0 ? offset - priorLine : offset;
              }
              else {
                  col--;
              }
          }
          while (offset < len && delta > 0) {
              const ch = source.charCodeAt(offset);
              offset++;
              delta--;
              if (ch == $LF) {
                  line++;
                  col = 0;
              }
              else {
                  col++;
              }
          }
          return new ParseLocation(this.file, offset, line, col);
      }
      // Return the source around the location
      // Up to `maxChars` or `maxLines` on each side of the location
      getContext(maxChars, maxLines) {
          const content = this.file.content;
          let startOffset = this.offset;
          if (startOffset != null) {
              if (startOffset > content.length - 1) {
                  startOffset = content.length - 1;
              }
              let endOffset = startOffset;
              let ctxChars = 0;
              let ctxLines = 0;
              while (ctxChars < maxChars && startOffset > 0) {
                  startOffset--;
                  ctxChars++;
                  if (content[startOffset] == '\n') {
                      if (++ctxLines == maxLines) {
                          break;
                      }
                  }
              }
              ctxChars = 0;
              ctxLines = 0;
              while (ctxChars < maxChars && endOffset < content.length - 1) {
                  endOffset++;
                  ctxChars++;
                  if (content[endOffset] == '\n') {
                      if (++ctxLines == maxLines) {
                          break;
                      }
                  }
              }
              return {
                  before: content.substring(startOffset, this.offset),
                  after: content.substring(this.offset, endOffset + 1),
              };
          }
          return null;
      }
  }
  class ParseSourceFile {
      constructor(content, url) {
          this.content = content;
          this.url = url;
      }
  }
  class ParseSourceSpan {
      constructor(start, end, details = null) {
          this.start = start;
          this.end = end;
          this.details = details;
      }
      toString() {
          return this.start.file.content.substring(this.start.offset, this.end.offset);
      }
  }
  var ParseErrorLevel;
  (function (ParseErrorLevel) {
      ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
      ParseErrorLevel[ParseErrorLevel["ERROR"] = 1] = "ERROR";
  })(ParseErrorLevel || (ParseErrorLevel = {}));
  class ParseError {
      constructor(span, msg, level = ParseErrorLevel.ERROR) {
          this.span = span;
          this.msg = msg;
          this.level = level;
      }
      contextualMessage() {
          const ctx = this.span.start.getContext(100, 3);
          return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` :
              this.msg;
      }
      toString() {
          const details = this.span.details ? `, ${this.span.details}` : '';
          return `${this.contextualMessage()}: ${this.span.start}${details}`;
      }
  }
  function typeSourceSpan(kind, type) {
      const moduleUrl = identifierModuleUrl(type);
      const sourceFileName = moduleUrl != null ? `in ${kind} ${identifierName(type)} in ${moduleUrl}` :
          `in ${kind} ${identifierName(type)}`;
      const sourceFile = new ParseSourceFile('', sourceFileName);
      return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * This file is a port of shadowCSS from webcomponents.js to TypeScript.
   *
   * Please make sure to keep to edits in sync with the source file.
   *
   * Source:
   * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
   *
   * The original file level comment is reproduced below
   */
  /*
    This is a limited shim for ShadowDOM css styling.
    https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

    The intention here is to support only the styling features which can be
    relatively simply implemented. The goal is to allow users to avoid the
    most obvious pitfalls and do so without compromising performance significantly.
    For ShadowDOM styling that's not covered here, a set of best practices
    can be provided that should allow users to accomplish more complex styling.

    The following is a list of specific ShadowDOM styling features and a brief
    discussion of the approach used to shim.

    Shimmed features:

    * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
    element using the :host rule. To shim this feature, the :host styles are
    reformatted and prefixed with a given scope name and promoted to a
    document level stylesheet.
    For example, given a scope name of .foo, a rule like this:

      :host {
          background: red;
        }
      }

    becomes:

      .foo {
        background: red;
      }

    * encapsulation: Styles defined within ShadowDOM, apply only to
    dom inside the ShadowDOM. Polymer uses one of two techniques to implement
    this feature.

    By default, rules are prefixed with the host element tag name
    as a descendant selector. This ensures styling does not leak out of the 'top'
    of the element's ShadowDOM. For example,

    div {
        font-weight: bold;
      }

    becomes:

    x-foo div {
        font-weight: bold;
      }

    becomes:


    Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
    selectors are scoped by adding an attribute selector suffix to each
    simple selector that contains the host element tag name. Each element
    in the element's ShadowDOM template is also given the scope attribute.
    Thus, these rules match only elements that have the scope attribute.
    For example, given a scope name of x-foo, a rule like this:

      div {
        font-weight: bold;
      }

    becomes:

      div[x-foo] {
        font-weight: bold;
      }

    Note that elements that are dynamically added to a scope must have the scope
    selector added to them manually.

    * upper/lower bound encapsulation: Styles which are defined outside a
    shadowRoot should not cross the ShadowDOM boundary and should not apply
    inside a shadowRoot.

    This styling behavior is not emulated. Some possible ways to do this that
    were rejected due to complexity and/or performance concerns include: (1) reset
    every possible property for every possible selector for a given scope name;
    (2) re-implement css in javascript.

    As an alternative, users should make sure to use selectors
    specific to the scope in which they are working.

    * ::distributed: This behavior is not emulated. It's often not necessary
    to style the contents of a specific insertion point and instead, descendants
    of the host element can be styled selectively. Users can also create an
    extra node around an insertion point and style that node's contents
    via descendent selectors. For example, with a shadowRoot like this:

      <style>
        ::content(div) {
          background: red;
        }
      </style>
      <content></content>

    could become:

      <style>
        / *@polyfill .content-container div * /
        ::content(div) {
          background: red;
        }
      </style>
      <div class="content-container">
        <content></content>
      </div>

    Note the use of @polyfill in the comment above a ShadowDOM specific style
    declaration. This is a directive to the styling shim to use the selector
    in comments in lieu of the next selector when running under polyfill.
  */
  class ShadowCss {
      constructor() {
          this.strictStyling = true;
      }
      /*
      * Shim some cssText with the given selector. Returns cssText that can
      * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
      *
      * When strictStyling is true:
      * - selector is the attribute added to all elements inside the host,
      * - hostSelector is the attribute added to the host itself.
      */
      shimCssText(cssText, selector, hostSelector = '') {
          const commentsWithHash = extractCommentsWithHash(cssText);
          cssText = stripComments(cssText);
          cssText = this._insertDirectives(cssText);
          const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);
          return [scopedCssText, ...commentsWithHash].join('\n');
      }
      _insertDirectives(cssText) {
          cssText = this._insertPolyfillDirectivesInCssText(cssText);
          return this._insertPolyfillRulesInCssText(cssText);
      }
      /*
       * Process styles to convert native ShadowDOM rules that will trip
       * up the css parser; we rely on decorating the stylesheet with inert rules.
       *
       * For example, we convert this rule:
       *
       * polyfill-next-selector { content: ':host menu-item'; }
       * ::content menu-item {
       *
       * to this:
       *
       * scopeName menu-item {
       *
      **/
      _insertPolyfillDirectivesInCssText(cssText) {
          // Difference with webcomponents.js: does not handle comments
          return cssText.replace(_cssContentNextSelectorRe, function (...m) { return m[2] + '{'; });
      }
      /*
       * Process styles to add rules which will only apply under the polyfill
       *
       * For example, we convert this rule:
       *
       * polyfill-rule {
       *   content: ':host menu-item';
       * ...
       * }
       *
       * to this:
       *
       * scopeName menu-item {...}
       *
      **/
      _insertPolyfillRulesInCssText(cssText) {
          // Difference with webcomponents.js: does not handle comments
          return cssText.replace(_cssContentRuleRe, (...m) => {
              const rule = m[0].replace(m[1], '').replace(m[2], '');
              return m[4] + rule;
          });
      }
      /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
       *
       *  .foo {... }
       *
       *  and converts this to
       *
       *  scopeName .foo { ... }
      */
      _scopeCssText(cssText, scopeSelector, hostSelector) {
          const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);
          // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively
          cssText = this._insertPolyfillHostInCssText(cssText);
          cssText = this._convertColonHost(cssText);
          cssText = this._convertColonHostContext(cssText);
          cssText = this._convertShadowDOMSelectors(cssText);
          if (scopeSelector) {
              cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
          }
          cssText = cssText + '\n' + unscopedRules;
          return cssText.trim();
      }
      /*
       * Process styles to add rules which will only apply under the polyfill
       * and do not process via CSSOM. (CSSOM is destructive to rules on rare
       * occasions, e.g. -webkit-calc on Safari.)
       * For example, we convert this rule:
       *
       * @polyfill-unscoped-rule {
       *   content: 'menu-item';
       * ... }
       *
       * to this:
       *
       * menu-item {...}
       *
      **/
      _extractUnscopedRulesFromCssText(cssText) {
          // Difference with webcomponents.js: does not handle comments
          let r = '';
          let m;
          _cssContentUnscopedRuleRe.lastIndex = 0;
          while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
              const rule = m[0].replace(m[2], '').replace(m[1], m[4]);
              r += rule + '\n\n';
          }
          return r;
      }
      /*
       * convert a rule like :host(.foo) > .bar { }
       *
       * to
       *
       * .foo<scopeName> > .bar
      */
      _convertColonHost(cssText) {
          return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
      }
      /*
       * convert a rule like :host-context(.foo) > .bar { }
       *
       * to
       *
       * .foo<scopeName> > .bar, .foo scopeName > .bar { }
       *
       * and
       *
       * :host-context(.foo:host) .bar { ... }
       *
       * to
       *
       * .foo<scopeName> .bar { ... }
      */
      _convertColonHostContext(cssText) {
          return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
      }
      _convertColonRule(cssText, regExp, partReplacer) {
          // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule
          return cssText.replace(regExp, function (...m) {
              if (m[2]) {
                  const parts = m[2].split(',');
                  const r = [];
                  for (let i = 0; i < parts.length; i++) {
                      const p = parts[i].trim();
                      if (!p)
                          break;
                      r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
                  }
                  return r.join(',');
              }
              else {
                  return _polyfillHostNoCombinator + m[3];
              }
          });
      }
      _colonHostContextPartReplacer(host, part, suffix) {
          if (part.indexOf(_polyfillHost) > -1) {
              return this._colonHostPartReplacer(host, part, suffix);
          }
          else {
              return host + part + suffix + ', ' + part + ' ' + host + suffix;
          }
      }
      _colonHostPartReplacer(host, part, suffix) {
          return host + part.replace(_polyfillHost, '') + suffix;
      }
      /*
       * Convert combinators like ::shadow and pseudo-elements like ::content
       * by replacing with space.
      */
      _convertShadowDOMSelectors(cssText) {
          return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);
      }
      // change a selector like 'div' to 'name div'
      _scopeSelectors(cssText, scopeSelector, hostSelector) {
          return processRules(cssText, (rule) => {
              let selector = rule.selector;
              let content = rule.content;
              if (rule.selector[0] != '@') {
                  selector =
                      this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);
              }
              else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||
                  rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {
                  content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);
              }
              return new CssRule(selector, content);
          });
      }
      _scopeSelector(selector, scopeSelector, hostSelector, strict) {
          return selector.split(',')
              .map(part => part.trim().split(_shadowDeepSelectors))
              .map((deepParts) => {
              const [shallowPart, ...otherParts] = deepParts;
              const applyScope = (shallowPart) => {
                  if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {
                      return strict ?
                          this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :
                          this._applySelectorScope(shallowPart, scopeSelector, hostSelector);
                  }
                  else {
                      return shallowPart;
                  }
              };
              return [applyScope(shallowPart), ...otherParts].join(' ');
          })
              .join(', ');
      }
      _selectorNeedsScoping(selector, scopeSelector) {
          const re = this._makeScopeMatcher(scopeSelector);
          return !re.test(selector);
      }
      _makeScopeMatcher(scopeSelector) {
          const lre = /\[/g;
          const rre = /\]/g;
          scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
          return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
      }
      _applySelectorScope(selector, scopeSelector, hostSelector) {
          // Difference from webcomponents.js: scopeSelector could not be an array
          return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
      }
      // scope via name and [is=name]
      _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
          // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
          _polyfillHostRe.lastIndex = 0;
          if (_polyfillHostRe.test(selector)) {
              const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;
              return selector
                  .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {
                  return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {
                      return before + replaceBy + colon + after;
                  });
              })
                  .replace(_polyfillHostRe, replaceBy + ' ');
          }
          return scopeSelector + ' ' + selector;
      }
      // return a selector with [name] suffix on each simple selector
      // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */
      _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
          const isRe = /\[is=([^\]]*)\]/g;
          scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);
          const attrName = '[' + scopeSelector + ']';
          const _scopeSelectorPart = (p) => {
              let scopedP = p.trim();
              if (!scopedP) {
                  return '';
              }
              if (p.indexOf(_polyfillHostNoCombinator) > -1) {
                  scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);
              }
              else {
                  // remove :host since it should be unnecessary
                  const t = p.replace(_polyfillHostRe, '');
                  if (t.length > 0) {
                      const matches = t.match(/([^:]*)(:*)(.*)/);
                      if (matches) {
                          scopedP = matches[1] + attrName + matches[2] + matches[3];
                      }
                  }
              }
              return scopedP;
          };
          const safeContent = new SafeSelector(selector);
          selector = safeContent.content();
          let scopedSelector = '';
          let startIndex = 0;
          let res;
          const sep = /( |>|\+|~(?!=))\s*/g;
          // If a selector appears before :host it should not be shimmed as it
          // matches on ancestor elements and not on elements in the host's shadow
          // `:host-context(div)` is transformed to
          // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
          // the `div` is not part of the component in the 2nd selectors and should not be scoped.
          // Historically `component-tag:host` was matching the component so we also want to preserve
          // this behavior to avoid breaking legacy apps (it should not match).
          // The behavior should be:
          // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
          // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
          //   `:host-context(tag)`)
          const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;
          // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present
          let shouldScope = !hasHost;
          while ((res = sep.exec(selector)) !== null) {
              const separator = res[1];
              const part = selector.slice(startIndex, res.index).trim();
              shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
              const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;
              scopedSelector += `${scopedPart} ${separator} `;
              startIndex = sep.lastIndex;
          }
          const part = selector.substring(startIndex);
          shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
          scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;
          // replace the placeholders with their original values
          return safeContent.restore(scopedSelector);
      }
      _insertPolyfillHostInCssText(selector) {
          return selector.replace(_colonHostContextRe, _polyfillHostContext)
              .replace(_colonHostRe, _polyfillHost);
      }
  }
  class SafeSelector {
      constructor(selector) {
          this.placeholders = [];
          this.index = 0;
          // Replaces attribute selectors with placeholders.
          // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.
          selector = selector.replace(/(\[[^\]]*\])/g, (_, keep) => {
              const replaceBy = `__ph-${this.index}__`;
              this.placeholders.push(keep);
              this.index++;
              return replaceBy;
          });
          // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
          // WS and "+" would otherwise be interpreted as selector separators.
          this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (_, pseudo, exp) => {
              const replaceBy = `__ph-${this.index}__`;
              this.placeholders.push(exp);
              this.index++;
              return pseudo + replaceBy;
          });
      }
      restore(content) {
          return content.replace(/__ph-(\d+)__/g, (ph, index) => this.placeholders[+index]);
      }
      content() { return this._content; }
  }
  const _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
  const _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  const _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
  const _polyfillHost = '-shadowcsshost';
  // note: :host-context pre-processed to -shadowcsshostcontext.
  const _polyfillHostContext = '-shadowcsscontext';
  const _parenSuffix = ')(?:\\((' +
      '(?:\\([^)(]*\\)|[^)(]*)+?' +
      ')\\))?([^,{]*)';
  const _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');
  const _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');
  const _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
  const _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
  const _shadowDOMSelectorsRe = [
      /::shadow/g,
      /::content/g,
      // Deprecated selectors
      /\/shadow-deep\//g,
      /\/shadow\//g,
  ];
  // The deep combinator is deprecated in the CSS spec
  // Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.
  // see https://github.com/angular/angular/pull/17677
  const _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
  const _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
  const _polyfillHostRe = /-shadowcsshost/gim;
  const _colonHostRe = /:host/gim;
  const _colonHostContextRe = /:host-context/gim;
  const _commentRe = /\/\*\s*[\s\S]*?\*\//g;
  function stripComments(input) {
      return input.replace(_commentRe, '');
  }
  const _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
  function extractCommentsWithHash(input) {
      return input.match(_commentWithHashRe) || [];
  }
  const _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
  const _curlyRe = /([{}])/g;
  const OPEN_CURLY = '{';
  const CLOSE_CURLY = '}';
  const BLOCK_PLACEHOLDER = '%BLOCK%';
  class CssRule {
      constructor(selector, content) {
          this.selector = selector;
          this.content = content;
      }
  }
  function processRules(input, ruleCallback) {
      const inputWithEscapedBlocks = escapeBlocks(input);
      let nextBlockIndex = 0;
      return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function (...m) {
          const selector = m[2];
          let content = '';
          let suffix = m[4];
          let contentPrefix = '';
          if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
              content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
              suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
              contentPrefix = '{';
          }
          const rule = ruleCallback(new CssRule(selector, content));
          return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;
      });
  }
  class StringWithEscapedBlocks {
      constructor(escapedString, blocks) {
          this.escapedString = escapedString;
          this.blocks = blocks;
      }
  }
  function escapeBlocks(input) {
      const inputParts = input.split(_curlyRe);
      const resultParts = [];
      const escapedBlocks = [];
      let bracketCount = 0;
      let currentBlockParts = [];
      for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {
          const part = inputParts[partIndex];
          if (part == CLOSE_CURLY) {
              bracketCount--;
          }
          if (bracketCount > 0) {
              currentBlockParts.push(part);
          }
          else {
              if (currentBlockParts.length > 0) {
                  escapedBlocks.push(currentBlockParts.join(''));
                  resultParts.push(BLOCK_PLACEHOLDER);
                  currentBlockParts = [];
              }
              resultParts.push(part);
          }
          if (part == OPEN_CURLY) {
              bracketCount++;
          }
      }
      if (currentBlockParts.length > 0) {
          escapedBlocks.push(currentBlockParts.join(''));
          resultParts.push(BLOCK_PLACEHOLDER);
      }
      return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const COMPONENT_VARIABLE = '%COMP%';
  const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
  const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
  class StylesCompileDependency {
      constructor(name, moduleUrl, setValue) {
          this.name = name;
          this.moduleUrl = moduleUrl;
          this.setValue = setValue;
      }
  }
  class CompiledStylesheet {
      constructor(outputCtx, stylesVar, dependencies, isShimmed, meta) {
          this.outputCtx = outputCtx;
          this.stylesVar = stylesVar;
          this.dependencies = dependencies;
          this.isShimmed = isShimmed;
          this.meta = meta;
      }
  }
  class StyleCompiler {
      constructor(_urlResolver) {
          this._urlResolver = _urlResolver;
          this._shadowCss = new ShadowCss();
      }
      compileComponent(outputCtx, comp) {
          const template = comp.template;
          return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({
              styles: template.styles,
              styleUrls: template.styleUrls,
              moduleUrl: identifierModuleUrl(comp.type)
          }), this.needsStyleShim(comp), true);
      }
      compileStyles(outputCtx, comp, stylesheet, shim = this.needsStyleShim(comp)) {
          return this._compileStyles(outputCtx, comp, stylesheet, shim, false);
      }
      needsStyleShim(comp) {
          return comp.template.encapsulation === ViewEncapsulation.Emulated;
      }
      _compileStyles(outputCtx, comp, stylesheet, shim, isComponentStylesheet) {
          const styleExpressions = stylesheet.styles.map(plainStyle => literal(this._shimIfNeeded(plainStyle, shim)));
          const dependencies = [];
          stylesheet.styleUrls.forEach((styleUrl) => {
              const exprIndex = styleExpressions.length;
              // Note: This placeholder will be filled later.
              styleExpressions.push(null);
              dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, (value) => styleExpressions[exprIndex] = outputCtx.importExpr(value)));
          });
          // styles variable contains plain strings and arrays of other styles arrays (recursive),
          // so we set its type to dynamic.
          const stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);
          const stmt = variable(stylesVar)
              .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))
              .toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [
              StmtModifier.Final, StmtModifier.Exported
          ]);
          outputCtx.statements.push(stmt);
          return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);
      }
      _shimIfNeeded(style, shim) {
          return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;
      }
  }
  function getStylesVarName(component) {
      let result = `styles`;
      if (component) {
          result += `_${identifierName(component.type)}`;
      }
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Parses string representation of a style and converts it into object literal.
   *
   * @param value string representation of style as used in the `style` attribute in HTML.
   *   Example: `color: red; height: auto`.
   * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',
   * 'auto']`
   */
  function parse(value) {
      // we use a string array here instead of a string map
      // because a string-map is not guaranteed to retain the
      // order of the entries whereas a string array can be
      // construted in a [key, value, key, value] format.
      const styles = [];
      let i = 0;
      let parenDepth = 0;
      let quote = 0 /* QuoteNone */;
      let valueStart = 0;
      let propStart = 0;
      let currentProp = null;
      let valueHasQuotes = false;
      while (i < value.length) {
          const token = value.charCodeAt(i++);
          switch (token) {
              case 40 /* OpenParen */:
                  parenDepth++;
                  break;
              case 41 /* CloseParen */:
                  parenDepth--;
                  break;
              case 39 /* QuoteSingle */:
                  // valueStart needs to be there since prop values don't
                  // have quotes in CSS
                  valueHasQuotes = valueHasQuotes || valueStart > 0;
                  if (quote === 0 /* QuoteNone */) {
                      quote = 39 /* QuoteSingle */;
                  }
                  else if (quote === 39 /* QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {
                      quote = 0 /* QuoteNone */;
                  }
                  break;
              case 34 /* QuoteDouble */:
                  // same logic as above
                  valueHasQuotes = valueHasQuotes || valueStart > 0;
                  if (quote === 0 /* QuoteNone */) {
                      quote = 34 /* QuoteDouble */;
                  }
                  else if (quote === 34 /* QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {
                      quote = 0 /* QuoteNone */;
                  }
                  break;
              case 58 /* Colon */:
                  if (!currentProp && parenDepth === 0 && quote === 0 /* QuoteNone */) {
                      currentProp = hyphenate(value.substring(propStart, i - 1).trim());
                      valueStart = i;
                  }
                  break;
              case 59 /* Semicolon */:
                  if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* QuoteNone */) {
                      const styleVal = value.substring(valueStart, i - 1).trim();
                      styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
                      propStart = i;
                      valueStart = 0;
                      currentProp = null;
                      valueHasQuotes = false;
                  }
                  break;
          }
      }
      if (currentProp && valueStart) {
          const styleVal = value.substr(valueStart).trim();
          styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
      }
      return styles;
  }
  function stripUnnecessaryQuotes(value) {
      const qS = value.charCodeAt(0);
      const qE = value.charCodeAt(value.length - 1);
      if (qS == qE && (qS == 39 /* QuoteSingle */ || qS == 34 /* QuoteDouble */)) {
          const tempValue = value.substring(1, value.length - 1);
          // special case to avoid using a multi-quoted string that was just chomped
          // (e.g. `font-family: "Verdana", "sans-serif"`)
          if (tempValue.indexOf('\'') == -1 && tempValue.indexOf('"') == -1) {
              value = tempValue;
          }
      }
      return value;
  }
  function hyphenate(value) {
      return value.replace(/[a-z][A-Z]/g, v => {
          return v.charAt(0) + '-' + v.charAt(1);
      }).toLowerCase();
  }

  /**
   * Produces creation/update instructions for all styling bindings (class and style)
   *
   * It also produces the creation instruction to register all initial styling values
   * (which are all the static class="..." and style="..." attribute values that exist
   * on an element within a template).
   *
   * The builder class below handles producing instructions for the following cases:
   *
   * - Static style/class attributes (style="..." and class="...")
   * - Dynamic style/class map bindings ([style]="map" and [class]="map|string")
   * - Dynamic style/class property bindings ([style.prop]="exp" and [class.name]="exp")
   *
   * Due to the complex relationship of all of these cases, the instructions generated
   * for these attributes/properties/bindings must be done so in the correct order. The
   * order which these must be generated is as follows:
   *
   * if (createMode) {
   *   elementStyling(...)
   * }
   * if (updateMode) {
   *   elementStylingMap(...)
   *   elementStyleProp(...)
   *   elementClassProp(...)
   *   elementStylingApp(...)
   * }
   *
   * The creation/update methods within the builder class produce these instructions.
   */
  class StylingBuilder {
      constructor(_elementIndexExpr, _directiveExpr) {
          this._elementIndexExpr = _elementIndexExpr;
          this._directiveExpr = _directiveExpr;
          /** Whether or not there are any static styling values present */
          this._hasInitialValues = false;
          /**
           *  Whether or not there are any styling bindings present
           *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)
           */
          this._hasBindings = false;
          /** the input for [class] (if it exists) */
          this._classMapInput = null;
          /** the input for [style] (if it exists) */
          this._styleMapInput = null;
          /** an array of each [style.prop] input */
          this._singleStyleInputs = null;
          /** an array of each [class.name] input */
          this._singleClassInputs = null;
          this._lastStylingInput = null;
          // maps are used instead of hash maps because a Map will
          // retain the ordering of the keys
          /**
           * Represents the location of each style binding in the template
           * (e.g. `<div [style.width]="w" [style.height]="h">` implies
           * that `width=0` and `height=1`)
           */
          this._stylesIndex = new Map();
          /**
           * Represents the location of each class binding in the template
           * (e.g. `<div [class.big]="b" [class.hidden]="h">` implies
           * that `big=0` and `hidden=1`)
           */
          this._classesIndex = new Map();
          this._initialStyleValues = [];
          this._initialClassValues = [];
          // certain style properties ALWAYS need sanitization
          // this is checked each time new styles are encountered
          this._useDefaultSanitizer = false;
      }
      hasBindingsOrInitialValues() { return this._hasBindings || this._hasInitialValues; }
      /**
       * Registers a given input to the styling builder to be later used when producing AOT code.
       *
       * The code below will only accept the input if it is somehow tied to styling (whether it be
       * style/class bindings or static style/class attributes).
       */
      registerBoundInput(input) {
          // [attr.style] or [attr.class] are skipped in the code below,
          // they should not be treated as styling-based bindings since
          // they are intended to be written directly to the attr and
          // will therefore skip all style/class resolution that is present
          // with style="", [style]="" and [style.prop]="", class="",
          // [class.prop]="". [class]="" assignments
          const name = input.name;
          let binding = null;
          switch (input.type) {
              case 0 /* Property */:
                  if (name == 'style') {
                      binding = this.registerStyleInput(null, input.value, '', input.sourceSpan);
                  }
                  else if (isClassBinding(input.name)) {
                      binding = this.registerClassInput(null, input.value, input.sourceSpan);
                  }
                  break;
              case 3 /* Style */:
                  binding = this.registerStyleInput(input.name, input.value, input.unit, input.sourceSpan);
                  break;
              case 2 /* Class */:
                  binding = this.registerClassInput(input.name, input.value, input.sourceSpan);
                  break;
          }
          return binding ? true : false;
      }
      registerStyleInput(propertyName, value, unit, sourceSpan) {
          const entry = { name: propertyName, unit, value, sourceSpan };
          if (propertyName) {
              (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
              this._useDefaultSanitizer = this._useDefaultSanitizer || isStyleSanitizable(propertyName);
              registerIntoMap(this._stylesIndex, propertyName);
          }
          else {
              this._useDefaultSanitizer = true;
              this._styleMapInput = entry;
          }
          this._lastStylingInput = entry;
          this._hasBindings = true;
          return entry;
      }
      registerClassInput(className, value, sourceSpan) {
          const entry = { name: className, value, sourceSpan };
          if (className) {
              (this._singleClassInputs = this._singleClassInputs || []).push(entry);
              registerIntoMap(this._classesIndex, className);
          }
          else {
              this._classMapInput = entry;
          }
          this._lastStylingInput = entry;
          this._hasBindings = true;
          return entry;
      }
      /**
       * Registers the element's static style string value to the builder.
       *
       * @param value the style string (e.g. `width:100px; height:200px;`)
       */
      registerStyleAttr(value) {
          this._initialStyleValues = parse(value);
          this._hasInitialValues = true;
      }
      /**
       * Registers the element's static class string value to the builder.
       *
       * @param value the className string (e.g. `disabled gold zoom`)
       */
      registerClassAttr(value) {
          this._initialClassValues = value.trim().split(/\s+/g);
          this._hasInitialValues = true;
      }
      /**
       * Appends all styling-related expressions to the provided attrs array.
       *
       * @param attrs an existing array where each of the styling expressions
       * will be inserted into.
       */
      populateInitialStylingAttrs(attrs) {
          // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]
          if (this._initialClassValues.length) {
              attrs.push(literal(1 /* Classes */));
              for (let i = 0; i < this._initialClassValues.length; i++) {
                  attrs.push(literal(this._initialClassValues[i]));
              }
          }
          // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]
          if (this._initialStyleValues.length) {
              attrs.push(literal(2 /* Styles */));
              for (let i = 0; i < this._initialStyleValues.length; i += 2) {
                  attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));
              }
          }
      }
      /**
       * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.
       *
       * The instruction generation code below is used for producing the AOT statement code which is
       * responsible for registering initial styles (within a directive hostBindings' creation block)
       * to the directive host element.
       */
      buildDirectiveHostAttrsInstruction(sourceSpan, constantPool) {
          if (this._hasInitialValues && this._directiveExpr) {
              return {
                  sourceSpan,
                  reference: Identifiers$1.elementHostAttrs,
                  buildParams: () => {
                      const attrs = [];
                      this.populateInitialStylingAttrs(attrs);
                      return [this._directiveExpr, getConstantLiteralFromArray(constantPool, attrs)];
                  }
              };
          }
          return null;
      }
      /**
       * Builds an instruction with all the expressions and parameters for `elementStyling`.
       *
       * The instruction generation code below is used for producing the AOT statement code which is
       * responsible for registering style/class bindings to an element.
       */
      buildElementStylingInstruction(sourceSpan, constantPool) {
          if (this._hasBindings) {
              return {
                  sourceSpan,
                  reference: Identifiers$1.elementStyling,
                  buildParams: () => {
                      // a string array of every style-based binding
                      const styleBindingProps = this._singleStyleInputs ? this._singleStyleInputs.map(i => literal(i.name)) : [];
                      // a string array of every class-based binding
                      const classBindingNames = this._singleClassInputs ? this._singleClassInputs.map(i => literal(i.name)) : [];
                      // to salvage space in the AOT generated code, there is no point in passing
                      // in `null` into a param if any follow-up params are not used. Therefore,
                      // only when a trailing param is used then it will be filled with nulls in between
                      // (otherwise a shorter amount of params will be filled). The code below helps
                      // determine how many params are required in the expression code.
                      //
                      // min params => elementStyling()
                      // max params => elementStyling(classBindings, styleBindings, sanitizer, directive)
                      let expectedNumberOfArgs = 0;
                      if (this._directiveExpr) {
                          expectedNumberOfArgs = 4;
                      }
                      else if (this._useDefaultSanitizer) {
                          expectedNumberOfArgs = 3;
                      }
                      else if (styleBindingProps.length) {
                          expectedNumberOfArgs = 2;
                      }
                      else if (classBindingNames.length) {
                          expectedNumberOfArgs = 1;
                      }
                      const params = [];
                      addParam(params, classBindingNames.length > 0, getConstantLiteralFromArray(constantPool, classBindingNames), 1, expectedNumberOfArgs);
                      addParam(params, styleBindingProps.length > 0, getConstantLiteralFromArray(constantPool, styleBindingProps), 2, expectedNumberOfArgs);
                      addParam(params, this._useDefaultSanitizer, importExpr(Identifiers$1.defaultStyleSanitizer), 3, expectedNumberOfArgs);
                      if (this._directiveExpr) {
                          params.push(this._directiveExpr);
                      }
                      return params;
                  }
              };
          }
          return null;
      }
      /**
       * Builds an instruction with all the expressions and parameters for `elementStylingMap`.
       *
       * The instruction data will contain all expressions for `elementStylingMap` to function
       * which include the `[style]` and `[class]` expression params (if they exist) as well as
       * the sanitizer and directive reference expression.
       */
      buildElementStylingMapInstruction(valueConverter) {
          if (this._classMapInput || this._styleMapInput) {
              const stylingInput = this._classMapInput || this._styleMapInput;
              // these values must be outside of the update block so that they can
              // be evaluted (the AST visit call) during creation time so that any
              // pipes can be picked up in time before the template is built
              const mapBasedClassValue = this._classMapInput ? this._classMapInput.value.visit(valueConverter) : null;
              const mapBasedStyleValue = this._styleMapInput ? this._styleMapInput.value.visit(valueConverter) : null;
              return {
                  sourceSpan: stylingInput.sourceSpan,
                  reference: Identifiers$1.elementStylingMap,
                  buildParams: (convertFn) => {
                      const params = [this._elementIndexExpr];
                      if (mapBasedClassValue) {
                          params.push(convertFn(mapBasedClassValue));
                      }
                      else if (this._styleMapInput) {
                          params.push(NULL_EXPR);
                      }
                      if (mapBasedStyleValue) {
                          params.push(convertFn(mapBasedStyleValue));
                      }
                      else if (this._directiveExpr) {
                          params.push(NULL_EXPR);
                      }
                      if (this._directiveExpr) {
                          params.push(this._directiveExpr);
                      }
                      return params;
                  }
              };
          }
          return null;
      }
      _buildSingleInputs(reference, inputs, mapIndex, allowUnits, valueConverter) {
          return inputs.map(input => {
              const bindingIndex = mapIndex.get(input.name);
              const value = input.value.visit(valueConverter);
              return {
                  sourceSpan: input.sourceSpan,
                  reference,
                  buildParams: (convertFn) => {
                      const params = [this._elementIndexExpr, literal(bindingIndex), convertFn(value)];
                      if (allowUnits) {
                          if (input.unit) {
                              params.push(literal(input.unit));
                          }
                          else if (this._directiveExpr) {
                              params.push(NULL_EXPR);
                          }
                      }
                      if (this._directiveExpr) {
                          params.push(this._directiveExpr);
                      }
                      return params;
                  }
              };
          });
      }
      _buildClassInputs(valueConverter) {
          if (this._singleClassInputs) {
              return this._buildSingleInputs(Identifiers$1.elementClassProp, this._singleClassInputs, this._classesIndex, false, valueConverter);
          }
          return [];
      }
      _buildStyleInputs(valueConverter) {
          if (this._singleStyleInputs) {
              return this._buildSingleInputs(Identifiers$1.elementStyleProp, this._singleStyleInputs, this._stylesIndex, true, valueConverter);
          }
          return [];
      }
      _buildApplyFn() {
          return {
              sourceSpan: this._lastStylingInput ? this._lastStylingInput.sourceSpan : null,
              reference: Identifiers$1.elementStylingApply,
              buildParams: () => {
                  const params = [this._elementIndexExpr];
                  if (this._directiveExpr) {
                      params.push(this._directiveExpr);
                  }
                  return params;
              }
          };
      }
      /**
       * Constructs all instructions which contain the expressions that will be placed
       * into the update block of a template function or a directive hostBindings function.
       */
      buildUpdateLevelInstructions(valueConverter) {
          const instructions = [];
          if (this._hasBindings) {
              const mapInstruction = this.buildElementStylingMapInstruction(valueConverter);
              if (mapInstruction) {
                  instructions.push(mapInstruction);
              }
              instructions.push(...this._buildStyleInputs(valueConverter));
              instructions.push(...this._buildClassInputs(valueConverter));
              instructions.push(this._buildApplyFn());
          }
          return instructions;
      }
  }
  function isClassBinding(name) {
      return name == 'className' || name == 'class';
  }
  function registerIntoMap(map, key) {
      if (!map.has(key)) {
          map.set(key, map.size);
      }
  }
  function isStyleSanitizable(prop) {
      return prop === 'background-image' || prop === 'background' || prop === 'border-image' ||
          prop === 'filter' || prop === 'list-style' || prop === 'list-style-image';
  }
  /**
   * Simple helper function to either provide the constant literal that will house the value
   * here or a null value if the provided values are empty.
   */
  function getConstantLiteralFromArray(constantPool, values) {
      return values.length ? constantPool.getConstLiteral(literalArr(values), true) : NULL_EXPR;
  }
  /**
   * Simple helper function that adds a parameter or does nothing at all depending on the provided
   * predicate and totalExpectedArgs values
   */
  function addParam(params, predicate, value, argNumber, totalExpectedArgs) {
      if (predicate) {
          params.push(value);
      }
      else if (argNumber < totalExpectedArgs) {
          params.push(NULL_EXPR);
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TokenType;
  (function (TokenType) {
      TokenType[TokenType["Character"] = 0] = "Character";
      TokenType[TokenType["Identifier"] = 1] = "Identifier";
      TokenType[TokenType["Keyword"] = 2] = "Keyword";
      TokenType[TokenType["String"] = 3] = "String";
      TokenType[TokenType["Operator"] = 4] = "Operator";
      TokenType[TokenType["Number"] = 5] = "Number";
      TokenType[TokenType["Error"] = 6] = "Error";
  })(TokenType || (TokenType = {}));
  const KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];
  class Lexer {
      tokenize(text) {
          const scanner = new _Scanner(text);
          const tokens = [];
          let token = scanner.scanToken();
          while (token != null) {
              tokens.push(token);
              token = scanner.scanToken();
          }
          return tokens;
      }
  }
  class Token {
      constructor(index, type, numValue, strValue) {
          this.index = index;
          this.type = type;
          this.numValue = numValue;
          this.strValue = strValue;
      }
      isCharacter(code) {
          return this.type == TokenType.Character && this.numValue == code;
      }
      isNumber() { return this.type == TokenType.Number; }
      isString() { return this.type == TokenType.String; }
      isOperator(operator) {
          return this.type == TokenType.Operator && this.strValue == operator;
      }
      isIdentifier() { return this.type == TokenType.Identifier; }
      isKeyword() { return this.type == TokenType.Keyword; }
      isKeywordLet() { return this.type == TokenType.Keyword && this.strValue == 'let'; }
      isKeywordAs() { return this.type == TokenType.Keyword && this.strValue == 'as'; }
      isKeywordNull() { return this.type == TokenType.Keyword && this.strValue == 'null'; }
      isKeywordUndefined() {
          return this.type == TokenType.Keyword && this.strValue == 'undefined';
      }
      isKeywordTrue() { return this.type == TokenType.Keyword && this.strValue == 'true'; }
      isKeywordFalse() { return this.type == TokenType.Keyword && this.strValue == 'false'; }
      isKeywordThis() { return this.type == TokenType.Keyword && this.strValue == 'this'; }
      isError() { return this.type == TokenType.Error; }
      toNumber() { return this.type == TokenType.Number ? this.numValue : -1; }
      toString() {
          switch (this.type) {
              case TokenType.Character:
              case TokenType.Identifier:
              case TokenType.Keyword:
              case TokenType.Operator:
              case TokenType.String:
              case TokenType.Error:
                  return this.strValue;
              case TokenType.Number:
                  return this.numValue.toString();
              default:
                  return null;
          }
      }
  }
  function newCharacterToken(index, code) {
      return new Token(index, TokenType.Character, code, String.fromCharCode(code));
  }
  function newIdentifierToken(index, text) {
      return new Token(index, TokenType.Identifier, 0, text);
  }
  function newKeywordToken(index, text) {
      return new Token(index, TokenType.Keyword, 0, text);
  }
  function newOperatorToken(index, text) {
      return new Token(index, TokenType.Operator, 0, text);
  }
  function newStringToken(index, text) {
      return new Token(index, TokenType.String, 0, text);
  }
  function newNumberToken(index, n) {
      return new Token(index, TokenType.Number, n, '');
  }
  function newErrorToken(index, message) {
      return new Token(index, TokenType.Error, 0, message);
  }
  const EOF = new Token(-1, TokenType.Character, 0, '');
  class _Scanner {
      constructor(input) {
          this.input = input;
          this.peek = 0;
          this.index = -1;
          this.length = input.length;
          this.advance();
      }
      advance() {
          this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
      }
      scanToken() {
          const input = this.input, length = this.length;
          let peek = this.peek, index = this.index;
          // Skip whitespace.
          while (peek <= $SPACE) {
              if (++index >= length) {
                  peek = $EOF;
                  break;
              }
              else {
                  peek = input.charCodeAt(index);
              }
          }
          this.peek = peek;
          this.index = index;
          if (index >= length) {
              return null;
          }
          // Handle identifiers and numbers.
          if (isIdentifierStart(peek))
              return this.scanIdentifier();
          if (isDigit(peek))
              return this.scanNumber(index);
          const start = index;
          switch (peek) {
              case $PERIOD:
                  this.advance();
                  return isDigit(this.peek) ? this.scanNumber(start) :
                      newCharacterToken(start, $PERIOD);
              case $LPAREN:
              case $RPAREN:
              case $LBRACE:
              case $RBRACE:
              case $LBRACKET:
              case $RBRACKET:
              case $COMMA:
              case $COLON:
              case $SEMICOLON:
                  return this.scanCharacter(start, peek);
              case $SQ:
              case $DQ:
                  return this.scanString();
              case $HASH:
              case $PLUS:
              case $MINUS:
              case $STAR:
              case $SLASH:
              case $PERCENT:
              case $CARET:
                  return this.scanOperator(start, String.fromCharCode(peek));
              case $QUESTION:
                  return this.scanComplexOperator(start, '?', $PERIOD, '.');
              case $LT:
              case $GT:
                  return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');
              case $BANG:
              case $EQ:
                  return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');
              case $AMPERSAND:
                  return this.scanComplexOperator(start, '&', $AMPERSAND, '&');
              case $BAR:
                  return this.scanComplexOperator(start, '|', $BAR, '|');
              case $NBSP:
                  while (isWhitespace(this.peek))
                      this.advance();
                  return this.scanToken();
          }
          this.advance();
          return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);
      }
      scanCharacter(start, code) {
          this.advance();
          return newCharacterToken(start, code);
      }
      scanOperator(start, str) {
          this.advance();
          return newOperatorToken(start, str);
      }
      /**
       * Tokenize a 2/3 char long operator
       *
       * @param start start index in the expression
       * @param one first symbol (always part of the operator)
       * @param twoCode code point for the second symbol
       * @param two second symbol (part of the operator when the second code point matches)
       * @param threeCode code point for the third symbol
       * @param three third symbol (part of the operator when provided and matches source expression)
       */
      scanComplexOperator(start, one, twoCode, two, threeCode, three) {
          this.advance();
          let str = one;
          if (this.peek == twoCode) {
              this.advance();
              str += two;
          }
          if (threeCode != null && this.peek == threeCode) {
              this.advance();
              str += three;
          }
          return newOperatorToken(start, str);
      }
      scanIdentifier() {
          const start = this.index;
          this.advance();
          while (isIdentifierPart(this.peek))
              this.advance();
          const str = this.input.substring(start, this.index);
          return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :
              newIdentifierToken(start, str);
      }
      scanNumber(start) {
          let simple = (this.index === start);
          this.advance(); // Skip initial digit.
          while (true) {
              if (isDigit(this.peek)) ;
              else if (this.peek == $PERIOD) {
                  simple = false;
              }
              else if (isExponentStart(this.peek)) {
                  this.advance();
                  if (isExponentSign(this.peek))
                      this.advance();
                  if (!isDigit(this.peek))
                      return this.error('Invalid exponent', -1);
                  simple = false;
              }
              else {
                  break;
              }
              this.advance();
          }
          const str = this.input.substring(start, this.index);
          const value = simple ? parseIntAutoRadix(str) : parseFloat(str);
          return newNumberToken(start, value);
      }
      scanString() {
          const start = this.index;
          const quote = this.peek;
          this.advance(); // Skip initial quote.
          let buffer = '';
          let marker = this.index;
          const input = this.input;
          while (this.peek != quote) {
              if (this.peek == $BACKSLASH) {
                  buffer += input.substring(marker, this.index);
                  this.advance();
                  let unescapedCode;
                  // Workaround for TS2.1-introduced type strictness
                  this.peek = this.peek;
                  if (this.peek == $u) {
                      // 4 character hex code for unicode character.
                      const hex = input.substring(this.index + 1, this.index + 5);
                      if (/^[0-9a-f]+$/i.test(hex)) {
                          unescapedCode = parseInt(hex, 16);
                      }
                      else {
                          return this.error(`Invalid unicode escape [\\u${hex}]`, 0);
                      }
                      for (let i = 0; i < 5; i++) {
                          this.advance();
                      }
                  }
                  else {
                      unescapedCode = unescape(this.peek);
                      this.advance();
                  }
                  buffer += String.fromCharCode(unescapedCode);
                  marker = this.index;
              }
              else if (this.peek == $EOF) {
                  return this.error('Unterminated quote', 0);
              }
              else {
                  this.advance();
              }
          }
          const last = input.substring(marker, this.index);
          this.advance(); // Skip terminating quote.
          return newStringToken(start, buffer + last);
      }
      error(message, offset) {
          const position = this.index + offset;
          return newErrorToken(position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);
      }
  }
  function isIdentifierStart(code) {
      return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||
          (code == $_) || (code == $$);
  }
  function isIdentifier(input) {
      if (input.length == 0)
          return false;
      const scanner = new _Scanner(input);
      if (!isIdentifierStart(scanner.peek))
          return false;
      scanner.advance();
      while (scanner.peek !== $EOF) {
          if (!isIdentifierPart(scanner.peek))
              return false;
          scanner.advance();
      }
      return true;
  }
  function isIdentifierPart(code) {
      return isAsciiLetter(code) || isDigit(code) || (code == $_) ||
          (code == $$);
  }
  function isExponentStart(code) {
      return code == $e || code == $E;
  }
  function isExponentSign(code) {
      return code == $MINUS || code == $PLUS;
  }
  function isQuote(code) {
      return code === $SQ || code === $DQ || code === $BT;
  }
  function unescape(code) {
      switch (code) {
          case $n:
              return $LF;
          case $f:
              return $FF;
          case $r:
              return $CR;
          case $t:
              return $TAB;
          case $v:
              return $VTAB;
          default:
              return code;
      }
  }
  function parseIntAutoRadix(text) {
      const result = parseInt(text);
      if (isNaN(result)) {
          throw new Error('Invalid integer literal when parsing ' + text);
      }
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class SplitInterpolation {
      constructor(strings, expressions, offsets) {
          this.strings = strings;
          this.expressions = expressions;
          this.offsets = offsets;
      }
  }
  class TemplateBindingParseResult {
      constructor(templateBindings, warnings, errors) {
          this.templateBindings = templateBindings;
          this.warnings = warnings;
          this.errors = errors;
      }
  }
  function _createInterpolateRegExp(config) {
      const pattern = escapeRegExp(config.start) + '([\\s\\S]*?)' + escapeRegExp(config.end);
      return new RegExp(pattern, 'g');
  }
  class Parser {
      constructor(_lexer) {
          this._lexer = _lexer;
          this.errors = [];
      }
      parseAction(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
          this._checkNoInterpolation(input, location, interpolationConfig);
          const sourceToLex = this._stripComments(input);
          const tokens = this._lexer.tokenize(this._stripComments(input));
          const ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)
              .parseChain();
          return new ASTWithSource(ast, input, location, this.errors);
      }
      parseBinding(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
          const ast = this._parseBindingAst(input, location, interpolationConfig);
          return new ASTWithSource(ast, input, location, this.errors);
      }
      parseSimpleBinding(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
          const ast = this._parseBindingAst(input, location, interpolationConfig);
          const errors = SimpleExpressionChecker.check(ast);
          if (errors.length > 0) {
              this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);
          }
          return new ASTWithSource(ast, input, location, this.errors);
      }
      _reportError(message, input, errLocation, ctxLocation) {
          this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
      }
      _parseBindingAst(input, location, interpolationConfig) {
          // Quotes expressions use 3rd-party expression language. We don't want to use
          // our lexer or parser for that, so we check for that ahead of time.
          const quote = this._parseQuote(input, location);
          if (quote != null) {
              return quote;
          }
          this._checkNoInterpolation(input, location, interpolationConfig);
          const sourceToLex = this._stripComments(input);
          const tokens = this._lexer.tokenize(sourceToLex);
          return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)
              .parseChain();
      }
      _parseQuote(input, location) {
          if (input == null)
              return null;
          const prefixSeparatorIndex = input.indexOf(':');
          if (prefixSeparatorIndex == -1)
              return null;
          const prefix = input.substring(0, prefixSeparatorIndex).trim();
          if (!isIdentifier(prefix))
              return null;
          const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);
          return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);
      }
      parseTemplateBindings(tplKey, tplValue, location) {
          const tokens = this._lexer.tokenize(tplValue);
          return new _ParseAST(tplValue, location, tokens, tplValue.length, false, this.errors, 0)
              .parseTemplateBindings(tplKey);
      }
      parseInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
          const split = this.splitInterpolation(input, location, interpolationConfig);
          if (split == null)
              return null;
          const expressions = [];
          for (let i = 0; i < split.expressions.length; ++i) {
              const expressionText = split.expressions[i];
              const sourceToLex = this._stripComments(expressionText);
              const tokens = this._lexer.tokenize(sourceToLex);
              const ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))
                  .parseChain();
              expressions.push(ast);
          }
          return new ASTWithSource(new Interpolation(new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions), input, location, this.errors);
      }
      splitInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
          const regexp = _createInterpolateRegExp(interpolationConfig);
          const parts = input.split(regexp);
          if (parts.length <= 1) {
              return null;
          }
          const strings = [];
          const expressions = [];
          const offsets = [];
          let offset = 0;
          for (let i = 0; i < parts.length; i++) {
              const part = parts[i];
              if (i % 2 === 0) {
                  // fixed string
                  strings.push(part);
                  offset += part.length;
              }
              else if (part.trim().length > 0) {
                  offset += interpolationConfig.start.length;
                  expressions.push(part);
                  offsets.push(offset);
                  offset += part.length + interpolationConfig.end.length;
              }
              else {
                  this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`, location);
                  expressions.push('$implict');
                  offsets.push(offset);
              }
          }
          return new SplitInterpolation(strings, expressions, offsets);
      }
      wrapLiteralPrimitive(input, location) {
          return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input, location, this.errors);
      }
      _stripComments(input) {
          const i = this._commentStart(input);
          return i != null ? input.substring(0, i).trim() : input;
      }
      _commentStart(input) {
          let outerQuote = null;
          for (let i = 0; i < input.length - 1; i++) {
              const char = input.charCodeAt(i);
              const nextChar = input.charCodeAt(i + 1);
              if (char === $SLASH && nextChar == $SLASH && outerQuote == null)
                  return i;
              if (outerQuote === char) {
                  outerQuote = null;
              }
              else if (outerQuote == null && isQuote(char)) {
                  outerQuote = char;
              }
          }
          return null;
      }
      _checkNoInterpolation(input, location, interpolationConfig) {
          const regexp = _createInterpolateRegExp(interpolationConfig);
          const parts = input.split(regexp);
          if (parts.length > 1) {
              this._reportError(`Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`, input, `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`, location);
          }
      }
      _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig) {
          let errLocation = '';
          for (let j = 0; j < partInErrIdx; j++) {
              errLocation += j % 2 === 0 ?
                  parts[j] :
                  `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;
          }
          return errLocation.length;
      }
  }
  class _ParseAST {
      constructor(input, location, tokens, inputLength, parseAction, errors, offset) {
          this.input = input;
          this.location = location;
          this.tokens = tokens;
          this.inputLength = inputLength;
          this.parseAction = parseAction;
          this.errors = errors;
          this.offset = offset;
          this.rparensExpected = 0;
          this.rbracketsExpected = 0;
          this.rbracesExpected = 0;
          this.index = 0;
      }
      peek(offset) {
          const i = this.index + offset;
          return i < this.tokens.length ? this.tokens[i] : EOF;
      }
      get next() { return this.peek(0); }
      get inputIndex() {
          return (this.index < this.tokens.length) ? this.next.index + this.offset :
              this.inputLength + this.offset;
      }
      span(start) { return new ParseSpan(start, this.inputIndex); }
      advance() { this.index++; }
      optionalCharacter(code) {
          if (this.next.isCharacter(code)) {
              this.advance();
              return true;
          }
          else {
              return false;
          }
      }
      peekKeywordLet() { return this.next.isKeywordLet(); }
      peekKeywordAs() { return this.next.isKeywordAs(); }
      expectCharacter(code) {
          if (this.optionalCharacter(code))
              return;
          this.error(`Missing expected ${String.fromCharCode(code)}`);
      }
      optionalOperator(op) {
          if (this.next.isOperator(op)) {
              this.advance();
              return true;
          }
          else {
              return false;
          }
      }
      expectOperator(operator) {
          if (this.optionalOperator(operator))
              return;
          this.error(`Missing expected operator ${operator}`);
      }
      expectIdentifierOrKeyword() {
          const n = this.next;
          if (!n.isIdentifier() && !n.isKeyword()) {
              this.error(`Unexpected token ${n}, expected identifier or keyword`);
              return '';
          }
          this.advance();
          return n.toString();
      }
      expectIdentifierOrKeywordOrString() {
          const n = this.next;
          if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
              this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);
              return '';
          }
          this.advance();
          return n.toString();
      }
      parseChain() {
          const exprs = [];
          const start = this.inputIndex;
          while (this.index < this.tokens.length) {
              const expr = this.parsePipe();
              exprs.push(expr);
              if (this.optionalCharacter($SEMICOLON)) {
                  if (!this.parseAction) {
                      this.error('Binding expression cannot contain chained expression');
                  }
                  while (this.optionalCharacter($SEMICOLON)) {
                  } // read all semicolons
              }
              else if (this.index < this.tokens.length) {
                  this.error(`Unexpected token '${this.next}'`);
              }
          }
          if (exprs.length == 0)
              return new EmptyExpr(this.span(start));
          if (exprs.length == 1)
              return exprs[0];
          return new Chain(this.span(start), exprs);
      }
      parsePipe() {
          let result = this.parseExpression();
          if (this.optionalOperator('|')) {
              if (this.parseAction) {
                  this.error('Cannot have a pipe in an action expression');
              }
              do {
                  const name = this.expectIdentifierOrKeyword();
                  const args = [];
                  while (this.optionalCharacter($COLON)) {
                      args.push(this.parseExpression());
                  }
                  result = new BindingPipe(this.span(result.span.start), result, name, args);
              } while (this.optionalOperator('|'));
          }
          return result;
      }
      parseExpression() { return this.parseConditional(); }
      parseConditional() {
          const start = this.inputIndex;
          const result = this.parseLogicalOr();
          if (this.optionalOperator('?')) {
              const yes = this.parsePipe();
              let no;
              if (!this.optionalCharacter($COLON)) {
                  const end = this.inputIndex;
                  const expression = this.input.substring(start, end);
                  this.error(`Conditional expression ${expression} requires all 3 expressions`);
                  no = new EmptyExpr(this.span(start));
              }
              else {
                  no = this.parsePipe();
              }
              return new Conditional(this.span(start), result, yes, no);
          }
          else {
              return result;
          }
      }
      parseLogicalOr() {
          // '||'
          let result = this.parseLogicalAnd();
          while (this.optionalOperator('||')) {
              const right = this.parseLogicalAnd();
              result = new Binary(this.span(result.span.start), '||', result, right);
          }
          return result;
      }
      parseLogicalAnd() {
          // '&&'
          let result = this.parseEquality();
          while (this.optionalOperator('&&')) {
              const right = this.parseEquality();
              result = new Binary(this.span(result.span.start), '&&', result, right);
          }
          return result;
      }
      parseEquality() {
          // '==','!=','===','!=='
          let result = this.parseRelational();
          while (this.next.type == TokenType.Operator) {
              const operator = this.next.strValue;
              switch (operator) {
                  case '==':
                  case '===':
                  case '!=':
                  case '!==':
                      this.advance();
                      const right = this.parseRelational();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      }
      parseRelational() {
          // '<', '>', '<=', '>='
          let result = this.parseAdditive();
          while (this.next.type == TokenType.Operator) {
              const operator = this.next.strValue;
              switch (operator) {
                  case '<':
                  case '>':
                  case '<=':
                  case '>=':
                      this.advance();
                      const right = this.parseAdditive();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      }
      parseAdditive() {
          // '+', '-'
          let result = this.parseMultiplicative();
          while (this.next.type == TokenType.Operator) {
              const operator = this.next.strValue;
              switch (operator) {
                  case '+':
                  case '-':
                      this.advance();
                      let right = this.parseMultiplicative();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      }
      parseMultiplicative() {
          // '*', '%', '/'
          let result = this.parsePrefix();
          while (this.next.type == TokenType.Operator) {
              const operator = this.next.strValue;
              switch (operator) {
                  case '*':
                  case '%':
                  case '/':
                      this.advance();
                      let right = this.parsePrefix();
                      result = new Binary(this.span(result.span.start), operator, result, right);
                      continue;
              }
              break;
          }
          return result;
      }
      parsePrefix() {
          if (this.next.type == TokenType.Operator) {
              const start = this.inputIndex;
              const operator = this.next.strValue;
              let result;
              switch (operator) {
                  case '+':
                      this.advance();
                      result = this.parsePrefix();
                      return new Binary(this.span(start), '-', result, new LiteralPrimitive(new ParseSpan(start, start), 0));
                  case '-':
                      this.advance();
                      result = this.parsePrefix();
                      return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);
                  case '!':
                      this.advance();
                      result = this.parsePrefix();
                      return new PrefixNot(this.span(start), result);
              }
          }
          return this.parseCallChain();
      }
      parseCallChain() {
          let result = this.parsePrimary();
          while (true) {
              if (this.optionalCharacter($PERIOD)) {
                  result = this.parseAccessMemberOrMethodCall(result, false);
              }
              else if (this.optionalOperator('?.')) {
                  result = this.parseAccessMemberOrMethodCall(result, true);
              }
              else if (this.optionalCharacter($LBRACKET)) {
                  this.rbracketsExpected++;
                  const key = this.parsePipe();
                  this.rbracketsExpected--;
                  this.expectCharacter($RBRACKET);
                  if (this.optionalOperator('=')) {
                      const value = this.parseConditional();
                      result = new KeyedWrite(this.span(result.span.start), result, key, value);
                  }
                  else {
                      result = new KeyedRead(this.span(result.span.start), result, key);
                  }
              }
              else if (this.optionalCharacter($LPAREN)) {
                  this.rparensExpected++;
                  const args = this.parseCallArguments();
                  this.rparensExpected--;
                  this.expectCharacter($RPAREN);
                  result = new FunctionCall(this.span(result.span.start), result, args);
              }
              else if (this.optionalOperator('!')) {
                  result = new NonNullAssert(this.span(result.span.start), result);
              }
              else {
                  return result;
              }
          }
      }
      parsePrimary() {
          const start = this.inputIndex;
          if (this.optionalCharacter($LPAREN)) {
              this.rparensExpected++;
              const result = this.parsePipe();
              this.rparensExpected--;
              this.expectCharacter($RPAREN);
              return result;
          }
          else if (this.next.isKeywordNull()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), null);
          }
          else if (this.next.isKeywordUndefined()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), void 0);
          }
          else if (this.next.isKeywordTrue()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), true);
          }
          else if (this.next.isKeywordFalse()) {
              this.advance();
              return new LiteralPrimitive(this.span(start), false);
          }
          else if (this.next.isKeywordThis()) {
              this.advance();
              return new ImplicitReceiver(this.span(start));
          }
          else if (this.optionalCharacter($LBRACKET)) {
              this.rbracketsExpected++;
              const elements = this.parseExpressionList($RBRACKET);
              this.rbracketsExpected--;
              this.expectCharacter($RBRACKET);
              return new LiteralArray(this.span(start), elements);
          }
          else if (this.next.isCharacter($LBRACE)) {
              return this.parseLiteralMap();
          }
          else if (this.next.isIdentifier()) {
              return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);
          }
          else if (this.next.isNumber()) {
              const value = this.next.toNumber();
              this.advance();
              return new LiteralPrimitive(this.span(start), value);
          }
          else if (this.next.isString()) {
              const literalValue = this.next.toString();
              this.advance();
              return new LiteralPrimitive(this.span(start), literalValue);
          }
          else if (this.index >= this.tokens.length) {
              this.error(`Unexpected end of expression: ${this.input}`);
              return new EmptyExpr(this.span(start));
          }
          else {
              this.error(`Unexpected token ${this.next}`);
              return new EmptyExpr(this.span(start));
          }
      }
      parseExpressionList(terminator) {
          const result = [];
          if (!this.next.isCharacter(terminator)) {
              do {
                  result.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
          }
          return result;
      }
      parseLiteralMap() {
          const keys = [];
          const values = [];
          const start = this.inputIndex;
          this.expectCharacter($LBRACE);
          if (!this.optionalCharacter($RBRACE)) {
              this.rbracesExpected++;
              do {
                  const quoted = this.next.isString();
                  const key = this.expectIdentifierOrKeywordOrString();
                  keys.push({ key, quoted });
                  this.expectCharacter($COLON);
                  values.push(this.parsePipe());
              } while (this.optionalCharacter($COMMA));
              this.rbracesExpected--;
              this.expectCharacter($RBRACE);
          }
          return new LiteralMap(this.span(start), keys, values);
      }
      parseAccessMemberOrMethodCall(receiver, isSafe = false) {
          const start = receiver.span.start;
          const id = this.expectIdentifierOrKeyword();
          if (this.optionalCharacter($LPAREN)) {
              this.rparensExpected++;
              const args = this.parseCallArguments();
              this.expectCharacter($RPAREN);
              this.rparensExpected--;
              const span = this.span(start);
              return isSafe ? new SafeMethodCall(span, receiver, id, args) :
                  new MethodCall(span, receiver, id, args);
          }
          else {
              if (isSafe) {
                  if (this.optionalOperator('=')) {
                      this.error('The \'?.\' operator cannot be used in the assignment');
                      return new EmptyExpr(this.span(start));
                  }
                  else {
                      return new SafePropertyRead(this.span(start), receiver, id);
                  }
              }
              else {
                  if (this.optionalOperator('=')) {
                      if (!this.parseAction) {
                          this.error('Bindings cannot contain assignments');
                          return new EmptyExpr(this.span(start));
                      }
                      const value = this.parseConditional();
                      return new PropertyWrite(this.span(start), receiver, id, value);
                  }
                  else {
                      return new PropertyRead(this.span(start), receiver, id);
                  }
              }
          }
      }
      parseCallArguments() {
          if (this.next.isCharacter($RPAREN))
              return [];
          const positionals = [];
          do {
              positionals.push(this.parsePipe());
          } while (this.optionalCharacter($COMMA));
          return positionals;
      }
      /**
       * An identifier, a keyword, a string with an optional `-` in between.
       */
      expectTemplateBindingKey() {
          let result = '';
          let operatorFound = false;
          do {
              result += this.expectIdentifierOrKeywordOrString();
              operatorFound = this.optionalOperator('-');
              if (operatorFound) {
                  result += '-';
              }
          } while (operatorFound);
          return result.toString();
      }
      // Parses the AST for `<some-tag *tplKey=AST>`
      parseTemplateBindings(tplKey) {
          let firstBinding = true;
          const bindings = [];
          const warnings = [];
          do {
              const start = this.inputIndex;
              let rawKey;
              let key;
              let isVar = false;
              if (firstBinding) {
                  rawKey = key = tplKey;
                  firstBinding = false;
              }
              else {
                  isVar = this.peekKeywordLet();
                  if (isVar)
                      this.advance();
                  rawKey = this.expectTemplateBindingKey();
                  key = isVar ? rawKey : tplKey + rawKey[0].toUpperCase() + rawKey.substring(1);
                  this.optionalCharacter($COLON);
              }
              let name = null;
              let expression = null;
              if (isVar) {
                  if (this.optionalOperator('=')) {
                      name = this.expectTemplateBindingKey();
                  }
                  else {
                      name = '\$implicit';
                  }
              }
              else if (this.peekKeywordAs()) {
                  this.advance(); // consume `as`
                  name = rawKey;
                  key = this.expectTemplateBindingKey(); // read local var name
                  isVar = true;
              }
              else if (this.next !== EOF && !this.peekKeywordLet()) {
                  const start = this.inputIndex;
                  const ast = this.parsePipe();
                  const source = this.input.substring(start - this.offset, this.inputIndex - this.offset);
                  expression = new ASTWithSource(ast, source, this.location, this.errors);
              }
              bindings.push(new TemplateBinding(this.span(start), key, isVar, name, expression));
              if (this.peekKeywordAs() && !isVar) {
                  const letStart = this.inputIndex;
                  this.advance(); // consume `as`
                  const letName = this.expectTemplateBindingKey(); // read local var name
                  bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null));
              }
              if (!this.optionalCharacter($SEMICOLON)) {
                  this.optionalCharacter($COMMA);
              }
          } while (this.index < this.tokens.length);
          return new TemplateBindingParseResult(bindings, warnings, this.errors);
      }
      error(message, index = null) {
          this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
          this.skip();
      }
      locationText(index = null) {
          if (index == null)
              index = this.index;
          return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :
              `at the end of the expression`;
      }
      // Error recovery should skip tokens until it encounters a recovery point. skip() treats
      // the end of input and a ';' as unconditionally a recovery point. It also treats ')',
      // '}' and ']' as conditional recovery points if one of calling productions is expecting
      // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing
      // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because
      // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols
      // must be conditional as they must be skipped if none of the calling productions are not
      // expecting the closing token else we will never make progress in the case of an
      // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because
      // parseChain() is always the root production and it expects a ';'.
      // If a production expects one of these token it increments the corresponding nesting count,
      // and then decrements it just prior to checking if the token is in the input.
      skip() {
          let n = this.next;
          while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&
              (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&
              (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&
              (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {
              if (this.next.isError()) {
                  this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
              }
              this.advance();
              n = this.next;
          }
      }
  }
  class SimpleExpressionChecker {
      constructor() {
          this.errors = [];
      }
      static check(ast) {
          const s = new SimpleExpressionChecker();
          ast.visit(s);
          return s.errors;
      }
      visitImplicitReceiver(ast, context) { }
      visitInterpolation(ast, context) { }
      visitLiteralPrimitive(ast, context) { }
      visitPropertyRead(ast, context) { }
      visitPropertyWrite(ast, context) { }
      visitSafePropertyRead(ast, context) { }
      visitMethodCall(ast, context) { }
      visitSafeMethodCall(ast, context) { }
      visitFunctionCall(ast, context) { }
      visitLiteralArray(ast, context) { this.visitAll(ast.expressions); }
      visitLiteralMap(ast, context) { this.visitAll(ast.values); }
      visitBinary(ast, context) { }
      visitPrefixNot(ast, context) { }
      visitNonNullAssert(ast, context) { }
      visitConditional(ast, context) { }
      visitPipe(ast, context) { this.errors.push('pipes'); }
      visitKeyedRead(ast, context) { }
      visitKeyedWrite(ast, context) { }
      visitAll(asts) { return asts.map(node => node.visit(this)); }
      visitChain(ast, context) { }
      visitQuote(ast, context) { }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class Text$2 {
      constructor(value, sourceSpan, i18n) {
          this.value = value;
          this.sourceSpan = sourceSpan;
          this.i18n = i18n;
      }
      visit(visitor, context) { return visitor.visitText(this, context); }
  }
  class Expansion {
      constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
          this.switchValue = switchValue;
          this.type = type;
          this.cases = cases;
          this.sourceSpan = sourceSpan;
          this.switchValueSourceSpan = switchValueSourceSpan;
          this.i18n = i18n;
      }
      visit(visitor, context) { return visitor.visitExpansion(this, context); }
  }
  class ExpansionCase {
      constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
          this.value = value;
          this.expression = expression;
          this.sourceSpan = sourceSpan;
          this.valueSourceSpan = valueSourceSpan;
          this.expSourceSpan = expSourceSpan;
      }
      visit(visitor, context) { return visitor.visitExpansionCase(this, context); }
  }
  class Attribute {
      constructor(name, value, sourceSpan, valueSpan, i18n) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
          this.valueSpan = valueSpan;
          this.i18n = i18n;
      }
      visit(visitor, context) { return visitor.visitAttribute(this, context); }
  }
  class Element$1 {
      constructor(name, attrs, children, sourceSpan, startSourceSpan = null, endSourceSpan = null, i18n) {
          this.name = name;
          this.attrs = attrs;
          this.children = children;
          this.sourceSpan = sourceSpan;
          this.startSourceSpan = startSourceSpan;
          this.endSourceSpan = endSourceSpan;
          this.i18n = i18n;
      }
      visit(visitor, context) { return visitor.visitElement(this, context); }
  }
  class Comment {
      constructor(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitComment(this, context); }
  }
  function visitAll(visitor, nodes, context = null) {
      const result = [];
      const visit = visitor.visit ?
          (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :
          (ast) => ast.visit(visitor, context);
      nodes.forEach(ast => {
          const astResult = visit(ast);
          if (astResult) {
              result.push(astResult);
          }
      });
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TokenType$1;
  (function (TokenType) {
      TokenType[TokenType["TAG_OPEN_START"] = 0] = "TAG_OPEN_START";
      TokenType[TokenType["TAG_OPEN_END"] = 1] = "TAG_OPEN_END";
      TokenType[TokenType["TAG_OPEN_END_VOID"] = 2] = "TAG_OPEN_END_VOID";
      TokenType[TokenType["TAG_CLOSE"] = 3] = "TAG_CLOSE";
      TokenType[TokenType["TEXT"] = 4] = "TEXT";
      TokenType[TokenType["ESCAPABLE_RAW_TEXT"] = 5] = "ESCAPABLE_RAW_TEXT";
      TokenType[TokenType["RAW_TEXT"] = 6] = "RAW_TEXT";
      TokenType[TokenType["COMMENT_START"] = 7] = "COMMENT_START";
      TokenType[TokenType["COMMENT_END"] = 8] = "COMMENT_END";
      TokenType[TokenType["CDATA_START"] = 9] = "CDATA_START";
      TokenType[TokenType["CDATA_END"] = 10] = "CDATA_END";
      TokenType[TokenType["ATTR_NAME"] = 11] = "ATTR_NAME";
      TokenType[TokenType["ATTR_VALUE"] = 12] = "ATTR_VALUE";
      TokenType[TokenType["DOC_TYPE"] = 13] = "DOC_TYPE";
      TokenType[TokenType["EXPANSION_FORM_START"] = 14] = "EXPANSION_FORM_START";
      TokenType[TokenType["EXPANSION_CASE_VALUE"] = 15] = "EXPANSION_CASE_VALUE";
      TokenType[TokenType["EXPANSION_CASE_EXP_START"] = 16] = "EXPANSION_CASE_EXP_START";
      TokenType[TokenType["EXPANSION_CASE_EXP_END"] = 17] = "EXPANSION_CASE_EXP_END";
      TokenType[TokenType["EXPANSION_FORM_END"] = 18] = "EXPANSION_FORM_END";
      TokenType[TokenType["EOF"] = 19] = "EOF";
  })(TokenType$1 || (TokenType$1 = {}));
  class Token$1 {
      constructor(type, parts, sourceSpan) {
          this.type = type;
          this.parts = parts;
          this.sourceSpan = sourceSpan;
      }
  }
  class TokenError extends ParseError {
      constructor(errorMsg, tokenType, span) {
          super(span, errorMsg);
          this.tokenType = tokenType;
      }
  }
  class TokenizeResult {
      constructor(tokens, errors) {
          this.tokens = tokens;
          this.errors = errors;
      }
  }
  function tokenize(source, url, getTagDefinition, options = {}) {
      return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options).tokenize();
  }
  const _CR_OR_CRLF_REGEXP = /\r\n?/g;
  function _unexpectedCharacterErrorMsg(charCode) {
      const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
      return `Unexpected character "${char}"`;
  }
  function _unknownEntityErrorMsg(entitySrc) {
      return `Unknown entity "${entitySrc}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
  }
  class _ControlFlowError {
      constructor(error) {
          this.error = error;
      }
  }
  // See http://www.w3.org/TR/html51/syntax.html#writing
  class _Tokenizer {
      /**
       * @param _file The html source
       * @param _getTagDefinition
       * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)
       * @param _interpolationConfig
       */
      constructor(_file, _getTagDefinition, options) {
          this._file = _file;
          this._getTagDefinition = _getTagDefinition;
          this._peek = -1;
          this._nextPeek = -1;
          this._index = -1;
          this._line = 0;
          this._column = -1;
          this._currentTokenStart = null;
          this._currentTokenType = null;
          this._expansionCaseStack = [];
          this._inInterpolation = false;
          this.tokens = [];
          this.errors = [];
          this._tokenizeIcu = options.tokenizeExpansionForms || false;
          this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
          this._input = _file.content;
          this._length = _file.content.length;
          this._advance();
      }
      _processCarriageReturns(content) {
          // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream
          // In order to keep the original position in the source, we can not
          // pre-process it.
          // Instead CRs are processed right before instantiating the tokens.
          return content.replace(_CR_OR_CRLF_REGEXP, '\n');
      }
      tokenize() {
          while (this._peek !== $EOF) {
              const start = this._getLocation();
              try {
                  if (this._attemptCharCode($LT)) {
                      if (this._attemptCharCode($BANG)) {
                          if (this._attemptCharCode($LBRACKET)) {
                              this._consumeCdata(start);
                          }
                          else if (this._attemptCharCode($MINUS)) {
                              this._consumeComment(start);
                          }
                          else {
                              this._consumeDocType(start);
                          }
                      }
                      else if (this._attemptCharCode($SLASH)) {
                          this._consumeTagClose(start);
                      }
                      else {
                          this._consumeTagOpen(start);
                      }
                  }
                  else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
                      this._consumeText();
                  }
              }
              catch (e) {
                  if (e instanceof _ControlFlowError) {
                      this.errors.push(e.error);
                  }
                  else {
                      throw e;
                  }
              }
          }
          this._beginToken(TokenType$1.EOF);
          this._endToken([]);
          return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);
      }
      /**
       * @returns whether an ICU token has been created
       * @internal
       */
      _tokenizeExpansionForm() {
          if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
              this._consumeExpansionFormStart();
              return true;
          }
          if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {
              this._consumeExpansionCaseStart();
              return true;
          }
          if (this._peek === $RBRACE) {
              if (this._isInExpansionCase()) {
                  this._consumeExpansionCaseEnd();
                  return true;
              }
              if (this._isInExpansionForm()) {
                  this._consumeExpansionFormEnd();
                  return true;
              }
          }
          return false;
      }
      _getLocation() {
          return new ParseLocation(this._file, this._index, this._line, this._column);
      }
      _getSpan(start = this._getLocation(), end = this._getLocation()) {
          return new ParseSourceSpan(start, end);
      }
      _beginToken(type, start = this._getLocation()) {
          this._currentTokenStart = start;
          this._currentTokenType = type;
      }
      _endToken(parts, end = this._getLocation()) {
          if (this._currentTokenStart === null) {
              throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._getSpan(end, end));
          }
          if (this._currentTokenType === null) {
              throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._getSpan(this._currentTokenStart, end));
          }
          const token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));
          this.tokens.push(token);
          this._currentTokenStart = null;
          this._currentTokenType = null;
          return token;
      }
      _createError(msg, span) {
          if (this._isInExpansionForm()) {
              msg += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`;
          }
          const error = new TokenError(msg, this._currentTokenType, span);
          this._currentTokenStart = null;
          this._currentTokenType = null;
          return new _ControlFlowError(error);
      }
      _advance() {
          if (this._index >= this._length) {
              throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());
          }
          if (this._peek === $LF) {
              this._line++;
              this._column = 0;
          }
          else if (this._peek !== $LF && this._peek !== $CR) {
              this._column++;
          }
          this._index++;
          this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);
          this._nextPeek =
              this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);
      }
      _attemptCharCode(charCode) {
          if (this._peek === charCode) {
              this._advance();
              return true;
          }
          return false;
      }
      _attemptCharCodeCaseInsensitive(charCode) {
          if (compareCharCodeCaseInsensitive(this._peek, charCode)) {
              this._advance();
              return true;
          }
          return false;
      }
      _requireCharCode(charCode) {
          const location = this._getLocation();
          if (!this._attemptCharCode(charCode)) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));
          }
      }
      _attemptStr(chars) {
          const len = chars.length;
          if (this._index + len > this._length) {
              return false;
          }
          const initialPosition = this._savePosition();
          for (let i = 0; i < len; i++) {
              if (!this._attemptCharCode(chars.charCodeAt(i))) {
                  // If attempting to parse the string fails, we want to reset the parser
                  // to where it was before the attempt
                  this._restorePosition(initialPosition);
                  return false;
              }
          }
          return true;
      }
      _attemptStrCaseInsensitive(chars) {
          for (let i = 0; i < chars.length; i++) {
              if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
                  return false;
              }
          }
          return true;
      }
      _requireStr(chars) {
          const location = this._getLocation();
          if (!this._attemptStr(chars)) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));
          }
      }
      _attemptCharCodeUntilFn(predicate) {
          while (!predicate(this._peek)) {
              this._advance();
          }
      }
      _requireCharCodeUntilFn(predicate, len) {
          const start = this._getLocation();
          this._attemptCharCodeUntilFn(predicate);
          if (this._index - start.offset < len) {
              throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));
          }
      }
      _attemptUntilChar(char) {
          while (this._peek !== char) {
              this._advance();
          }
      }
      _readChar(decodeEntities) {
          if (decodeEntities && this._peek === $AMPERSAND) {
              return this._decodeEntity();
          }
          else {
              const index = this._index;
              this._advance();
              return this._input[index];
          }
      }
      _decodeEntity() {
          const start = this._getLocation();
          this._advance();
          if (this._attemptCharCode($HASH)) {
              const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);
              const numberStart = this._getLocation().offset;
              this._attemptCharCodeUntilFn(isDigitEntityEnd);
              if (this._peek != $SEMICOLON) {
                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
              }
              this._advance();
              const strNum = this._input.substring(numberStart, this._index - 1);
              try {
                  const charCode = parseInt(strNum, isHex ? 16 : 10);
                  return String.fromCharCode(charCode);
              }
              catch (_a) {
                  const entity = this._input.substring(start.offset + 1, this._index - 1);
                  throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));
              }
          }
          else {
              const startPosition = this._savePosition();
              this._attemptCharCodeUntilFn(isNamedEntityEnd);
              if (this._peek != $SEMICOLON) {
                  this._restorePosition(startPosition);
                  return '&';
              }
              this._advance();
              const name = this._input.substring(start.offset + 1, this._index - 1);
              const char = NAMED_ENTITIES[name];
              if (!char) {
                  throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));
              }
              return char;
          }
      }
      _consumeRawText(decodeEntities, firstCharOfEnd, attemptEndRest) {
          let tagCloseStart;
          const textStart = this._getLocation();
          this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);
          const parts = [];
          while (true) {
              tagCloseStart = this._getLocation();
              if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {
                  break;
              }
              if (this._index > tagCloseStart.offset) {
                  // add the characters consumed by the previous if statement to the output
                  parts.push(this._input.substring(tagCloseStart.offset, this._index));
              }
              while (this._peek !== firstCharOfEnd) {
                  parts.push(this._readChar(decodeEntities));
              }
          }
          return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);
      }
      _consumeComment(start) {
          this._beginToken(TokenType$1.COMMENT_START, start);
          this._requireCharCode($MINUS);
          this._endToken([]);
          const textToken = this._consumeRawText(false, $MINUS, () => this._attemptStr('->'));
          this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);
          this._endToken([]);
      }
      _consumeCdata(start) {
          this._beginToken(TokenType$1.CDATA_START, start);
          this._requireStr('CDATA[');
          this._endToken([]);
          const textToken = this._consumeRawText(false, $RBRACKET, () => this._attemptStr(']>'));
          this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);
          this._endToken([]);
      }
      _consumeDocType(start) {
          this._beginToken(TokenType$1.DOC_TYPE, start);
          this._attemptUntilChar($GT);
          this._advance();
          this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);
      }
      _consumePrefixAndName() {
          const nameOrPrefixStart = this._index;
          let prefix = null;
          while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {
              this._advance();
          }
          let nameStart;
          if (this._peek === $COLON) {
              this._advance();
              prefix = this._input.substring(nameOrPrefixStart, this._index - 1);
              nameStart = this._index;
          }
          else {
              nameStart = nameOrPrefixStart;
          }
          this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);
          const name = this._input.substring(nameStart, this._index);
          return [prefix, name];
      }
      _consumeTagOpen(start) {
          const savedPos = this._savePosition();
          let tagName;
          let lowercaseTagName;
          try {
              if (!isAsciiLetter(this._peek)) {
                  throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());
              }
              const nameStart = this._index;
              this._consumeTagOpenStart(start);
              tagName = this._input.substring(nameStart, this._index);
              lowercaseTagName = tagName.toLowerCase();
              this._attemptCharCodeUntilFn(isNotWhitespace);
              while (this._peek !== $SLASH && this._peek !== $GT) {
                  this._consumeAttributeName();
                  this._attemptCharCodeUntilFn(isNotWhitespace);
                  if (this._attemptCharCode($EQ)) {
                      this._attemptCharCodeUntilFn(isNotWhitespace);
                      this._consumeAttributeValue();
                  }
                  this._attemptCharCodeUntilFn(isNotWhitespace);
              }
              this._consumeTagOpenEnd();
          }
          catch (e) {
              if (e instanceof _ControlFlowError) {
                  // When the start tag is invalid, assume we want a "<"
                  this._restorePosition(savedPos);
                  // Back to back text tokens are merged at the end
                  this._beginToken(TokenType$1.TEXT, start);
                  this._endToken(['<']);
                  return;
              }
              throw e;
          }
          const contentTokenType = this._getTagDefinition(tagName).contentType;
          if (contentTokenType === TagContentType.RAW_TEXT) {
              this._consumeRawTextWithTagClose(lowercaseTagName, false);
          }
          else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
              this._consumeRawTextWithTagClose(lowercaseTagName, true);
          }
      }
      _consumeRawTextWithTagClose(lowercaseTagName, decodeEntities) {
          const textToken = this._consumeRawText(decodeEntities, $LT, () => {
              if (!this._attemptCharCode($SLASH))
                  return false;
              this._attemptCharCodeUntilFn(isNotWhitespace);
              if (!this._attemptStrCaseInsensitive(lowercaseTagName))
                  return false;
              this._attemptCharCodeUntilFn(isNotWhitespace);
              return this._attemptCharCode($GT);
          });
          this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);
          this._endToken([null, lowercaseTagName]);
      }
      _consumeTagOpenStart(start) {
          this._beginToken(TokenType$1.TAG_OPEN_START, start);
          const parts = this._consumePrefixAndName();
          this._endToken(parts);
      }
      _consumeAttributeName() {
          this._beginToken(TokenType$1.ATTR_NAME);
          const prefixAndName = this._consumePrefixAndName();
          this._endToken(prefixAndName);
      }
      _consumeAttributeValue() {
          this._beginToken(TokenType$1.ATTR_VALUE);
          let value;
          if (this._peek === $SQ || this._peek === $DQ) {
              const quoteChar = this._peek;
              this._advance();
              const parts = [];
              while (this._peek !== quoteChar) {
                  parts.push(this._readChar(true));
              }
              value = parts.join('');
              this._advance();
          }
          else {
              const valueStart = this._index;
              this._requireCharCodeUntilFn(isNameEnd, 1);
              value = this._input.substring(valueStart, this._index);
          }
          this._endToken([this._processCarriageReturns(value)]);
      }
      _consumeTagOpenEnd() {
          const tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;
          this._beginToken(tokenType);
          this._requireCharCode($GT);
          this._endToken([]);
      }
      _consumeTagClose(start) {
          this._beginToken(TokenType$1.TAG_CLOSE, start);
          this._attemptCharCodeUntilFn(isNotWhitespace);
          const prefixAndName = this._consumePrefixAndName();
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._requireCharCode($GT);
          this._endToken(prefixAndName);
      }
      _consumeExpansionFormStart() {
          this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());
          this._requireCharCode($LBRACE);
          this._endToken([]);
          this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);
          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
          const condition = this._readUntil($COMMA);
          this._endToken([condition], this._getLocation());
          this._requireCharCode($COMMA);
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());
          const type = this._readUntil($COMMA);
          this._endToken([type], this._getLocation());
          this._requireCharCode($COMMA);
          this._attemptCharCodeUntilFn(isNotWhitespace);
      }
      _consumeExpansionCaseStart() {
          this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());
          const value = this._readUntil($LBRACE).trim();
          this._endToken([value], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());
          this._requireCharCode($LBRACE);
          this._endToken([], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);
      }
      _consumeExpansionCaseEnd() {
          this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());
          this._requireCharCode($RBRACE);
          this._endToken([], this._getLocation());
          this._attemptCharCodeUntilFn(isNotWhitespace);
          this._expansionCaseStack.pop();
      }
      _consumeExpansionFormEnd() {
          this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());
          this._requireCharCode($RBRACE);
          this._endToken([]);
          this._expansionCaseStack.pop();
      }
      _consumeText() {
          const start = this._getLocation();
          this._beginToken(TokenType$1.TEXT, start);
          const parts = [];
          do {
              if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
                  parts.push(this._interpolationConfig.start);
                  this._inInterpolation = true;
              }
              else if (this._interpolationConfig && this._inInterpolation &&
                  this._attemptStr(this._interpolationConfig.end)) {
                  parts.push(this._interpolationConfig.end);
                  this._inInterpolation = false;
              }
              else {
                  parts.push(this._readChar(true));
              }
          } while (!this._isTextEnd());
          this._endToken([this._processCarriageReturns(parts.join(''))]);
      }
      _isTextEnd() {
          if (this._peek === $LT || this._peek === $EOF) {
              return true;
          }
          if (this._tokenizeIcu && !this._inInterpolation) {
              if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {
                  // start of an expansion form
                  return true;
              }
              if (this._peek === $RBRACE && this._isInExpansionCase()) {
                  // end of and expansion case
                  return true;
              }
          }
          return false;
      }
      _savePosition() {
          return [this._peek, this._index, this._column, this._line, this.tokens.length];
      }
      _readUntil(char) {
          const start = this._index;
          this._attemptUntilChar(char);
          return this._input.substring(start, this._index);
      }
      _restorePosition(position) {
          this._peek = position[0];
          this._index = position[1];
          this._column = position[2];
          this._line = position[3];
          const nbTokens = position[4];
          if (nbTokens < this.tokens.length) {
              // remove any extra tokens
              this.tokens = this.tokens.slice(0, nbTokens);
          }
      }
      _isInExpansionCase() {
          return this._expansionCaseStack.length > 0 &&
              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                  TokenType$1.EXPANSION_CASE_EXP_START;
      }
      _isInExpansionForm() {
          return this._expansionCaseStack.length > 0 &&
              this._expansionCaseStack[this._expansionCaseStack.length - 1] ===
                  TokenType$1.EXPANSION_FORM_START;
      }
  }
  function isNotWhitespace(code) {
      return !isWhitespace(code) || code === $EOF;
  }
  function isNameEnd(code) {
      return isWhitespace(code) || code === $GT || code === $SLASH ||
          code === $SQ || code === $DQ || code === $EQ;
  }
  function isPrefixEnd(code) {
      return (code < $a || $z < code) && (code < $A || $Z < code) &&
          (code < $0 || code > $9);
  }
  function isDigitEntityEnd(code) {
      return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);
  }
  function isNamedEntityEnd(code) {
      return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);
  }
  function isExpansionFormStart(input, offset, interpolationConfig) {
      const isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;
      return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;
  }
  function isExpansionCaseStart(peek) {
      return peek === $EQ || isAsciiLetter(peek) || isDigit(peek);
  }
  function compareCharCodeCaseInsensitive(code1, code2) {
      return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);
  }
  function toUpperCaseCharCode(code) {
      return code >= $a && code <= $z ? code - $a + $A : code;
  }
  function mergeTextTokens(srcTokens) {
      const dstTokens = [];
      let lastDstToken = undefined;
      for (let i = 0; i < srcTokens.length; i++) {
          const token = srcTokens[i];
          if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {
              lastDstToken.parts[0] += token.parts[0];
              lastDstToken.sourceSpan.end = token.sourceSpan.end;
          }
          else {
              lastDstToken = token;
              dstTokens.push(lastDstToken);
          }
      }
      return dstTokens;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class TreeError extends ParseError {
      constructor(elementName, span, msg) {
          super(span, msg);
          this.elementName = elementName;
      }
      static create(elementName, span, msg) {
          return new TreeError(elementName, span, msg);
      }
  }
  class ParseTreeResult {
      constructor(rootNodes, errors) {
          this.rootNodes = rootNodes;
          this.errors = errors;
      }
  }
  class Parser$1 {
      constructor(getTagDefinition) {
          this.getTagDefinition = getTagDefinition;
      }
      parse(source, url, options) {
          const tokensAndErrors = tokenize(source, url, this.getTagDefinition, options);
          const treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();
          return new ParseTreeResult(treeAndErrors.rootNodes, tokensAndErrors.errors.concat(treeAndErrors.errors));
      }
  }
  class _TreeBuilder {
      constructor(tokens, getTagDefinition) {
          this.tokens = tokens;
          this.getTagDefinition = getTagDefinition;
          this._index = -1;
          this._rootNodes = [];
          this._errors = [];
          this._elementStack = [];
          this._advance();
      }
      build() {
          while (this._peek.type !== TokenType$1.EOF) {
              if (this._peek.type === TokenType$1.TAG_OPEN_START) {
                  this._consumeStartTag(this._advance());
              }
              else if (this._peek.type === TokenType$1.TAG_CLOSE) {
                  this._consumeEndTag(this._advance());
              }
              else if (this._peek.type === TokenType$1.CDATA_START) {
                  this._closeVoidElement();
                  this._consumeCdata(this._advance());
              }
              else if (this._peek.type === TokenType$1.COMMENT_START) {
                  this._closeVoidElement();
                  this._consumeComment(this._advance());
              }
              else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||
                  this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {
                  this._closeVoidElement();
                  this._consumeText(this._advance());
              }
              else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {
                  this._consumeExpansion(this._advance());
              }
              else {
                  // Skip all other tokens...
                  this._advance();
              }
          }
          return new ParseTreeResult(this._rootNodes, this._errors);
      }
      _advance() {
          const prev = this._peek;
          if (this._index < this.tokens.length - 1) {
              // Note: there is always an EOF token at the end
              this._index++;
          }
          this._peek = this.tokens[this._index];
          return prev;
      }
      _advanceIf(type) {
          if (this._peek.type === type) {
              return this._advance();
          }
          return null;
      }
      _consumeCdata(startToken) {
          this._consumeText(this._advance());
          this._advanceIf(TokenType$1.CDATA_END);
      }
      _consumeComment(token) {
          const text = this._advanceIf(TokenType$1.RAW_TEXT);
          this._advanceIf(TokenType$1.COMMENT_END);
          const value = text != null ? text.parts[0].trim() : null;
          this._addToParent(new Comment(value, token.sourceSpan));
      }
      _consumeExpansion(token) {
          const switchValue = this._advance();
          const type = this._advance();
          const cases = [];
          // read =
          while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {
              const expCase = this._parseExpansionCase();
              if (!expCase)
                  return; // error
              cases.push(expCase);
          }
          // read the final }
          if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {
              this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));
              return;
          }
          const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);
          this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));
          this._advance();
      }
      _parseExpansionCase() {
          const value = this._advance();
          // read {
          if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {
              this._errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));
              return null;
          }
          // read until }
          const start = this._advance();
          const exp = this._collectExpansionExpTokens(start);
          if (!exp)
              return null;
          const end = this._advance();
          exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));
          // parse everything in between { and }
          const parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();
          if (parsedExp.errors.length > 0) {
              this._errors = this._errors.concat(parsedExp.errors);
              return null;
          }
          const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);
          const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);
          return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
      }
      _collectExpansionExpTokens(start) {
          const exp = [];
          const expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];
          while (true) {
              if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||
                  this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {
                  expansionFormStack.push(this._peek.type);
              }
              if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {
                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {
                      expansionFormStack.pop();
                      if (expansionFormStack.length == 0)
                          return exp;
                  }
                  else {
                      this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                      return null;
                  }
              }
              if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {
                  if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {
                      expansionFormStack.pop();
                  }
                  else {
                      this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                      return null;
                  }
              }
              if (this._peek.type === TokenType$1.EOF) {
                  this._errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));
                  return null;
              }
              exp.push(this._advance());
          }
      }
      _consumeText(token) {
          let text = token.parts[0];
          if (text.length > 0 && text[0] == '\n') {
              const parent = this._getParentElement();
              if (parent != null && parent.children.length == 0 &&
                  this.getTagDefinition(parent.name).ignoreFirstLf) {
                  text = text.substring(1);
              }
          }
          if (text.length > 0) {
              this._addToParent(new Text$2(text, token.sourceSpan));
          }
      }
      _closeVoidElement() {
          const el = this._getParentElement();
          if (el && this.getTagDefinition(el.name).isVoid) {
              this._elementStack.pop();
          }
      }
      _consumeStartTag(startTagToken) {
          const prefix = startTagToken.parts[0];
          const name = startTagToken.parts[1];
          const attrs = [];
          while (this._peek.type === TokenType$1.ATTR_NAME) {
              attrs.push(this._consumeAttr(this._advance()));
          }
          const fullName = this._getElementFullName(prefix, name, this._getParentElement());
          let selfClosing = false;
          // Note: There could have been a tokenizer error
          // so that we don't get a token for the end tag...
          if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {
              this._advance();
              selfClosing = true;
              const tagDef = this.getTagDefinition(fullName);
              if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
                  this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed "${startTagToken.parts[1]}"`));
              }
          }
          else if (this._peek.type === TokenType$1.TAG_OPEN_END) {
              this._advance();
              selfClosing = false;
          }
          const end = this._peek.sourceSpan.start;
          const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);
          const el = new Element$1(fullName, attrs, [], span, span, undefined);
          this._pushElement(el);
          if (selfClosing) {
              this._popElement(fullName);
              el.endSourceSpan = span;
          }
      }
      _pushElement(el) {
          const parentEl = this._getParentElement();
          if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
              this._elementStack.pop();
          }
          const tagDef = this.getTagDefinition(el.name);
          const { parent, container } = this._getParentElementSkippingContainers();
          if (parent && tagDef.requireExtraParent(parent.name)) {
              const newParent = new Element$1(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
              this._insertBeforeContainer(parent, container, newParent);
          }
          this._addToParent(el);
          this._elementStack.push(el);
      }
      _consumeEndTag(endTagToken) {
          const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());
          if (this._getParentElement()) {
              this._getParentElement().endSourceSpan = endTagToken.sourceSpan;
          }
          if (this.getTagDefinition(fullName).isVoid) {
              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags "${endTagToken.parts[1]}"`));
          }
          else if (!this._popElement(fullName)) {
              const errMsg = `Unexpected closing tag "${fullName}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
              this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
          }
      }
      _popElement(fullName) {
          for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
              const el = this._elementStack[stackIndex];
              if (el.name == fullName) {
                  this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);
                  return true;
              }
              if (!this.getTagDefinition(el.name).closedByParent) {
                  return false;
              }
          }
          return false;
      }
      _consumeAttr(attrName) {
          const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
          let end = attrName.sourceSpan.end;
          let value = '';
          let valueSpan = undefined;
          if (this._peek.type === TokenType$1.ATTR_VALUE) {
              const valueToken = this._advance();
              value = valueToken.parts[0];
              end = valueToken.sourceSpan.end;
              valueSpan = valueToken.sourceSpan;
          }
          return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);
      }
      _getParentElement() {
          return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
      }
      /**
       * Returns the parent in the DOM and the container.
       *
       * `<ng-container>` elements are skipped as they are not rendered as DOM element.
       */
      _getParentElementSkippingContainers() {
          let container = null;
          for (let i = this._elementStack.length - 1; i >= 0; i--) {
              if (!isNgContainer(this._elementStack[i].name)) {
                  return { parent: this._elementStack[i], container };
              }
              container = this._elementStack[i];
          }
          return { parent: null, container };
      }
      _addToParent(node) {
          const parent = this._getParentElement();
          if (parent != null) {
              parent.children.push(node);
          }
          else {
              this._rootNodes.push(node);
          }
      }
      /**
       * Insert a node between the parent and the container.
       * When no container is given, the node is appended as a child of the parent.
       * Also updates the element stack accordingly.
       *
       * @internal
       */
      _insertBeforeContainer(parent, container, node) {
          if (!container) {
              this._addToParent(node);
              this._elementStack.push(node);
          }
          else {
              if (parent) {
                  // replace the container with the new node in the children
                  const index = parent.children.indexOf(container);
                  parent.children[index] = node;
              }
              else {
                  this._rootNodes.push(node);
              }
              node.children.push(container);
              this._elementStack.splice(this._elementStack.indexOf(container), 0, node);
          }
      }
      _getElementFullName(prefix, localName, parentElement) {
          if (prefix == null) {
              prefix = this.getTagDefinition(localName).implicitNamespacePrefix;
              if (prefix == null && parentElement != null) {
                  prefix = getNsPrefix(parentElement.name);
              }
          }
          return mergeNsAndName(prefix, localName);
      }
  }
  function lastOnStack(stack, element) {
      return stack.length > 0 && stack[stack.length - 1] === element;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class HtmlParser extends Parser$1 {
      constructor() { super(getHtmlTagDefinition); }
      parse(source, url, options) {
          return super.parse(source, url, options);
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';
  const SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);
  // Equivalent to \s with \u00a0 (non-breaking space) excluded.
  // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
  const WS_CHARS = ' \f\n\r\t\v\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff';
  const NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);
  const WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');
  function hasPreserveWhitespacesAttr(attrs) {
      return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);
  }
  /**
   * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:
   * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32
   * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character
   * and later on replaced by a space. We are re-implementing the same idea here.
   */
  function replaceNgsp(value) {
      // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE
      return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');
  }
  /**
   * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:
   * - consider spaces, tabs and new lines as whitespace characters;
   * - drop text nodes consisting of whitespace characters only;
   * - for all other text nodes replace consecutive whitespace characters with one space;
   * - convert &ngsp; pseudo-entity to a single space;
   *
   * Removal and trimming of whitespaces have positive performance impact (less code to generate
   * while compiling templates, faster view creation). At the same time it can be "destructive"
   * in some cases (whitespaces can influence layout). Because of the potential of breaking layout
   * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for
   * whitespace removal. The default option for whitespace removal will be revisited in Angular 6
   * and might be changed to "on" by default.
   */
  class WhitespaceVisitor {
      visitElement(element, context) {
          if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
              // don't descent into elements where we need to preserve whitespaces
              // but still visit all attributes to eliminate one used as a market to preserve WS
              return new Element$1(element.name, visitAll(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
          }
          return new Element$1(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
      }
      visitAttribute(attribute, context) {
          return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
      }
      visitText(text, context) {
          const isNotBlank = text.value.match(NO_WS_REGEXP);
          if (isNotBlank) {
              return new Text$2(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);
          }
          return null;
      }
      visitComment(comment, context) { return comment; }
      visitExpansion(expansion, context) { return expansion; }
      visitExpansionCase(expansionCase, context) { return expansionCase; }
  }
  function removeWhitespaces(htmlAstWithErrors) {
      return new ParseTreeResult(visitAll(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // =================================================================================================
  // =================================================================================================
  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
  // =================================================================================================
  // =================================================================================================
  //
  //        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
  //                               Reach out to mprobst for details.
  //
  // =================================================================================================
  /** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */
  let _SECURITY_SCHEMA;
  function SECURITY_SCHEMA() {
      if (!_SECURITY_SCHEMA) {
          _SECURITY_SCHEMA = {};
          // Case is insignificant below, all element and attribute names are lower-cased for lookup.
          registerContext(SecurityContext.HTML, [
              'iframe|srcdoc',
              '*|innerHTML',
              '*|outerHTML',
          ]);
          registerContext(SecurityContext.STYLE, ['*|style']);
          // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
          registerContext(SecurityContext.URL, [
              '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',
              'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',
              'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',
              'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',
          ]);
          registerContext(SecurityContext.RESOURCE_URL, [
              'applet|code',
              'applet|codebase',
              'base|href',
              'embed|src',
              'frame|src',
              'head|profile',
              'html|manifest',
              'iframe|src',
              'link|href',
              'media|src',
              'object|codebase',
              'object|data',
              'script|src',
          ]);
      }
      return _SECURITY_SCHEMA;
  }
  function registerContext(ctx, specs) {
      for (const spec of specs)
          _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class ElementSchemaRegistry {
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const BOOLEAN = 'boolean';
  const NUMBER = 'number';
  const STRING = 'string';
  const OBJECT = 'object';
  /**
   * This array represents the DOM schema. It encodes inheritance, properties, and events.
   *
   * ## Overview
   *
   * Each line represents one kind of element. The `element_inheritance` and properties are joined
   * using `element_inheritance|properties` syntax.
   *
   * ## Element Inheritance
   *
   * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
   * Here the individual elements are separated by `,` (commas). Every element in the list
   * has identical properties.
   *
   * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
   * specified then `""` (blank) element is assumed.
   *
   * NOTE: The blank element inherits from root `[Element]` element, the super element of all
   * elements.
   *
   * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
   *
   * ## Properties
   *
   * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
   * by a special character designating its type:
   *
   * - (no prefix): property is a string.
   * - `*`: property represents an event.
   * - `!`: property is a boolean.
   * - `#`: property is a number.
   * - `%`: property is an object.
   *
   * ## Query
   *
   * The class creates an internal squas representation which allows to easily answer the query of
   * if a given property exist on a given element.
   *
   * NOTE: We don't yet support querying for types or events.
   * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
   *       see dom_element_schema_registry_spec.ts
   */
  // =================================================================================================
  // =================================================================================================
  // =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
  // =================================================================================================
  // =================================================================================================
  //
  //                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
  //
  // Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
  // dom_security_schema.ts. Reach out to mprobst & rjamet for details.
  //
  // =================================================================================================
  const SCHEMA = [
      '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +
          /* added manually to avoid breaking changes */
          ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',
      '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
      'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',
      'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',
      ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',
      ':svg:graphics^:svg:|',
      ':svg:animation^:svg:|*begin,*end,*repeat',
      ':svg:geometry^:svg:|',
      ':svg:componentTransferFunction^:svg:|',
      ':svg:gradient^:svg:|',
      ':svg:textContent^:svg:graphics|',
      ':svg:textPositioning^:svg:textContent|',
      'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',
      'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',
      'audio^media|',
      'br^[HTMLElement]|clear',
      'base^[HTMLElement]|href,target',
      'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',
      'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',
      'canvas^[HTMLElement]|#height,#width',
      'content^[HTMLElement]|select',
      'dl^[HTMLElement]|!compact',
      'datalist^[HTMLElement]|',
      'details^[HTMLElement]|!open',
      'dialog^[HTMLElement]|!open,returnValue',
      'dir^[HTMLElement]|!compact',
      'div^[HTMLElement]|align',
      'embed^[HTMLElement]|align,height,name,src,type,width',
      'fieldset^[HTMLElement]|!disabled,name',
      'font^[HTMLElement]|color,face,size',
      'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',
      'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',
      'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',
      'hr^[HTMLElement]|align,color,!noShade,size,width',
      'head^[HTMLElement]|',
      'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',
      'html^[HTMLElement]|version',
      'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',
      'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',
      'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',
      'li^[HTMLElement]|type,#value',
      'label^[HTMLElement]|htmlFor',
      'legend^[HTMLElement]|align',
      'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',
      'map^[HTMLElement]|name',
      'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',
      'menu^[HTMLElement]|!compact',
      'meta^[HTMLElement]|content,httpEquiv,name,scheme',
      'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',
      'ins,del^[HTMLElement]|cite,dateTime',
      'ol^[HTMLElement]|!compact,!reversed,#start,type',
      'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',
      'optgroup^[HTMLElement]|!disabled,label',
      'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',
      'output^[HTMLElement]|defaultValue,%htmlFor,name,value',
      'p^[HTMLElement]|align',
      'param^[HTMLElement]|name,type,value,valueType',
      'picture^[HTMLElement]|',
      'pre^[HTMLElement]|#width',
      'progress^[HTMLElement]|#max,#value',
      'q,blockquote,cite^[HTMLElement]|',
      'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',
      'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',
      'shadow^[HTMLElement]|',
      'slot^[HTMLElement]|name',
      'source^[HTMLElement]|media,sizes,src,srcset,type',
      'span^[HTMLElement]|',
      'style^[HTMLElement]|!disabled,media,type',
      'caption^[HTMLElement]|align',
      'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',
      'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',
      'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',
      'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',
      'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',
      'template^[HTMLElement]|',
      'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',
      'title^[HTMLElement]|text',
      'track^[HTMLElement]|!default,kind,label,src,srclang',
      'ul^[HTMLElement]|!compact,type',
      'unknown^[HTMLElement]|',
      'video^media|#height,poster,#width',
      ':svg:a^:svg:graphics|',
      ':svg:animate^:svg:animation|',
      ':svg:animateMotion^:svg:animation|',
      ':svg:animateTransform^:svg:animation|',
      ':svg:circle^:svg:geometry|',
      ':svg:clipPath^:svg:graphics|',
      ':svg:defs^:svg:graphics|',
      ':svg:desc^:svg:|',
      ':svg:discard^:svg:|',
      ':svg:ellipse^:svg:geometry|',
      ':svg:feBlend^:svg:|',
      ':svg:feColorMatrix^:svg:|',
      ':svg:feComponentTransfer^:svg:|',
      ':svg:feComposite^:svg:|',
      ':svg:feConvolveMatrix^:svg:|',
      ':svg:feDiffuseLighting^:svg:|',
      ':svg:feDisplacementMap^:svg:|',
      ':svg:feDistantLight^:svg:|',
      ':svg:feDropShadow^:svg:|',
      ':svg:feFlood^:svg:|',
      ':svg:feFuncA^:svg:componentTransferFunction|',
      ':svg:feFuncB^:svg:componentTransferFunction|',
      ':svg:feFuncG^:svg:componentTransferFunction|',
      ':svg:feFuncR^:svg:componentTransferFunction|',
      ':svg:feGaussianBlur^:svg:|',
      ':svg:feImage^:svg:|',
      ':svg:feMerge^:svg:|',
      ':svg:feMergeNode^:svg:|',
      ':svg:feMorphology^:svg:|',
      ':svg:feOffset^:svg:|',
      ':svg:fePointLight^:svg:|',
      ':svg:feSpecularLighting^:svg:|',
      ':svg:feSpotLight^:svg:|',
      ':svg:feTile^:svg:|',
      ':svg:feTurbulence^:svg:|',
      ':svg:filter^:svg:|',
      ':svg:foreignObject^:svg:graphics|',
      ':svg:g^:svg:graphics|',
      ':svg:image^:svg:graphics|',
      ':svg:line^:svg:geometry|',
      ':svg:linearGradient^:svg:gradient|',
      ':svg:mpath^:svg:|',
      ':svg:marker^:svg:|',
      ':svg:mask^:svg:|',
      ':svg:metadata^:svg:|',
      ':svg:path^:svg:geometry|',
      ':svg:pattern^:svg:|',
      ':svg:polygon^:svg:geometry|',
      ':svg:polyline^:svg:geometry|',
      ':svg:radialGradient^:svg:gradient|',
      ':svg:rect^:svg:geometry|',
      ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',
      ':svg:script^:svg:|type',
      ':svg:set^:svg:animation|',
      ':svg:stop^:svg:|',
      ':svg:style^:svg:|!disabled,media,title,type',
      ':svg:switch^:svg:graphics|',
      ':svg:symbol^:svg:|',
      ':svg:tspan^:svg:textPositioning|',
      ':svg:text^:svg:textPositioning|',
      ':svg:textPath^:svg:textContent|',
      ':svg:title^:svg:|',
      ':svg:use^:svg:graphics|',
      ':svg:view^:svg:|#zoomAndPan',
      'data^[HTMLElement]|value',
      'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',
      'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',
      'summary^[HTMLElement]|',
      'time^[HTMLElement]|dateTime',
      ':svg:cursor^:svg:|',
  ];
  const _ATTR_TO_PROP = {
      'class': 'className',
      'for': 'htmlFor',
      'formaction': 'formAction',
      'innerHtml': 'innerHTML',
      'readonly': 'readOnly',
      'tabindex': 'tabIndex',
  };
  class DomElementSchemaRegistry extends ElementSchemaRegistry {
      constructor() {
          super();
          this._schema = {};
          SCHEMA.forEach(encodedType => {
              const type = {};
              const [strType, strProperties] = encodedType.split('|');
              const properties = strProperties.split(',');
              const [typeNames, superName] = strType.split('^');
              typeNames.split(',').forEach(tag => this._schema[tag.toLowerCase()] = type);
              const superType = superName && this._schema[superName.toLowerCase()];
              if (superType) {
                  Object.keys(superType).forEach((prop) => { type[prop] = superType[prop]; });
              }
              properties.forEach((property) => {
                  if (property.length > 0) {
                      switch (property[0]) {
                          case '*':
                              // We don't yet support events.
                              // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events
                              // will
                              // almost certainly introduce bad XSS vulnerabilities.
                              // type[property.substring(1)] = EVENT;
                              break;
                          case '!':
                              type[property.substring(1)] = BOOLEAN;
                              break;
                          case '#':
                              type[property.substring(1)] = NUMBER;
                              break;
                          case '%':
                              type[property.substring(1)] = OBJECT;
                              break;
                          default:
                              type[property] = STRING;
                      }
                  }
              });
          });
      }
      hasProperty(tagName, propName, schemaMetas) {
          if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {
              return true;
          }
          if (tagName.indexOf('-') > -1) {
              if (isNgContainer(tagName) || isNgContent(tagName)) {
                  return false;
              }
              if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {
                  // Can't tell now as we don't know which properties a custom element will get
                  // once it is instantiated
                  return true;
              }
          }
          const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];
          return !!elementProperties[propName];
      }
      hasElement(tagName, schemaMetas) {
          if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {
              return true;
          }
          if (tagName.indexOf('-') > -1) {
              if (isNgContainer(tagName) || isNgContent(tagName)) {
                  return true;
              }
              if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {
                  // Allow any custom elements
                  return true;
              }
          }
          return !!this._schema[tagName.toLowerCase()];
      }
      /**
       * securityContext returns the security context for the given property on the given DOM tag.
       *
       * Tag and property name are statically known and cannot change at runtime, i.e. it is not
       * possible to bind a value into a changing attribute or tag name.
       *
       * The filtering is white list based. All attributes in the schema above are assumed to have the
       * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
       * attack vectors are assigned their appropriate context.
       */
      securityContext(tagName, propName, isAttribute) {
          if (isAttribute) {
              // NB: For security purposes, use the mapped property name, not the attribute name.
              propName = this.getMappedPropName(propName);
          }
          // Make sure comparisons are case insensitive, so that case differences between attribute and
          // property names do not have a security impact.
          tagName = tagName.toLowerCase();
          propName = propName.toLowerCase();
          let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];
          if (ctx) {
              return ctx;
          }
          ctx = SECURITY_SCHEMA()['*|' + propName];
          return ctx ? ctx : SecurityContext.NONE;
      }
      getMappedPropName(propName) { return _ATTR_TO_PROP[propName] || propName; }
      getDefaultComponentElementName() { return 'ng-component'; }
      validateProperty(name) {
          if (name.toLowerCase().startsWith('on')) {
              const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +
                  `please use (${name.slice(2)})=...` +
                  `\nIf '${name}' is a directive input, make sure the directive is imported by the` +
                  ` current module.`;
              return { error: true, msg: msg };
          }
          else {
              return { error: false };
          }
      }
      validateAttribute(name) {
          if (name.toLowerCase().startsWith('on')) {
              const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +
                  `please use (${name.slice(2)})=...`;
              return { error: true, msg: msg };
          }
          else {
              return { error: false };
          }
      }
      allKnownElementNames() { return Object.keys(this._schema); }
      normalizeAnimationStyleProperty(propName) {
          return dashCaseToCamelCase(propName);
      }
      normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
          let unit = '';
          const strVal = val.toString().trim();
          let errorMsg = null;
          if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {
              if (typeof val === 'number') {
                  unit = 'px';
              }
              else {
                  const valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);
                  if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
                      errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;
                  }
              }
          }
          return { error: errorMsg, value: strVal + unit };
      }
  }
  function _isPixelDimensionStyle(prop) {
      switch (prop) {
          case 'width':
          case 'height':
          case 'minWidth':
          case 'minHeight':
          case 'maxWidth':
          case 'maxHeight':
          case 'left':
          case 'top':
          case 'bottom':
          case 'right':
          case 'fontSize':
          case 'outlineWidth':
          case 'outlineOffset':
          case 'paddingTop':
          case 'paddingLeft':
          case 'paddingBottom':
          case 'paddingRight':
          case 'marginTop':
          case 'marginLeft':
          case 'marginBottom':
          case 'marginRight':
          case 'borderRadius':
          case 'borderWidth':
          case 'borderTopWidth':
          case 'borderLeftWidth':
          case 'borderRightWidth':
          case 'borderBottomWidth':
          case 'textIndent':
              return true;
          default:
              return false;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const PROPERTY_PARTS_SEPARATOR = '.';
  const ATTRIBUTE_PREFIX = 'attr';
  const CLASS_PREFIX = 'class';
  const STYLE_PREFIX = 'style';
  const ANIMATE_PROP_PREFIX = 'animate-';
  /**
   * Parses bindings in templates and in the directive host area.
   */
  class BindingParser {
      constructor(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {
          this._exprParser = _exprParser;
          this._interpolationConfig = _interpolationConfig;
          this._schemaRegistry = _schemaRegistry;
          this.errors = errors;
          this.pipesByName = null;
          this._usedPipes = new Map();
          // When the `pipes` parameter is `null`, do not check for used pipes
          // This is used in IVY when we might not know the available pipes at compile time
          if (pipes) {
              const pipesByName = new Map();
              pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));
              this.pipesByName = pipesByName;
          }
      }
      get interpolationConfig() { return this._interpolationConfig; }
      getUsedPipes() { return Array.from(this._usedPipes.values()); }
      createBoundHostProperties(dirMeta, sourceSpan) {
          if (dirMeta.hostProperties) {
              const boundProps = [];
              Object.keys(dirMeta.hostProperties).forEach(propName => {
                  const expression = dirMeta.hostProperties[propName];
                  if (typeof expression === 'string') {
                      this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps);
                  }
                  else {
                      this._reportError(`Value of the host property binding "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
                  }
              });
              return boundProps;
          }
          return null;
      }
      createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {
          const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);
          return boundProps &&
              boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));
      }
      createDirectiveHostEventAsts(dirMeta, sourceSpan) {
          if (dirMeta.hostListeners) {
              const targetEvents = [];
              Object.keys(dirMeta.hostListeners).forEach(propName => {
                  const expression = dirMeta.hostListeners[propName];
                  if (typeof expression === 'string') {
                      this.parseEvent(propName, expression, sourceSpan, [], targetEvents);
                  }
                  else {
                      this._reportError(`Value of the host listener "${propName}" needs to be a string representing an expression but got "${expression}" (${typeof expression})`, sourceSpan);
                  }
              });
              return targetEvents;
          }
          return null;
      }
      parseInterpolation(value, sourceSpan) {
          const sourceInfo = sourceSpan.start.toString();
          try {
              const ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);
              if (ast)
                  this._reportExpressionParserErrors(ast.errors, sourceSpan);
              this._checkPipes(ast, sourceSpan);
              return ast;
          }
          catch (e) {
              this._reportError(`${e}`, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      }
      // Parse an inline template binding. ie `<tag *tplKey="<tplValue>">`
      parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {
          const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan);
          for (let i = 0; i < bindings.length; i++) {
              const binding = bindings[i];
              if (binding.keyIsVar) {
                  targetVars.push(new ParsedVariable(binding.key, binding.name, sourceSpan));
              }
              else if (binding.expression) {
                  this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);
              }
              else {
                  targetMatchableAttrs.push([binding.key, '']);
                  this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);
              }
          }
      }
      _parseTemplateBindings(tplKey, tplValue, sourceSpan) {
          const sourceInfo = sourceSpan.start.toString();
          try {
              const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo);
              this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);
              bindingsResult.templateBindings.forEach((binding) => {
                  if (binding.expression) {
                      this._checkPipes(binding.expression, sourceSpan);
                  }
              });
              bindingsResult.warnings.forEach((warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });
              return bindingsResult.templateBindings;
          }
          catch (e) {
              this._reportError(`${e}`, sourceSpan);
              return [];
          }
      }
      parseLiteralAttr(name, value, sourceSpan, targetMatchableAttrs, targetProps) {
          if (isAnimationLabel(name)) {
              name = name.substring(1);
              if (value) {
                  this._reportError(`Assigning animation triggers via @prop="exp" attributes with an expression is invalid.` +
                      ` Use property bindings (e.g. [@prop]="exp") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);
              }
              this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);
          }
          else {
              targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), ParsedPropertyType.LITERAL_ATTR, sourceSpan));
          }
      }
      parsePropertyBinding(name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {
          let isAnimationProp = false;
          if (name.startsWith(ANIMATE_PROP_PREFIX)) {
              isAnimationProp = true;
              name = name.substring(ANIMATE_PROP_PREFIX.length);
          }
          else if (isAnimationLabel(name)) {
              isAnimationProp = true;
              name = name.substring(1);
          }
          if (isAnimationProp) {
              this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);
          }
          else {
              this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);
          }
      }
      parsePropertyInterpolation(name, value, sourceSpan, targetMatchableAttrs, targetProps) {
          const expr = this.parseInterpolation(value, sourceSpan);
          if (expr) {
              this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);
              return true;
          }
          return false;
      }
      _parsePropertyAst(name, ast, sourceSpan, targetMatchableAttrs, targetProps) {
          targetMatchableAttrs.push([name, ast.source]);
          targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan));
      }
      _parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps) {
          // This will occur when a @trigger is not paired with an expression.
          // For animations it is valid to not have an expression since */void
          // states will be applied by angular when the element is attached/detached
          const ast = this._parseBinding(expression || 'undefined', false, sourceSpan);
          targetMatchableAttrs.push([name, ast.source]);
          targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan));
      }
      _parseBinding(value, isHostBinding, sourceSpan) {
          const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();
          try {
              const ast = isHostBinding ?
                  this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :
                  this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);
              if (ast)
                  this._reportExpressionParserErrors(ast.errors, sourceSpan);
              this._checkPipes(ast, sourceSpan);
              return ast;
          }
          catch (e) {
              this._reportError(`${e}`, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      }
      createBoundElementProperty(elementSelector, boundProp) {
          if (boundProp.isAnimation) {
              return new BoundElementProperty(boundProp.name, 4 /* Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan);
          }
          let unit = null;
          let bindingType = undefined;
          let boundPropertyName = null;
          const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
          let securityContexts = undefined;
          // Check check for special cases (prefix style, attr, class)
          if (parts.length > 1) {
              if (parts[0] == ATTRIBUTE_PREFIX) {
                  boundPropertyName = parts[1];
                  this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
                  securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
                  const nsSeparatorIdx = boundPropertyName.indexOf(':');
                  if (nsSeparatorIdx > -1) {
                      const ns = boundPropertyName.substring(0, nsSeparatorIdx);
                      const name = boundPropertyName.substring(nsSeparatorIdx + 1);
                      boundPropertyName = mergeNsAndName(ns, name);
                  }
                  bindingType = 1 /* Attribute */;
              }
              else if (parts[0] == CLASS_PREFIX) {
                  boundPropertyName = parts[1];
                  bindingType = 2 /* Class */;
                  securityContexts = [SecurityContext.NONE];
              }
              else if (parts[0] == STYLE_PREFIX) {
                  unit = parts.length > 2 ? parts[2] : null;
                  boundPropertyName = parts[1];
                  bindingType = 3 /* Style */;
                  securityContexts = [SecurityContext.STYLE];
              }
          }
          // If not a special case, use the full property name
          if (boundPropertyName === null) {
              boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);
              securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);
              bindingType = 0 /* Property */;
              this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);
          }
          return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan);
      }
      parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          if (isAnimationLabel(name)) {
              name = name.substr(1);
              this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);
          }
          else {
              this._parseRegularEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);
          }
      }
      _parseAnimationEvent(name, expression, sourceSpan, targetEvents) {
          const matches = splitAtPeriod(name, [name, '']);
          const eventName = matches[0];
          const phase = matches[1].toLowerCase();
          if (phase) {
              switch (phase) {
                  case 'start':
                  case 'done':
                      const ast = this._parseAction(expression, sourceSpan);
                      targetEvents.push(new ParsedEvent(eventName, phase, 1 /* Animation */, ast, sourceSpan));
                      break;
                  default:
                      this._reportError(`The provided animation output phase value "${phase}" for "@${eventName}" is not supported (use start or done)`, sourceSpan);
                      break;
              }
          }
          else {
              this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);
          }
      }
      _parseRegularEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          // long format: 'target: eventName'
          const [target, eventName] = splitAtColon(name, [null, name]);
          const ast = this._parseAction(expression, sourceSpan);
          targetMatchableAttrs.push([name, ast.source]);
          targetEvents.push(new ParsedEvent(eventName, target, 0 /* Regular */, ast, sourceSpan));
          // Don't detect directives for event names for now,
          // so don't add the event name to the matchableAttrs
      }
      _parseAction(value, sourceSpan) {
          const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();
          try {
              const ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);
              if (ast) {
                  this._reportExpressionParserErrors(ast.errors, sourceSpan);
              }
              if (!ast || ast.ast instanceof EmptyExpr) {
                  this._reportError(`Empty expressions are not allowed`, sourceSpan);
                  return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
              }
              this._checkPipes(ast, sourceSpan);
              return ast;
          }
          catch (e) {
              this._reportError(`${e}`, sourceSpan);
              return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);
          }
      }
      _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
          this.errors.push(new ParseError(sourceSpan, message, level));
      }
      _reportExpressionParserErrors(errors, sourceSpan) {
          for (const error$$1 of errors) {
              this._reportError(error$$1.message, sourceSpan);
          }
      }
      // Make sure all the used pipes are known in `this.pipesByName`
      _checkPipes(ast, sourceSpan) {
          if (ast && this.pipesByName) {
              const collector = new PipeCollector();
              ast.visit(collector);
              collector.pipes.forEach((ast, pipeName) => {
                  const pipeMeta = this.pipesByName.get(pipeName);
                  if (!pipeMeta) {
                      this._reportError(`The pipe '${pipeName}' could not be found`, new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));
                  }
                  else {
                      this._usedPipes.set(pipeName, pipeMeta);
                  }
              });
          }
      }
      /**
       * @param propName the name of the property / attribute
       * @param sourceSpan
       * @param isAttr true when binding to an attribute
       */
      _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
          const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :
              this._schemaRegistry.validateProperty(propName);
          if (report.error) {
              this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
          }
      }
  }
  class PipeCollector extends RecursiveAstVisitor$1 {
      constructor() {
          super(...arguments);
          this.pipes = new Map();
      }
      visitPipe(ast, context) {
          this.pipes.set(ast.name, ast);
          ast.exp.visit(this);
          this.visitAll(ast.args, context);
          return null;
      }
  }
  function isAnimationLabel(name) {
      return name[0] == '@';
  }
  function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
      const ctxs = [];
      CssSelector.parse(selector).forEach((selector) => {
          const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
          const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())
              .map((selector) => selector.element));
          const possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));
          ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));
      });
      return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class Text$3 {
      constructor(value, sourceSpan) {
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor) { return visitor.visitText(this); }
  }
  class BoundText {
      constructor(value, sourceSpan, i18n) {
          this.value = value;
          this.sourceSpan = sourceSpan;
          this.i18n = i18n;
      }
      visit(visitor) { return visitor.visitBoundText(this); }
  }
  class TextAttribute {
      constructor(name, value, sourceSpan, valueSpan, i18n) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
          this.valueSpan = valueSpan;
          this.i18n = i18n;
      }
      visit(visitor) { return visitor.visitTextAttribute(this); }
  }
  class BoundAttribute {
      constructor(name, type, securityContext, value, unit, sourceSpan, i18n) {
          this.name = name;
          this.type = type;
          this.securityContext = securityContext;
          this.value = value;
          this.unit = unit;
          this.sourceSpan = sourceSpan;
          this.i18n = i18n;
      }
      static fromBoundElementProperty(prop, i18n) {
          return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, i18n);
      }
      visit(visitor) { return visitor.visitBoundAttribute(this); }
  }
  class BoundEvent {
      constructor(name, type, handler, target, phase, sourceSpan) {
          this.name = name;
          this.type = type;
          this.handler = handler;
          this.target = target;
          this.phase = phase;
          this.sourceSpan = sourceSpan;
      }
      static fromParsedEvent(event) {
          const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;
          const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;
          return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan);
      }
      visit(visitor) { return visitor.visitBoundEvent(this); }
  }
  class Element$1$1 {
      constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
          this.name = name;
          this.attributes = attributes;
          this.inputs = inputs;
          this.outputs = outputs;
          this.children = children;
          this.references = references;
          this.sourceSpan = sourceSpan;
          this.startSourceSpan = startSourceSpan;
          this.endSourceSpan = endSourceSpan;
          this.i18n = i18n;
      }
      visit(visitor) { return visitor.visitElement(this); }
  }
  class Template {
      constructor(tagName, attributes, inputs, outputs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
          this.tagName = tagName;
          this.attributes = attributes;
          this.inputs = inputs;
          this.outputs = outputs;
          this.children = children;
          this.references = references;
          this.variables = variables;
          this.sourceSpan = sourceSpan;
          this.startSourceSpan = startSourceSpan;
          this.endSourceSpan = endSourceSpan;
          this.i18n = i18n;
      }
      visit(visitor) { return visitor.visitTemplate(this); }
  }
  class Content {
      constructor(selector, attributes, sourceSpan, i18n) {
          this.selector = selector;
          this.attributes = attributes;
          this.sourceSpan = sourceSpan;
          this.i18n = i18n;
      }
      visit(visitor) { return visitor.visitContent(this); }
  }
  class Variable {
      constructor(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor) { return visitor.visitVariable(this); }
  }
  class Reference {
      constructor(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor) { return visitor.visitReference(this); }
  }
  class Icu$1 {
      constructor(vars, placeholders, sourceSpan, i18n) {
          this.vars = vars;
          this.placeholders = placeholders;
          this.sourceSpan = sourceSpan;
          this.i18n = i18n;
      }
      visit(visitor) { return visitor.visitIcu(this); }
  }
  function visitAll$1(visitor, nodes) {
      const result = [];
      if (visitor.visit) {
          for (const node of nodes) {
              const newNode = visitor.visit(node) || node.visit(visitor);
          }
      }
      else {
          for (const node of nodes) {
              const newNode = node.visit(visitor);
              if (newNode) {
                  result.push(newNode);
              }
          }
      }
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class StyleWithImports {
      constructor(style, styleUrls) {
          this.style = style;
          this.styleUrls = styleUrls;
      }
  }
  function isStyleUrlResolvable(url) {
      if (url == null || url.length === 0 || url[0] == '/')
          return false;
      const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
      return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
  }
  /**
   * Rewrites stylesheets by resolving and removing the @import urls that
   * are either relative or don't have a `package:` scheme
   */
  function extractStyleUrls(resolver, baseUrl, cssText) {
      const foundUrls = [];
      const modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '')
          .replace(CSS_IMPORT_REGEXP, (...m) => {
          const url = m[1] || m[2];
          if (!isStyleUrlResolvable(url)) {
              // Do not attempt to resolve non-package absolute URLs with URI
              // scheme
              return m[0];
          }
          foundUrls.push(resolver.resolve(baseUrl, url));
          return '';
      });
      return new StyleWithImports(modifiedCssText, foundUrls);
  }
  const CSS_IMPORT_REGEXP = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g;
  const CSS_STRIPPABLE_COMMENT_REGEXP = /\/\*(?!#\s*(?:sourceURL|sourceMappingURL)=)[\s\S]+?\*\//g;
  const URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const NG_CONTENT_SELECT_ATTR = 'select';
  const LINK_ELEMENT = 'link';
  const LINK_STYLE_REL_ATTR = 'rel';
  const LINK_STYLE_HREF_ATTR = 'href';
  const LINK_STYLE_REL_VALUE = 'stylesheet';
  const STYLE_ELEMENT = 'style';
  const SCRIPT_ELEMENT = 'script';
  const NG_NON_BINDABLE_ATTR = 'ngNonBindable';
  const NG_PROJECT_AS = 'ngProjectAs';
  function preparseElement(ast) {
      let selectAttr = null;
      let hrefAttr = null;
      let relAttr = null;
      let nonBindable = false;
      let projectAs = '';
      ast.attrs.forEach(attr => {
          const lcAttrName = attr.name.toLowerCase();
          if (lcAttrName == NG_CONTENT_SELECT_ATTR) {
              selectAttr = attr.value;
          }
          else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
              hrefAttr = attr.value;
          }
          else if (lcAttrName == LINK_STYLE_REL_ATTR) {
              relAttr = attr.value;
          }
          else if (attr.name == NG_NON_BINDABLE_ATTR) {
              nonBindable = true;
          }
          else if (attr.name == NG_PROJECT_AS) {
              if (attr.value.length > 0) {
                  projectAs = attr.value;
              }
          }
      });
      selectAttr = normalizeNgContentSelect(selectAttr);
      const nodeName = ast.name.toLowerCase();
      let type = PreparsedElementType.OTHER;
      if (isNgContent(nodeName)) {
          type = PreparsedElementType.NG_CONTENT;
      }
      else if (nodeName == STYLE_ELEMENT) {
          type = PreparsedElementType.STYLE;
      }
      else if (nodeName == SCRIPT_ELEMENT) {
          type = PreparsedElementType.SCRIPT;
      }
      else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
          type = PreparsedElementType.STYLESHEET;
      }
      return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
  }
  var PreparsedElementType;
  (function (PreparsedElementType) {
      PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
      PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
      PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
      PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
      PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
  })(PreparsedElementType || (PreparsedElementType = {}));
  class PreparsedElement {
      constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {
          this.type = type;
          this.selectAttr = selectAttr;
          this.hrefAttr = hrefAttr;
          this.nonBindable = nonBindable;
          this.projectAs = projectAs;
      }
  }
  function normalizeNgContentSelect(selectAttr) {
      if (selectAttr === null || selectAttr.length === 0) {
          return '*';
      }
      return selectAttr;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
  // Group 1 = "bind-"
  const KW_BIND_IDX = 1;
  // Group 2 = "let-"
  const KW_LET_IDX = 2;
  // Group 3 = "ref-/#"
  const KW_REF_IDX = 3;
  // Group 4 = "on-"
  const KW_ON_IDX = 4;
  // Group 5 = "bindon-"
  const KW_BINDON_IDX = 5;
  // Group 6 = "@"
  const KW_AT_IDX = 6;
  // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
  const IDENT_KW_IDX = 7;
  // Group 8 = identifier inside [()]
  const IDENT_BANANA_BOX_IDX = 8;
  // Group 9 = identifier inside []
  const IDENT_PROPERTY_IDX = 9;
  // Group 10 = identifier inside ()
  const IDENT_EVENT_IDX = 10;
  const TEMPLATE_ATTR_PREFIX = '*';
  function htmlAstToRender3Ast(htmlNodes, bindingParser) {
      const transformer = new HtmlAstToIvyAst(bindingParser);
      const ivyNodes = visitAll(transformer, htmlNodes);
      // Errors might originate in either the binding parser or the html to ivy transformer
      const allErrors = bindingParser.errors.concat(transformer.errors);
      const errors = allErrors.filter(e => e.level === ParseErrorLevel.ERROR);
      if (errors.length > 0) {
          const errorString = errors.join('\n');
          throw syntaxError(`Template parse errors:\n${errorString}`, errors);
      }
      return {
          nodes: ivyNodes,
          errors: allErrors,
      };
  }
  class HtmlAstToIvyAst {
      constructor(bindingParser) {
          this.bindingParser = bindingParser;
          this.errors = [];
      }
      // HTML visitor
      visitElement(element) {
          const preparsedElement = preparseElement(element);
          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
              preparsedElement.type === PreparsedElementType.STYLE) {
              // Skipping <script> for security reasons
              // Skipping <style> as we already processed them
              // in the StyleCompiler
              return null;
          }
          if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
              isStyleUrlResolvable(preparsedElement.hrefAttr)) {
              // Skipping stylesheets with either relative urls or package scheme as we already processed
              // them in the StyleCompiler
              return null;
          }
          // Whether the element is a `<ng-template>`
          const isTemplateElement = isNgTemplate(element.name);
          const parsedProperties = [];
          const boundEvents = [];
          const variables = [];
          const references = [];
          const attributes = [];
          const i18nAttrsMeta = {};
          const templateParsedProperties = [];
          const templateVariables = [];
          // Whether the element has any *-attribute
          let elementHasInlineTemplate = false;
          for (const attribute of element.attrs) {
              let hasBinding = false;
              const normalizedName = normalizeAttributeName(attribute.name);
              // `*attr` defines template bindings
              let isTemplateBinding = false;
              if (attribute.i18n) {
                  i18nAttrsMeta[attribute.name] = attribute.i18n;
              }
              if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
                  // *-attributes
                  if (elementHasInlineTemplate) {
                      this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);
                  }
                  isTemplateBinding = true;
                  elementHasInlineTemplate = true;
                  const templateValue = attribute.value;
                  const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);
                  const parsedVariables = [];
                  this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, [], templateParsedProperties, parsedVariables);
                  templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan)));
              }
              else {
                  // Check for variables, events, property bindings, interpolation
                  hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);
              }
              if (!hasBinding && !isTemplateBinding) {
                  // don't include the bindings as attributes as well in the AST
                  attributes.push(this.visitAttribute(attribute));
              }
          }
          const children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);
          let parsedElement;
          if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
              // `<ng-content>`
              if (element.children && !element.children.every(isEmptyTextNode)) {
                  this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);
              }
              const selector = preparsedElement.selectAttr;
              const attrs = element.attrs.map(attr => this.visitAttribute(attr));
              parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);
          }
          else if (isTemplateElement) {
              // `<ng-template>`
              const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
              parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
          }
          else {
              const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);
              parsedElement = new Element$1$1(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
          }
          if (elementHasInlineTemplate) {
              const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);
              // TODO(pk): test for this case
              parsedElement = new Template(parsedElement.name, attrs.literal, attrs.bound, [], [parsedElement], [], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
          }
          return parsedElement;
      }
      visitAttribute(attribute) {
          return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.valueSpan, attribute.i18n);
      }
      visitText(text) {
          return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);
      }
      visitExpansion(expansion) {
          const meta = expansion.i18n;
          // do not generate Icu in case it was created
          // outside of i18n block in a template
          if (!meta) {
              return null;
          }
          const vars = {};
          const placeholders = {};
          // extract VARs from ICUs - we process them separately while
          // assembling resulting message via goog.getMsg function, since
          // we need to pass them to top-level goog.getMsg call
          Object.keys(meta.placeholders).forEach(key => {
              const value = meta.placeholders[key];
              if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
                  const config = this.bindingParser.interpolationConfig;
                  // ICU expression is a plain string, not wrapped into start
                  // and end tags, so we wrap it before passing to binding parser
                  const wrapped = `${config.start}${value}${config.end}`;
                  vars[key] = this._visitTextWithInterpolation(wrapped, expansion.sourceSpan);
              }
              else {
                  placeholders[key] = this._visitTextWithInterpolation(value, expansion.sourceSpan);
              }
          });
          return new Icu$1(vars, placeholders, expansion.sourceSpan, meta);
      }
      visitExpansionCase(expansionCase) { return null; }
      visitComment(comment) { return null; }
      // convert view engine `ParsedProperty` to a format suitable for IVY
      extractAttributes(elementName, properties, i18nPropsMeta) {
          const bound = [];
          const literal = [];
          properties.forEach(prop => {
              const i18n = i18nPropsMeta[prop.name];
              if (prop.isLiteral) {
                  literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, undefined, i18n));
              }
              else {
                  const bep = this.bindingParser.createBoundElementProperty(elementName, prop);
                  bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
              }
          });
          return { bound, literal };
      }
      parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
          const name = normalizeAttributeName(attribute.name);
          const value = attribute.value;
          const srcSpan = attribute.sourceSpan;
          const bindParts = name.match(BIND_NAME_REGEXP);
          let hasBinding = false;
          if (bindParts) {
              hasBinding = true;
              if (bindParts[KW_BIND_IDX] != null) {
                  this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, matchableAttributes, parsedProperties);
              }
              else if (bindParts[KW_LET_IDX]) {
                  if (isTemplateElement) {
                      const identifier = bindParts[IDENT_KW_IDX];
                      this.parseVariable(identifier, value, srcSpan, variables);
                  }
                  else {
                      this.reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
                  }
              }
              else if (bindParts[KW_REF_IDX]) {
                  const identifier = bindParts[IDENT_KW_IDX];
                  this.parseReference(identifier, value, srcSpan, references);
              }
              else if (bindParts[KW_ON_IDX]) {
                  const events = [];
                  this.bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, matchableAttributes, events);
                  addEvents(events, boundEvents);
              }
              else if (bindParts[KW_BINDON_IDX]) {
                  this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, matchableAttributes, parsedProperties);
                  this.parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, matchableAttributes, boundEvents);
              }
              else if (bindParts[KW_AT_IDX]) {
                  this.bindingParser.parseLiteralAttr(name, value, srcSpan, matchableAttributes, parsedProperties);
              }
              else if (bindParts[IDENT_BANANA_BOX_IDX]) {
                  this.bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, matchableAttributes, parsedProperties);
                  this.parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, matchableAttributes, boundEvents);
              }
              else if (bindParts[IDENT_PROPERTY_IDX]) {
                  this.bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, matchableAttributes, parsedProperties);
              }
              else if (bindParts[IDENT_EVENT_IDX]) {
                  const events = [];
                  this.bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, matchableAttributes, events);
                  addEvents(events, boundEvents);
              }
          }
          else {
              hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, matchableAttributes, parsedProperties);
          }
          return hasBinding;
      }
      _visitTextWithInterpolation(value, sourceSpan, i18n) {
          const valueNoNgsp = replaceNgsp(value);
          const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);
          return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);
      }
      parseVariable(identifier, value, sourceSpan, variables) {
          if (identifier.indexOf('-') > -1) {
              this.reportError(`"-" is not allowed in variable names`, sourceSpan);
          }
          variables.push(new Variable(identifier, value, sourceSpan));
      }
      parseReference(identifier, value, sourceSpan, references) {
          if (identifier.indexOf('-') > -1) {
              this.reportError(`"-" is not allowed in reference names`, sourceSpan);
          }
          references.push(new Reference(identifier, value, sourceSpan));
      }
      parseAssignmentEvent(name, expression, sourceSpan, targetMatchableAttrs, boundEvents) {
          const events = [];
          this.bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, targetMatchableAttrs, events);
          addEvents(events, boundEvents);
      }
      reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
          this.errors.push(new ParseError(sourceSpan, message, level));
      }
  }
  class NonBindableVisitor {
      visitElement(ast) {
          const preparsedElement = preparseElement(ast);
          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
              preparsedElement.type === PreparsedElementType.STYLE ||
              preparsedElement.type === PreparsedElementType.STYLESHEET) {
              // Skipping <script> for security reasons
              // Skipping <style> and stylesheets as we already processed them
              // in the StyleCompiler
              return null;
          }
          const children = visitAll(this, ast.children, null);
          return new Element$1$1(ast.name, visitAll(this, ast.attrs), 
          /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
      }
      visitComment(comment) { return null; }
      visitAttribute(attribute) {
          return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, undefined, attribute.i18n);
      }
      visitText(text) { return new Text$3(text.value, text.sourceSpan); }
      visitExpansion(expansion) { return null; }
      visitExpansionCase(expansionCase) { return null; }
  }
  const NON_BINDABLE_VISITOR = new NonBindableVisitor();
  function normalizeAttributeName(attrName) {
      return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
  }
  function addEvents(events, boundEvents) {
      boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));
  }
  function isEmptyTextNode(node) {
      return node instanceof Text$2 && node.value.trim().length == 0;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  var TagType;
  (function (TagType) {
      TagType[TagType["ELEMENT"] = 0] = "ELEMENT";
      TagType[TagType["TEMPLATE"] = 1] = "TEMPLATE";
  })(TagType || (TagType = {}));
  /**
   * Generates an object that is used as a shared state between parent and all child contexts.
   */
  function setupRegistry() {
      return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };
  }
  /**
   * I18nContext is a helper class which keeps track of all i18n-related aspects
   * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.
   *
   * When we enter a nested template, the top-level context is being passed down
   * to the nested component, which uses this context to generate a child instance
   * of I18nContext class (to handle nested template) and at the end, reconciles it back
   * with the parent context.
   *
   * @param index Instruction index of i18nStart, which initiates this context
   * @param ref Reference to a translation const that represents the content if thus context
   * @param level Nestng level defined for child contexts
   * @param templateIndex Instruction index of a template which this context belongs to
   * @param meta Meta information (id, meaning, description, etc) associated with this context
   */
  class I18nContext {
      constructor(index, ref, level = 0, templateIndex = null, meta, registry) {
          this.index = index;
          this.ref = ref;
          this.level = level;
          this.templateIndex = templateIndex;
          this.meta = meta;
          this.registry = registry;
          this.bindings = new Set();
          this.placeholders = new Map();
          this._unresolvedCtxCount = 0;
          this._registry = registry || setupRegistry();
          this.id = this._registry.getUniqueId();
      }
      appendTag(type, node, index, closed) {
          if (node.isVoid && closed) {
              return; // ignore "close" for void tags
          }
          const ph = node.isVoid || !closed ? node.startName : node.closeName;
          const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };
          updatePlaceholderMap(this.placeholders, ph, content);
      }
      get icus() { return this._registry.icus; }
      get isRoot() { return this.level === 0; }
      get isResolved() { return this._unresolvedCtxCount === 0; }
      getSerializedPlaceholders() {
          const result = new Map();
          this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));
          return result;
      }
      // public API to accumulate i18n-related content
      appendBinding(binding) { this.bindings.add(binding); }
      appendIcu(name, ref) {
          updatePlaceholderMap(this._registry.icus, name, ref);
      }
      appendBoundText(node) {
          const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
          phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));
      }
      appendTemplate(node, index) {
          // add open and close tags at the same time,
          // since we process nested templates separately
          this.appendTag(TagType.TEMPLATE, node, index, false);
          this.appendTag(TagType.TEMPLATE, node, index, true);
          this._unresolvedCtxCount++;
      }
      appendElement(node, index, closed) {
          this.appendTag(TagType.ELEMENT, node, index, closed);
      }
      /**
       * Generates an instance of a child context based on the root one,
       * when we enter a nested template within I18n section.
       *
       * @param index Instruction index of corresponding i18nStart, which initiates this context
       * @param templateIndex Instruction index of a template which this context belongs to
       * @param meta Meta information (id, meaning, description, etc) associated with this context
       *
       * @returns I18nContext instance
       */
      forkChildContext(index, templateIndex, meta) {
          return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
      }
      /**
       * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).
       *
       * @param context Child I18nContext instance to be reconciled with parent context.
       */
      reconcileChildContext(context) {
          // set the right context id for open and close
          // template tags, so we can use it as sub-block ids
          ['start', 'close'].forEach((op) => {
              const key = context.meta[`${op}Name`];
              const phs = this.placeholders.get(key) || [];
              const tag = phs.find(findTemplateFn(this.id, context.templateIndex));
              if (tag) {
                  tag.ctx = context.id;
              }
          });
          // reconcile placeholders
          const childPhs = context.placeholders;
          childPhs.forEach((values, key) => {
              const phs = this.placeholders.get(key);
              if (!phs) {
                  this.placeholders.set(key, values);
                  return;
              }
              // try to find matching template...
              const tmplIdx = findIndex(phs, findTemplateFn(context.id, context.templateIndex));
              if (tmplIdx >= 0) {
                  // ... if found - replace it with nested template content
                  const isCloseTag = key.startsWith('CLOSE');
                  const isTemplateTag = key.endsWith('NG-TEMPLATE');
                  if (isTemplateTag) {
                      // current template's content is placed before or after
                      // parent template tag, depending on the open/close atrribute
                      phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);
                  }
                  else {
                      const idx = isCloseTag ? values.length - 1 : 0;
                      values[idx].tmpl = phs[tmplIdx];
                      phs.splice(tmplIdx, 1, ...values);
                  }
              }
              else {
                  // ... otherwise just append content to placeholder value
                  phs.push(...values);
              }
              this.placeholders.set(key, phs);
          });
          this._unresolvedCtxCount--;
      }
  }
  //
  // Helper methods
  //
  function wrap(symbol, index, contextId, closed) {
      const state = closed ? '/' : '';
      return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);
  }
  function wrapTag(symbol, { index, ctx, isVoid }, closed) {
      return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :
          wrap(symbol, index, ctx, closed);
  }
  function findTemplateFn(ctx, templateIndex) {
      return (token) => typeof token === 'object' && token.type === TagType.TEMPLATE &&
          token.index === templateIndex && token.ctx === ctx;
  }
  function serializePlaceholderValue(value) {
      const element = (data, closed) => wrapTag('#', data, closed);
      const template = (data, closed) => wrapTag('*', data, closed);
      switch (value.type) {
          case TagType.ELEMENT:
              // close element tag
              if (value.closed) {
                  return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');
              }
              // open element tag that also initiates a template
              if (value.tmpl) {
                  return template(value.tmpl) + element(value) +
                      (value.isVoid ? template(value.tmpl, true) : '');
              }
              return element(value);
          case TagType.TEMPLATE:
              return template(value, value.closed);
          default:
              return value;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const TAG_TO_PLACEHOLDER_NAMES = {
      'A': 'LINK',
      'B': 'BOLD_TEXT',
      'BR': 'LINE_BREAK',
      'EM': 'EMPHASISED_TEXT',
      'H1': 'HEADING_LEVEL1',
      'H2': 'HEADING_LEVEL2',
      'H3': 'HEADING_LEVEL3',
      'H4': 'HEADING_LEVEL4',
      'H5': 'HEADING_LEVEL5',
      'H6': 'HEADING_LEVEL6',
      'HR': 'HORIZONTAL_RULE',
      'I': 'ITALIC_TEXT',
      'LI': 'LIST_ITEM',
      'LINK': 'MEDIA_LINK',
      'OL': 'ORDERED_LIST',
      'P': 'PARAGRAPH',
      'Q': 'QUOTATION',
      'S': 'STRIKETHROUGH_TEXT',
      'SMALL': 'SMALL_TEXT',
      'SUB': 'SUBSTRIPT',
      'SUP': 'SUPERSCRIPT',
      'TBODY': 'TABLE_BODY',
      'TD': 'TABLE_CELL',
      'TFOOT': 'TABLE_FOOTER',
      'TH': 'TABLE_HEADER_CELL',
      'THEAD': 'TABLE_HEADER',
      'TR': 'TABLE_ROW',
      'TT': 'MONOSPACED_TEXT',
      'U': 'UNDERLINED_TEXT',
      'UL': 'UNORDERED_LIST',
  };
  /**
   * Creates unique names for placeholder with different content.
   *
   * Returns the same placeholder name when the content is identical.
   */
  class PlaceholderRegistry {
      constructor() {
          // Count the occurrence of the base name top generate a unique name
          this._placeHolderNameCounts = {};
          // Maps signature to placeholder names
          this._signatureToName = {};
      }
      getStartTagPlaceholderName(tag, attrs, isVoid) {
          const signature = this._hashTag(tag, attrs, isVoid);
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          const upperTag = tag.toUpperCase();
          const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
          const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);
          this._signatureToName[signature] = name;
          return name;
      }
      getCloseTagPlaceholderName(tag) {
          const signature = this._hashClosingTag(tag);
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          const upperTag = tag.toUpperCase();
          const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;
          const name = this._generateUniqueName(`CLOSE_${baseName}`);
          this._signatureToName[signature] = name;
          return name;
      }
      getPlaceholderName(name, content) {
          const upperName = name.toUpperCase();
          const signature = `PH: ${upperName}=${content}`;
          if (this._signatureToName[signature]) {
              return this._signatureToName[signature];
          }
          const uniqueName = this._generateUniqueName(upperName);
          this._signatureToName[signature] = uniqueName;
          return uniqueName;
      }
      getUniquePlaceholder(name) {
          return this._generateUniqueName(name.toUpperCase());
      }
      // Generate a hash for a tag - does not take attribute order into account
      _hashTag(tag, attrs, isVoid) {
          const start = `<${tag}`;
          const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');
          const end = isVoid ? '/>' : `></${tag}>`;
          return start + strAttrs + end;
      }
      _hashClosingTag(tag) { return this._hashTag(`/${tag}`, {}, false); }
      _generateUniqueName(base) {
          const seen = this._placeHolderNameCounts.hasOwnProperty(base);
          if (!seen) {
              this._placeHolderNameCounts[base] = 1;
              return base;
          }
          const id = this._placeHolderNameCounts[base];
          this._placeHolderNameCounts[base] = id + 1;
          return `${base}_${id}`;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const _expParser = new Parser(new Lexer());
  /**
   * Returns a function converting html nodes to an i18n Message given an interpolationConfig
   */
  function createI18nMessageFactory(interpolationConfig) {
      const visitor = new _I18nVisitor(_expParser, interpolationConfig);
      return (nodes, meaning, description, id, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, id, visitNodeFn);
  }
  class _I18nVisitor {
      constructor(_expressionParser, _interpolationConfig) {
          this._expressionParser = _expressionParser;
          this._interpolationConfig = _interpolationConfig;
      }
      toI18nMessage(nodes, meaning, description, id, visitNodeFn) {
          this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;
          this._icuDepth = 0;
          this._placeholderRegistry = new PlaceholderRegistry();
          this._placeholderToContent = {};
          this._placeholderToMessage = {};
          this._visitNodeFn = visitNodeFn;
          const i18nodes = visitAll(this, nodes, {});
          return new Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);
      }
      _visitNode(html, i18n) {
          if (this._visitNodeFn) {
              this._visitNodeFn(html, i18n);
          }
          return i18n;
      }
      visitElement(el, context) {
          const children = visitAll(this, el.children);
          const attrs = {};
          el.attrs.forEach(attr => {
              // Do not visit the attributes, translatable ones are top-level ASTs
              attrs[attr.name] = attr.value;
          });
          const isVoid = getHtmlTagDefinition(el.name).isVoid;
          const startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
          this._placeholderToContent[startPhName] = el.sourceSpan.toString();
          let closePhName = '';
          if (!isVoid) {
              closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);
              this._placeholderToContent[closePhName] = `</${el.name}>`;
          }
          const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);
          return this._visitNode(el, node);
      }
      visitAttribute(attribute, context) {
          const node = this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);
          return this._visitNode(attribute, node);
      }
      visitText(text, context) {
          const node = this._visitTextWithInterpolation(text.value, text.sourceSpan);
          return this._visitNode(text, node);
      }
      visitComment(comment, context) { return null; }
      visitExpansion(icu, context) {
          this._icuDepth++;
          const i18nIcuCases = {};
          const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
          icu.cases.forEach((caze) => {
              i18nIcuCases[caze.value] = new Container(caze.expression.map((node) => node.visit(this, {})), caze.expSourceSpan);
          });
          this._icuDepth--;
          if (this._isIcu || this._icuDepth > 0) {
              // Returns an ICU node when:
              // - the message (vs a part of the message) is an ICU message, or
              // - the ICU message is nested.
              const expPh = this._placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);
              i18nIcu.expressionPlaceholder = expPh;
              this._placeholderToContent[expPh] = icu.switchValue;
              return this._visitNode(icu, i18nIcu);
          }
          // Else returns a placeholder
          // ICU placeholders should not be replaced with their original content but with the their
          // translations. We need to create a new visitor (they are not re-entrant) to compute the
          // message id.
          // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg
          const phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
          const visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);
          this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');
          const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
          return this._visitNode(icu, node);
      }
      visitExpansionCase(icuCase, context) {
          throw new Error('Unreachable code');
      }
      _visitTextWithInterpolation(text, sourceSpan) {
          const splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);
          if (!splitInterpolation) {
              // No expression, return a single text
              return new Text(text, sourceSpan);
          }
          // Return a group of text + expressions
          const nodes = [];
          const container = new Container(nodes, sourceSpan);
          const { start: sDelimiter, end: eDelimiter } = this._interpolationConfig;
          for (let i = 0; i < splitInterpolation.strings.length - 1; i++) {
              const expression = splitInterpolation.expressions[i];
              const baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';
              const phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);
              if (splitInterpolation.strings[i].length) {
                  // No need to add empty strings
                  nodes.push(new Text(splitInterpolation.strings[i], sourceSpan));
              }
              nodes.push(new Placeholder(expression, phName, sourceSpan));
              this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;
          }
          // The last index contains no expression
          const lastStringIdx = splitInterpolation.strings.length - 1;
          if (splitInterpolation.strings[lastStringIdx].length) {
              nodes.push(new Text(splitInterpolation.strings[lastStringIdx], sourceSpan));
          }
          return container;
      }
  }
  const _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
  function _extractPlaceholderName(input) {
      return input.split(_CUSTOM_PH_EXP)[2];
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function setI18nRefs(html, i18n) {
      html.i18n = i18n;
  }
  /**
   * This visitor walks over HTML parse tree and converts information stored in
   * i18n-related attributes ("i18n" and "i18n-*") into i18n meta object that is
   * stored with other element's and attribute's information.
   */
  class I18nMetaVisitor {
      constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false) {
          this.interpolationConfig = interpolationConfig;
          this.keepI18nAttrs = keepI18nAttrs;
          // i18n message generation factory
          this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
      }
      _generateI18nMessage(nodes, meta = '', visitNodeFn) {
          const parsed = typeof meta === 'string' ? parseI18nMeta(meta) : metaFromI18nMessage(meta);
          const message = this._createI18nMessage(nodes, parsed.meaning || '', parsed.description || '', parsed.id || '', visitNodeFn);
          if (!message.id) {
              // generate (or restore) message id if not specified in template
              message.id = typeof meta !== 'string' && meta.id || decimalDigest(message);
          }
          return message;
      }
      visitElement(element, context) {
          if (hasI18nAttrs(element)) {
              const attrs = [];
              const attrsMeta = {};
              for (const attr of element.attrs) {
                  if (attr.name === I18N_ATTR) {
                      // root 'i18n' node attribute
                      const i18n = element.i18n || attr.value;
                      const message = this._generateI18nMessage(element.children, i18n, setI18nRefs);
                      // do not assign empty i18n meta
                      if (message.nodes.length) {
                          element.i18n = message;
                      }
                  }
                  else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {
                      // 'i18n-*' attributes
                      const key = attr.name.slice(I18N_ATTR_PREFIX.length);
                      attrsMeta[key] = attr.value;
                  }
                  else {
                      // non-i18n attributes
                      attrs.push(attr);
                  }
              }
              // set i18n meta for attributes
              if (Object.keys(attrsMeta).length) {
                  for (const attr of attrs) {
                      const meta = attrsMeta[attr.name];
                      // do not create translation for empty attributes
                      if (meta !== undefined && attr.value) {
                          attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
                      }
                  }
              }
              if (!this.keepI18nAttrs) {
                  // update element's attributes,
                  // keeping only non-i18n related ones
                  element.attrs = attrs;
              }
          }
          visitAll(this, element.children);
          return element;
      }
      visitExpansion(expansion, context) {
          let message;
          const meta = expansion.i18n;
          if (meta instanceof IcuPlaceholder) {
              // set ICU placeholder name (e.g. "ICU_1"),
              // generated while processing root element contents,
              // so we can reference it when we output translation
              const name = meta.name;
              message = this._generateI18nMessage([expansion], meta);
              const icu = icuFromI18nMessage(message);
              icu.name = name;
          }
          else {
              // when ICU is a root level translation
              message = this._generateI18nMessage([expansion], meta);
          }
          expansion.i18n = message;
          return expansion;
      }
      visitText(text, context) { return text; }
      visitAttribute(attribute, context) { return attribute; }
      visitComment(comment, context) { return comment; }
      visitExpansionCase(expansionCase, context) { return expansionCase; }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const formatPh = (value) => `{$${formatI18nPlaceholderName(value)}}`;
  /**
   * This visitor walks over i18n tree and generates its string representation,
   * including ICUs and placeholders in {$PLACEHOLDER} format.
   */
  class SerializerVisitor {
      visitText(text, context) { return text.value; }
      visitContainer(container, context) {
          return container.children.map(child => child.visit(this)).join('');
      }
      visitIcu(icu, context) {
          const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);
          return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;
      }
      visitTagPlaceholder(ph, context) {
          return ph.isVoid ?
              formatPh(ph.startName) :
              `${formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${formatPh(ph.closeName)}`;
      }
      visitPlaceholder(ph, context) { return formatPh(ph.name); }
      visitIcuPlaceholder(ph, context) { return formatPh(ph.name); }
  }
  const serializerVisitor$1 = new SerializerVisitor();
  function getSerializedI18nContent(message) {
      return message.nodes.map(node => node.visit(serializerVisitor$1, null)).join('');
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function mapBindingToInstruction(type) {
      switch (type) {
          case 0 /* Property */:
          case 4 /* Animation */:
              return Identifiers$1.elementProperty;
          case 2 /* Class */:
              return Identifiers$1.elementClassProp;
          case 1 /* Attribute */:
              return Identifiers$1.elementAttribute;
          default:
              return undefined;
      }
  }
  //  if (rf & flags) { .. }
  function renderFlagCheckIfStmt(flags, statements) {
      return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
  }
  // Default selector used by `<ng-content>` if none specified
  const DEFAULT_NG_CONTENT_SELECTOR = '*';
  // Selector attribute name of `<ng-content>`
  const NG_CONTENT_SELECT_ATTR$1 = 'select';
  class TemplateDefinitionBuilder {
      constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, viewQueries, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds) {
          this.constantPool = constantPool;
          this.level = level;
          this.contextName = contextName;
          this.i18nContext = i18nContext;
          this.templateIndex = templateIndex;
          this.templateName = templateName;
          this.viewQueries = viewQueries;
          this.directiveMatcher = directiveMatcher;
          this.directives = directives;
          this.pipeTypeByName = pipeTypeByName;
          this.pipes = pipes;
          this._namespace = _namespace;
          this.relativeContextFilePath = relativeContextFilePath;
          this.i18nUseExternalIds = i18nUseExternalIds;
          this._dataIndex = 0;
          this._bindingContext = 0;
          this._prefixCode = [];
          /**
           * List of callbacks to generate creation mode instructions. We store them here as we process
           * the template so bindings in listeners are resolved only once all nodes have been visited.
           * This ensures all local refs and context variables are available for matching.
           */
          this._creationCodeFns = [];
          /**
           * List of callbacks to generate update mode instructions. We store them here as we process
           * the template so bindings are resolved only once all nodes have been visited. This ensures
           * all local refs and context variables are available for matching.
           */
          this._updateCodeFns = [];
          /** Temporary variable declarations generated from visiting pipes, literals, etc. */
          this._tempVariables = [];
          /**
           * List of callbacks to build nested templates. Nested templates must not be visited until
           * after the parent template has finished visiting all of its nodes. This ensures that all
           * local ref bindings in nested templates are able to find local ref values if the refs
           * are defined after the template declaration.
           */
          this._nestedTemplateFns = [];
          this._unsupported = unsupported;
          // i18n context local to this template
          this.i18n = null;
          // Number of slots to reserve for pureFunctions
          this._pureFunctionSlots = 0;
          // Number of binding slots
          this._bindingSlots = 0;
          // Whether the template includes <ng-content> tags.
          this._hasNgContent = false;
          // Selectors found in the <ng-content> tags in the template.
          this._ngContentSelectors = [];
          // Number of non-default selectors found in all parent templates of this template. We need to
          // track it to properly adjust projection bucket index in the `projection` instruction.
          this._ngContentSelectorsOffset = 0;
          // These should be handled in the template or element directly.
          this.visitReference = invalid$1;
          this.visitVariable = invalid$1;
          this.visitTextAttribute = invalid$1;
          this.visitBoundAttribute = invalid$1;
          this.visitBoundEvent = invalid$1;
          // view queries can take up space in data and allocation happens earlier (in the "viewQuery"
          // function)
          this._dataIndex = viewQueries.length;
          this._bindingScope = parentBindingScope.nestedScope(level);
          // Turn the relative context file path into an identifier by replacing non-alphanumeric
          // characters with underscores.
          this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';
          this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {
              const pipeType = pipeTypeByName.get(name);
              if (pipeType) {
                  this.pipes.add(pipeType);
              }
              this._bindingScope.set(this.level, localName, value);
              this.creationInstruction(null, Identifiers$1.pipe, [literal(slot), literal(name)]);
          });
      }
      registerContextVariables(variable$$1) {
          const scopedName = this._bindingScope.freshReferenceName();
          const retrievalLevel = this.level;
          const lhs = variable(variable$$1.name + scopedName);
          this._bindingScope.set(retrievalLevel, variable$$1.name, lhs, 1 /* CONTEXT */, (scope, relativeLevel) => {
              let rhs;
              if (scope.bindingLevel === retrievalLevel) {
                  // e.g. ctx
                  rhs = variable(CONTEXT_NAME);
              }
              else {
                  const sharedCtxVar = scope.getSharedContextName(retrievalLevel);
                  // e.g. ctx_r0   OR  x(2);
                  rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
              }
              // e.g. const $item$ = x(2).$implicit;
              return [lhs.set(rhs.prop(variable$$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
          });
      }
      buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {
          this._ngContentSelectorsOffset = ngContentSelectorsOffset;
          if (this._namespace !== Identifiers$1.namespaceHTML) {
              this.creationInstruction(null, this._namespace);
          }
          // Create variable bindings
          variables.forEach(v => this.registerContextVariables(v));
          // Initiate i18n context in case:
          // - this template has parent i18n context
          // - or the template has i18n meta associated with it,
          //   but it's not initiated by the Element (e.g. <ng-template i18n>)
          const initI18nContext = this.i18nContext || (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&
              !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));
          const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);
          if (initI18nContext) {
              this.i18nStart(null, i18n, selfClosingI18nInstruction);
          }
          // This is the initial pass through the nodes of this template. In this pass, we
          // queue all creation mode and update mode instructions for generation in the second
          // pass. It's necessary to separate the passes to ensure local refs are defined before
          // resolving bindings. We also count bindings in this pass as we walk bound expressions.
          visitAll$1(this, nodes);
          // Add total binding count to pure function count so pure function instructions are
          // generated with the correct slot offset when update instructions are processed.
          this._pureFunctionSlots += this._bindingSlots;
          // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and
          // `pipeBind` update instructions), so we have to update the slot offsets manually
          // to account for bindings.
          this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);
          // Nested templates must be processed before creation instructions so template()
          // instructions can be generated with the correct internal const count.
          this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());
          // Output the `projectionDef` instruction when some `<ng-content>` are present.
          // The `projectionDef` instruction only emitted for the component template and it is skipped for
          // nested templates (<ng-template> tags).
          if (this.level === 0 && this._hasNgContent) {
              const parameters = [];
              // Only selectors with a non-default value are generated
              if (this._ngContentSelectors.length) {
                  const r3Selectors = this._ngContentSelectors.map(s => parseSelectorToR3Selector(s));
                  // `projectionDef` needs both the parsed and raw value of the selectors
                  const parsed = this.constantPool.getConstLiteral(asLiteral(r3Selectors), true);
                  const unParsed = this.constantPool.getConstLiteral(asLiteral(this._ngContentSelectors), true);
                  parameters.push(parsed, unParsed);
              }
              // Since we accumulate ngContent selectors while processing template elements,
              // we *prepend* `projectionDef` to creation instructions block, to put it before
              // any `projection` instructions
              this.creationInstruction(null, Identifiers$1.projectionDef, parameters, /* prepend */ true);
          }
          if (initI18nContext) {
              this.i18nEnd(null, selfClosingI18nInstruction);
          }
          // Generate all the creation mode instructions (e.g. resolve bindings in listeners)
          const creationStatements = this._creationCodeFns.map((fn$$1) => fn$$1());
          // Generate all the update mode instructions (e.g. resolve property or text bindings)
          const updateStatements = this._updateCodeFns.map((fn$$1) => fn$$1());
          //  Variable declaration must occur after binding resolution so we can generate context
          //  instructions that build on each other.
          // e.g. const b = nextContext().$implicit(); const b = nextContext();
          const creationVariables = this._bindingScope.viewSnapshotStatements();
          const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);
          const creationBlock = creationStatements.length > 0 ?
              [renderFlagCheckIfStmt(1 /* Create */, creationVariables.concat(creationStatements))] :
              [];
          const updateBlock = updateStatements.length > 0 ?
              [renderFlagCheckIfStmt(2 /* Update */, updateVariables.concat(updateStatements))] :
              [];
          return fn(
          // i.e. (rf: RenderFlags, ctx: any)
          [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
              // Temporary variable declarations for query refresh (i.e. let _t: any;)
              ...this._prefixCode,
              // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })
              ...creationBlock,
              // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})
              ...updateBlock,
          ], INFERRED_TYPE, null, this.templateName);
      }
      // LocalResolver
      getLocal(name) { return this._bindingScope.get(name); }
      i18nTranslate(message, params = {}, ref, transformFn) {
          const _ref = ref || this.i18nAllocateRef(message.id);
          const _params = {};
          if (params && Object.keys(params).length) {
              Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key)] = params[key]);
          }
          const meta = metaFromI18nMessage(message);
          const content = getSerializedI18nContent(message);
          const statements = getTranslationDeclStmts(_ref, content, meta, _params, transformFn);
          this.constantPool.statements.push(...statements);
          return _ref;
      }
      i18nAppendBindings(expressions) {
          if (!this.i18n || !expressions.length)
              return;
          const implicit = variable(CONTEXT_NAME);
          expressions.forEach(expression => {
              const binding = this.convertExpressionBinding(implicit, expression);
              this.i18n.appendBinding(binding);
          });
      }
      i18nBindProps(props) {
          const bound = {};
          Object.keys(props).forEach(key => {
              const prop = props[key];
              if (prop instanceof Text$3) {
                  bound[key] = literal(prop.value);
              }
              else {
                  const value = prop.value.visit(this._valueConverter);
                  this.allocateBindingSlots(value);
                  if (value instanceof Interpolation) {
                      const { strings, expressions } = value;
                      const { id, bindings } = this.i18n;
                      const label = assembleI18nBoundString(strings, bindings.size, id);
                      this.i18nAppendBindings(expressions);
                      bound[key] = literal(label);
                  }
              }
          });
          return bound;
      }
      i18nAllocateRef(messageId) {
          let name;
          const suffix = this.fileBasedI18nSuffix.toUpperCase();
          if (this.i18nUseExternalIds) {
              const prefix = getTranslationConstPrefix(`EXTERNAL_`);
              const uniqueSuffix = this.constantPool.uniqueName(suffix);
              name = `${prefix}${messageId}$$${uniqueSuffix}`;
          }
          else {
              const prefix = getTranslationConstPrefix(suffix);
              name = this.constantPool.uniqueName(prefix);
          }
          return variable(name);
      }
      i18nUpdateRef(context) {
          const { icus, meta, isRoot, isResolved } = context;
          if (isRoot && isResolved && !isSingleI18nIcu(meta)) {
              const placeholders = context.getSerializedPlaceholders();
              let icuMapping = {};
              let params = placeholders.size ? placeholdersToParams(placeholders) : {};
              if (icus.size) {
                  icus.forEach((refs, key) => {
                      if (refs.length === 1) {
                          // if we have one ICU defined for a given
                          // placeholder - just output its reference
                          params[key] = refs[0];
                      }
                      else {
                          // ... otherwise we need to activate post-processing
                          // to replace ICU placeholders with proper values
                          const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);
                          params[key] = literal(placeholder);
                          icuMapping[key] = literalArr(refs);
                      }
                  });
              }
              // translation requires post processing in 2 cases:
              // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])
              // - if we have multiple ICUs that refer to the same placeholder name
              const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) ||
                  Object.keys(icuMapping).length;
              let transformFn;
              if (needsPostprocessing) {
                  transformFn = (raw) => {
                      const args = [raw];
                      if (Object.keys(icuMapping).length) {
                          args.push(mapLiteral(icuMapping, true));
                      }
                      return instruction(null, Identifiers$1.i18nPostprocess, args);
                  };
              }
              this.i18nTranslate(meta, params, context.ref, transformFn);
          }
      }
      i18nStart(span = null, meta, selfClosing) {
          const index = this.allocateDataSlot();
          if (this.i18nContext) {
              this.i18n = this.i18nContext.forkChildContext(index, this.templateIndex, meta);
          }
          else {
              const ref = this.i18nAllocateRef(meta.id);
              this.i18n = new I18nContext(index, ref, 0, this.templateIndex, meta);
          }
          // generate i18nStart instruction
          const { id, ref } = this.i18n;
          const params = [literal(index), ref];
          if (id > 0) {
              // do not push 3rd argument (sub-block id)
              // into i18nStart call for top level i18n context
              params.push(literal(id));
          }
          this.creationInstruction(span, selfClosing ? Identifiers$1.i18n : Identifiers$1.i18nStart, params);
      }
      i18nEnd(span = null, selfClosing) {
          if (!this.i18n) {
              throw new Error('i18nEnd is executed with no i18n context present');
          }
          if (this.i18nContext) {
              this.i18nContext.reconcileChildContext(this.i18n);
              this.i18nUpdateRef(this.i18nContext);
          }
          else {
              this.i18nUpdateRef(this.i18n);
          }
          // setup accumulated bindings
          const { index, bindings } = this.i18n;
          if (bindings.size) {
              bindings.forEach(binding => this.updateInstruction(span, Identifiers$1.i18nExp, [binding]));
              this.updateInstruction(span, Identifiers$1.i18nApply, [literal(index)]);
          }
          if (!selfClosing) {
              this.creationInstruction(span, Identifiers$1.i18nEnd);
          }
          this.i18n = null; // reset local i18n context
      }
      visitContent(ngContent) {
          this._hasNgContent = true;
          const slot = this.allocateDataSlot();
          let selectorIndex = ngContent.selector === DEFAULT_NG_CONTENT_SELECTOR ?
              0 :
              this._ngContentSelectors.push(ngContent.selector) + this._ngContentSelectorsOffset;
          const parameters = [literal(slot)];
          const attributeAsList = [];
          ngContent.attributes.forEach((attribute) => {
              const { name, value } = attribute;
              if (name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1) {
                  attributeAsList.push(name, value);
              }
          });
          if (attributeAsList.length > 0) {
              parameters.push(literal(selectorIndex), asLiteral(attributeAsList));
          }
          else if (selectorIndex !== 0) {
              parameters.push(literal(selectorIndex));
          }
          this.creationInstruction(ngContent.sourceSpan, Identifiers$1.projection, parameters);
      }
      getNamespaceInstruction(namespaceKey) {
          switch (namespaceKey) {
              case 'math':
                  return Identifiers$1.namespaceMathML;
              case 'svg':
                  return Identifiers$1.namespaceSVG;
              default:
                  return Identifiers$1.namespaceHTML;
          }
      }
      addNamespaceInstruction(nsInstruction, element) {
          this._namespace = nsInstruction;
          this.creationInstruction(element.sourceSpan, nsInstruction);
      }
      visitElement(element) {
          const elementIndex = this.allocateDataSlot();
          const stylingBuilder = new StylingBuilder(literal(elementIndex), null);
          let isNonBindableMode = false;
          const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);
          if (isI18nRootElement && this.i18n) {
              throw new Error(`Could not mark an element as translatable inside of a translatable section`);
          }
          const i18nAttrs = [];
          const outputAttrs = [];
          const [namespaceKey, elementName] = splitNsName(element.name);
          const isNgContainer$$1 = isNgContainer(element.name);
          // Handle styling, i18n, ngNonBindable attributes
          for (const attr of element.attributes) {
              const { name, value } = attr;
              if (name === NON_BINDABLE_ATTR) {
                  isNonBindableMode = true;
              }
              else if (name === 'style') {
                  stylingBuilder.registerStyleAttr(value);
              }
              else if (name === 'class') {
                  stylingBuilder.registerClassAttr(value);
              }
              else if (attr.i18n) {
                  i18nAttrs.push(attr);
              }
              else {
                  outputAttrs.push(attr);
              }
          }
          // Match directives on non i18n attributes
          this.matchDirectives(element.name, element);
          // Regular element or ng-container creation mode
          const parameters = [literal(elementIndex)];
          if (!isNgContainer$$1) {
              parameters.push(literal(elementName));
          }
          // Add the attributes
          const attributes = [];
          const allOtherInputs = [];
          element.inputs.forEach((input) => {
              if (!stylingBuilder.registerBoundInput(input)) {
                  if (input.type === 0 /* Property */) {
                      if (input.i18n) {
                          i18nAttrs.push(input);
                      }
                      else {
                          allOtherInputs.push(input);
                      }
                  }
                  else {
                      allOtherInputs.push(input);
                  }
              }
          });
          outputAttrs.forEach(attr => attributes.push(literal(attr.name), literal(attr.value)));
          // this will build the instructions so that they fall into the following syntax
          // add attributes for directive matching purposes
          attributes.push(...this.prepareSyntheticAndSelectOnlyAttrs(allOtherInputs, element.outputs, stylingBuilder));
          parameters.push(this.toAttrsParam(attributes));
          // local refs (ex.: <div #foo #bar="baz">)
          parameters.push(this.prepareRefsParameter(element.references));
          const wasInNamespace = this._namespace;
          const currentNamespace = this.getNamespaceInstruction(namespaceKey);
          // If the namespace is changing now, include an instruction to change it
          // during element creation.
          if (currentNamespace !== wasInNamespace) {
              this.addNamespaceInstruction(currentNamespace, element);
          }
          const implicit = variable(CONTEXT_NAME);
          if (this.i18n) {
              this.i18n.appendElement(element.i18n, elementIndex);
          }
          const hasChildren = () => {
              if (!isI18nRootElement && this.i18n) {
                  // we do not append text node instructions and ICUs inside i18n section,
                  // so we exclude them while calculating whether current element has children
                  return !hasTextChildrenOnly(element.children);
              }
              return element.children.length > 0;
          };
          const createSelfClosingInstruction = !stylingBuilder.hasBindingsOrInitialValues() &&
              !isNgContainer$$1 && element.outputs.length === 0 && i18nAttrs.length === 0 && !hasChildren();
          const createSelfClosingI18nInstruction = !createSelfClosingInstruction &&
              !stylingBuilder.hasBindingsOrInitialValues() && hasTextChildrenOnly(element.children);
          if (createSelfClosingInstruction) {
              this.creationInstruction(element.sourceSpan, Identifiers$1.element, trimTrailingNulls(parameters));
          }
          else {
              this.creationInstruction(element.sourceSpan, isNgContainer$$1 ? Identifiers$1.elementContainerStart : Identifiers$1.elementStart, trimTrailingNulls(parameters));
              if (isNonBindableMode) {
                  this.creationInstruction(element.sourceSpan, Identifiers$1.disableBindings);
              }
              if (isI18nRootElement) {
                  this.i18nStart(element.sourceSpan, element.i18n, createSelfClosingI18nInstruction);
              }
              // process i18n element attributes
              if (i18nAttrs.length) {
                  let hasBindings = false;
                  const i18nAttrArgs = [];
                  i18nAttrs.forEach(attr => {
                      const message = attr.i18n;
                      if (attr instanceof TextAttribute) {
                          i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message));
                      }
                      else {
                          const converted = attr.value.visit(this._valueConverter);
                          this.allocateBindingSlots(converted);
                          if (converted instanceof Interpolation) {
                              const placeholders = assembleBoundTextPlaceholders(message);
                              const params = placeholdersToParams(placeholders);
                              i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));
                              converted.expressions.forEach(expression => {
                                  hasBindings = true;
                                  const binding = this.convertExpressionBinding(implicit, expression);
                                  this.updateInstruction(element.sourceSpan, Identifiers$1.i18nExp, [binding]);
                              });
                          }
                      }
                  });
                  if (i18nAttrArgs.length) {
                      const index = literal(this.allocateDataSlot());
                      const args = this.constantPool.getConstLiteral(literalArr(i18nAttrArgs), true);
                      this.creationInstruction(element.sourceSpan, Identifiers$1.i18nAttributes, [index, args]);
                      if (hasBindings) {
                          this.updateInstruction(element.sourceSpan, Identifiers$1.i18nApply, [index]);
                      }
                  }
              }
              // The style bindings code is placed into two distinct blocks within the template function AOT
              // code: creation and update. The creation code contains the `elementStyling` instructions
              // which will apply the collected binding values to the element. `elementStyling` is
              // designed to run inside of `elementStart` and `elementEnd`. The update instructions
              // (things like `elementStyleProp`, `elementClassProp`, etc..) are applied later on in this
              // file
              this.processStylingInstruction(implicit, stylingBuilder.buildElementStylingInstruction(element.sourceSpan, this.constantPool), true);
              // Generate Listeners (outputs)
              element.outputs.forEach((outputAst) => {
                  this.creationInstruction(outputAst.sourceSpan, Identifiers$1.listener, this.prepareListenerParameter(element.name, outputAst, elementIndex));
              });
          }
          // the code here will collect all update-level styling instructions and add them to the
          // update block of the template function AOT code. Instructions like `elementStyleProp`,
          // `elementStylingMap`, `elementClassProp` and `elementStylingApply` are all generated
          // and assign in the code below.
          stylingBuilder.buildUpdateLevelInstructions(this._valueConverter).forEach(instruction => {
              this.processStylingInstruction(implicit, instruction, false);
          });
          // Generate element input bindings
          allOtherInputs.forEach((input) => {
              const instruction = mapBindingToInstruction(input.type);
              if (input.type === 4 /* Animation */) {
                  const value = input.value.visit(this._valueConverter);
                  // setProperty without a value doesn't make any sense
                  if (value.name || value.value) {
                      const bindingName = prepareSyntheticPropertyName(input.name);
                      this.allocateBindingSlots(value);
                      this.updateInstruction(input.sourceSpan, Identifiers$1.elementProperty, () => {
                          return [
                              literal(elementIndex), literal(bindingName),
                              this.convertPropertyBinding(implicit, value)
                          ];
                      });
                  }
              }
              else if (instruction) {
                  const params = [];
                  const sanitizationRef = resolveSanitizationFn(input, input.securityContext);
                  if (sanitizationRef)
                      params.push(sanitizationRef);
                  // TODO(chuckj): runtime: security context
                  const value = input.value.visit(this._valueConverter);
                  this.allocateBindingSlots(value);
                  this.updateInstruction(input.sourceSpan, instruction, () => {
                      return [
                          literal(elementIndex), literal(input.name),
                          this.convertPropertyBinding(implicit, value), ...params
                      ];
                  });
              }
              else {
                  this._unsupported(`binding type ${input.type}`);
              }
          });
          // Traverse element child nodes
          visitAll$1(this, element.children);
          if (!isI18nRootElement && this.i18n) {
              this.i18n.appendElement(element.i18n, elementIndex, true);
          }
          if (!createSelfClosingInstruction) {
              // Finish element construction mode.
              const span = element.endSourceSpan || element.sourceSpan;
              if (isI18nRootElement) {
                  this.i18nEnd(span, createSelfClosingI18nInstruction);
              }
              if (isNonBindableMode) {
                  this.creationInstruction(span, Identifiers$1.enableBindings);
              }
              this.creationInstruction(span, isNgContainer$$1 ? Identifiers$1.elementContainerEnd : Identifiers$1.elementEnd);
          }
      }
      visitTemplate(template) {
          const templateIndex = this.allocateDataSlot();
          if (this.i18n) {
              this.i18n.appendTemplate(template.i18n, templateIndex);
          }
          const tagName = sanitizeIdentifier(template.tagName || '');
          const contextName = `${tagName ? this.contextName + '_' + tagName : ''}_${templateIndex}`;
          const templateName = `${contextName}_Template`;
          const parameters = [
              literal(templateIndex),
              variable(templateName),
              literal(template.tagName),
          ];
          // find directives matching on a given <ng-template> node
          this.matchDirectives('ng-template', template);
          // prepare attributes parameter (including attributes used for directive matching)
          const attrsExprs = [];
          template.attributes.forEach((a) => { attrsExprs.push(asLiteral(a.name), asLiteral(a.value)); });
          attrsExprs.push(...this.prepareSyntheticAndSelectOnlyAttrs(template.inputs, template.outputs));
          parameters.push(this.toAttrsParam(attrsExprs));
          // local refs (ex.: <ng-template #foo>)
          if (template.references && template.references.length) {
              parameters.push(this.prepareRefsParameter(template.references));
              parameters.push(importExpr(Identifiers$1.templateRefExtractor));
          }
          // handle property bindings e.g. p(1, 'ngForOf', ɵbind(ctx.items));
          const context = variable(CONTEXT_NAME);
          template.inputs.forEach(input => {
              const value = input.value.visit(this._valueConverter);
              this.allocateBindingSlots(value);
              this.updateInstruction(template.sourceSpan, Identifiers$1.elementProperty, () => {
                  return [
                      literal(templateIndex), literal(input.name),
                      this.convertPropertyBinding(context, value)
                  ];
              });
          });
          // Create the template function
          const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, [], this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds);
          // Nested templates must not be visited until after their parent templates have completed
          // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't
          // be able to support bindings in nested templates to local refs that occur after the
          // template definition. e.g. <div *ngIf="showing">{{ foo }}</div>  <div #foo></div>
          this._nestedTemplateFns.push(() => {
              const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentSelectors.length + this._ngContentSelectorsOffset, template.i18n);
              this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName, null));
              if (templateVisitor._hasNgContent) {
                  this._hasNgContent = true;
                  this._ngContentSelectors.push(...templateVisitor._ngContentSelectors);
              }
          });
          // e.g. template(1, MyComp_Template_1)
          this.creationInstruction(template.sourceSpan, Identifiers$1.templateCreate, () => {
              parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
              return trimTrailingNulls(parameters);
          });
          // Generate listeners for directive output
          template.outputs.forEach((outputAst) => {
              this.creationInstruction(outputAst.sourceSpan, Identifiers$1.listener, this.prepareListenerParameter('ng_template', outputAst, templateIndex));
          });
      }
      visitBoundText(text) {
          if (this.i18n) {
              const value = text.value.visit(this._valueConverter);
              this.allocateBindingSlots(value);
              if (value instanceof Interpolation) {
                  this.i18n.appendBoundText(text.i18n);
                  this.i18nAppendBindings(value.expressions);
              }
              return;
          }
          const nodeIndex = this.allocateDataSlot();
          this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(nodeIndex)]);
          const value = text.value.visit(this._valueConverter);
          this.allocateBindingSlots(value);
          this.updateInstruction(text.sourceSpan, Identifiers$1.textBinding, () => [literal(nodeIndex), this.convertPropertyBinding(variable(CONTEXT_NAME), value)]);
      }
      visitText(text) {
          // when a text element is located within a translatable
          // block, we exclude this text element from instructions set,
          // since it will be captured in i18n content and processed at runtime
          if (!this.i18n) {
              this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(this.allocateDataSlot()), literal(text.value)]);
          }
      }
      visitIcu(icu) {
          let initWasInvoked = false;
          // if an ICU was created outside of i18n block, we still treat
          // it as a translatable entity and invoke i18nStart and i18nEnd
          // to generate i18n context and the necessary instructions
          if (!this.i18n) {
              initWasInvoked = true;
              this.i18nStart(null, icu.i18n, true);
          }
          const i18n = this.i18n;
          const vars = this.i18nBindProps(icu.vars);
          const placeholders = this.i18nBindProps(icu.placeholders);
          // output ICU directly and keep ICU reference in context
          const message = icu.i18n;
          const transformFn = (raw) => instruction(null, Identifiers$1.i18nPostprocess, [raw, mapLiteral(vars, true)]);
          // in case the whole i18n message is a single ICU - we do not need to
          // create a separate top-level translation, we can use the root ref instead
          // and make this ICU a top-level translation
          if (isSingleI18nIcu(i18n.meta)) {
              this.i18nTranslate(message, placeholders, i18n.ref, transformFn);
          }
          else {
              // output ICU directly and keep ICU reference in context
              const ref = this.i18nTranslate(message, placeholders, undefined, transformFn);
              i18n.appendIcu(icuFromI18nMessage(message).name, ref);
          }
          if (initWasInvoked) {
              this.i18nEnd(null, true);
          }
          return null;
      }
      allocateDataSlot() { return this._dataIndex++; }
      getConstCount() { return this._dataIndex; }
      getVarCount() { return this._pureFunctionSlots; }
      bindingContext() { return `${this._bindingContext++}`; }
      // Bindings must only be resolved after all local refs have been visited, so all
      // instructions are queued in callbacks that execute once the initial pass has completed.
      // Otherwise, we wouldn't be able to support local refs that are defined after their
      // bindings. e.g. {{ foo }} <div #foo></div>
      instructionFn(fns, span, reference, paramsOrFn, prepend = false) {
          fns[prepend ? 'unshift' : 'push'](() => {
              const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();
              return instruction(span, reference, params).toStmt();
          });
      }
      processStylingInstruction(implicit, instruction, createMode) {
          if (instruction) {
              const paramsFn = () => instruction.buildParams(value => this.convertPropertyBinding(implicit, value, true));
              if (createMode) {
                  this.creationInstruction(instruction.sourceSpan, instruction.reference, paramsFn);
              }
              else {
                  this.updateInstruction(instruction.sourceSpan, instruction.reference, paramsFn);
              }
          }
      }
      creationInstruction(span, reference, paramsOrFn, prepend) {
          this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
      }
      updateInstruction(span, reference, paramsOrFn) {
          this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
      }
      allocatePureFunctionSlots(numSlots) {
          const originalSlots = this._pureFunctionSlots;
          this._pureFunctionSlots += numSlots;
          return originalSlots;
      }
      allocateBindingSlots(value) {
          this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
      }
      convertExpressionBinding(implicit, value) {
          const convertedPropertyBinding = convertPropertyBinding(this, implicit, value, this.bindingContext(), BindingForm.TrySimple);
          const valExpr = convertedPropertyBinding.currValExpr;
          return importExpr(Identifiers$1.bind).callFn([valExpr]);
      }
      convertPropertyBinding(implicit, value, skipBindFn) {
          const interpolationFn = value instanceof Interpolation ? interpolate : () => error('Unexpected interpolation');
          const convertedPropertyBinding = convertPropertyBinding(this, implicit, value, this.bindingContext(), BindingForm.TrySimple, interpolationFn);
          this._tempVariables.push(...convertedPropertyBinding.stmts);
          const valExpr = convertedPropertyBinding.currValExpr;
          return value instanceof Interpolation || skipBindFn ? valExpr :
              importExpr(Identifiers$1.bind).callFn([valExpr]);
      }
      matchDirectives(tagName, elOrTpl) {
          if (this.directiveMatcher) {
              const selector = createCssSelector(tagName, getAttrsForDirectiveMatching(elOrTpl));
              this.directiveMatcher.match(selector, (cssSelector, staticType) => { this.directives.add(staticType); });
          }
      }
      /**
       * Prepares all attribute expression values for the `TAttributes` array.
       *
       * The purpose of this function is to properly construct an attributes array that
       * is passed into the `elementStart` (or just `element`) functions. Because there
       * are many different types of attributes, the array needs to be constructed in a
       * special way so that `elementStart` can properly evaluate them.
       *
       * The format looks like this:
       *
       * ```
       * attrs = [prop, value, prop2, value2,
       *   CLASSES, class1, class2,
       *   STYLES, style1, value1, style2, value2,
       *   SELECT_ONLY, name1, name2, name2, ...]
       * ```
       */
      prepareSyntheticAndSelectOnlyAttrs(inputs, outputs, styles) {
          const attrExprs = [];
          const nonSyntheticInputs = [];
          const alreadySeen = new Set();
          function isASTWithSource(ast) {
              return ast instanceof ASTWithSource;
          }
          function isLiteralPrimitive(ast) {
              return ast instanceof LiteralPrimitive;
          }
          function addAttrExpr(key, value) {
              if (typeof key === 'string') {
                  if (!alreadySeen.has(key)) {
                      attrExprs.push(literal(key));
                      if (value !== undefined) {
                          attrExprs.push(value);
                      }
                      alreadySeen.add(key);
                  }
              }
              else {
                  attrExprs.push(literal(key));
              }
          }
          if (inputs.length) {
              const EMPTY_STRING_EXPR = asLiteral('');
              inputs.forEach(input => {
                  if (input.type === 4 /* Animation */) {
                      // @attributes are for Renderer2 animation @triggers, but this feature
                      // may be supported differently in future versions of angular. However,
                      // @triggers should always just be treated as regular attributes (it's up
                      // to the renderer to detect and use them in a special way).
                      const valueExp = input.value;
                      if (isASTWithSource(valueExp)) {
                          const literal$$1 = valueExp.ast;
                          if (isLiteralPrimitive(literal$$1) && literal$$1.value === undefined) {
                              addAttrExpr(prepareSyntheticPropertyName(input.name), EMPTY_STRING_EXPR);
                          }
                      }
                  }
                  else {
                      nonSyntheticInputs.push(input);
                  }
              });
          }
          // it's important that this occurs before SelectOnly because once `elementStart`
          // comes across the SelectOnly marker then it will continue reading each value as
          // as single property value cell by cell.
          if (styles) {
              styles.populateInitialStylingAttrs(attrExprs);
          }
          if (nonSyntheticInputs.length || outputs.length) {
              addAttrExpr(3 /* SelectOnly */);
              nonSyntheticInputs.forEach((i) => addAttrExpr(i.name));
              outputs.forEach((o) => {
                  const name = o.type === 1 /* Animation */ ? getSyntheticPropertyName(o.name) : o.name;
                  addAttrExpr(name);
              });
          }
          return attrExprs;
      }
      toAttrsParam(attrsExprs) {
          return attrsExprs.length > 0 ?
              this.constantPool.getConstLiteral(literalArr(attrsExprs), true) :
              TYPED_NULL_EXPR;
      }
      prepareRefsParameter(references) {
          if (!references || references.length === 0) {
              return TYPED_NULL_EXPR;
          }
          const refsParam = flatten(references.map(reference => {
              const slot = this.allocateDataSlot();
              // Generate the update temporary.
              const variableName = this._bindingScope.freshReferenceName();
              const retrievalLevel = this.level;
              const lhs = variable(variableName);
              this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DEFAULT */, (scope, relativeLevel) => {
                  // e.g. nextContext(2);
                  const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];
                  // e.g. const $foo$ = reference(1);
                  const refExpr = lhs.set(importExpr(Identifiers$1.reference).callFn([literal(slot)]));
                  return nextContextStmt.concat(refExpr.toConstDecl());
              }, true);
              return [reference.name, reference.value];
          }));
          return this.constantPool.getConstLiteral(asLiteral(refsParam), true);
      }
      prepareListenerParameter(tagName, outputAst, index) {
          let eventName = outputAst.name;
          let bindingFnName;
          if (outputAst.type === 1 /* Animation */) {
              // synthetic @listener.foo values are treated the exact same as are standard listeners
              bindingFnName = prepareSyntheticListenerFunctionName(eventName, outputAst.phase);
              eventName = prepareSyntheticListenerName(eventName, outputAst.phase);
          }
          else {
              bindingFnName = sanitizeIdentifier(eventName);
          }
          const tagNameSanitized = sanitizeIdentifier(tagName);
          const functionName = `${this.templateName}_${tagNameSanitized}_${bindingFnName}_${index}_listener`;
          return () => {
              const listenerScope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel);
              const bindingExpr = convertActionBinding(listenerScope, variable(CONTEXT_NAME), outputAst.handler, 'b', () => error('Unexpected interpolation'));
              const statements = [
                  ...listenerScope.restoreViewStatement(), ...listenerScope.variableDeclarations(),
                  ...bindingExpr.render3Stmts
              ];
              const handler = fn([new FnParam('$event', DYNAMIC_TYPE)], statements, INFERRED_TYPE, null, functionName);
              return [literal(eventName), handler];
          };
      }
  }
  class ValueConverter extends AstMemoryEfficientTransformer {
      constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
          super();
          this.constantPool = constantPool;
          this.allocateSlot = allocateSlot;
          this.allocatePureFunctionSlots = allocatePureFunctionSlots;
          this.definePipe = definePipe;
          this._pipeBindExprs = [];
      }
      // AstMemoryEfficientTransformer
      visitPipe(pipe, context) {
          // Allocate a slot to create the pipe
          const slot = this.allocateSlot();
          const slotPseudoLocal = `PIPE:${slot}`;
          // Allocate one slot for the result plus one slot per pipe argument
          const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);
          const target = new PropertyRead(pipe.span, new ImplicitReceiver(pipe.span), slotPseudoLocal);
          const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);
          this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));
          const args = [pipe.exp, ...pipe.args];
          const convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe.span, args)]) : this.visitAll(args);
          const pipeBindExpr = new FunctionCall(pipe.span, target, [
              new LiteralPrimitive(pipe.span, slot),
              new LiteralPrimitive(pipe.span, pureFunctionSlot),
              ...convertedArgs,
          ]);
          this._pipeBindExprs.push(pipeBindExpr);
          return pipeBindExpr;
      }
      updatePipeSlotOffsets(bindingSlots) {
          this._pipeBindExprs.forEach((pipe) => {
              // update the slot offset arg (index 1) to account for binding slots
              const slotOffset = pipe.args[1];
              slotOffset.value += bindingSlots;
          });
      }
      visitLiteralArray(array, context) {
          return new BuiltinFunctionCall(array.span, this.visitAll(array.expressions), values => {
              // If the literal has calculated (non-literal) elements transform it into
              // calls to literal factories that compose the literal and will cache intermediate
              // values. Otherwise, just return an literal array that contains the values.
              const literal$$1 = literalArr(values);
              return values.every(a => a.isConstant()) ?
                  this.constantPool.getConstLiteral(literal$$1, true) :
                  getLiteralFactory(this.constantPool, literal$$1, this.allocatePureFunctionSlots);
          });
      }
      visitLiteralMap(map, context) {
          return new BuiltinFunctionCall(map.span, this.visitAll(map.values), values => {
              // If the literal has calculated (non-literal) elements  transform it into
              // calls to literal factories that compose the literal and will cache intermediate
              // values. Otherwise, just return an literal array that contains the values.
              const literal$$1 = literalMap(values.map((value, index) => ({ key: map.keys[index].key, value, quoted: map.keys[index].quoted })));
              return values.every(a => a.isConstant()) ?
                  this.constantPool.getConstLiteral(literal$$1, true) :
                  getLiteralFactory(this.constantPool, literal$$1, this.allocatePureFunctionSlots);
          });
      }
  }
  // Pipes always have at least one parameter, the value they operate on
  const pipeBindingIdentifiers = [Identifiers$1.pipeBind1, Identifiers$1.pipeBind2, Identifiers$1.pipeBind3, Identifiers$1.pipeBind4];
  function pipeBindingCallInfo(args) {
      const identifier = pipeBindingIdentifiers[args.length];
      return {
          identifier: identifier || Identifiers$1.pipeBindV,
          isVarLength: !identifier,
      };
  }
  const pureFunctionIdentifiers = [
      Identifiers$1.pureFunction0, Identifiers$1.pureFunction1, Identifiers$1.pureFunction2, Identifiers$1.pureFunction3, Identifiers$1.pureFunction4,
      Identifiers$1.pureFunction5, Identifiers$1.pureFunction6, Identifiers$1.pureFunction7, Identifiers$1.pureFunction8
  ];
  function pureFunctionCallInfo(args) {
      const identifier = pureFunctionIdentifiers[args.length];
      return {
          identifier: identifier || Identifiers$1.pureFunctionV,
          isVarLength: !identifier,
      };
  }
  function instruction(span, reference, params) {
      return importExpr(reference, null, span).callFn(params, span);
  }
  // e.g. x(2);
  function generateNextContextExpr(relativeLevelDiff) {
      return importExpr(Identifiers$1.nextContext)
          .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
  }
  function getLiteralFactory(constantPool, literal$$1, allocateSlots) {
      const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$$1);
      // Allocate 1 slot for the result plus 1 per argument
      const startSlot = allocateSlots(1 + literalFactoryArguments.length);
      literalFactoryArguments.length > 0 || error(`Expected arguments to a literal factory function`);
      const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);
      // Literal factories are pure functions that only need to be re-invoked when the parameters
      // change.
      const args = [
          literal(startSlot),
          literalFactory,
      ];
      if (isVarLength) {
          args.push(literalArr(literalFactoryArguments));
      }
      else {
          args.push(...literalFactoryArguments);
      }
      return importExpr(identifier).callFn(args);
  }
  /** The prefix used to get a shared context in BindingScope's map. */
  const SHARED_CONTEXT_KEY = '$$shared_ctx$$';
  class BindingScope {
      constructor(bindingLevel = 0, parent = null) {
          this.bindingLevel = bindingLevel;
          this.parent = parent;
          /** Keeps a map from local variables to their BindingData. */
          this.map = new Map();
          this.referenceNameIndex = 0;
          this.restoreViewVariable = null;
      }
      static get ROOT_SCOPE() {
          if (!BindingScope._ROOT_SCOPE) {
              BindingScope._ROOT_SCOPE = new BindingScope().set(0, '$event', variable('$event'));
          }
          return BindingScope._ROOT_SCOPE;
      }
      get(name) {
          let current = this;
          while (current) {
              let value = current.map.get(name);
              if (value != null) {
                  if (current !== this) {
                      // make a local copy and reset the `declare` state
                      value = {
                          retrievalLevel: value.retrievalLevel,
                          lhs: value.lhs,
                          declareLocalCallback: value.declareLocalCallback,
                          declare: false,
                          priority: value.priority,
                          localRef: value.localRef
                      };
                      // Cache the value locally.
                      this.map.set(name, value);
                      // Possibly generate a shared context var
                      this.maybeGenerateSharedContextVar(value);
                      this.maybeRestoreView(value.retrievalLevel, value.localRef);
                  }
                  if (value.declareLocalCallback && !value.declare) {
                      value.declare = true;
                  }
                  return value.lhs;
              }
              current = current.parent;
          }
          // If we get to this point, we are looking for a property on the top level component
          // - If level === 0, we are on the top and don't need to re-declare `ctx`.
          // - If level > 0, we are in an embedded view. We need to retrieve the name of the
          // local var we used to store the component context, e.g. const $comp$ = x();
          return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
      }
      /**
       * Create a local variable for later reference.
       *
       * @param retrievalLevel The level from which this value can be retrieved
       * @param name Name of the variable.
       * @param lhs AST representing the left hand side of the `let lhs = rhs;`.
       * @param priority The sorting priority of this var
       * @param declareLocalCallback The callback to invoke when declaring this local var
       * @param localRef Whether or not this is a local ref
       */
      set(retrievalLevel, name, lhs, priority = 0 /* DEFAULT */, declareLocalCallback, localRef) {
          !this.map.has(name) ||
              error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);
          this.map.set(name, {
              retrievalLevel: retrievalLevel,
              lhs: lhs,
              declare: false,
              declareLocalCallback: declareLocalCallback,
              priority: priority,
              localRef: localRef || false
          });
          return this;
      }
      getLocal(name) { return this.get(name); }
      nestedScope(level) {
          const newScope = new BindingScope(level, this);
          if (level > 0)
              newScope.generateSharedContextVar(0);
          return newScope;
      }
      getSharedContextName(retrievalLevel) {
          const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);
          return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
      }
      maybeGenerateSharedContextVar(value) {
          if (value.priority === 1 /* CONTEXT */) {
              const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);
              if (sharedCtxObj) {
                  sharedCtxObj.declare = true;
              }
              else {
                  this.generateSharedContextVar(value.retrievalLevel);
              }
          }
      }
      generateSharedContextVar(retrievalLevel) {
          const lhs = variable(CONTEXT_NAME + this.freshReferenceName());
          this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
              retrievalLevel: retrievalLevel,
              lhs: lhs,
              declareLocalCallback: (scope, relativeLevel) => {
                  // const ctx_r0 = nextContext(2);
                  return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
              },
              declare: false,
              priority: 2 /* SHARED_CONTEXT */,
              localRef: false
          });
      }
      getComponentProperty(name) {
          const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
          componentValue.declare = true;
          this.maybeRestoreView(0, false);
          return componentValue.lhs.prop(name);
      }
      maybeRestoreView(retrievalLevel, localRefLookup) {
          // We want to restore the current view in listener fns if:
          // 1 - we are accessing a value in a parent view, which requires walking the view tree rather
          // than using the ctx arg. In this case, the retrieval and binding level will be different.
          // 2 - we are looking up a local ref, which requires restoring the view where the local
          // ref is stored
          if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {
              if (!this.parent.restoreViewVariable) {
                  // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction
                  this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
              }
              this.restoreViewVariable = this.parent.restoreViewVariable;
          }
      }
      restoreViewStatement() {
          // restoreView($state$);
          return this.restoreViewVariable ?
              [instruction(null, Identifiers$1.restoreView, [this.restoreViewVariable]).toStmt()] :
              [];
      }
      viewSnapshotStatements() {
          // const $state$ = getCurrentView();
          const getCurrentViewInstruction = instruction(null, Identifiers$1.getCurrentView, []);
          return this.restoreViewVariable ?
              [this.restoreViewVariable.set(getCurrentViewInstruction).toConstDecl()] :
              [];
      }
      isListenerScope() { return this.parent && this.parent.bindingLevel === this.bindingLevel; }
      variableDeclarations() {
          let currentContextLevel = 0;
          return Array.from(this.map.values())
              .filter(value => value.declare)
              .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)
              .reduce((stmts, value) => {
              const levelDiff = this.bindingLevel - value.retrievalLevel;
              const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);
              currentContextLevel = levelDiff;
              return stmts.concat(currStmts);
          }, []);
      }
      freshReferenceName() {
          let current = this;
          // Find the top scope as it maintains the global reference count
          while (current.parent)
              current = current.parent;
          const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;
          return ref;
      }
  }
  /**
   * Creates a `CssSelector` given a tag name and a map of attributes
   */
  function createCssSelector(tag, attributes) {
      const cssSelector = new CssSelector();
      cssSelector.setElement(tag);
      Object.getOwnPropertyNames(attributes).forEach((name) => {
          const value = attributes[name];
          cssSelector.addAttribute(name, value);
          if (name.toLowerCase() === 'class') {
              const classes = value.trim().split(/\s+/);
              classes.forEach(className => cssSelector.addClassName(className));
          }
      });
      return cssSelector;
  }
  function interpolate(args) {
      args = args.slice(1); // Ignore the length prefix added for render2
      switch (args.length) {
          case 3:
              return importExpr(Identifiers$1.interpolation1).callFn(args);
          case 5:
              return importExpr(Identifiers$1.interpolation2).callFn(args);
          case 7:
              return importExpr(Identifiers$1.interpolation3).callFn(args);
          case 9:
              return importExpr(Identifiers$1.interpolation4).callFn(args);
          case 11:
              return importExpr(Identifiers$1.interpolation5).callFn(args);
          case 13:
              return importExpr(Identifiers$1.interpolation6).callFn(args);
          case 15:
              return importExpr(Identifiers$1.interpolation7).callFn(args);
          case 17:
              return importExpr(Identifiers$1.interpolation8).callFn(args);
      }
      (args.length >= 19 && args.length % 2 == 1) ||
          error(`Invalid interpolation argument length ${args.length}`);
      return importExpr(Identifiers$1.interpolationV).callFn([literalArr(args)]);
  }
  /**
   * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.
   *
   * @param template text of the template to parse
   * @param templateUrl URL to use for source mapping of the parsed template
   * @param options options to modify how the template is parsed
   */
  function parseTemplate(template, templateUrl, options = {}) {
      const { interpolationConfig, preserveWhitespaces } = options;
      const bindingParser = makeBindingParser(interpolationConfig);
      const htmlParser = new HtmlParser();
      const parseResult = htmlParser.parse(template, templateUrl, Object.assign({}, options, { tokenizeExpansionForms: true }));
      if (parseResult.errors && parseResult.errors.length > 0) {
          return { errors: parseResult.errors, nodes: [] };
      }
      let rootNodes = parseResult.rootNodes;
      // process i18n meta information (scan attributes, generate ids)
      // before we run whitespace removal process, because existing i18n
      // extraction process (ng xi18n) relies on a raw content to generate
      // message ids
      rootNodes =
          visitAll(new I18nMetaVisitor(interpolationConfig, !preserveWhitespaces), rootNodes);
      if (!preserveWhitespaces) {
          rootNodes = visitAll(new WhitespaceVisitor(), rootNodes);
          // run i18n meta visitor again in case we remove whitespaces, because
          // that might affect generated i18n message content. During this pass
          // i18n IDs generated at the first pass will be preserved, so we can mimic
          // existing extraction process (ng xi18n)
          rootNodes = visitAll(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);
      }
      const { nodes, errors } = htmlAstToRender3Ast(rootNodes, bindingParser);
      if (errors && errors.length > 0) {
          return { errors, nodes: [] };
      }
      return { nodes };
  }
  /**
   * Construct a `BindingParser` with a default configuration.
   */
  function makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {
      return new BindingParser(new Parser(new Lexer()), interpolationConfig, new DomElementSchemaRegistry(), null, []);
  }
  function resolveSanitizationFn(input, context) {
      switch (context) {
          case SecurityContext.HTML:
              return importExpr(Identifiers$1.sanitizeHtml);
          case SecurityContext.SCRIPT:
              return importExpr(Identifiers$1.sanitizeScript);
          case SecurityContext.STYLE:
              // the compiler does not fill in an instruction for [style.prop?] binding
              // values because the style algorithm knows internally what props are subject
              // to sanitization (only [attr.style] values are explicitly sanitized)
              return input.type === 1 /* Attribute */ ? importExpr(Identifiers$1.sanitizeStyle) : null;
          case SecurityContext.URL:
              return importExpr(Identifiers$1.sanitizeUrl);
          case SecurityContext.RESOURCE_URL:
              return importExpr(Identifiers$1.sanitizeResourceUrl);
          default:
              return null;
      }
  }
  function isSingleElementTemplate(children) {
      return children.length === 1 && children[0] instanceof Element$1$1;
  }
  function isTextNode(node) {
      return node instanceof Text$3 || node instanceof BoundText || node instanceof Icu$1;
  }
  function hasTextChildrenOnly(children) {
      return children.every(isTextNode);
  }
  // This regex matches any binding names that contain the "attr." prefix, e.g. "attr.required"
  // If there is a match, the first matching group will contain the attribute name to bind.
  const ATTR_REGEX = /attr\.([^\]]+)/;
  function getStylingPrefix(propName) {
      return propName.substring(0, 5).toLowerCase();
  }
  function baseDirectiveFields(meta, constantPool, bindingParser) {
      const definitionMap = new DefinitionMap();
      // e.g. `type: MyDirective`
      definitionMap.set('type', meta.type);
      // e.g. `selectors: [['', 'someDir', '']]`
      definitionMap.set('selectors', createDirectiveSelector(meta.selector));
      // e.g. `factory: () => new MyApp(directiveInject(ElementRef))`
      const result = compileFactoryFunction({
          name: meta.name,
          type: meta.type,
          deps: meta.deps,
          injectFn: Identifiers$1.directiveInject,
      });
      definitionMap.set('factory', result.factory);
      definitionMap.set('contentQueries', createContentQueriesFunction(meta, constantPool));
      definitionMap.set('contentQueriesRefresh', createContentQueriesRefreshFunction(meta));
      // Initialize hostVarsCount to number of bound host properties (interpolations illegal),
      // except 'style' and 'class' properties, since they should *not* allocate host var slots
      const hostVarsCount = Object.keys(meta.host.properties)
          .filter(name => {
          const prefix = getStylingPrefix(name);
          return prefix !== 'style' && prefix !== 'class';
      })
          .length;
      const elVarExp = variable('elIndex');
      const contextVarExp = variable(CONTEXT_NAME);
      const styleBuilder = new StylingBuilder(elVarExp, contextVarExp);
      const allOtherAttributes = {};
      const attrNames = Object.getOwnPropertyNames(meta.host.attributes);
      for (let i = 0; i < attrNames.length; i++) {
          const attr = attrNames[i];
          const value = meta.host.attributes[attr];
          switch (attr) {
              // style attributes are handled in the styling context
              case 'style':
                  styleBuilder.registerStyleAttr(value);
                  break;
              // class attributes are handled in the styling context
              case 'class':
                  styleBuilder.registerClassAttr(value);
                  break;
              default:
                  allOtherAttributes[attr] = value;
                  break;
          }
      }
      // e.g. `attributes: ['role', 'listbox']`
      definitionMap.set('attributes', createHostAttributesArray(allOtherAttributes));
      // e.g. `hostBindings: (rf, ctx, elIndex) => { ... }
      definitionMap.set('hostBindings', createHostBindingsFunction(meta, elVarExp, contextVarExp, styleBuilder, bindingParser, constantPool, hostVarsCount));
      // e.g 'inputs: {a: 'a'}`
      definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));
      // e.g 'outputs: {a: 'a'}`
      definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));
      if (meta.exportAs !== null) {
          definitionMap.set('exportAs', literal(meta.exportAs));
      }
      return { definitionMap, statements: result.statements };
  }
  /**
   * Add features to the definition map.
   */
  function addFeatures(definitionMap, meta) {
      // e.g. `features: [NgOnChangesFeature]`
      const features = [];
      const providers = meta.providers;
      const viewProviders = meta.viewProviders;
      if (providers || viewProviders) {
          const args = [providers || new LiteralArrayExpr([])];
          if (viewProviders) {
              args.push(viewProviders);
          }
          features.push(importExpr(Identifiers$1.ProvidersFeature).callFn(args));
      }
      if (meta.usesInheritance) {
          features.push(importExpr(Identifiers$1.InheritDefinitionFeature));
      }
      if (meta.lifecycle.usesOnChanges) {
          features.push(importExpr(Identifiers$1.NgOnChangesFeature));
      }
      if (features.length) {
          definitionMap.set('features', literalArr(features));
      }
  }
  /**
   * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.
   */
  function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
      const { definitionMap, statements } = baseDirectiveFields(meta, constantPool, bindingParser);
      addFeatures(definitionMap, meta);
      const expression = importExpr(Identifiers$1.defineDirective).callFn([definitionMap.toLiteralMap()]);
      // On the type side, remove newlines from the selector as it will need to fit into a TypeScript
      // string literal, which must be on one line.
      const selectorForType = (meta.selector || '').replace(/\n/g, '');
      const type = createTypeForDef(meta, Identifiers$1.DirectiveDefWithMeta);
      return { expression, type, statements };
  }
  /**
   * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.
   */
  function compileComponentFromMetadata(meta, constantPool, bindingParser) {
      const { definitionMap, statements } = baseDirectiveFields(meta, constantPool, bindingParser);
      addFeatures(definitionMap, meta);
      const selector = meta.selector && CssSelector.parse(meta.selector);
      const firstSelector = selector && selector[0];
      // e.g. `attr: ["class", ".my.app"]`
      // This is optional an only included if the first selector of a component specifies attributes.
      if (firstSelector) {
          const selectorAttributes = firstSelector.getAttrs();
          if (selectorAttributes.length) {
              definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), 
              /* forceShared */ true));
          }
      }
      // Generate the CSS matcher that recognize directive
      let directiveMatcher = null;
      if (meta.directives.length > 0) {
          const matcher = new SelectorMatcher();
          for (const { selector, expression } of meta.directives) {
              matcher.addSelectables(CssSelector.parse(selector), expression);
          }
          directiveMatcher = matcher;
      }
      if (meta.viewQueries.length) {
          definitionMap.set('viewQuery', createViewQueriesFunction(meta, constantPool));
      }
      // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`
      const templateTypeName = meta.name;
      const templateName = templateTypeName ? `${templateTypeName}_Template` : null;
      const directivesUsed = new Set();
      const pipesUsed = new Set();
      const changeDetection = meta.changeDetection;
      const template = meta.template;
      const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.ROOT_SCOPE, 0, templateTypeName, null, null, templateName, meta.viewQueries, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers$1.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
      const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);
      // e.g. `consts: 2`
      definitionMap.set('consts', literal(templateBuilder.getConstCount()));
      // e.g. `vars: 2`
      definitionMap.set('vars', literal(templateBuilder.getVarCount()));
      definitionMap.set('template', templateFunctionExpression);
      // e.g. `directives: [MyDirective]`
      if (directivesUsed.size) {
          let directivesExpr = literalArr(Array.from(directivesUsed));
          if (meta.wrapDirectivesAndPipesInClosure) {
              directivesExpr = fn([], [new ReturnStatement(directivesExpr)]);
          }
          definitionMap.set('directives', directivesExpr);
      }
      // e.g. `pipes: [MyPipe]`
      if (pipesUsed.size) {
          let pipesExpr = literalArr(Array.from(pipesUsed));
          if (meta.wrapDirectivesAndPipesInClosure) {
              pipesExpr = fn([], [new ReturnStatement(pipesExpr)]);
          }
          definitionMap.set('pipes', pipesExpr);
      }
      if (meta.encapsulation === null) {
          meta.encapsulation = ViewEncapsulation.Emulated;
      }
      // e.g. `styles: [str1, str2]`
      if (meta.styles && meta.styles.length) {
          const styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?
              compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :
              meta.styles;
          const strings = styleValues.map(str => literal(str));
          definitionMap.set('styles', literalArr(strings));
      }
      else if (meta.encapsulation === ViewEncapsulation.Emulated) {
          // If there is no style, don't generate css selectors on elements
          meta.encapsulation = ViewEncapsulation.None;
      }
      // Only set view encapsulation if it's not the default value
      if (meta.encapsulation !== ViewEncapsulation.Emulated) {
          definitionMap.set('encapsulation', literal(meta.encapsulation));
      }
      // e.g. `animation: [trigger('123', [])]`
      if (meta.animations !== null) {
          definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));
      }
      // Only set the change detection flag if it's defined and it's not the default.
      if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {
          definitionMap.set('changeDetection', literal(changeDetection));
      }
      // On the type side, remove newlines from the selector as it will need to fit into a TypeScript
      // string literal, which must be on one line.
      const selectorForType = (meta.selector || '').replace(/\n/g, '');
      const expression = importExpr(Identifiers$1.defineComponent).callFn([definitionMap.toLiteralMap()]);
      const type = createTypeForDef(meta, Identifiers$1.ComponentDefWithMeta);
      return { expression, type, statements };
  }
  function createQueryDefinition(query, constantPool, idx) {
      const predicate = getQueryPredicate(query, constantPool);
      // e.g. r3.query(null, somePredicate, false) or r3.query(0, ['div'], false)
      const parameters = [
          literal(idx, INFERRED_TYPE),
          predicate,
          literal(query.descendants),
      ];
      if (query.read) {
          parameters.push(query.read);
      }
      return importExpr(Identifiers$1.query).callFn(parameters);
  }
  // Turn a directive selector into an R3-compatible selector for directive def
  function createDirectiveSelector(selector) {
      return asLiteral(parseSelectorToR3Selector(selector));
  }
  function createHostAttributesArray(attributes) {
      const values = [];
      for (let key of Object.getOwnPropertyNames(attributes)) {
          const value = attributes[key];
          values.push(literal(key), literal(value));
      }
      if (values.length > 0) {
          return literalArr(values);
      }
      return null;
  }
  // Return a contentQueries function or null if one is not necessary.
  function createContentQueriesFunction(meta, constantPool) {
      if (meta.queries.length) {
          const statements = meta.queries.map((query) => {
              const queryDefinition = createQueryDefinition(query, constantPool, null);
              return importExpr(Identifiers$1.registerContentQuery)
                  .callFn([queryDefinition, variable('dirIndex')])
                  .toStmt();
          });
          const typeName = meta.name;
          const parameters = [new FnParam('dirIndex', NUMBER_TYPE)];
          return fn(parameters, statements, INFERRED_TYPE, null, typeName ? `${typeName}_ContentQueries` : null);
      }
      return null;
  }
  // Return a contentQueriesRefresh function or null if one is not necessary.
  function createContentQueriesRefreshFunction(meta) {
      if (meta.queries.length > 0) {
          const statements = [];
          const typeName = meta.name;
          const parameters = [
              new FnParam('dirIndex', NUMBER_TYPE),
              new FnParam('queryStartIndex', NUMBER_TYPE),
          ];
          const directiveInstanceVar = variable('instance');
          // var $tmp$: any;
          const temporary = temporaryAllocator(statements, TEMPORARY_NAME);
          // const $instance$ = $r3$.ɵload(dirIndex);
          statements.push(directiveInstanceVar.set(importExpr(Identifiers$1.load).callFn([variable('dirIndex')]))
              .toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));
          meta.queries.forEach((query, idx) => {
              const loadQLArg = variable('queryStartIndex');
              const getQueryList = importExpr(Identifiers$1.loadQueryList).callFn([
                  idx > 0 ? loadQLArg.plus(literal(idx)) : loadQLArg
              ]);
              const assignToTemporary = temporary().set(getQueryList);
              const callQueryRefresh = importExpr(Identifiers$1.queryRefresh).callFn([assignToTemporary]);
              const updateDirective = directiveInstanceVar.prop(query.propertyName)
                  .set(query.first ? temporary().prop('first') : temporary());
              const refreshQueryAndUpdateDirective = callQueryRefresh.and(updateDirective);
              statements.push(refreshQueryAndUpdateDirective.toStmt());
          });
          return fn(parameters, statements, INFERRED_TYPE, null, typeName ? `${typeName}_ContentQueriesRefresh` : null);
      }
      return null;
  }
  function stringAsType(str) {
      return expressionType(literal(str));
  }
  function stringMapAsType(map) {
      const mapValues = Object.keys(map).map(key => {
          const value = Array.isArray(map[key]) ? map[key][0] : map[key];
          return {
              key,
              value: literal(value),
              quoted: true,
          };
      });
      return expressionType(literalMap(mapValues));
  }
  function stringArrayAsType(arr) {
      return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) :
          NONE_TYPE;
  }
  function createTypeForDef(meta, typeBase) {
      // On the type side, remove newlines from the selector as it will need to fit into a TypeScript
      // string literal, which must be on one line.
      const selectorForType = (meta.selector || '').replace(/\n/g, '');
      return expressionType(importExpr(typeBase, [
          typeWithParameters(meta.type, meta.typeArgumentCount),
          stringAsType(selectorForType),
          meta.exportAs !== null ? stringAsType(meta.exportAs) : NONE_TYPE,
          stringMapAsType(meta.inputs),
          stringMapAsType(meta.outputs),
          stringArrayAsType(meta.queries.map(q => q.propertyName)),
      ]));
  }
  // Define and update any view queries
  function createViewQueriesFunction(meta, constantPool) {
      const createStatements = [];
      const updateStatements = [];
      const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
      for (let i = 0; i < meta.viewQueries.length; i++) {
          const query = meta.viewQueries[i];
          // creation, e.g. r3.Q(0, somePredicate, true);
          const queryDefinition = createQueryDefinition(query, constantPool, i);
          createStatements.push(queryDefinition.toStmt());
          // update, e.g. (r3.qR(tmp = r3.ɵload(0)) && (ctx.someDir = tmp));
          const temporary = tempAllocator();
          const getQueryList = importExpr(Identifiers$1.load).callFn([literal(i)]);
          const refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);
          const updateDirective = variable(CONTEXT_NAME)
              .prop(query.propertyName)
              .set(query.first ? temporary.prop('first') : temporary);
          updateStatements.push(refresh.and(updateDirective).toStmt());
      }
      const viewQueryFnName = meta.name ? `${meta.name}_Query` : null;
      return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [
          renderFlagCheckIfStmt(1 /* Create */, createStatements),
          renderFlagCheckIfStmt(2 /* Update */, updateStatements)
      ], INFERRED_TYPE, null, viewQueryFnName);
  }
  // Return a host binding function or null if one is not necessary.
  function createHostBindingsFunction(meta, elVarExp, bindingContext, styleBuilder, bindingParser, constantPool, hostVarsCount) {
      const createStatements = [];
      const updateStatements = [];
      let totalHostVarsCount = hostVarsCount;
      const hostBindingSourceSpan = meta.typeSourceSpan;
      const directiveSummary = metadataAsSummary(meta);
      // Calculate host event bindings
      const eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);
      if (eventBindings && eventBindings.length) {
          const listeners = createHostListeners(bindingContext, eventBindings, meta);
          createStatements.push(...listeners);
      }
      // Calculate the host property bindings
      const bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);
      const bindingFn = (implicit, value) => {
          return convertPropertyBinding(null, implicit, value, 'b', BindingForm.TrySimple, () => error('Unexpected interpolation'));
      };
      if (bindings) {
          const hostVarsCountFn = (numSlots) => {
              const originalVarsCount = totalHostVarsCount;
              totalHostVarsCount += numSlots;
              return originalVarsCount;
          };
          const valueConverter = new ValueConverter(constantPool, 
          /* new nodes are illegal here */ () => error('Unexpected node'), hostVarsCountFn, 
          /* pipes are illegal here */ () => error('Unexpected pipe'));
          for (const binding of bindings) {
              const name = binding.name;
              const stylePrefix = getStylingPrefix(name);
              if (stylePrefix === 'style') {
                  const { propertyName, unit } = parseNamedProperty(name);
                  styleBuilder.registerStyleInput(propertyName, binding.expression, unit, binding.sourceSpan);
              }
              else if (stylePrefix === 'class') {
                  styleBuilder.registerClassInput(parseNamedProperty(name).propertyName, binding.expression, binding.sourceSpan);
              }
              else {
                  // resolve literal arrays and literal objects
                  const value = binding.expression.visit(valueConverter);
                  const bindingExpr = bindingFn(bindingContext, value);
                  const { bindingName, instruction, extraParams } = getBindingNameAndInstruction(binding);
                  const instructionParams = [
                      elVarExp, literal(bindingName), importExpr(Identifiers$1.bind).callFn([bindingExpr.currValExpr])
                  ];
                  updateStatements.push(...bindingExpr.stmts);
                  updateStatements.push(importExpr(instruction).callFn(instructionParams.concat(extraParams)).toStmt());
              }
          }
          if (styleBuilder.hasBindingsOrInitialValues()) {
              // since we're dealing with directives here and directives have a hostBinding
              // function, we need to generate special instructions that deal with styling
              // (both bindings and initial values). The instruction below will instruct
              // all initial styling (styling that is inside of a host binding within a
              // directive) to be attached to the host element of the directive.
              const hostAttrsInstruction = styleBuilder.buildDirectiveHostAttrsInstruction(null, constantPool);
              if (hostAttrsInstruction) {
                  createStatements.push(createStylingStmt(hostAttrsInstruction, bindingContext, bindingFn));
              }
              // singular style/class bindings (things like `[style.prop]` and `[class.name]`)
              // MUST be registered on a given element within the component/directive
              // templateFn/hostBindingsFn functions. The instruction below will figure out
              // what all the bindings are and then generate the statements required to register
              // those bindings to the element via `elementStyling`.
              const elementStylingInstruction = styleBuilder.buildElementStylingInstruction(null, constantPool);
              if (elementStylingInstruction) {
                  createStatements.push(createStylingStmt(elementStylingInstruction, bindingContext, bindingFn));
              }
              // finally each binding that was registered in the statement above will need to be added to
              // the update block of a component/directive templateFn/hostBindingsFn so that the bindings
              // are evaluated and updated for the element.
              styleBuilder.buildUpdateLevelInstructions(valueConverter).forEach(instruction => {
                  updateStatements.push(createStylingStmt(instruction, bindingContext, bindingFn));
              });
          }
      }
      if (totalHostVarsCount) {
          createStatements.unshift(importExpr(Identifiers$1.allocHostVars).callFn([literal(totalHostVarsCount)]).toStmt());
      }
      if (createStatements.length > 0 || updateStatements.length > 0) {
          const hostBindingsFnName = meta.name ? `${meta.name}_HostBindings` : null;
          const statements = [];
          if (createStatements.length > 0) {
              statements.push(renderFlagCheckIfStmt(1 /* Create */, createStatements));
          }
          if (updateStatements.length > 0) {
              statements.push(renderFlagCheckIfStmt(2 /* Update */, updateStatements));
          }
          return fn([
              new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),
              new FnParam(elVarExp.name, NUMBER_TYPE)
          ], statements, INFERRED_TYPE, null, hostBindingsFnName);
      }
      return null;
  }
  function createStylingStmt(instruction, bindingContext, bindingFn) {
      const params = instruction.buildParams(value => bindingFn(bindingContext, value).currValExpr);
      return importExpr(instruction.reference, null, instruction.sourceSpan)
          .callFn(params, instruction.sourceSpan)
          .toStmt();
  }
  function getBindingNameAndInstruction(binding) {
      let bindingName = binding.name;
      let instruction;
      const extraParams = [];
      // Check to see if this is an attr binding or a property binding
      const attrMatches = bindingName.match(ATTR_REGEX);
      if (attrMatches) {
          bindingName = attrMatches[1];
          instruction = Identifiers$1.elementAttribute;
      }
      else {
          if (binding.isAnimation) {
              bindingName = prepareSyntheticPropertyName(bindingName);
              // host bindings that have a synthetic property (e.g. @foo) should always be rendered
              // in the context of the component and not the parent. Therefore there is a special
              // compatibility instruction available for this purpose.
              instruction = Identifiers$1.componentHostSyntheticProperty;
          }
          else {
              instruction = Identifiers$1.elementProperty;
          }
          extraParams.push(literal(null), // TODO: This should be a sanitizer fn (FW-785)
          literal(true) // host bindings must have nativeOnly prop set to true
          );
      }
      return { bindingName, instruction, extraParams };
  }
  function createHostListeners(bindingContext, eventBindings, meta) {
      return eventBindings.map(binding => {
          const bindingExpr = convertActionBinding(null, bindingContext, binding.handler, 'b', () => error('Unexpected interpolation'));
          let bindingName = binding.name && sanitizeIdentifier(binding.name);
          let bindingFnName = bindingName;
          if (binding.type === 1 /* Animation */) {
              bindingFnName = prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase);
              bindingName = prepareSyntheticListenerName(bindingName, binding.targetOrPhase);
          }
          const typeName = meta.name;
          const functionName = typeName && bindingName ? `${typeName}_${bindingFnName}_HostBindingHandler` : null;
          const handler = fn([new FnParam('$event', DYNAMIC_TYPE)], [...bindingExpr.render3Stmts], INFERRED_TYPE, null, functionName);
          return importExpr(Identifiers$1.listener).callFn([literal(bindingName), handler]).toStmt();
      });
  }
  function metadataAsSummary(meta) {
      // clang-format off
      return {
          hostAttributes: meta.host.attributes,
          hostListeners: meta.host.listeners,
          hostProperties: meta.host.properties,
      };
      // clang-format on
  }
  const HOST_REG_EXP$1 = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
  function parseHostBindings(host) {
      const attributes = {};
      const listeners = {};
      const properties = {};
      Object.keys(host).forEach(key => {
          const value = host[key];
          const matches = key.match(HOST_REG_EXP$1);
          if (matches === null) {
              attributes[key] = value;
          }
          else if (matches[1 /* Binding */] != null) {
              // synthetic properties (the ones that have a `@` as a prefix)
              // are still treated the same as regular properties. Therefore
              // there is no point in storing them in a separate map.
              properties[matches[1 /* Binding */]] = value;
          }
          else if (matches[2 /* Event */] != null) {
              listeners[matches[2 /* Event */]] = value;
          }
      });
      return { attributes, listeners, properties };
  }
  function compileStyles(styles, selector, hostSelector) {
      const shadowCss = new ShadowCss();
      return styles.map(style => { return shadowCss.shimCssText(style, selector, hostSelector); });
  }
  function parseNamedProperty(name) {
      let unit = '';
      let propertyName = '';
      const index = name.indexOf('.');
      if (index > 0) {
          const unitIndex = name.lastIndexOf('.');
          if (unitIndex !== index) {
              unit = name.substring(unitIndex + 1, name.length);
              propertyName = name.substring(index + 1, unitIndex);
          }
          else {
              propertyName = name.substring(index + 1, name.length);
          }
      }
      return { propertyName, unit };
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class CompilerFacadeImpl {
      constructor() {
          this.R3ResolvedDependencyType = R3ResolvedDependencyType;
          this.elementSchemaRegistry = new DomElementSchemaRegistry();
      }
      compilePipe(angularCoreEnv, sourceMapUrl, facade) {
          const res = compilePipeFromMetadata({
              name: facade.name,
              type: new WrappedNodeExpr(facade.type),
              deps: convertR3DependencyMetadataArray(facade.deps),
              pipeName: facade.pipeName,
              pure: facade.pure,
          });
          return jitExpression(res.expression, angularCoreEnv, sourceMapUrl, res.statements);
      }
      compileInjectable(angularCoreEnv, sourceMapUrl, facade) {
          const { expression, statements } = compileInjectable({
              name: facade.name,
              type: new WrappedNodeExpr(facade.type),
              typeArgumentCount: facade.typeArgumentCount,
              providedIn: computeProvidedIn(facade.providedIn),
              useClass: wrapExpression(facade, USE_CLASS),
              useFactory: wrapExpression(facade, USE_FACTORY),
              useValue: wrapExpression(facade, USE_VALUE),
              useExisting: wrapExpression(facade, USE_EXISTING),
              ctorDeps: convertR3DependencyMetadataArray(facade.ctorDeps),
              userDeps: convertR3DependencyMetadataArray(facade.userDeps) || undefined,
          });
          return jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
      }
      compileInjector(angularCoreEnv, sourceMapUrl, facade) {
          const meta = {
              name: facade.name,
              type: new WrappedNodeExpr(facade.type),
              deps: convertR3DependencyMetadataArray(facade.deps),
              providers: new WrappedNodeExpr(facade.providers),
              imports: new WrappedNodeExpr(facade.imports),
          };
          const res = compileInjector(meta);
          return jitExpression(res.expression, angularCoreEnv, sourceMapUrl, res.statements);
      }
      compileNgModule(angularCoreEnv, sourceMapUrl, facade) {
          const meta = {
              type: new WrappedNodeExpr(facade.type),
              bootstrap: facade.bootstrap.map(wrapReference),
              declarations: facade.declarations.map(wrapReference),
              imports: facade.imports.map(wrapReference),
              exports: facade.exports.map(wrapReference),
              emitInline: true,
          };
          const res = compileNgModule(meta);
          return jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
      }
      compileDirective(angularCoreEnv, sourceMapUrl, facade) {
          const constantPool = new ConstantPool();
          const bindingParser = makeBindingParser();
          const meta = convertDirectiveFacadeToMetadata(facade);
          const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
          const preStatements = [...constantPool.statements, ...res.statements];
          return jitExpression(res.expression, angularCoreEnv, sourceMapUrl, preStatements);
      }
      compileComponent(angularCoreEnv, sourceMapUrl, facade) {
          // The ConstantPool is a requirement of the JIT'er.
          const constantPool = new ConstantPool();
          const interpolationConfig = facade.interpolation ?
              InterpolationConfig.fromArray(facade.interpolation) :
              DEFAULT_INTERPOLATION_CONFIG;
          // Parse the template and check for errors.
          const template = parseTemplate(facade.template, sourceMapUrl, { preserveWhitespaces: facade.preserveWhitespaces, interpolationConfig });
          if (template.errors !== undefined) {
              const errors = template.errors.map(err => err.toString()).join(', ');
              throw new Error(`Errors during JIT compilation of template for ${facade.name}: ${errors}`);
          }
          // Compile the component metadata, including template, into an expression.
          // TODO(alxhub): implement inputs, outputs, queries, etc.
          const res = compileComponentFromMetadata(Object.assign({}, facade, convertDirectiveFacadeToMetadata(facade), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), wrapDirectivesAndPipesInClosure: false, styles: facade.styles || [], encapsulation: facade.encapsulation, interpolation: interpolationConfig, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :
                  null, relativeContextFilePath: '', i18nUseExternalIds: true }), constantPool, makeBindingParser(interpolationConfig));
          const preStatements = [...constantPool.statements, ...res.statements];
          return jitExpression(res.expression, angularCoreEnv, sourceMapUrl, preStatements);
      }
  }
  const USE_CLASS = Object.keys({ useClass: null })[0];
  const USE_FACTORY = Object.keys({ useFactory: null })[0];
  const USE_VALUE = Object.keys({ useValue: null })[0];
  const USE_EXISTING = Object.keys({ useExisting: null })[0];
  const wrapReference = function (value) {
      const wrapped = new WrappedNodeExpr(value);
      return { value: wrapped, type: wrapped };
  };
  function convertToR3QueryMetadata(facade) {
      return Object.assign({}, facade, { predicate: Array.isArray(facade.predicate) ? facade.predicate :
              new WrappedNodeExpr(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null });
  }
  function convertDirectiveFacadeToMetadata(facade) {
      const inputsFromMetadata = parseInputOutputs(facade.inputs || []);
      const outputsFromMetadata = parseInputOutputs(facade.outputs || []);
      const propMetadata = facade.propMetadata;
      const inputsFromType = {};
      const outputsFromType = {};
      for (const field in propMetadata) {
          if (propMetadata.hasOwnProperty(field)) {
              propMetadata[field].forEach(ann => {
                  if (isInput(ann)) {
                      inputsFromType[field] =
                          ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
                  }
                  else if (isOutput(ann)) {
                      outputsFromType[field] = ann.bindingPropertyName || field;
                  }
              });
          }
      }
      return Object.assign({}, facade, { typeSourceSpan: null, type: new WrappedNodeExpr(facade.type), deps: convertR3DependencyMetadataArray(facade.deps), host: extractHostBindings(facade.host, facade.propMetadata), inputs: Object.assign({}, inputsFromMetadata, inputsFromType), outputs: Object.assign({}, outputsFromMetadata, outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null });
  }
  function wrapExpression(obj, property) {
      if (obj.hasOwnProperty(property)) {
          return new WrappedNodeExpr(obj[property]);
      }
      else {
          return undefined;
      }
  }
  function computeProvidedIn(providedIn) {
      if (providedIn == null || typeof providedIn === 'string') {
          return new LiteralExpr(providedIn);
      }
      else {
          return new WrappedNodeExpr(providedIn);
      }
  }
  function convertR3DependencyMetadata(facade) {
      let tokenExpr;
      if (facade.token === null) {
          tokenExpr = new LiteralExpr(null);
      }
      else if (facade.resolved === R3ResolvedDependencyType.Attribute) {
          tokenExpr = new LiteralExpr(facade.token);
      }
      else {
          tokenExpr = new WrappedNodeExpr(facade.token);
      }
      return {
          token: tokenExpr,
          resolved: facade.resolved,
          host: facade.host,
          optional: facade.optional,
          self: facade.self,
          skipSelf: facade.skipSelf
      };
  }
  function convertR3DependencyMetadataArray(facades) {
      return facades == null ? null : facades.map(convertR3DependencyMetadata);
  }
  function extractHostBindings(host, propMetadata) {
      // First parse the declarations from the metadata.
      const { attributes, listeners, properties } = parseHostBindings(host || {});
      // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.
      for (const field in propMetadata) {
          if (propMetadata.hasOwnProperty(field)) {
              propMetadata[field].forEach(ann => {
                  if (isHostBinding(ann)) {
                      properties[ann.hostPropertyName || field] = field;
                  }
                  else if (isHostListener(ann)) {
                      listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;
                  }
              });
          }
      }
      return { attributes, listeners, properties };
  }
  function isHostBinding(value) {
      return value.ngMetadataName === 'HostBinding';
  }
  function isHostListener(value) {
      return value.ngMetadataName === 'HostListener';
  }
  function isInput(value) {
      return value.ngMetadataName === 'Input';
  }
  function isOutput(value) {
      return value.ngMetadataName === 'Output';
  }
  function parseInputOutputs(values) {
      return values.reduce((map, value) => {
          const [field, property] = value.split(',').map(piece => piece.trim());
          map[field] = property || field;
          return map;
      }, {});
  }
  function publishFacade(global) {
      const ng = global.ng || (global.ng = {});
      ng.ɵcompilerFacade = new CompilerFacadeImpl();
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const VERSION$1 = new Version('7.2.8');

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * A segment of text within the template.
   */
  class TextAst {
      constructor(value, ngContentIndex, sourceSpan) {
          this.value = value;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitText(this, context); }
  }
  /**
   * A bound expression within the text of a template.
   */
  class BoundTextAst {
      constructor(value, ngContentIndex, sourceSpan) {
          this.value = value;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) {
          return visitor.visitBoundText(this, context);
      }
  }
  /**
   * A plain attribute on an element.
   */
  class AttrAst {
      constructor(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) { return visitor.visitAttr(this, context); }
  }
  const BoundPropertyMapping = {
      [4 /* Animation */]: 4 /* Animation */,
      [1 /* Attribute */]: 1 /* Attribute */,
      [2 /* Class */]: 2 /* Class */,
      [0 /* Property */]: 0 /* Property */,
      [3 /* Style */]: 3 /* Style */,
  };
  /**
   * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
   * `[@trigger]="stateExp"`)
   */
  class BoundElementPropertyAst {
      constructor(name, type, securityContext, value, unit, sourceSpan) {
          this.name = name;
          this.type = type;
          this.securityContext = securityContext;
          this.value = value;
          this.unit = unit;
          this.sourceSpan = sourceSpan;
          this.isAnimation = this.type === 4 /* Animation */;
      }
      static fromBoundProperty(prop) {
          const type = BoundPropertyMapping[prop.type];
          return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);
      }
      visit(visitor, context) {
          return visitor.visitElementProperty(this, context);
      }
  }
  /**
   * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
   * `(@trigger.phase)="callback($event)"`).
   */
  class BoundEventAst {
      constructor(name, target, phase, handler, sourceSpan) {
          this.name = name;
          this.target = target;
          this.phase = phase;
          this.handler = handler;
          this.sourceSpan = sourceSpan;
          this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);
          this.isAnimation = !!this.phase;
      }
      static calcFullName(name, target, phase) {
          if (target) {
              return `${target}:${name}`;
          }
          if (phase) {
              return `@${name}.${phase}`;
          }
          return name;
      }
      static fromParsedEvent(event) {
          const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;
          const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;
          return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan);
      }
      visit(visitor, context) {
          return visitor.visitEvent(this, context);
      }
  }
  /**
   * A reference declaration on an element (e.g. `let someName="expression"`).
   */
  class ReferenceAst {
      constructor(name, value, originalValue, sourceSpan) {
          this.name = name;
          this.value = value;
          this.originalValue = originalValue;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) {
          return visitor.visitReference(this, context);
      }
  }
  /**
   * A variable declaration on a <ng-template> (e.g. `var-someName="someLocalName"`).
   */
  class VariableAst {
      constructor(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      static fromParsedVariable(v) {
          return new VariableAst(v.name, v.value, v.sourceSpan);
      }
      visit(visitor, context) {
          return visitor.visitVariable(this, context);
      }
  }
  /**
   * An element declaration in a template.
   */
  class ElementAst {
      constructor(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {
          this.name = name;
          this.attrs = attrs;
          this.inputs = inputs;
          this.outputs = outputs;
          this.references = references;
          this.directives = directives;
          this.providers = providers;
          this.hasViewContainer = hasViewContainer;
          this.queryMatches = queryMatches;
          this.children = children;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
          this.endSourceSpan = endSourceSpan;
      }
      visit(visitor, context) {
          return visitor.visitElement(this, context);
      }
  }
  /**
   * A `<ng-template>` element included in an Angular template.
   */
  class EmbeddedTemplateAst {
      constructor(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {
          this.attrs = attrs;
          this.outputs = outputs;
          this.references = references;
          this.variables = variables;
          this.directives = directives;
          this.providers = providers;
          this.hasViewContainer = hasViewContainer;
          this.queryMatches = queryMatches;
          this.children = children;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) {
          return visitor.visitEmbeddedTemplate(this, context);
      }
  }
  /**
   * A directive property with a bound value (e.g. `*ngIf="condition").
   */
  class BoundDirectivePropertyAst {
      constructor(directiveName, templateName, value, sourceSpan) {
          this.directiveName = directiveName;
          this.templateName = templateName;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) {
          return visitor.visitDirectiveProperty(this, context);
      }
  }
  /**
   * A directive declared on an element.
   */
  class DirectiveAst {
      constructor(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {
          this.directive = directive;
          this.inputs = inputs;
          this.hostProperties = hostProperties;
          this.hostEvents = hostEvents;
          this.contentQueryStartId = contentQueryStartId;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) {
          return visitor.visitDirective(this, context);
      }
  }
  /**
   * A provider declared on an element
   */
  class ProviderAst {
      constructor(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {
          this.token = token;
          this.multiProvider = multiProvider;
          this.eager = eager;
          this.providers = providers;
          this.providerType = providerType;
          this.lifecycleHooks = lifecycleHooks;
          this.sourceSpan = sourceSpan;
          this.isModule = isModule;
      }
      visit(visitor, context) {
          // No visit method in the visitor for now...
          return null;
      }
  }
  var ProviderAstType;
  (function (ProviderAstType) {
      ProviderAstType[ProviderAstType["PublicService"] = 0] = "PublicService";
      ProviderAstType[ProviderAstType["PrivateService"] = 1] = "PrivateService";
      ProviderAstType[ProviderAstType["Component"] = 2] = "Component";
      ProviderAstType[ProviderAstType["Directive"] = 3] = "Directive";
      ProviderAstType[ProviderAstType["Builtin"] = 4] = "Builtin";
  })(ProviderAstType || (ProviderAstType = {}));
  /**
   * Position where content is to be projected (instance of `<ng-content>` in a template).
   */
  class NgContentAst {
      constructor(index, ngContentIndex, sourceSpan) {
          this.index = index;
          this.ngContentIndex = ngContentIndex;
          this.sourceSpan = sourceSpan;
      }
      visit(visitor, context) {
          return visitor.visitNgContent(this, context);
      }
  }
  /**
   * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
   */
  function templateVisitAll(visitor, asts, context = null) {
      const result = [];
      const visit = visitor.visit ?
          (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :
          (ast) => ast.visit(visitor, context);
      asts.forEach(ast => {
          const astResult = visit(ast);
          if (astResult) {
              result.push(astResult);
          }
      });
      return result;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class CompilerConfig {
      constructor({ defaultEncapsulation = ViewEncapsulation.Emulated, useJit = true, jitDevMode = false, missingTranslation = null, preserveWhitespaces, strictInjectionParameters } = {}) {
          this.defaultEncapsulation = defaultEncapsulation;
          this.useJit = !!useJit;
          this.jitDevMode = !!jitDevMode;
          this.missingTranslation = missingTranslation;
          this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));
          this.strictInjectionParameters = strictInjectionParameters === true;
      }
  }
  function preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {
      return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class DirectiveNormalizer {
      constructor(_resourceLoader, _urlResolver, _htmlParser, _config) {
          this._resourceLoader = _resourceLoader;
          this._urlResolver = _urlResolver;
          this._htmlParser = _htmlParser;
          this._config = _config;
          this._resourceLoaderCache = new Map();
      }
      clearCache() { this._resourceLoaderCache.clear(); }
      clearCacheFor(normalizedDirective) {
          if (!normalizedDirective.isComponent) {
              return;
          }
          const template = normalizedDirective.template;
          this._resourceLoaderCache.delete(template.templateUrl);
          template.externalStylesheets.forEach((stylesheet) => { this._resourceLoaderCache.delete(stylesheet.moduleUrl); });
      }
      _fetch(url) {
          let result = this._resourceLoaderCache.get(url);
          if (!result) {
              result = this._resourceLoader.get(url);
              this._resourceLoaderCache.set(url, result);
          }
          return result;
      }
      normalizeTemplate(prenormData) {
          if (isDefined(prenormData.template)) {
              if (isDefined(prenormData.templateUrl)) {
                  throw syntaxError(`'${stringify(prenormData.componentType)}' component cannot define both template and templateUrl`);
              }
              if (typeof prenormData.template !== 'string') {
                  throw syntaxError(`The template specified for component ${stringify(prenormData.componentType)} is not a string`);
              }
          }
          else if (isDefined(prenormData.templateUrl)) {
              if (typeof prenormData.templateUrl !== 'string') {
                  throw syntaxError(`The templateUrl specified for component ${stringify(prenormData.componentType)} is not a string`);
              }
          }
          else {
              throw syntaxError(`No template specified for component ${stringify(prenormData.componentType)}`);
          }
          if (isDefined(prenormData.preserveWhitespaces) &&
              typeof prenormData.preserveWhitespaces !== 'boolean') {
              throw syntaxError(`The preserveWhitespaces option for component ${stringify(prenormData.componentType)} must be a boolean`);
          }
          return SyncAsync.then(this._preParseTemplate(prenormData), (preparsedTemplate) => this._normalizeTemplateMetadata(prenormData, preparsedTemplate));
      }
      _preParseTemplate(prenomData) {
          let template;
          let templateUrl;
          if (prenomData.template != null) {
              template = prenomData.template;
              templateUrl = prenomData.moduleUrl;
          }
          else {
              templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);
              template = this._fetch(templateUrl);
          }
          return SyncAsync.then(template, (template) => this._preparseLoadedTemplate(prenomData, template, templateUrl));
      }
      _preparseLoadedTemplate(prenormData, template, templateAbsUrl) {
          const isInline = !!prenormData.template;
          const interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);
          const templateUrl = templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline, templateUrl: templateAbsUrl });
          const rootNodesAndErrors = this._htmlParser.parse(template, templateUrl, { tokenizeExpansionForms: true, interpolationConfig });
          if (rootNodesAndErrors.errors.length > 0) {
              const errorString = rootNodesAndErrors.errors.join('\n');
              throw syntaxError(`Template parse errors:\n${errorString}`);
          }
          const templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: prenormData.styles, moduleUrl: prenormData.moduleUrl }));
          const visitor = new TemplatePreparseVisitor();
          visitAll(visitor, rootNodesAndErrors.rootNodes);
          const templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));
          const styles = templateMetadataStyles.styles.concat(templateStyles.styles);
          const inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);
          const styleUrls = this
              ._normalizeStylesheet(new CompileStylesheetMetadata({ styleUrls: prenormData.styleUrls, moduleUrl: prenormData.moduleUrl }))
              .styleUrls;
          return {
              template,
              templateUrl: templateAbsUrl, isInline,
              htmlAst: rootNodesAndErrors, styles, inlineStyleUrls, styleUrls,
              ngContentSelectors: visitor.ngContentSelectors,
          };
      }
      _normalizeTemplateMetadata(prenormData, preparsedTemplate) {
          return SyncAsync.then(this._loadMissingExternalStylesheets(preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)), (externalStylesheets) => this._normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, externalStylesheets));
      }
      _normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, stylesheets) {
          // Algorithm:
          // - produce exactly 1 entry per original styleUrl in
          // CompileTemplateMetadata.externalStylesheets with all styles inlined
          // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.
          // Reason: be able to determine how many stylesheets there are even without loading
          // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously
          // (as resource loading may be async)
          const styles = [...preparsedTemplate.styles];
          this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);
          const styleUrls = preparsedTemplate.styleUrls;
          const externalStylesheets = styleUrls.map(styleUrl => {
              const stylesheet = stylesheets.get(styleUrl);
              const styles = [...stylesheet.styles];
              this._inlineStyles(stylesheet.styleUrls, stylesheets, styles);
              return new CompileStylesheetMetadata({ moduleUrl: styleUrl, styles: styles });
          });
          let encapsulation = prenormData.encapsulation;
          if (encapsulation == null) {
              encapsulation = this._config.defaultEncapsulation;
          }
          if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 &&
              styleUrls.length === 0) {
              encapsulation = ViewEncapsulation.None;
          }
          return new CompileTemplateMetadata({
              encapsulation,
              template: preparsedTemplate.template,
              templateUrl: preparsedTemplate.templateUrl,
              htmlAst: preparsedTemplate.htmlAst, styles, styleUrls,
              ngContentSelectors: preparsedTemplate.ngContentSelectors,
              animations: prenormData.animations,
              interpolation: prenormData.interpolation,
              isInline: preparsedTemplate.isInline, externalStylesheets,
              preserveWhitespaces: preserveWhitespacesDefault(prenormData.preserveWhitespaces, this._config.preserveWhitespaces),
          });
      }
      _inlineStyles(styleUrls, stylesheets, targetStyles) {
          styleUrls.forEach(styleUrl => {
              const stylesheet = stylesheets.get(styleUrl);
              stylesheet.styles.forEach(style => targetStyles.push(style));
              this._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);
          });
      }
      _loadMissingExternalStylesheets(styleUrls, loadedStylesheets = new Map()) {
          return SyncAsync.then(SyncAsync.all(styleUrls.filter((styleUrl) => !loadedStylesheets.has(styleUrl))
              .map(styleUrl => SyncAsync.then(this._fetch(styleUrl), (loadedStyle) => {
              const stylesheet = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));
              loadedStylesheets.set(styleUrl, stylesheet);
              return this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);
          }))), (_) => loadedStylesheets);
      }
      _normalizeStylesheet(stylesheet) {
          const moduleUrl = stylesheet.moduleUrl;
          const allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)
              .map(url => this._urlResolver.resolve(moduleUrl, url));
          const allStyles = stylesheet.styles.map(style => {
              const styleWithImports = extractStyleUrls(this._urlResolver, moduleUrl, style);
              allStyleUrls.push(...styleWithImports.styleUrls);
              return styleWithImports.style;
          });
          return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl });
      }
  }
  class TemplatePreparseVisitor {
      constructor() {
          this.ngContentSelectors = [];
          this.styles = [];
          this.styleUrls = [];
          this.ngNonBindableStackCount = 0;
      }
      visitElement(ast, context) {
          const preparsedElement = preparseElement(ast);
          switch (preparsedElement.type) {
              case PreparsedElementType.NG_CONTENT:
                  if (this.ngNonBindableStackCount === 0) {
                      this.ngContentSelectors.push(preparsedElement.selectAttr);
                  }
                  break;
              case PreparsedElementType.STYLE:
                  let textContent = '';
                  ast.children.forEach(child => {
                      if (child instanceof Text$2) {
                          textContent += child.value;
                      }
                  });
                  this.styles.push(textContent);
                  break;
              case PreparsedElementType.STYLESHEET:
                  this.styleUrls.push(preparsedElement.hrefAttr);
                  break;
              default:
                  break;
          }
          if (preparsedElement.nonBindable) {
              this.ngNonBindableStackCount++;
          }
          visitAll(this, ast.children);
          if (preparsedElement.nonBindable) {
              this.ngNonBindableStackCount--;
          }
          return null;
      }
      visitExpansion(ast, context) { visitAll(this, ast.cases); }
      visitExpansionCase(ast, context) {
          visitAll(this, ast.expression);
      }
      visitComment(ast, context) { return null; }
      visitAttribute(ast, context) { return null; }
      visitText(ast, context) { return null; }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const QUERY_METADATA_IDENTIFIERS = [
      createViewChild,
      createViewChildren,
      createContentChild,
      createContentChildren,
  ];
  /*
   * Resolve a `Type` for {@link Directive}.
   *
   * This interface can be overridden by the application developer to create custom behavior.
   *
   * See {@link Compiler}
   */
  class DirectiveResolver {
      constructor(_reflector) {
          this._reflector = _reflector;
      }
      isDirective(type) {
          const typeMetadata = this._reflector.annotations(resolveForwardRef(type));
          return typeMetadata && typeMetadata.some(isDirectiveMetadata);
      }
      resolve(type, throwIfNotFound = true) {
          const typeMetadata = this._reflector.annotations(resolveForwardRef(type));
          if (typeMetadata) {
              const metadata = findLast(typeMetadata, isDirectiveMetadata);
              if (metadata) {
                  const propertyMetadata = this._reflector.propMetadata(type);
                  const guards = this._reflector.guards(type);
                  return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);
              }
          }
          if (throwIfNotFound) {
              throw new Error(`No Directive annotation found on ${stringify(type)}`);
          }
          return null;
      }
      _mergeWithPropertyMetadata(dm, propertyMetadata, guards, directiveType) {
          const inputs = [];
          const outputs = [];
          const host = {};
          const queries = {};
          Object.keys(propertyMetadata).forEach((propName) => {
              const input = findLast(propertyMetadata[propName], (a) => createInput.isTypeOf(a));
              if (input) {
                  if (input.bindingPropertyName) {
                      inputs.push(`${propName}: ${input.bindingPropertyName}`);
                  }
                  else {
                      inputs.push(propName);
                  }
              }
              const output = findLast(propertyMetadata[propName], (a) => createOutput.isTypeOf(a));
              if (output) {
                  if (output.bindingPropertyName) {
                      outputs.push(`${propName}: ${output.bindingPropertyName}`);
                  }
                  else {
                      outputs.push(propName);
                  }
              }
              const hostBindings = propertyMetadata[propName].filter(a => createHostBinding.isTypeOf(a));
              hostBindings.forEach(hostBinding => {
                  if (hostBinding.hostPropertyName) {
                      const startWith = hostBinding.hostPropertyName[0];
                      if (startWith === '(') {
                          throw new Error(`@HostBinding can not bind to events. Use @HostListener instead.`);
                      }
                      else if (startWith === '[') {
                          throw new Error(`@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);
                      }
                      host[`[${hostBinding.hostPropertyName}]`] = propName;
                  }
                  else {
                      host[`[${propName}]`] = propName;
                  }
              });
              const hostListeners = propertyMetadata[propName].filter(a => createHostListener.isTypeOf(a));
              hostListeners.forEach(hostListener => {
                  const args = hostListener.args || [];
                  host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;
              });
              const query = findLast(propertyMetadata[propName], (a) => QUERY_METADATA_IDENTIFIERS.some(i => i.isTypeOf(a)));
              if (query) {
                  queries[propName] = query;
              }
          });
          return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);
      }
      _extractPublicName(def) { return splitAtColon(def, [null, def])[1].trim(); }
      _dedupeBindings(bindings) {
          const names = new Set();
          const publicNames = new Set();
          const reversedResult = [];
          // go last to first to allow later entries to overwrite previous entries
          for (let i = bindings.length - 1; i >= 0; i--) {
              const binding = bindings[i];
              const name = this._extractPublicName(binding);
              publicNames.add(name);
              if (!names.has(name)) {
                  names.add(name);
                  reversedResult.push(binding);
              }
          }
          return reversedResult.reverse();
      }
      _merge(directive, inputs, outputs, host, queries, guards, directiveType) {
          const mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);
          const mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);
          const mergedHost = directive.host ? Object.assign({}, directive.host, host) : host;
          const mergedQueries = directive.queries ? Object.assign({}, directive.queries, queries) : queries;
          if (createComponent.isTypeOf(directive)) {
              const comp = directive;
              return createComponent({
                  selector: comp.selector,
                  inputs: mergedInputs,
                  outputs: mergedOutputs,
                  host: mergedHost,
                  exportAs: comp.exportAs,
                  moduleId: comp.moduleId,
                  queries: mergedQueries,
                  changeDetection: comp.changeDetection,
                  providers: comp.providers,
                  viewProviders: comp.viewProviders,
                  entryComponents: comp.entryComponents,
                  template: comp.template,
                  templateUrl: comp.templateUrl,
                  styles: comp.styles,
                  styleUrls: comp.styleUrls,
                  encapsulation: comp.encapsulation,
                  animations: comp.animations,
                  interpolation: comp.interpolation,
                  preserveWhitespaces: directive.preserveWhitespaces,
              });
          }
          else {
              return createDirective({
                  selector: directive.selector,
                  inputs: mergedInputs,
                  outputs: mergedOutputs,
                  host: mergedHost,
                  exportAs: directive.exportAs,
                  queries: mergedQueries,
                  providers: directive.providers, guards
              });
          }
      }
  }
  function isDirectiveMetadata(type) {
      return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);
  }
  function findLast(arr, condition) {
      for (let i = arr.length - 1; i >= 0; i--) {
          if (condition(arr[i])) {
              return arr[i];
          }
      }
      return null;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * An i18n error.
   */
  class I18nError extends ParseError {
      constructor(span, msg) { super(span, msg); }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const _I18N_ATTR = 'i18n';
  const _I18N_ATTR_PREFIX = 'i18n-';
  const _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
  const MEANING_SEPARATOR = '|';
  const ID_SEPARATOR = '@@';
  let i18nCommentsWarned = false;
  function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
      const visitor = new _Visitor$2(implicitTags, implicitAttrs);
      return visitor.merge(nodes, translations, interpolationConfig);
  }
  class ExtractionResult {
      constructor(messages, errors) {
          this.messages = messages;
          this.errors = errors;
      }
  }
  var _VisitorMode;
  (function (_VisitorMode) {
      _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
      _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
  })(_VisitorMode || (_VisitorMode = {}));
  /**
   * This Visitor is used:
   * 1. to extract all the translatable strings from an html AST (see `extract()`),
   * 2. to replace the translatable strings with the actual translations (see `merge()`)
   *
   * @internal
   */
  class _Visitor$2 {
      constructor(_implicitTags, _implicitAttrs) {
          this._implicitTags = _implicitTags;
          this._implicitAttrs = _implicitAttrs;
      }
      /**
       * Extracts the messages from the tree
       */
      extract(nodes, interpolationConfig) {
          this._init(_VisitorMode.Extract, interpolationConfig);
          nodes.forEach(node => node.visit(this, null));
          if (this._inI18nBlock) {
              this._reportError(nodes[nodes.length - 1], 'Unclosed block');
          }
          return new ExtractionResult(this._messages, this._errors);
      }
      /**
       * Returns a tree where all translatable nodes are translated
       */
      merge(nodes, translations, interpolationConfig) {
          this._init(_VisitorMode.Merge, interpolationConfig);
          this._translations = translations;
          // Construct a single fake root element
          const wrapper = new Element$1('wrapper', [], nodes, undefined, undefined, undefined);
          const translatedNode = wrapper.visit(this, null);
          if (this._inI18nBlock) {
              this._reportError(nodes[nodes.length - 1], 'Unclosed block');
          }
          return new ParseTreeResult(translatedNode.children, this._errors);
      }
      visitExpansionCase(icuCase, context) {
          // Parse cases for translatable html attributes
          const expression = visitAll(this, icuCase.expression, context);
          if (this._mode === _VisitorMode.Merge) {
              return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
          }
      }
      visitExpansion(icu, context) {
          this._mayBeAddBlockChildren(icu);
          const wasInIcu = this._inIcu;
          if (!this._inIcu) {
              // nested ICU messages should not be extracted but top-level translated as a whole
              if (this._isInTranslatableSection) {
                  this._addMessage([icu]);
              }
              this._inIcu = true;
          }
          const cases = visitAll(this, icu.cases, context);
          if (this._mode === _VisitorMode.Merge) {
              icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
          }
          this._inIcu = wasInIcu;
          return icu;
      }
      visitComment(comment, context) {
          const isOpening = _isOpeningComment(comment);
          if (isOpening && this._isInTranslatableSection) {
              this._reportError(comment, 'Could not start a block inside a translatable section');
              return;
          }
          const isClosing = _isClosingComment(comment);
          if (isClosing && !this._inI18nBlock) {
              this._reportError(comment, 'Trying to close an unopened block');
              return;
          }
          if (!this._inI18nNode && !this._inIcu) {
              if (!this._inI18nBlock) {
                  if (isOpening) {
                      // deprecated from v5 you should use <ng-container i18n> instead of i18n comments
                      if (!i18nCommentsWarned && console && console.warn) {
                          i18nCommentsWarned = true;
                          const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';
                          // TODO(ocombe): use a log service once there is a public one available
                          console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);
                      }
                      this._inI18nBlock = true;
                      this._blockStartDepth = this._depth;
                      this._blockChildren = [];
                      this._blockMeaningAndDesc =
                          comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();
                      this._openTranslatableSection(comment);
                  }
              }
              else {
                  if (isClosing) {
                      if (this._depth == this._blockStartDepth) {
                          this._closeTranslatableSection(comment, this._blockChildren);
                          this._inI18nBlock = false;
                          const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);
                          // merge attributes in sections
                          const nodes = this._translateMessage(comment, message);
                          return visitAll(this, nodes);
                      }
                      else {
                          this._reportError(comment, 'I18N blocks should not cross element boundaries');
                          return;
                      }
                  }
              }
          }
      }
      visitText(text, context) {
          if (this._isInTranslatableSection) {
              this._mayBeAddBlockChildren(text);
          }
          return text;
      }
      visitElement(el, context) {
          this._mayBeAddBlockChildren(el);
          this._depth++;
          const wasInI18nNode = this._inI18nNode;
          const wasInImplicitNode = this._inImplicitNode;
          let childNodes = [];
          let translatedChildNodes = undefined;
          // Extract:
          // - top level nodes with the (implicit) "i18n" attribute if not already in a section
          // - ICU messages
          const i18nAttr = _getI18nAttr(el);
          const i18nMeta = i18nAttr ? i18nAttr.value : '';
          const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&
              !this._isInTranslatableSection;
          const isTopLevelImplicit = !wasInImplicitNode && isImplicit;
          this._inImplicitNode = wasInImplicitNode || isImplicit;
          if (!this._isInTranslatableSection && !this._inIcu) {
              if (i18nAttr || isTopLevelImplicit) {
                  this._inI18nNode = true;
                  const message = this._addMessage(el.children, i18nMeta);
                  translatedChildNodes = this._translateMessage(el, message);
              }
              if (this._mode == _VisitorMode.Extract) {
                  const isTranslatable = i18nAttr || isTopLevelImplicit;
                  if (isTranslatable)
                      this._openTranslatableSection(el);
                  visitAll(this, el.children);
                  if (isTranslatable)
                      this._closeTranslatableSection(el, el.children);
              }
          }
          else {
              if (i18nAttr || isTopLevelImplicit) {
                  this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
              }
              if (this._mode == _VisitorMode.Extract) {
                  // Descend into child nodes for extraction
                  visitAll(this, el.children);
              }
          }
          if (this._mode === _VisitorMode.Merge) {
              const visitNodes = translatedChildNodes || el.children;
              visitNodes.forEach(child => {
                  const visited = child.visit(this, context);
                  if (visited && !this._isInTranslatableSection) {
                      // Do not add the children from translatable sections (= i18n blocks here)
                      // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)
                      childNodes = childNodes.concat(visited);
                  }
              });
          }
          this._visitAttributesOf(el);
          this._depth--;
          this._inI18nNode = wasInI18nNode;
          this._inImplicitNode = wasInImplicitNode;
          if (this._mode === _VisitorMode.Merge) {
              const translatedAttrs = this._translateAttributes(el);
              return new Element$1(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
          }
          return null;
      }
      visitAttribute(attribute, context) {
          throw new Error('unreachable code');
      }
      _init(mode, interpolationConfig) {
          this._mode = mode;
          this._inI18nBlock = false;
          this._inI18nNode = false;
          this._depth = 0;
          this._inIcu = false;
          this._msgCountAtSectionStart = undefined;
          this._errors = [];
          this._messages = [];
          this._inImplicitNode = false;
          this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
      }
      // looks for translatable attributes
      _visitAttributesOf(el) {
          const explicitAttrNameToValue = {};
          const implicitAttrNames = this._implicitAttrs[el.name] || [];
          el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))
              .forEach(attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
              attr.value);
          el.attrs.forEach(attr => {
              if (attr.name in explicitAttrNameToValue) {
                  this._addMessage([attr], explicitAttrNameToValue[attr.name]);
              }
              else if (implicitAttrNames.some(name => attr.name === name)) {
                  this._addMessage([attr]);
              }
          });
      }
      // add a translatable message
      _addMessage(ast, msgMeta) {
          if (ast.length == 0 ||
              ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {
              // Do not create empty messages
              return null;
          }
          const { meaning, description, id } = _parseMessageMeta(msgMeta);
          const message = this._createI18nMessage(ast, meaning, description, id);
          this._messages.push(message);
          return message;
      }
      // Translates the given message given the `TranslationBundle`
      // This is used for translating elements / blocks - see `_translateAttributes` for attributes
      // no-op when called in extraction mode (returns [])
      _translateMessage(el, message) {
          if (message && this._mode === _VisitorMode.Merge) {
              const nodes = this._translations.get(message);
              if (nodes) {
                  return nodes;
              }
              this._reportError(el, `Translation unavailable for message id="${this._translations.digest(message)}"`);
          }
          return [];
      }
      // translate the attributes of an element and remove i18n specific attributes
      _translateAttributes(el) {
          const attributes = el.attrs;
          const i18nParsedMessageMeta = {};
          attributes.forEach(attr => {
              if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
                  i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =
                      _parseMessageMeta(attr.value);
              }
          });
          const translatedAttributes = [];
          attributes.forEach((attr) => {
              if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
                  // strip i18n specific attributes
                  return;
              }
              if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {
                  const { meaning, description, id } = i18nParsedMessageMeta[attr.name];
                  const message = this._createI18nMessage([attr], meaning, description, id);
                  const nodes = this._translations.get(message);
                  if (nodes) {
                      if (nodes.length == 0) {
                          translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan));
                      }
                      else if (nodes[0] instanceof Text$2) {
                          const value = nodes[0].value;
                          translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan));
                      }
                      else {
                          this._reportError(el, `Unexpected translation for attribute "${attr.name}" (id="${id || this._translations.digest(message)}")`);
                      }
                  }
                  else {
                      this._reportError(el, `Translation unavailable for attribute "${attr.name}" (id="${id || this._translations.digest(message)}")`);
                  }
              }
              else {
                  translatedAttributes.push(attr);
              }
          });
          return translatedAttributes;
      }
      /**
       * Add the node as a child of the block when:
       * - we are in a block,
       * - we are not inside a ICU message (those are handled separately),
       * - the node is a "direct child" of the block
       */
      _mayBeAddBlockChildren(node) {
          if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
              this._blockChildren.push(node);
          }
      }
      /**
       * Marks the start of a section, see `_closeTranslatableSection`
       */
      _openTranslatableSection(node) {
          if (this._isInTranslatableSection) {
              this._reportError(node, 'Unexpected section start');
          }
          else {
              this._msgCountAtSectionStart = this._messages.length;
          }
      }
      /**
       * A translatable section could be:
       * - the content of translatable element,
       * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments
       */
      get _isInTranslatableSection() {
          return this._msgCountAtSectionStart !== void 0;
      }
      /**
       * Terminates a section.
       *
       * If a section has only one significant children (comments not significant) then we should not
       * keep the message from this children:
       *
       * `<p i18n="meaning|description">{ICU message}</p>` would produce two messages:
       * - one for the <p> content with meaning and description,
       * - another one for the ICU message.
       *
       * In this case the last message is discarded as it contains less information (the AST is
       * otherwise identical).
       *
       * Note that we should still keep messages extracted from attributes inside the section (ie in the
       * ICU message here)
       */
      _closeTranslatableSection(node, directChildren) {
          if (!this._isInTranslatableSection) {
              this._reportError(node, 'Unexpected section end');
              return;
          }
          const startIndex = this._msgCountAtSectionStart;
          const significantChildren = directChildren.reduce((count, node) => count + (node instanceof Comment ? 0 : 1), 0);
          if (significantChildren == 1) {
              for (let i = this._messages.length - 1; i >= startIndex; i--) {
                  const ast = this._messages[i].nodes;
                  if (!(ast.length == 1 && ast[0] instanceof Text)) {
                      this._messages.splice(i, 1);
                      break;
                  }
              }
          }
          this._msgCountAtSectionStart = undefined;
      }
      _reportError(node, msg) {
          this._errors.push(new I18nError(node.sourceSpan, msg));
      }
  }
  function _isOpeningComment(n) {
      return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));
  }
  function _isClosingComment(n) {
      return !!(n instanceof Comment && n.value && n.value === '/i18n');
  }
  function _getI18nAttr(p) {
      return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;
  }
  function _parseMessageMeta(i18n) {
      if (!i18n)
          return { meaning: '', description: '', id: '' };
      const idIndex = i18n.indexOf(ID_SEPARATOR);
      const descIndex = i18n.indexOf(MEANING_SEPARATOR);
      const [meaningAndDesc, id] = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];
      const [meaning, description] = (descIndex > -1) ?
          [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :
          ['', meaningAndDesc];
      return { meaning, description, id };
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class XmlTagDefinition {
      constructor() {
          this.closedByParent = false;
          this.contentType = TagContentType.PARSABLE_DATA;
          this.isVoid = false;
          this.ignoreFirstLf = false;
          this.canSelfClose = true;
      }
      requireExtraParent(currentParent) { return false; }
      isClosedByChild(name) { return false; }
  }
  const _TAG_DEFINITION = new XmlTagDefinition();
  function getXmlTagDefinition(tagName) {
      return _TAG_DEFINITION;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class XmlParser extends Parser$1 {
      constructor() { super(getXmlTagDefinition); }
      parse(source, url, options) {
          return super.parse(source, url, options);
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const _VERSION = '1.2';
  const _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';
  // TODO(vicb): make this a param (s/_/-/)
  const _DEFAULT_SOURCE_LANG = 'en';
  const _PLACEHOLDER_TAG$1 = 'x';
  const _MARKER_TAG = 'mrk';
  const _FILE_TAG = 'file';
  const _SOURCE_TAG$1 = 'source';
  const _SEGMENT_SOURCE_TAG = 'seg-source';
  const _TARGET_TAG = 'target';
  const _UNIT_TAG = 'trans-unit';
  const _CONTEXT_GROUP_TAG = 'context-group';
  const _CONTEXT_TAG = 'context';
  // http://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html
  // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html
  class Xliff extends Serializer {
      write(messages, locale) {
          const visitor = new _WriteVisitor();
          const transUnits = [];
          messages.forEach(message => {
              let contextTags = [];
              message.sources.forEach((source) => {
                  let contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });
                  contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$1(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$1(`${source.startLine}`)]), new CR(8));
                  contextTags.push(new CR(8), contextGroupTag);
              });
              const transUnit = new Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });
              transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), ...contextTags);
              if (message.description) {
                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$1(message.description)]));
              }
              if (message.meaning) {
                  transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$1(message.meaning)]));
              }
              transUnit.children.push(new CR(6));
              transUnits.push(new CR(6), transUnit);
          });
          const body = new Tag('body', {}, [...transUnits, new CR(4)]);
          const file = new Tag('file', {
              'source-language': locale || _DEFAULT_SOURCE_LANG,
              datatype: 'plaintext',
              original: 'ng2.template',
          }, [new CR(4), body, new CR(2)]);
          const xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);
          return serialize([
              new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()
          ]);
      }
      load(content, url) {
          // xliff to xml nodes
          const xliffParser = new XliffParser();
          const { locale, msgIdToHtml, errors } = xliffParser.parse(content, url);
          // xml nodes to i18n nodes
          const i18nNodesByMsgId = {};
          const converter = new XmlToI18n();
          Object.keys(msgIdToHtml).forEach(msgId => {
              const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);
              errors.push(...e);
              i18nNodesByMsgId[msgId] = i18nNodes;
          });
          if (errors.length) {
              throw new Error(`xliff parse errors:\n${errors.join('\n')}`);
          }
          return { locale: locale, i18nNodesByMsgId };
      }
      digest(message) { return digest(message); }
  }
  class _WriteVisitor {
      visitText(text, context) { return [new Text$1(text.value)]; }
      visitContainer(container, context) {
          const nodes = [];
          container.children.forEach((node) => nodes.push(...node.visit(this)));
          return nodes;
      }
      visitIcu(icu, context) {
          const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];
          Object.keys(icu.cases).forEach((c) => {
              nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));
          });
          nodes.push(new Text$1(`}`));
          return nodes;
      }
      visitTagPlaceholder(ph, context) {
          const ctype = getCtypeForTag(ph.tag);
          if (ph.isVoid) {
              // void tags have no children nor closing tags
              return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>` })];
          }
          const startTagPh = new Tag(_PLACEHOLDER_TAG$1, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}>` });
          const closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { id: ph.closeName, ctype, 'equiv-text': `</${ph.tag}>` });
          return [startTagPh, ...this.serialize(ph.children), closeTagPh];
      }
      visitPlaceholder(ph, context) {
          return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.name, 'equiv-text': `{{${ph.value}}}` })];
      }
      visitIcuPlaceholder(ph, context) {
          const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ')}}`;
          return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.name, 'equiv-text': equivText })];
      }
      serialize(nodes) {
          return [].concat(...nodes.map(node => node.visit(this)));
      }
  }
  // TODO(vicb): add error management (structure)
  // Extract messages as xml nodes from the xliff file
  class XliffParser {
      constructor() {
          this._locale = null;
      }
      parse(xliff, url) {
          this._unitMlString = null;
          this._msgIdToHtml = {};
          const xml = new XmlParser().parse(xliff, url);
          this._errors = xml.errors;
          visitAll(this, xml.rootNodes, null);
          return {
              msgIdToHtml: this._msgIdToHtml,
              errors: this._errors,
              locale: this._locale,
          };
      }
      visitElement(element, context) {
          switch (element.name) {
              case _UNIT_TAG:
                  this._unitMlString = null;
                  const idAttr = element.attrs.find((attr) => attr.name === 'id');
                  if (!idAttr) {
                      this._addError(element, `<${_UNIT_TAG}> misses the "id" attribute`);
                  }
                  else {
                      const id = idAttr.value;
                      if (this._msgIdToHtml.hasOwnProperty(id)) {
                          this._addError(element, `Duplicated translations for msg ${id}`);
                      }
                      else {
                          visitAll(this, element.children, null);
                          if (typeof this._unitMlString === 'string') {
                              this._msgIdToHtml[id] = this._unitMlString;
                          }
                          else {
                              this._addError(element, `Message ${id} misses a translation`);
                          }
                      }
                  }
                  break;
              // ignore those tags
              case _SOURCE_TAG$1:
              case _SEGMENT_SOURCE_TAG:
                  break;
              case _TARGET_TAG:
                  const innerTextStart = element.startSourceSpan.end.offset;
                  const innerTextEnd = element.endSourceSpan.start.offset;
                  const content = element.startSourceSpan.start.file.content;
                  const innerText = content.slice(innerTextStart, innerTextEnd);
                  this._unitMlString = innerText;
                  break;
              case _FILE_TAG:
                  const localeAttr = element.attrs.find((attr) => attr.name === 'target-language');
                  if (localeAttr) {
                      this._locale = localeAttr.value;
                  }
                  visitAll(this, element.children, null);
                  break;
              default:
                  // TODO(vicb): assert file structure, xliff version
                  // For now only recurse on unhandled nodes
                  visitAll(this, element.children, null);
          }
      }
      visitAttribute(attribute, context) { }
      visitText(text, context) { }
      visitComment(comment, context) { }
      visitExpansion(expansion, context) { }
      visitExpansionCase(expansionCase, context) { }
      _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      }
  }
  // Convert ml nodes (xliff syntax) to i18n nodes
  class XmlToI18n {
      convert(message, url) {
          const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });
          this._errors = xmlIcu.errors;
          const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?
              [] :
              [].concat(...visitAll(this, xmlIcu.rootNodes));
          return {
              i18nNodes: i18nNodes,
              errors: this._errors,
          };
      }
      visitText(text, context) { return new Text(text.value, text.sourceSpan); }
      visitElement(el, context) {
          if (el.name === _PLACEHOLDER_TAG$1) {
              const nameAttr = el.attrs.find((attr) => attr.name === 'id');
              if (nameAttr) {
                  return new Placeholder('', nameAttr.value, el.sourceSpan);
              }
              this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the "id" attribute`);
              return null;
          }
          if (el.name === _MARKER_TAG) {
              return [].concat(...visitAll(this, el.children));
          }
          this._addError(el, `Unexpected tag`);
          return null;
      }
      visitExpansion(icu, context) {
          const caseMap = {};
          visitAll(this, icu.cases).forEach((c) => {
              caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
          });
          return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
      }
      visitExpansionCase(icuCase, context) {
          return {
              value: icuCase.value,
              nodes: visitAll(this, icuCase.expression),
          };
      }
      visitComment(comment, context) { }
      visitAttribute(attribute, context) { }
      _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      }
  }
  function getCtypeForTag(tag) {
      switch (tag.toLowerCase()) {
          case 'br':
              return 'lb';
          case 'img':
              return 'image';
          default:
              return `x-${tag}`;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const _VERSION$1 = '2.0';
  const _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0';
  // TODO(vicb): make this a param (s/_/-/)
  const _DEFAULT_SOURCE_LANG$1 = 'en';
  const _PLACEHOLDER_TAG$2 = 'ph';
  const _PLACEHOLDER_SPANNING_TAG = 'pc';
  const _MARKER_TAG$1 = 'mrk';
  const _XLIFF_TAG = 'xliff';
  const _SOURCE_TAG$2 = 'source';
  const _TARGET_TAG$1 = 'target';
  const _UNIT_TAG$1 = 'unit';
  // http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html
  class Xliff2 extends Serializer {
      write(messages, locale) {
          const visitor = new _WriteVisitor$1();
          const units = [];
          messages.forEach(message => {
              const unit = new Tag(_UNIT_TAG$1, { id: message.id });
              const notes = new Tag('notes');
              if (message.description || message.meaning) {
                  if (message.description) {
                      notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$1(message.description)]));
                  }
                  if (message.meaning) {
                      notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$1(message.meaning)]));
                  }
              }
              message.sources.forEach((source) => {
                  notes.children.push(new CR(8), new Tag('note', { category: 'location' }, [
                      new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)
                  ]));
              });
              notes.children.push(new CR(6));
              unit.children.push(new CR(6), notes);
              const segment = new Tag('segment');
              segment.children.push(new CR(8), new Tag(_SOURCE_TAG$2, {}, visitor.serialize(message.nodes)), new CR(6));
              unit.children.push(new CR(6), segment, new CR(4));
              units.push(new CR(4), unit);
          });
          const file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, [...units, new CR(2)]);
          const xliff = new Tag(_XLIFF_TAG, { version: _VERSION$1, xmlns: _XMLNS$1, srcLang: locale || _DEFAULT_SOURCE_LANG$1 }, [new CR(2), file, new CR()]);
          return serialize([
              new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()
          ]);
      }
      load(content, url) {
          // xliff to xml nodes
          const xliff2Parser = new Xliff2Parser();
          const { locale, msgIdToHtml, errors } = xliff2Parser.parse(content, url);
          // xml nodes to i18n nodes
          const i18nNodesByMsgId = {};
          const converter = new XmlToI18n$1();
          Object.keys(msgIdToHtml).forEach(msgId => {
              const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);
              errors.push(...e);
              i18nNodesByMsgId[msgId] = i18nNodes;
          });
          if (errors.length) {
              throw new Error(`xliff2 parse errors:\n${errors.join('\n')}`);
          }
          return { locale: locale, i18nNodesByMsgId };
      }
      digest(message) { return decimalDigest(message); }
  }
  class _WriteVisitor$1 {
      visitText(text, context) { return [new Text$1(text.value)]; }
      visitContainer(container, context) {
          const nodes = [];
          container.children.forEach((node) => nodes.push(...node.visit(this)));
          return nodes;
      }
      visitIcu(icu, context) {
          const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];
          Object.keys(icu.cases).forEach((c) => {
              nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));
          });
          nodes.push(new Text$1(`}`));
          return nodes;
      }
      visitTagPlaceholder(ph, context) {
          const type = getTypeForTag(ph.tag);
          if (ph.isVoid) {
              const tagPh = new Tag(_PLACEHOLDER_TAG$2, {
                  id: (this._nextPlaceholderId++).toString(),
                  equiv: ph.startName,
                  type: type,
                  disp: `<${ph.tag}/>`,
              });
              return [tagPh];
          }
          const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {
              id: (this._nextPlaceholderId++).toString(),
              equivStart: ph.startName,
              equivEnd: ph.closeName,
              type: type,
              dispStart: `<${ph.tag}>`,
              dispEnd: `</${ph.tag}>`,
          });
          const nodes = [].concat(...ph.children.map(node => node.visit(this)));
          if (nodes.length) {
              nodes.forEach((node) => tagPc.children.push(node));
          }
          else {
              tagPc.children.push(new Text$1(''));
          }
          return [tagPc];
      }
      visitPlaceholder(ph, context) {
          const idStr = (this._nextPlaceholderId++).toString();
          return [new Tag(_PLACEHOLDER_TAG$2, {
                  id: idStr,
                  equiv: ph.name,
                  disp: `{{${ph.value}}}`,
              })];
      }
      visitIcuPlaceholder(ph, context) {
          const cases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');
          const idStr = (this._nextPlaceholderId++).toString();
          return [new Tag(_PLACEHOLDER_TAG$2, { id: idStr, equiv: ph.name, disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}` })];
      }
      serialize(nodes) {
          this._nextPlaceholderId = 0;
          return [].concat(...nodes.map(node => node.visit(this)));
      }
  }
  // Extract messages as xml nodes from the xliff file
  class Xliff2Parser {
      constructor() {
          this._locale = null;
      }
      parse(xliff, url) {
          this._unitMlString = null;
          this._msgIdToHtml = {};
          const xml = new XmlParser().parse(xliff, url);
          this._errors = xml.errors;
          visitAll(this, xml.rootNodes, null);
          return {
              msgIdToHtml: this._msgIdToHtml,
              errors: this._errors,
              locale: this._locale,
          };
      }
      visitElement(element, context) {
          switch (element.name) {
              case _UNIT_TAG$1:
                  this._unitMlString = null;
                  const idAttr = element.attrs.find((attr) => attr.name === 'id');
                  if (!idAttr) {
                      this._addError(element, `<${_UNIT_TAG$1}> misses the "id" attribute`);
                  }
                  else {
                      const id = idAttr.value;
                      if (this._msgIdToHtml.hasOwnProperty(id)) {
                          this._addError(element, `Duplicated translations for msg ${id}`);
                      }
                      else {
                          visitAll(this, element.children, null);
                          if (typeof this._unitMlString === 'string') {
                              this._msgIdToHtml[id] = this._unitMlString;
                          }
                          else {
                              this._addError(element, `Message ${id} misses a translation`);
                          }
                      }
                  }
                  break;
              case _SOURCE_TAG$2:
                  // ignore source message
                  break;
              case _TARGET_TAG$1:
                  const innerTextStart = element.startSourceSpan.end.offset;
                  const innerTextEnd = element.endSourceSpan.start.offset;
                  const content = element.startSourceSpan.start.file.content;
                  const innerText = content.slice(innerTextStart, innerTextEnd);
                  this._unitMlString = innerText;
                  break;
              case _XLIFF_TAG:
                  const localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');
                  if (localeAttr) {
                      this._locale = localeAttr.value;
                  }
                  const versionAttr = element.attrs.find((attr) => attr.name === 'version');
                  if (versionAttr) {
                      const version = versionAttr.value;
                      if (version !== '2.0') {
                          this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);
                      }
                      else {
                          visitAll(this, element.children, null);
                      }
                  }
                  break;
              default:
                  visitAll(this, element.children, null);
          }
      }
      visitAttribute(attribute, context) { }
      visitText(text, context) { }
      visitComment(comment, context) { }
      visitExpansion(expansion, context) { }
      visitExpansionCase(expansionCase, context) { }
      _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      }
  }
  // Convert ml nodes (xliff syntax) to i18n nodes
  class XmlToI18n$1 {
      convert(message, url) {
          const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });
          this._errors = xmlIcu.errors;
          const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?
              [] :
              [].concat(...visitAll(this, xmlIcu.rootNodes));
          return {
              i18nNodes,
              errors: this._errors,
          };
      }
      visitText(text, context) { return new Text(text.value, text.sourceSpan); }
      visitElement(el, context) {
          switch (el.name) {
              case _PLACEHOLDER_TAG$2:
                  const nameAttr = el.attrs.find((attr) => attr.name === 'equiv');
                  if (nameAttr) {
                      return [new Placeholder('', nameAttr.value, el.sourceSpan)];
                  }
                  this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the "equiv" attribute`);
                  break;
              case _PLACEHOLDER_SPANNING_TAG:
                  const startAttr = el.attrs.find((attr) => attr.name === 'equivStart');
                  const endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');
                  if (!startAttr) {
                      this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the "equivStart" attribute`);
                  }
                  else if (!endAttr) {
                      this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the "equivEnd" attribute`);
                  }
                  else {
                      const startId = startAttr.value;
                      const endId = endAttr.value;
                      const nodes = [];
                      return nodes.concat(new Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new Placeholder('', endId, el.sourceSpan));
                  }
                  break;
              case _MARKER_TAG$1:
                  return [].concat(...visitAll(this, el.children));
              default:
                  this._addError(el, `Unexpected tag`);
          }
          return null;
      }
      visitExpansion(icu, context) {
          const caseMap = {};
          visitAll(this, icu.cases).forEach((c) => {
              caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
          });
          return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
      }
      visitExpansionCase(icuCase, context) {
          return {
              value: icuCase.value,
              nodes: [].concat(...visitAll(this, icuCase.expression)),
          };
      }
      visitComment(comment, context) { }
      visitAttribute(attribute, context) { }
      _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      }
  }
  function getTypeForTag(tag) {
      switch (tag.toLowerCase()) {
          case 'br':
          case 'b':
          case 'i':
          case 'u':
              return 'fmt';
          case 'img':
              return 'image';
          case 'a':
              return 'link';
          default:
              return 'other';
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const _TRANSLATIONS_TAG = 'translationbundle';
  const _TRANSLATION_TAG = 'translation';
  const _PLACEHOLDER_TAG$3 = 'ph';
  class Xtb extends Serializer {
      write(messages, locale) { throw new Error('Unsupported'); }
      load(content, url) {
          // xtb to xml nodes
          const xtbParser = new XtbParser();
          const { locale, msgIdToHtml, errors } = xtbParser.parse(content, url);
          // xml nodes to i18n nodes
          const i18nNodesByMsgId = {};
          const converter = new XmlToI18n$2();
          // Because we should be able to load xtb files that rely on features not supported by angular,
          // we need to delay the conversion of html to i18n nodes so that non angular messages are not
          // converted
          Object.keys(msgIdToHtml).forEach(msgId => {
              const valueFn = function () {
                  const { i18nNodes, errors } = converter.convert(msgIdToHtml[msgId], url);
                  if (errors.length) {
                      throw new Error(`xtb parse errors:\n${errors.join('\n')}`);
                  }
                  return i18nNodes;
              };
              createLazyProperty(i18nNodesByMsgId, msgId, valueFn);
          });
          if (errors.length) {
              throw new Error(`xtb parse errors:\n${errors.join('\n')}`);
          }
          return { locale: locale, i18nNodesByMsgId };
      }
      digest(message) { return digest$1(message); }
      createNameMapper(message) {
          return new SimplePlaceholderMapper(message, toPublicName);
      }
  }
  function createLazyProperty(messages, id, valueFn) {
      Object.defineProperty(messages, id, {
          configurable: true,
          enumerable: true,
          get: function () {
              const value = valueFn();
              Object.defineProperty(messages, id, { enumerable: true, value });
              return value;
          },
          set: _ => { throw new Error('Could not overwrite an XTB translation'); },
      });
  }
  // Extract messages as xml nodes from the xtb file
  class XtbParser {
      constructor() {
          this._locale = null;
      }
      parse(xtb, url) {
          this._bundleDepth = 0;
          this._msgIdToHtml = {};
          // We can not parse the ICU messages at this point as some messages might not originate
          // from Angular that could not be lex'd.
          const xml = new XmlParser().parse(xtb, url);
          this._errors = xml.errors;
          visitAll(this, xml.rootNodes);
          return {
              msgIdToHtml: this._msgIdToHtml,
              errors: this._errors,
              locale: this._locale,
          };
      }
      visitElement(element, context) {
          switch (element.name) {
              case _TRANSLATIONS_TAG:
                  this._bundleDepth++;
                  if (this._bundleDepth > 1) {
                      this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);
                  }
                  const langAttr = element.attrs.find((attr) => attr.name === 'lang');
                  if (langAttr) {
                      this._locale = langAttr.value;
                  }
                  visitAll(this, element.children, null);
                  this._bundleDepth--;
                  break;
              case _TRANSLATION_TAG:
                  const idAttr = element.attrs.find((attr) => attr.name === 'id');
                  if (!idAttr) {
                      this._addError(element, `<${_TRANSLATION_TAG}> misses the "id" attribute`);
                  }
                  else {
                      const id = idAttr.value;
                      if (this._msgIdToHtml.hasOwnProperty(id)) {
                          this._addError(element, `Duplicated translations for msg ${id}`);
                      }
                      else {
                          const innerTextStart = element.startSourceSpan.end.offset;
                          const innerTextEnd = element.endSourceSpan.start.offset;
                          const content = element.startSourceSpan.start.file.content;
                          const innerText = content.slice(innerTextStart, innerTextEnd);
                          this._msgIdToHtml[id] = innerText;
                      }
                  }
                  break;
              default:
                  this._addError(element, 'Unexpected tag');
          }
      }
      visitAttribute(attribute, context) { }
      visitText(text, context) { }
      visitComment(comment, context) { }
      visitExpansion(expansion, context) { }
      visitExpansionCase(expansionCase, context) { }
      _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      }
  }
  // Convert ml nodes (xtb syntax) to i18n nodes
  class XmlToI18n$2 {
      convert(message, url) {
          const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });
          this._errors = xmlIcu.errors;
          const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?
              [] :
              visitAll(this, xmlIcu.rootNodes);
          return {
              i18nNodes,
              errors: this._errors,
          };
      }
      visitText(text, context) { return new Text(text.value, text.sourceSpan); }
      visitExpansion(icu, context) {
          const caseMap = {};
          visitAll(this, icu.cases).forEach(c => {
              caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
          });
          return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
      }
      visitExpansionCase(icuCase, context) {
          return {
              value: icuCase.value,
              nodes: visitAll(this, icuCase.expression),
          };
      }
      visitElement(el, context) {
          if (el.name === _PLACEHOLDER_TAG$3) {
              const nameAttr = el.attrs.find((attr) => attr.name === 'name');
              if (nameAttr) {
                  return new Placeholder('', nameAttr.value, el.sourceSpan);
              }
              this._addError(el, `<${_PLACEHOLDER_TAG$3}> misses the "name" attribute`);
          }
          else {
              this._addError(el, `Unexpected tag`);
          }
          return null;
      }
      visitComment(comment, context) { }
      visitAttribute(attribute, context) { }
      _addError(node, message) {
          this._errors.push(new I18nError(node.sourceSpan, message));
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * A container for translated messages
   */
  class TranslationBundle {
      constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {
          this._i18nNodesByMsgId = _i18nNodesByMsgId;
          this.digest = digest;
          this.mapperFactory = mapperFactory;
          this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);
      }
      // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.
      static load(content, url, serializer, missingTranslationStrategy, console) {
          const { locale, i18nNodesByMsgId } = serializer.load(content, url);
          const digestFn = (m) => serializer.digest(m);
          const mapperFactory = (m) => serializer.createNameMapper(m);
          return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);
      }
      // Returns the translation as HTML nodes from the given source message.
      get(srcMsg) {
          const html = this._i18nToHtml.convert(srcMsg);
          if (html.errors.length) {
              throw new Error(html.errors.join('\n'));
          }
          return html.nodes;
      }
      has(srcMsg) { return this.digest(srcMsg) in this._i18nNodesByMsgId; }
  }
  class I18nToHtmlVisitor {
      constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {
          this._i18nNodesByMsgId = _i18nNodesByMsgId;
          this._locale = _locale;
          this._digest = _digest;
          this._mapperFactory = _mapperFactory;
          this._missingTranslationStrategy = _missingTranslationStrategy;
          this._console = _console;
          this._contextStack = [];
          this._errors = [];
      }
      convert(srcMsg) {
          this._contextStack.length = 0;
          this._errors.length = 0;
          // i18n to text
          const text = this._convertToText(srcMsg);
          // text to html
          const url = srcMsg.nodes[0].sourceSpan.start.file.url;
          const html = new HtmlParser().parse(text, url, { tokenizeExpansionForms: true });
          return {
              nodes: html.rootNodes,
              errors: [...this._errors, ...html.errors],
          };
      }
      visitText(text, context) {
          // `convert()` uses an `HtmlParser` to return `html.Node`s
          // we should then make sure that any special characters are escaped
          return escapeXml(text.value);
      }
      visitContainer(container, context) {
          return container.children.map(n => n.visit(this)).join('');
      }
      visitIcu(icu, context) {
          const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);
          // TODO(vicb): Once all format switch to using expression placeholders
          // we should throw when the placeholder is not in the source message
          const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?
              this._srcMsg.placeholders[icu.expression] :
              icu.expression;
          return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;
      }
      visitPlaceholder(ph, context) {
          const phName = this._mapper(ph.name);
          if (this._srcMsg.placeholders.hasOwnProperty(phName)) {
              return this._srcMsg.placeholders[phName];
          }
          if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {
              return this._convertToText(this._srcMsg.placeholderToMessage[phName]);
          }
          this._addError(ph, `Unknown placeholder "${ph.name}"`);
          return '';
      }
      // Loaded message contains only placeholders (vs tag and icu placeholders).
      // However when a translation can not be found, we need to serialize the source message
      // which can contain tag placeholders
      visitTagPlaceholder(ph, context) {
          const tag = `${ph.tag}`;
          const attrs = Object.keys(ph.attrs).map(name => `${name}="${ph.attrs[name]}"`).join(' ');
          if (ph.isVoid) {
              return `<${tag} ${attrs}/>`;
          }
          const children = ph.children.map((c) => c.visit(this)).join('');
          return `<${tag} ${attrs}>${children}</${tag}>`;
      }
      // Loaded message contains only placeholders (vs tag and icu placeholders).
      // However when a translation can not be found, we need to serialize the source message
      // which can contain tag placeholders
      visitIcuPlaceholder(ph, context) {
          // An ICU placeholder references the source message to be serialized
          return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);
      }
      /**
       * Convert a source message to a translated text string:
       * - text nodes are replaced with their translation,
       * - placeholders are replaced with their content,
       * - ICU nodes are converted to ICU expressions.
       */
      _convertToText(srcMsg) {
          const id = this._digest(srcMsg);
          const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;
          let nodes;
          this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });
          this._srcMsg = srcMsg;
          if (this._i18nNodesByMsgId.hasOwnProperty(id)) {
              // When there is a translation use its nodes as the source
              // And create a mapper to convert serialized placeholder names to internal names
              nodes = this._i18nNodesByMsgId[id];
              this._mapper = (name) => mapper ? mapper.toInternalName(name) : name;
          }
          else {
              // When no translation has been found
              // - report an error / a warning / nothing,
              // - use the nodes from the original message
              // - placeholders are already internal and need no mapper
              if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {
                  const ctx = this._locale ? ` for locale "${this._locale}"` : '';
                  this._addError(srcMsg.nodes[0], `Missing translation for message "${id}"${ctx}`);
              }
              else if (this._console &&
                  this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {
                  const ctx = this._locale ? ` for locale "${this._locale}"` : '';
                  this._console.warn(`Missing translation for message "${id}"${ctx}`);
              }
              nodes = srcMsg.nodes;
              this._mapper = (name) => name;
          }
          const text = nodes.map(node => node.visit(this)).join('');
          const context = this._contextStack.pop();
          this._srcMsg = context.msg;
          this._mapper = context.mapper;
          return text;
      }
      _addError(el, msg) {
          this._errors.push(new I18nError(el.sourceSpan, msg));
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class I18NHtmlParser {
      constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {
          this._htmlParser = _htmlParser;
          if (translations) {
              const serializer = createSerializer(translationsFormat);
              this._translationBundle =
                  TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);
          }
          else {
              this._translationBundle =
                  new TranslationBundle({}, null, digest, undefined, missingTranslation, console);
          }
      }
      parse(source, url, options = {}) {
          const interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
          const parseResult = this._htmlParser.parse(source, url, Object.assign({ interpolationConfig }, options));
          if (parseResult.errors.length) {
              return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);
          }
          return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});
      }
  }
  function createSerializer(format) {
      format = (format || 'xlf').toLowerCase();
      switch (format) {
          case 'xmb':
              return new Xmb();
          case 'xtb':
              return new Xtb();
          case 'xliff2':
          case 'xlf2':
              return new Xliff2();
          case 'xliff':
          case 'xlf':
          default:
              return new Xliff();
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const QUOTED_KEYS = '$quoted$';
  function convertValueToOutputAst(ctx, value, type = null) {
      return visitValue(value, new _ValueOutputAstTransformer(ctx), type);
  }
  class _ValueOutputAstTransformer {
      constructor(ctx) {
          this.ctx = ctx;
      }
      visitArray(arr, type) {
          return literalArr(arr.map(value => visitValue(value, this, null)), type);
      }
      visitStringMap(map, type) {
          const entries = [];
          const quotedSet = new Set(map && map[QUOTED_KEYS]);
          Object.keys(map).forEach(key => {
              entries.push(new LiteralMapEntry(key, visitValue(map[key], this, null), quotedSet.has(key)));
          });
          return new LiteralMapExpr(entries, type);
      }
      visitPrimitive(value, type) { return literal(value, type); }
      visitOther(value, type) {
          if (value instanceof Expression) {
              return value;
          }
          else {
              return this.ctx.importExpr(value);
          }
      }
  }
  function ngfactoryFilePath(filePath, forceSourceFile = false) {
      const urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);
      return `${urlWithSuffix[0]}.ngfactory${normalizeGenFileSuffix(urlWithSuffix[1])}`;
  }
  function splitTypescriptSuffix(path, forceSourceFile = false) {
      if (path.endsWith('.d.ts')) {
          return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];
      }
      const lastDot = path.lastIndexOf('.');
      if (lastDot !== -1) {
          return [path.substring(0, lastDot), path.substring(lastDot)];
      }
      return [path, ''];
  }
  function normalizeGenFileSuffix(srcFileSuffix) {
      return srcFileSuffix === '.tsx' ? '.ts' : srcFileSuffix;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const ERROR_COMPONENT_TYPE = 'ngComponentType';
  // Design notes:
  // - don't lazily create metadata:
  //   For some metadata, we need to do async work sometimes,
  //   so the user has to kick off this loading.
  //   But we want to report errors even when the async work is
  //   not required to check that the user would have been able
  //   to wait correctly.
  class CompileMetadataResolver {
      constructor(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {
          this._config = _config;
          this._htmlParser = _htmlParser;
          this._ngModuleResolver = _ngModuleResolver;
          this._directiveResolver = _directiveResolver;
          this._pipeResolver = _pipeResolver;
          this._summaryResolver = _summaryResolver;
          this._schemaRegistry = _schemaRegistry;
          this._directiveNormalizer = _directiveNormalizer;
          this._console = _console;
          this._staticSymbolCache = _staticSymbolCache;
          this._reflector = _reflector;
          this._errorCollector = _errorCollector;
          this._nonNormalizedDirectiveCache = new Map();
          this._directiveCache = new Map();
          this._summaryCache = new Map();
          this._pipeCache = new Map();
          this._ngModuleCache = new Map();
          this._ngModuleOfTypes = new Map();
          this._shallowModuleCache = new Map();
      }
      getReflector() { return this._reflector; }
      clearCacheFor(type) {
          const dirMeta = this._directiveCache.get(type);
          this._directiveCache.delete(type);
          this._nonNormalizedDirectiveCache.delete(type);
          this._summaryCache.delete(type);
          this._pipeCache.delete(type);
          this._ngModuleOfTypes.delete(type);
          // Clear all of the NgModule as they contain transitive information!
          this._ngModuleCache.clear();
          if (dirMeta) {
              this._directiveNormalizer.clearCacheFor(dirMeta);
          }
      }
      clearCache() {
          this._directiveCache.clear();
          this._nonNormalizedDirectiveCache.clear();
          this._summaryCache.clear();
          this._pipeCache.clear();
          this._ngModuleCache.clear();
          this._ngModuleOfTypes.clear();
          this._directiveNormalizer.clearCache();
      }
      _createProxyClass(baseType, name) {
          let delegate = null;
          const proxyClass = function () {
              if (!delegate) {
                  throw new Error(`Illegal state: Class ${name} for type ${stringify(baseType)} is not compiled yet!`);
              }
              return delegate.apply(this, arguments);
          };
          proxyClass.setDelegate = (d) => {
              delegate = d;
              proxyClass.prototype = d.prototype;
          };
          // Make stringify work correctly
          proxyClass.overriddenName = name;
          return proxyClass;
      }
      getGeneratedClass(dirType, name) {
          if (dirType instanceof StaticSymbol) {
              return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);
          }
          else {
              return this._createProxyClass(dirType, name);
          }
      }
      getComponentViewClass(dirType) {
          return this.getGeneratedClass(dirType, viewClassName(dirType, 0));
      }
      getHostComponentViewClass(dirType) {
          return this.getGeneratedClass(dirType, hostViewClassName(dirType));
      }
      getHostComponentType(dirType) {
          const name = `${identifierName({ reference: dirType })}_Host`;
          if (dirType instanceof StaticSymbol) {
              return this._staticSymbolCache.get(dirType.filePath, name);
          }
          return this._createProxyClass(dirType, name);
      }
      getRendererType(dirType) {
          if (dirType instanceof StaticSymbol) {
              return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));
          }
          else {
              // returning an object as proxy,
              // that we fill later during runtime compilation.
              return {};
          }
      }
      getComponentFactory(selector, dirType, inputs, outputs) {
          if (dirType instanceof StaticSymbol) {
              return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));
          }
          else {
              const hostView = this.getHostComponentViewClass(dirType);
              // Note: ngContentSelectors will be filled later once the template is
              // loaded.
              const createComponentFactory = this._reflector.resolveExternalReference(Identifiers.createComponentFactory);
              return createComponentFactory(selector, dirType, hostView, inputs, outputs, []);
          }
      }
      initComponentFactory(factory, ngContentSelectors) {
          if (!(factory instanceof StaticSymbol)) {
              factory.ngContentSelectors.push(...ngContentSelectors);
          }
      }
      _loadSummary(type, kind) {
          let typeSummary = this._summaryCache.get(type);
          if (!typeSummary) {
              const summary = this._summaryResolver.resolveSummary(type);
              typeSummary = summary ? summary.type : null;
              this._summaryCache.set(type, typeSummary || null);
          }
          return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;
      }
      getHostComponentMetadata(compMeta, hostViewType) {
          const hostType = this.getHostComponentType(compMeta.type.reference);
          if (!hostViewType) {
              hostViewType = this.getHostComponentViewClass(hostType);
          }
          // Note: ! is ok here as this method should only be called with normalized directive
          // metadata, which always fills in the selector.
          const template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();
          const templateUrl = '';
          const htmlAst = this._htmlParser.parse(template, templateUrl);
          return CompileDirectiveMetadata.create({
              isHost: true,
              type: { reference: hostType, diDeps: [], lifecycleHooks: [] },
              template: new CompileTemplateMetadata({
                  encapsulation: ViewEncapsulation.None,
                  template,
                  templateUrl,
                  htmlAst,
                  styles: [],
                  styleUrls: [],
                  ngContentSelectors: [],
                  animations: [],
                  isInline: true,
                  externalStylesheets: [],
                  interpolation: null,
                  preserveWhitespaces: false,
              }),
              exportAs: null,
              changeDetection: ChangeDetectionStrategy.Default,
              inputs: [],
              outputs: [],
              host: {},
              isComponent: true,
              selector: '*',
              providers: [],
              viewProviders: [],
              queries: [],
              guards: {},
              viewQueries: [],
              componentViewType: hostViewType,
              rendererType: { id: '__Host__', encapsulation: ViewEncapsulation.None, styles: [], data: {} },
              entryComponents: [],
              componentFactory: null
          });
      }
      loadDirectiveMetadata(ngModuleType, directiveType, isSync) {
          if (this._directiveCache.has(directiveType)) {
              return null;
          }
          directiveType = resolveForwardRef(directiveType);
          const { annotation, metadata } = this.getNonNormalizedDirectiveMetadata(directiveType);
          const createDirectiveMetadata = (templateMetadata) => {
              const normalizedDirMeta = new CompileDirectiveMetadata({
                  isHost: false,
                  type: metadata.type,
                  isComponent: metadata.isComponent,
                  selector: metadata.selector,
                  exportAs: metadata.exportAs,
                  changeDetection: metadata.changeDetection,
                  inputs: metadata.inputs,
                  outputs: metadata.outputs,
                  hostListeners: metadata.hostListeners,
                  hostProperties: metadata.hostProperties,
                  hostAttributes: metadata.hostAttributes,
                  providers: metadata.providers,
                  viewProviders: metadata.viewProviders,
                  queries: metadata.queries,
                  guards: metadata.guards,
                  viewQueries: metadata.viewQueries,
                  entryComponents: metadata.entryComponents,
                  componentViewType: metadata.componentViewType,
                  rendererType: metadata.rendererType,
                  componentFactory: metadata.componentFactory,
                  template: templateMetadata
              });
              if (templateMetadata) {
                  this.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);
              }
              this._directiveCache.set(directiveType, normalizedDirMeta);
              this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());
              return null;
          };
          if (metadata.isComponent) {
              const template = metadata.template;
              const templateMeta = this._directiveNormalizer.normalizeTemplate({
                  ngModuleType,
                  componentType: directiveType,
                  moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),
                  encapsulation: template.encapsulation,
                  template: template.template,
                  templateUrl: template.templateUrl,
                  styles: template.styles,
                  styleUrls: template.styleUrls,
                  animations: template.animations,
                  interpolation: template.interpolation,
                  preserveWhitespaces: template.preserveWhitespaces
              });
              if (isPromise(templateMeta) && isSync) {
                  this._reportError(componentStillLoadingError(directiveType), directiveType);
                  return null;
              }
              return SyncAsync.then(templateMeta, createDirectiveMetadata);
          }
          else {
              // directive
              createDirectiveMetadata(null);
              return null;
          }
      }
      getNonNormalizedDirectiveMetadata(directiveType) {
          directiveType = resolveForwardRef(directiveType);
          if (!directiveType) {
              return null;
          }
          let cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);
          if (cacheEntry) {
              return cacheEntry;
          }
          const dirMeta = this._directiveResolver.resolve(directiveType, false);
          if (!dirMeta) {
              return null;
          }
          let nonNormalizedTemplateMetadata = undefined;
          if (createComponent.isTypeOf(dirMeta)) {
              // component
              const compMeta = dirMeta;
              assertArrayOfStrings('styles', compMeta.styles);
              assertArrayOfStrings('styleUrls', compMeta.styleUrls);
              assertInterpolationSymbols('interpolation', compMeta.interpolation);
              const animations = compMeta.animations;
              nonNormalizedTemplateMetadata = new CompileTemplateMetadata({
                  encapsulation: noUndefined(compMeta.encapsulation),
                  template: noUndefined(compMeta.template),
                  templateUrl: noUndefined(compMeta.templateUrl),
                  htmlAst: null,
                  styles: compMeta.styles || [],
                  styleUrls: compMeta.styleUrls || [],
                  animations: animations || [],
                  interpolation: noUndefined(compMeta.interpolation),
                  isInline: !!compMeta.template,
                  externalStylesheets: [],
                  ngContentSelectors: [],
                  preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces),
              });
          }
          let changeDetectionStrategy = null;
          let viewProviders = [];
          let entryComponentMetadata = [];
          let selector = dirMeta.selector;
          if (createComponent.isTypeOf(dirMeta)) {
              // Component
              const compMeta = dirMeta;
              changeDetectionStrategy = compMeta.changeDetection;
              if (compMeta.viewProviders) {
                  viewProviders = this._getProvidersMetadata(compMeta.viewProviders, entryComponentMetadata, `viewProviders for "${stringifyType(directiveType)}"`, [], directiveType);
              }
              if (compMeta.entryComponents) {
                  entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents)
                      .map((type) => this._getEntryComponentMetadata(type))
                      .concat(entryComponentMetadata);
              }
              if (!selector) {
                  selector = this._schemaRegistry.getDefaultComponentElementName();
              }
          }
          else {
              // Directive
              if (!selector) {
                  this._reportError(syntaxError(`Directive ${stringifyType(directiveType)} has no selector, please add it!`), directiveType);
                  selector = 'error';
              }
          }
          let providers = [];
          if (dirMeta.providers != null) {
              providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, `providers for "${stringifyType(directiveType)}"`, [], directiveType);
          }
          let queries = [];
          let viewQueries = [];
          if (dirMeta.queries != null) {
              queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);
              viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);
          }
          const metadata = CompileDirectiveMetadata.create({
              isHost: false,
              selector: selector,
              exportAs: noUndefined(dirMeta.exportAs),
              isComponent: !!nonNormalizedTemplateMetadata,
              type: this._getTypeMetadata(directiveType),
              template: nonNormalizedTemplateMetadata,
              changeDetection: changeDetectionStrategy,
              inputs: dirMeta.inputs || [],
              outputs: dirMeta.outputs || [],
              host: dirMeta.host || {},
              providers: providers || [],
              viewProviders: viewProviders || [],
              queries: queries || [],
              guards: dirMeta.guards || {},
              viewQueries: viewQueries || [],
              entryComponents: entryComponentMetadata,
              componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :
                  null,
              rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,
              componentFactory: null
          });
          if (nonNormalizedTemplateMetadata) {
              metadata.componentFactory =
                  this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);
          }
          cacheEntry = { metadata, annotation: dirMeta };
          this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);
          return cacheEntry;
      }
      /**
       * Gets the metadata for the given directive.
       * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
       */
      getDirectiveMetadata(directiveType) {
          const dirMeta = this._directiveCache.get(directiveType);
          if (!dirMeta) {
              this._reportError(syntaxError(`Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive ${stringifyType(directiveType)}.`), directiveType);
          }
          return dirMeta;
      }
      getDirectiveSummary(dirType) {
          const dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);
          if (!dirSummary) {
              this._reportError(syntaxError(`Illegal state: Could not load the summary for directive ${stringifyType(dirType)}.`), dirType);
          }
          return dirSummary;
      }
      isDirective(type) {
          return !!this._loadSummary(type, CompileSummaryKind.Directive) ||
              this._directiveResolver.isDirective(type);
      }
      isPipe(type) {
          return !!this._loadSummary(type, CompileSummaryKind.Pipe) ||
              this._pipeResolver.isPipe(type);
      }
      isNgModule(type) {
          return !!this._loadSummary(type, CompileSummaryKind.NgModule) ||
              this._ngModuleResolver.isNgModule(type);
      }
      getNgModuleSummary(moduleType, alreadyCollecting = null) {
          let moduleSummary = this._loadSummary(moduleType, CompileSummaryKind.NgModule);
          if (!moduleSummary) {
              const moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);
              moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;
              if (moduleSummary) {
                  this._summaryCache.set(moduleType, moduleSummary);
              }
          }
          return moduleSummary;
      }
      /**
       * Loads the declared directives and pipes of an NgModule.
       */
      loadNgModuleDirectiveAndPipeMetadata(moduleType, isSync, throwIfNotFound = true) {
          const ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);
          const loading = [];
          if (ngModule) {
              ngModule.declaredDirectives.forEach((id) => {
                  const promise = this.loadDirectiveMetadata(moduleType, id.reference, isSync);
                  if (promise) {
                      loading.push(promise);
                  }
              });
              ngModule.declaredPipes.forEach((id) => this._loadPipeMetadata(id.reference));
          }
          return Promise.all(loading);
      }
      getShallowModuleMetadata(moduleType) {
          let compileMeta = this._shallowModuleCache.get(moduleType);
          if (compileMeta) {
              return compileMeta;
          }
          const ngModuleMeta = findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);
          compileMeta = {
              type: this._getTypeMetadata(moduleType),
              rawExports: ngModuleMeta.exports,
              rawImports: ngModuleMeta.imports,
              rawProviders: ngModuleMeta.providers,
          };
          this._shallowModuleCache.set(moduleType, compileMeta);
          return compileMeta;
      }
      getNgModuleMetadata(moduleType, throwIfNotFound = true, alreadyCollecting = null) {
          moduleType = resolveForwardRef(moduleType);
          let compileMeta = this._ngModuleCache.get(moduleType);
          if (compileMeta) {
              return compileMeta;
          }
          const meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);
          if (!meta) {
              return null;
          }
          const declaredDirectives = [];
          const exportedNonModuleIdentifiers = [];
          const declaredPipes = [];
          const importedModules = [];
          const exportedModules = [];
          const providers = [];
          const entryComponents = [];
          const bootstrapComponents = [];
          const schemas = [];
          if (meta.imports) {
              flattenAndDedupeArray(meta.imports).forEach((importedType) => {
                  let importedModuleType = undefined;
                  if (isValidType(importedType)) {
                      importedModuleType = importedType;
                  }
                  else if (importedType && importedType.ngModule) {
                      const moduleWithProviders = importedType;
                      importedModuleType = moduleWithProviders.ngModule;
                      if (moduleWithProviders.providers) {
                          providers.push(...this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, `provider for the NgModule '${stringifyType(importedModuleType)}'`, [], importedType));
                      }
                  }
                  if (importedModuleType) {
                      if (this._checkSelfImport(moduleType, importedModuleType))
                          return;
                      if (!alreadyCollecting)
                          alreadyCollecting = new Set();
                      if (alreadyCollecting.has(importedModuleType)) {
                          this._reportError(syntaxError(`${this._getTypeDescriptor(importedModuleType)} '${stringifyType(importedType)}' is imported recursively by the module '${stringifyType(moduleType)}'.`), moduleType);
                          return;
                      }
                      alreadyCollecting.add(importedModuleType);
                      const importedModuleSummary = this.getNgModuleSummary(importedModuleType, alreadyCollecting);
                      alreadyCollecting.delete(importedModuleType);
                      if (!importedModuleSummary) {
                          this._reportError(syntaxError(`Unexpected ${this._getTypeDescriptor(importedType)} '${stringifyType(importedType)}' imported by the module '${stringifyType(moduleType)}'. Please add a @NgModule annotation.`), moduleType);
                          return;
                      }
                      importedModules.push(importedModuleSummary);
                  }
                  else {
                      this._reportError(syntaxError(`Unexpected value '${stringifyType(importedType)}' imported by the module '${stringifyType(moduleType)}'`), moduleType);
                      return;
                  }
              });
          }
          if (meta.exports) {
              flattenAndDedupeArray(meta.exports).forEach((exportedType) => {
                  if (!isValidType(exportedType)) {
                      this._reportError(syntaxError(`Unexpected value '${stringifyType(exportedType)}' exported by the module '${stringifyType(moduleType)}'`), moduleType);
                      return;
                  }
                  if (!alreadyCollecting)
                      alreadyCollecting = new Set();
                  if (alreadyCollecting.has(exportedType)) {
                      this._reportError(syntaxError(`${this._getTypeDescriptor(exportedType)} '${stringify(exportedType)}' is exported recursively by the module '${stringifyType(moduleType)}'`), moduleType);
                      return;
                  }
                  alreadyCollecting.add(exportedType);
                  const exportedModuleSummary = this.getNgModuleSummary(exportedType, alreadyCollecting);
                  alreadyCollecting.delete(exportedType);
                  if (exportedModuleSummary) {
                      exportedModules.push(exportedModuleSummary);
                  }
                  else {
                      exportedNonModuleIdentifiers.push(this._getIdentifierMetadata(exportedType));
                  }
              });
          }
          // Note: This will be modified later, so we rely on
          // getting a new instance every time!
          const transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);
          if (meta.declarations) {
              flattenAndDedupeArray(meta.declarations).forEach((declaredType) => {
                  if (!isValidType(declaredType)) {
                      this._reportError(syntaxError(`Unexpected value '${stringifyType(declaredType)}' declared by the module '${stringifyType(moduleType)}'`), moduleType);
                      return;
                  }
                  const declaredIdentifier = this._getIdentifierMetadata(declaredType);
                  if (this.isDirective(declaredType)) {
                      transitiveModule.addDirective(declaredIdentifier);
                      declaredDirectives.push(declaredIdentifier);
                      this._addTypeToModule(declaredType, moduleType);
                  }
                  else if (this.isPipe(declaredType)) {
                      transitiveModule.addPipe(declaredIdentifier);
                      transitiveModule.pipes.push(declaredIdentifier);
                      declaredPipes.push(declaredIdentifier);
                      this._addTypeToModule(declaredType, moduleType);
                  }
                  else {
                      this._reportError(syntaxError(`Unexpected ${this._getTypeDescriptor(declaredType)} '${stringifyType(declaredType)}' declared by the module '${stringifyType(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`), moduleType);
                      return;
                  }
              });
          }
          const exportedDirectives = [];
          const exportedPipes = [];
          exportedNonModuleIdentifiers.forEach((exportedId) => {
              if (transitiveModule.directivesSet.has(exportedId.reference)) {
                  exportedDirectives.push(exportedId);
                  transitiveModule.addExportedDirective(exportedId);
              }
              else if (transitiveModule.pipesSet.has(exportedId.reference)) {
                  exportedPipes.push(exportedId);
                  transitiveModule.addExportedPipe(exportedId);
              }
              else {
                  this._reportError(syntaxError(`Can't export ${this._getTypeDescriptor(exportedId.reference)} ${stringifyType(exportedId.reference)} from ${stringifyType(moduleType)} as it was neither declared nor imported!`), moduleType);
                  return;
              }
          });
          // The providers of the module have to go last
          // so that they overwrite any other provider we already added.
          if (meta.providers) {
              providers.push(...this._getProvidersMetadata(meta.providers, entryComponents, `provider for the NgModule '${stringifyType(moduleType)}'`, [], moduleType));
          }
          if (meta.entryComponents) {
              entryComponents.push(...flattenAndDedupeArray(meta.entryComponents)
                  .map(type => this._getEntryComponentMetadata(type)));
          }
          if (meta.bootstrap) {
              flattenAndDedupeArray(meta.bootstrap).forEach(type => {
                  if (!isValidType(type)) {
                      this._reportError(syntaxError(`Unexpected value '${stringifyType(type)}' used in the bootstrap property of module '${stringifyType(moduleType)}'`), moduleType);
                      return;
                  }
                  bootstrapComponents.push(this._getIdentifierMetadata(type));
              });
          }
          entryComponents.push(...bootstrapComponents.map(type => this._getEntryComponentMetadata(type.reference)));
          if (meta.schemas) {
              schemas.push(...flattenAndDedupeArray(meta.schemas));
          }
          compileMeta = new CompileNgModuleMetadata({
              type: this._getTypeMetadata(moduleType),
              providers,
              entryComponents,
              bootstrapComponents,
              schemas,
              declaredDirectives,
              exportedDirectives,
              declaredPipes,
              exportedPipes,
              importedModules,
              exportedModules,
              transitiveModule,
              id: meta.id || null,
          });
          entryComponents.forEach((id) => transitiveModule.addEntryComponent(id));
          providers.forEach((provider) => transitiveModule.addProvider(provider, compileMeta.type));
          transitiveModule.addModule(compileMeta.type);
          this._ngModuleCache.set(moduleType, compileMeta);
          return compileMeta;
      }
      _checkSelfImport(moduleType, importedModuleType) {
          if (moduleType === importedModuleType) {
              this._reportError(syntaxError(`'${stringifyType(moduleType)}' module can't import itself`), moduleType);
              return true;
          }
          return false;
      }
      _getTypeDescriptor(type) {
          if (isValidType(type)) {
              if (this.isDirective(type)) {
                  return 'directive';
              }
              if (this.isPipe(type)) {
                  return 'pipe';
              }
              if (this.isNgModule(type)) {
                  return 'module';
              }
          }
          if (type.provide) {
              return 'provider';
          }
          return 'value';
      }
      _addTypeToModule(type, moduleType) {
          const oldModule = this._ngModuleOfTypes.get(type);
          if (oldModule && oldModule !== moduleType) {
              this._reportError(syntaxError(`Type ${stringifyType(type)} is part of the declarations of 2 modules: ${stringifyType(oldModule)} and ${stringifyType(moduleType)}! ` +
                  `Please consider moving ${stringifyType(type)} to a higher module that imports ${stringifyType(oldModule)} and ${stringifyType(moduleType)}. ` +
                  `You can also create a new NgModule that exports and includes ${stringifyType(type)} then import that NgModule in ${stringifyType(oldModule)} and ${stringifyType(moduleType)}.`), moduleType);
              return;
          }
          this._ngModuleOfTypes.set(type, moduleType);
      }
      _getTransitiveNgModuleMetadata(importedModules, exportedModules) {
          // collect `providers` / `entryComponents` from all imported and all exported modules
          const result = new TransitiveCompileNgModuleMetadata();
          const modulesByToken = new Map();
          importedModules.concat(exportedModules).forEach((modSummary) => {
              modSummary.modules.forEach((mod) => result.addModule(mod));
              modSummary.entryComponents.forEach((comp) => result.addEntryComponent(comp));
              const addedTokens = new Set();
              modSummary.providers.forEach((entry) => {
                  const tokenRef = tokenReference(entry.provider.token);
                  let prevModules = modulesByToken.get(tokenRef);
                  if (!prevModules) {
                      prevModules = new Set();
                      modulesByToken.set(tokenRef, prevModules);
                  }
                  const moduleRef = entry.module.reference;
                  // Note: the providers of one module may still contain multiple providers
                  // per token (e.g. for multi providers), and we need to preserve these.
                  if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {
                      prevModules.add(moduleRef);
                      addedTokens.add(tokenRef);
                      result.addProvider(entry.provider, entry.module);
                  }
              });
          });
          exportedModules.forEach((modSummary) => {
              modSummary.exportedDirectives.forEach((id) => result.addExportedDirective(id));
              modSummary.exportedPipes.forEach((id) => result.addExportedPipe(id));
          });
          importedModules.forEach((modSummary) => {
              modSummary.exportedDirectives.forEach((id) => result.addDirective(id));
              modSummary.exportedPipes.forEach((id) => result.addPipe(id));
          });
          return result;
      }
      _getIdentifierMetadata(type) {
          type = resolveForwardRef(type);
          return { reference: type };
      }
      isInjectable(type) {
          const annotations = this._reflector.tryAnnotations(type);
          return annotations.some(ann => createInjectable.isTypeOf(ann));
      }
      getInjectableSummary(type) {
          return {
              summaryKind: CompileSummaryKind.Injectable,
              type: this._getTypeMetadata(type, null, false)
          };
      }
      getInjectableMetadata(type, dependencies = null, throwOnUnknownDeps = true) {
          const typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);
          const typeMetadata = typeSummary ?
              typeSummary.type :
              this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);
          const annotations = this._reflector.annotations(type).filter(ann => createInjectable.isTypeOf(ann));
          if (annotations.length === 0) {
              return null;
          }
          const meta = annotations[annotations.length - 1];
          return {
              symbol: type,
              type: typeMetadata,
              providedIn: meta.providedIn,
              useValue: meta.useValue,
              useClass: meta.useClass,
              useExisting: meta.useExisting,
              useFactory: meta.useFactory,
              deps: meta.deps,
          };
      }
      _getTypeMetadata(type, dependencies = null, throwOnUnknownDeps = true) {
          const identifier = this._getIdentifierMetadata(type);
          return {
              reference: identifier.reference,
              diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),
              lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),
          };
      }
      _getFactoryMetadata(factory, dependencies = null) {
          factory = resolveForwardRef(factory);
          return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };
      }
      /**
       * Gets the metadata for the given pipe.
       * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
       */
      getPipeMetadata(pipeType) {
          const pipeMeta = this._pipeCache.get(pipeType);
          if (!pipeMeta) {
              this._reportError(syntaxError(`Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe ${stringifyType(pipeType)}.`), pipeType);
          }
          return pipeMeta || null;
      }
      getPipeSummary(pipeType) {
          const pipeSummary = this._loadSummary(pipeType, CompileSummaryKind.Pipe);
          if (!pipeSummary) {
              this._reportError(syntaxError(`Illegal state: Could not load the summary for pipe ${stringifyType(pipeType)}.`), pipeType);
          }
          return pipeSummary;
      }
      getOrLoadPipeMetadata(pipeType) {
          let pipeMeta = this._pipeCache.get(pipeType);
          if (!pipeMeta) {
              pipeMeta = this._loadPipeMetadata(pipeType);
          }
          return pipeMeta;
      }
      _loadPipeMetadata(pipeType) {
          pipeType = resolveForwardRef(pipeType);
          const pipeAnnotation = this._pipeResolver.resolve(pipeType);
          const pipeMeta = new CompilePipeMetadata({
              type: this._getTypeMetadata(pipeType),
              name: pipeAnnotation.name,
              pure: !!pipeAnnotation.pure
          });
          this._pipeCache.set(pipeType, pipeMeta);
          this._summaryCache.set(pipeType, pipeMeta.toSummary());
          return pipeMeta;
      }
      _getDependenciesMetadata(typeOrFunc, dependencies, throwOnUnknownDeps = true) {
          let hasUnknownDeps = false;
          const params = dependencies || this._reflector.parameters(typeOrFunc) || [];
          const dependenciesMetadata = params.map((param) => {
              let isAttribute = false;
              let isHost = false;
              let isSelf = false;
              let isSkipSelf = false;
              let isOptional = false;
              let token = null;
              if (Array.isArray(param)) {
                  param.forEach((paramEntry) => {
                      if (createHost.isTypeOf(paramEntry)) {
                          isHost = true;
                      }
                      else if (createSelf.isTypeOf(paramEntry)) {
                          isSelf = true;
                      }
                      else if (createSkipSelf.isTypeOf(paramEntry)) {
                          isSkipSelf = true;
                      }
                      else if (createOptional.isTypeOf(paramEntry)) {
                          isOptional = true;
                      }
                      else if (createAttribute.isTypeOf(paramEntry)) {
                          isAttribute = true;
                          token = paramEntry.attributeName;
                      }
                      else if (createInject.isTypeOf(paramEntry)) {
                          token = paramEntry.token;
                      }
                      else if (createInjectionToken.isTypeOf(paramEntry) || paramEntry instanceof StaticSymbol) {
                          token = paramEntry;
                      }
                      else if (isValidType(paramEntry) && token == null) {
                          token = paramEntry;
                      }
                  });
              }
              else {
                  token = param;
              }
              if (token == null) {
                  hasUnknownDeps = true;
                  return null;
              }
              return {
                  isAttribute,
                  isHost,
                  isSelf,
                  isSkipSelf,
                  isOptional,
                  token: this._getTokenMetadata(token)
              };
          });
          if (hasUnknownDeps) {
              const depsTokens = dependenciesMetadata.map((dep) => dep ? stringifyType(dep.token) : '?').join(', ');
              const message = `Can't resolve all parameters for ${stringifyType(typeOrFunc)}: (${depsTokens}).`;
              if (throwOnUnknownDeps || this._config.strictInjectionParameters) {
                  this._reportError(syntaxError(message), typeOrFunc);
              }
              else {
                  this._console.warn(`Warning: ${message} This will become an error in Angular v6.x`);
              }
          }
          return dependenciesMetadata;
      }
      _getTokenMetadata(token) {
          token = resolveForwardRef(token);
          let compileToken;
          if (typeof token === 'string') {
              compileToken = { value: token };
          }
          else {
              compileToken = { identifier: { reference: token } };
          }
          return compileToken;
      }
      _getProvidersMetadata(providers, targetEntryComponents, debugInfo, compileProviders = [], type) {
          providers.forEach((provider, providerIdx) => {
              if (Array.isArray(provider)) {
                  this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);
              }
              else {
                  provider = resolveForwardRef(provider);
                  let providerMeta = undefined;
                  if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {
                      this._validateProvider(provider);
                      providerMeta = new ProviderMeta(provider.provide, provider);
                  }
                  else if (isValidType(provider)) {
                      providerMeta = new ProviderMeta(provider, { useClass: provider });
                  }
                  else if (provider === void 0) {
                      this._reportError(syntaxError(`Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.`));
                      return;
                  }
                  else {
                      const providersInfo = providers.reduce((soFar, seenProvider, seenProviderIdx) => {
                          if (seenProviderIdx < providerIdx) {
                              soFar.push(`${stringifyType(seenProvider)}`);
                          }
                          else if (seenProviderIdx == providerIdx) {
                              soFar.push(`?${stringifyType(seenProvider)}?`);
                          }
                          else if (seenProviderIdx == providerIdx + 1) {
                              soFar.push('...');
                          }
                          return soFar;
                      }, [])
                          .join(', ');
                      this._reportError(syntaxError(`Invalid ${debugInfo ? debugInfo : 'provider'} - only instances of Provider and Type are allowed, got: [${providersInfo}]`), type);
                      return;
                  }
                  if (providerMeta.token ===
                      this._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {
                      targetEntryComponents.push(...this._getEntryComponentsFromProvider(providerMeta, type));
                  }
                  else {
                      compileProviders.push(this.getProviderMetadata(providerMeta));
                  }
              }
          });
          return compileProviders;
      }
      _validateProvider(provider) {
          if (provider.hasOwnProperty('useClass') && provider.useClass == null) {
              this._reportError(syntaxError(`Invalid provider for ${stringifyType(provider.provide)}. useClass cannot be ${provider.useClass}.
           Usually it happens when:
           1. There's a circular dependency (might be caused by using index.ts (barrel) files).
           2. Class was used before it was declared. Use forwardRef in this case.`));
          }
      }
      _getEntryComponentsFromProvider(provider, type) {
          const components = [];
          const collectedIdentifiers = [];
          if (provider.useFactory || provider.useExisting || provider.useClass) {
              this._reportError(syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!`), type);
              return [];
          }
          if (!provider.multi) {
              this._reportError(syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!`), type);
              return [];
          }
          extractIdentifiers(provider.useValue, collectedIdentifiers);
          collectedIdentifiers.forEach((identifier) => {
              const entry = this._getEntryComponentMetadata(identifier.reference, false);
              if (entry) {
                  components.push(entry);
              }
          });
          return components;
      }
      _getEntryComponentMetadata(dirType, throwIfNotFound = true) {
          const dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);
          if (dirMeta && dirMeta.metadata.isComponent) {
              return { componentType: dirType, componentFactory: dirMeta.metadata.componentFactory };
          }
          const dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);
          if (dirSummary && dirSummary.isComponent) {
              return { componentType: dirType, componentFactory: dirSummary.componentFactory };
          }
          if (throwIfNotFound) {
              throw syntaxError(`${dirType.name} cannot be used as an entry component.`);
          }
          return null;
      }
      _getInjectableTypeMetadata(type, dependencies = null) {
          const typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);
          if (typeSummary) {
              return typeSummary.type;
          }
          return this._getTypeMetadata(type, dependencies);
      }
      getProviderMetadata(provider) {
          let compileDeps = undefined;
          let compileTypeMetadata = null;
          let compileFactoryMetadata = null;
          let token = this._getTokenMetadata(provider.token);
          if (provider.useClass) {
              compileTypeMetadata =
                  this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);
              compileDeps = compileTypeMetadata.diDeps;
              if (provider.token === provider.useClass) {
                  // use the compileTypeMetadata as it contains information about lifecycleHooks...
                  token = { identifier: compileTypeMetadata };
              }
          }
          else if (provider.useFactory) {
              compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);
              compileDeps = compileFactoryMetadata.diDeps;
          }
          return {
              token: token,
              useClass: compileTypeMetadata,
              useValue: provider.useValue,
              useFactory: compileFactoryMetadata,
              useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,
              deps: compileDeps,
              multi: provider.multi
          };
      }
      _getQueriesMetadata(queries, isViewQuery, directiveType) {
          const res = [];
          Object.keys(queries).forEach((propertyName) => {
              const query = queries[propertyName];
              if (query.isViewQuery === isViewQuery) {
                  res.push(this._getQueryMetadata(query, propertyName, directiveType));
              }
          });
          return res;
      }
      _queryVarBindings(selector) { return selector.split(/\s*,\s*/); }
      _getQueryMetadata(q, propertyName, typeOrFunc) {
          let selectors;
          if (typeof q.selector === 'string') {
              selectors =
                  this._queryVarBindings(q.selector).map(varName => this._getTokenMetadata(varName));
          }
          else {
              if (!q.selector) {
                  this._reportError(syntaxError(`Can't construct a query for the property "${propertyName}" of "${stringifyType(typeOrFunc)}" since the query selector wasn't defined.`), typeOrFunc);
                  selectors = [];
              }
              else {
                  selectors = [this._getTokenMetadata(q.selector)];
              }
          }
          return {
              selectors,
              first: q.first,
              descendants: q.descendants, propertyName,
              read: q.read ? this._getTokenMetadata(q.read) : null
          };
      }
      _reportError(error$$1, type, otherType) {
          if (this._errorCollector) {
              this._errorCollector(error$$1, type);
              if (otherType) {
                  this._errorCollector(error$$1, otherType);
              }
          }
          else {
              throw error$$1;
          }
      }
  }
  function flattenArray(tree, out = []) {
      if (tree) {
          for (let i = 0; i < tree.length; i++) {
              const item = resolveForwardRef(tree[i]);
              if (Array.isArray(item)) {
                  flattenArray(item, out);
              }
              else {
                  out.push(item);
              }
          }
      }
      return out;
  }
  function dedupeArray(array) {
      if (array) {
          return Array.from(new Set(array));
      }
      return [];
  }
  function flattenAndDedupeArray(tree) {
      return dedupeArray(flattenArray(tree));
  }
  function isValidType(value) {
      return (value instanceof StaticSymbol) || (value instanceof Type);
  }
  function extractIdentifiers(value, targetIdentifiers) {
      visitValue(value, new _CompileValueConverter(), targetIdentifiers);
  }
  class _CompileValueConverter extends ValueTransformer {
      visitOther(value, targetIdentifiers) {
          targetIdentifiers.push({ reference: value });
      }
  }
  function stringifyType(type) {
      if (type instanceof StaticSymbol) {
          return `${type.name} in ${type.filePath}`;
      }
      else {
          return stringify(type);
      }
  }
  /**
   * Indicates that a component is still being loaded in a synchronous compile.
   */
  function componentStillLoadingError(compType) {
      const error$$1 = Error(`Can't compile synchronously as ${stringify(compType)} is still being loaded!`);
      error$$1[ERROR_COMPONENT_TYPE] = compType;
      return error$$1;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class ProviderError extends ParseError {
      constructor(message, span) { super(span, message); }
  }
  class ProviderViewContext {
      constructor(reflector, component) {
          this.reflector = reflector;
          this.component = component;
          this.errors = [];
          this.viewQueries = _getViewQueries(component);
          this.viewProviders = new Map();
          component.viewProviders.forEach((provider) => {
              if (this.viewProviders.get(tokenReference(provider.token)) == null) {
                  this.viewProviders.set(tokenReference(provider.token), true);
              }
          });
      }
  }
  class ProviderElementContext {
      constructor(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {
          this.viewContext = viewContext;
          this._parent = _parent;
          this._isViewRoot = _isViewRoot;
          this._directiveAsts = _directiveAsts;
          this._sourceSpan = _sourceSpan;
          this._transformedProviders = new Map();
          this._seenProviders = new Map();
          this._queriedTokens = new Map();
          this.transformedHasViewContainer = false;
          this._attrs = {};
          attrs.forEach((attrAst) => this._attrs[attrAst.name] = attrAst.value);
          const directivesMeta = _directiveAsts.map(directiveAst => directiveAst.directive);
          this._allProviders =
              _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);
          this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);
          Array.from(this._allProviders.values()).forEach((provider) => {
              this._addQueryReadsTo(provider.token, provider.token, this._queriedTokens);
          });
          if (isTemplate) {
              const templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);
              this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);
          }
          refs.forEach((refAst) => {
              let defaultQueryValue = refAst.value ||
                  createTokenForExternalReference(this.viewContext.reflector, Identifiers.ElementRef);
              this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, this._queriedTokens);
          });
          if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {
              this.transformedHasViewContainer = true;
          }
          // create the providers that we know are eager first
          Array.from(this._allProviders.values()).forEach((provider) => {
              const eager = provider.eager || this._queriedTokens.get(tokenReference(provider.token));
              if (eager) {
                  this._getOrCreateLocalProvider(provider.providerType, provider.token, true);
              }
          });
      }
      afterElement() {
          // collect lazy providers
          Array.from(this._allProviders.values()).forEach((provider) => {
              this._getOrCreateLocalProvider(provider.providerType, provider.token, false);
          });
      }
      get transformProviders() {
          // Note: Maps keep their insertion order.
          const lazyProviders = [];
          const eagerProviders = [];
          this._transformedProviders.forEach(provider => {
              if (provider.eager) {
                  eagerProviders.push(provider);
              }
              else {
                  lazyProviders.push(provider);
              }
          });
          return lazyProviders.concat(eagerProviders);
      }
      get transformedDirectiveAsts() {
          const sortedProviderTypes = this.transformProviders.map(provider => provider.token.identifier);
          const sortedDirectives = this._directiveAsts.slice();
          sortedDirectives.sort((dir1, dir2) => sortedProviderTypes.indexOf(dir1.directive.type) -
              sortedProviderTypes.indexOf(dir2.directive.type));
          return sortedDirectives;
      }
      get queryMatches() {
          const allMatches = [];
          this._queriedTokens.forEach((matches) => { allMatches.push(...matches); });
          return allMatches;
      }
      _addQueryReadsTo(token, defaultValue, queryReadTokens) {
          this._getQueriesFor(token).forEach((query) => {
              const queryValue = query.meta.read || defaultValue;
              const tokenRef = tokenReference(queryValue);
              let queryMatches = queryReadTokens.get(tokenRef);
              if (!queryMatches) {
                  queryMatches = [];
                  queryReadTokens.set(tokenRef, queryMatches);
              }
              queryMatches.push({ queryId: query.queryId, value: queryValue });
          });
      }
      _getQueriesFor(token) {
          const result = [];
          let currentEl = this;
          let distance = 0;
          let queries;
          while (currentEl !== null) {
              queries = currentEl._contentQueries.get(tokenReference(token));
              if (queries) {
                  result.push(...queries.filter((query) => query.meta.descendants || distance <= 1));
              }
              if (currentEl._directiveAsts.length > 0) {
                  distance++;
              }
              currentEl = currentEl._parent;
          }
          queries = this.viewContext.viewQueries.get(tokenReference(token));
          if (queries) {
              result.push(...queries);
          }
          return result;
      }
      _getOrCreateLocalProvider(requestingProviderType, token, eager) {
          const resolvedProvider = this._allProviders.get(tokenReference(token));
          if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||
              requestingProviderType === ProviderAstType.PublicService) &&
              resolvedProvider.providerType === ProviderAstType.PrivateService) ||
              ((requestingProviderType === ProviderAstType.PrivateService ||
                  requestingProviderType === ProviderAstType.PublicService) &&
                  resolvedProvider.providerType === ProviderAstType.Builtin)) {
              return null;
          }
          let transformedProviderAst = this._transformedProviders.get(tokenReference(token));
          if (transformedProviderAst) {
              return transformedProviderAst;
          }
          if (this._seenProviders.get(tokenReference(token)) != null) {
              this.viewContext.errors.push(new ProviderError(`Cannot instantiate cyclic dependency! ${tokenName(token)}`, this._sourceSpan));
              return null;
          }
          this._seenProviders.set(tokenReference(token), true);
          const transformedProviders = resolvedProvider.providers.map((provider) => {
              let transformedUseValue = provider.useValue;
              let transformedUseExisting = provider.useExisting;
              let transformedDeps = undefined;
              if (provider.useExisting != null) {
                  const existingDiDep = this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager);
                  if (existingDiDep.token != null) {
                      transformedUseExisting = existingDiDep.token;
                  }
                  else {
                      transformedUseExisting = null;
                      transformedUseValue = existingDiDep.value;
                  }
              }
              else if (provider.useFactory) {
                  const deps = provider.deps || provider.useFactory.diDeps;
                  transformedDeps =
                      deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager));
              }
              else if (provider.useClass) {
                  const deps = provider.deps || provider.useClass.diDeps;
                  transformedDeps =
                      deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager));
              }
              return _transformProvider(provider, {
                  useExisting: transformedUseExisting,
                  useValue: transformedUseValue,
                  deps: transformedDeps
              });
          });
          transformedProviderAst =
              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
          this._transformedProviders.set(tokenReference(token), transformedProviderAst);
          return transformedProviderAst;
      }
      _getLocalDependency(requestingProviderType, dep, eager = false) {
          if (dep.isAttribute) {
              const attrValue = this._attrs[dep.token.value];
              return { isValue: true, value: attrValue == null ? null : attrValue };
          }
          if (dep.token != null) {
              // access builtints
              if ((requestingProviderType === ProviderAstType.Directive ||
                  requestingProviderType === ProviderAstType.Component)) {
                  if (tokenReference(dep.token) ===
                      this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) ||
                      tokenReference(dep.token) ===
                          this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) ||
                      tokenReference(dep.token) ===
                          this.viewContext.reflector.resolveExternalReference(Identifiers.ChangeDetectorRef) ||
                      tokenReference(dep.token) ===
                          this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
                      return dep;
                  }
                  if (tokenReference(dep.token) ===
                      this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {
                      this.transformedHasViewContainer = true;
                  }
              }
              // access the injector
              if (tokenReference(dep.token) ===
                  this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {
                  return dep;
              }
              // access providers
              if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {
                  return dep;
              }
          }
          return null;
      }
      _getDependency(requestingProviderType, dep, eager = false) {
          let currElement = this;
          let currEager = eager;
          let result = null;
          if (!dep.isSkipSelf) {
              result = this._getLocalDependency(requestingProviderType, dep, eager);
          }
          if (dep.isSelf) {
              if (!result && dep.isOptional) {
                  result = { isValue: true, value: null };
              }
          }
          else {
              // check parent elements
              while (!result && currElement._parent) {
                  const prevElement = currElement;
                  currElement = currElement._parent;
                  if (prevElement._isViewRoot) {
                      currEager = false;
                  }
                  result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);
              }
              // check @Host restriction
              if (!result) {
                  if (!dep.isHost || this.viewContext.component.isHost ||
                      this.viewContext.component.type.reference === tokenReference(dep.token) ||
                      this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {
                      result = dep;
                  }
                  else {
                      result = dep.isOptional ? { isValue: true, value: null } : null;
                  }
              }
          }
          if (!result) {
              this.viewContext.errors.push(new ProviderError(`No provider for ${tokenName(dep.token)}`, this._sourceSpan));
          }
          return result;
      }
  }
  class NgModuleProviderAnalyzer {
      constructor(reflector, ngModule, extraProviders, sourceSpan) {
          this.reflector = reflector;
          this._transformedProviders = new Map();
          this._seenProviders = new Map();
          this._errors = [];
          this._allProviders = new Map();
          ngModule.transitiveModule.modules.forEach((ngModuleType) => {
              const ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };
              _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, this._errors, this._allProviders, /* isModule */ true);
          });
          _resolveProviders(ngModule.transitiveModule.providers.map(entry => entry.provider).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders, 
          /* isModule */ false);
      }
      parse() {
          Array.from(this._allProviders.values()).forEach((provider) => {
              this._getOrCreateLocalProvider(provider.token, provider.eager);
          });
          if (this._errors.length > 0) {
              const errorString = this._errors.join('\n');
              throw new Error(`Provider parse errors:\n${errorString}`);
          }
          // Note: Maps keep their insertion order.
          const lazyProviders = [];
          const eagerProviders = [];
          this._transformedProviders.forEach(provider => {
              if (provider.eager) {
                  eagerProviders.push(provider);
              }
              else {
                  lazyProviders.push(provider);
              }
          });
          return lazyProviders.concat(eagerProviders);
      }
      _getOrCreateLocalProvider(token, eager) {
          const resolvedProvider = this._allProviders.get(tokenReference(token));
          if (!resolvedProvider) {
              return null;
          }
          let transformedProviderAst = this._transformedProviders.get(tokenReference(token));
          if (transformedProviderAst) {
              return transformedProviderAst;
          }
          if (this._seenProviders.get(tokenReference(token)) != null) {
              this._errors.push(new ProviderError(`Cannot instantiate cyclic dependency! ${tokenName(token)}`, resolvedProvider.sourceSpan));
              return null;
          }
          this._seenProviders.set(tokenReference(token), true);
          const transformedProviders = resolvedProvider.providers.map((provider) => {
              let transformedUseValue = provider.useValue;
              let transformedUseExisting = provider.useExisting;
              let transformedDeps = undefined;
              if (provider.useExisting != null) {
                  const existingDiDep = this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);
                  if (existingDiDep.token != null) {
                      transformedUseExisting = existingDiDep.token;
                  }
                  else {
                      transformedUseExisting = null;
                      transformedUseValue = existingDiDep.value;
                  }
              }
              else if (provider.useFactory) {
                  const deps = provider.deps || provider.useFactory.diDeps;
                  transformedDeps =
                      deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));
              }
              else if (provider.useClass) {
                  const deps = provider.deps || provider.useClass.diDeps;
                  transformedDeps =
                      deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));
              }
              return _transformProvider(provider, {
                  useExisting: transformedUseExisting,
                  useValue: transformedUseValue,
                  deps: transformedDeps
              });
          });
          transformedProviderAst =
              _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });
          this._transformedProviders.set(tokenReference(token), transformedProviderAst);
          return transformedProviderAst;
      }
      _getDependency(dep, eager = false, requestorSourceSpan) {
          if (!dep.isSkipSelf && dep.token != null) {
              // access the injector
              if (tokenReference(dep.token) ===
                  this.reflector.resolveExternalReference(Identifiers.Injector) ||
                  tokenReference(dep.token) ===
                      this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) ;
              else if (this._getOrCreateLocalProvider(dep.token, eager) != null) ;
          }
          return dep;
      }
  }
  function _transformProvider(provider, { useExisting, useValue, deps }) {
      return {
          token: provider.token,
          useClass: provider.useClass,
          useExisting: useExisting,
          useFactory: provider.useFactory,
          useValue: useValue,
          deps: deps,
          multi: provider.multi
      };
  }
  function _transformProviderAst(provider, { eager, providers }) {
      return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);
  }
  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {
      const providersByToken = new Map();
      directives.forEach((directive) => {
          const dirProvider = { token: { identifier: directive.type }, useClass: directive.type };
          _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken, /* isModule */ false);
      });
      // Note: directives need to be able to overwrite providers of a component!
      const directivesWithComponentFirst = directives.filter(dir => dir.isComponent).concat(directives.filter(dir => !dir.isComponent));
      directivesWithComponentFirst.forEach((directive) => {
          _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);
          _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);
      });
      return providersByToken;
  }
  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {
      providers.forEach((provider) => {
          let resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));
          if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {
              targetErrors.push(new ProviderError(`Mixing multi and non multi provider is not possible for token ${tokenName(resolvedProvider.token)}`, sourceSpan));
          }
          if (!resolvedProvider) {
              const lifecycleHooks = provider.token.identifier &&
                  provider.token.identifier.lifecycleHooks ?
                  provider.token.identifier.lifecycleHooks :
                  [];
              const isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);
              resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);
              targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);
          }
          else {
              if (!provider.multi) {
                  resolvedProvider.providers.length = 0;
              }
              resolvedProvider.providers.push(provider);
          }
      });
  }
  function _getViewQueries(component) {
      // Note: queries start with id 1 so we can use the number in a Bloom filter!
      let viewQueryId = 1;
      const viewQueries = new Map();
      if (component.viewQueries) {
          component.viewQueries.forEach((query) => _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }));
      }
      return viewQueries;
  }
  function _getContentQueries(contentQueryStartId, directives) {
      let contentQueryId = contentQueryStartId;
      const contentQueries = new Map();
      directives.forEach((directive, directiveIndex) => {
          if (directive.queries) {
              directive.queries.forEach((query) => _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }));
          }
      });
      return contentQueries;
  }
  function _addQueryToTokenMap(map, query) {
      query.meta.selectors.forEach((token) => {
          let entry = map.get(tokenReference(token));
          if (!entry) {
              entry = [];
              map.set(tokenReference(token), entry);
          }
          entry.push(query);
      });
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function providerDef(ctx, providerAst) {
      let flags = 0 /* None */;
      if (!providerAst.eager) {
          flags |= 4096 /* LazyProvider */;
      }
      if (providerAst.providerType === ProviderAstType.PrivateService) {
          flags |= 8192 /* PrivateProvider */;
      }
      if (providerAst.isModule) {
          flags |= 1073741824 /* TypeModuleProvider */;
      }
      providerAst.lifecycleHooks.forEach((lifecycleHook) => {
          // for regular providers, we only support ngOnDestroy
          if (lifecycleHook === LifecycleHooks.OnDestroy ||
              providerAst.providerType === ProviderAstType.Directive ||
              providerAst.providerType === ProviderAstType.Component) {
              flags |= lifecycleHookToNodeFlag(lifecycleHook);
          }
      });
      const { providerExpr, flags: providerFlags, depsExpr } = providerAst.multiProvider ?
          multiProviderDef(ctx, flags, providerAst.providers) :
          singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);
      return {
          providerExpr,
          flags: providerFlags, depsExpr,
          tokenExpr: tokenExpr(ctx, providerAst.token),
      };
  }
  function multiProviderDef(ctx, flags, providers) {
      const allDepDefs = [];
      const allParams = [];
      const exprs = providers.map((provider, providerIndex) => {
          let expr;
          if (provider.useClass) {
              const depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);
              expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);
          }
          else if (provider.useFactory) {
              const depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);
              expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);
          }
          else if (provider.useExisting) {
              const depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);
              expr = depExprs[0];
          }
          else {
              expr = convertValueToOutputAst(ctx, provider.useValue);
          }
          return expr;
      });
      const providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);
      return {
          providerExpr,
          flags: flags | 1024 /* TypeFactoryProvider */,
          depsExpr: literalArr(allDepDefs)
      };
      function convertDeps(providerIndex, deps) {
          return deps.map((dep, depIndex) => {
              const paramName = `p${providerIndex}_${depIndex}`;
              allParams.push(new FnParam(paramName, DYNAMIC_TYPE));
              allDepDefs.push(depDef(ctx, dep));
              return variable(paramName);
          });
      }
  }
  function singleProviderDef(ctx, flags, providerType, providerMeta) {
      let providerExpr;
      let deps;
      if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {
          providerExpr = ctx.importExpr(providerMeta.useClass.reference);
          flags |= 16384 /* TypeDirective */;
          deps = providerMeta.deps || providerMeta.useClass.diDeps;
      }
      else {
          if (providerMeta.useClass) {
              providerExpr = ctx.importExpr(providerMeta.useClass.reference);
              flags |= 512 /* TypeClassProvider */;
              deps = providerMeta.deps || providerMeta.useClass.diDeps;
          }
          else if (providerMeta.useFactory) {
              providerExpr = ctx.importExpr(providerMeta.useFactory.reference);
              flags |= 1024 /* TypeFactoryProvider */;
              deps = providerMeta.deps || providerMeta.useFactory.diDeps;
          }
          else if (providerMeta.useExisting) {
              providerExpr = NULL_EXPR;
              flags |= 2048 /* TypeUseExistingProvider */;
              deps = [{ token: providerMeta.useExisting }];
          }
          else {
              providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);
              flags |= 256 /* TypeValueProvider */;
              deps = [];
          }
      }
      const depsExpr = literalArr(deps.map(dep => depDef(ctx, dep)));
      return { providerExpr, flags, depsExpr };
  }
  function tokenExpr(ctx, tokenMeta) {
      return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :
          literal(tokenMeta.value);
  }
  function depDef(ctx, dep) {
      // Note: the following fields have already been normalized out by provider_analyzer:
      // - isAttribute, isHost
      const expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token);
      let flags = 0 /* None */;
      if (dep.isSkipSelf) {
          flags |= 1 /* SkipSelf */;
      }
      if (dep.isOptional) {
          flags |= 2 /* Optional */;
      }
      if (dep.isSelf) {
          flags |= 4 /* Self */;
      }
      if (dep.isValue) {
          flags |= 8 /* Value */;
      }
      return flags === 0 /* None */ ? expr : literalArr([literal(flags), expr]);
  }
  function lifecycleHookToNodeFlag(lifecycleHook) {
      let nodeFlag = 0 /* None */;
      switch (lifecycleHook) {
          case LifecycleHooks.AfterContentChecked:
              nodeFlag = 2097152 /* AfterContentChecked */;
              break;
          case LifecycleHooks.AfterContentInit:
              nodeFlag = 1048576 /* AfterContentInit */;
              break;
          case LifecycleHooks.AfterViewChecked:
              nodeFlag = 8388608 /* AfterViewChecked */;
              break;
          case LifecycleHooks.AfterViewInit:
              nodeFlag = 4194304 /* AfterViewInit */;
              break;
          case LifecycleHooks.DoCheck:
              nodeFlag = 262144 /* DoCheck */;
              break;
          case LifecycleHooks.OnChanges:
              nodeFlag = 524288 /* OnChanges */;
              break;
          case LifecycleHooks.OnDestroy:
              nodeFlag = 131072 /* OnDestroy */;
              break;
          case LifecycleHooks.OnInit:
              nodeFlag = 65536 /* OnInit */;
              break;
      }
      return nodeFlag;
  }
  function componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {
      const entryComponentFactories = entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));
      const token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);
      const classMeta = {
          diDeps: [
              { isValue: true, value: literalArr(entryComponentFactories) },
              { token: token, isSkipSelf: true, isOptional: true },
              { token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef) },
          ],
          lifecycleHooks: [],
          reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)
      };
      const { providerExpr, flags: providerFlags, depsExpr } = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {
          token,
          multi: false,
          useClass: classMeta,
      });
      return { providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token) };
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  class NgModuleCompileResult {
      constructor(ngModuleFactoryVar) {
          this.ngModuleFactoryVar = ngModuleFactoryVar;
      }
  }
  const LOG_VAR = variable('_l');
  class NgModuleCompiler {
      constructor(reflector) {
          this.reflector = reflector;
      }
      compile(ctx, ngModuleMeta, extraProviders) {
          const sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);
          const entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;
          const bootstrapComponents = ngModuleMeta.bootstrapComponents;
          const providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);
          const providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0 /* None */, entryComponentFactories)]
              .concat(providerParser.parse().map((provider) => providerDef(ctx, provider)))
              .map(({ providerExpr, depsExpr, flags, tokenExpr }) => {
              return importExpr(Identifiers.moduleProviderDef).callFn([
                  literal(flags), tokenExpr, providerExpr, depsExpr
              ]);
          });
          const ngModuleDef = importExpr(Identifiers.moduleDef).callFn([literalArr(providerDefs)]);
          const ngModuleDefFactory = fn([new FnParam(LOG_VAR.name)], [new ReturnStatement(ngModuleDef)], INFERRED_TYPE);
          const ngModuleFactoryVar = `${identifierName(ngModuleMeta.type)}NgFactory`;
          this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, importExpr(Identifiers.createModuleFactory).callFn([
              ctx.importExpr(ngModuleMeta.type.reference),
              literalArr(bootstrapComponents.map(id => ctx.importExpr(id.reference))),
              ngModuleDefFactory
          ]));
          if (ngModuleMeta.id) {
              const id = typeof ngModuleMeta.id === 'string' ? literal(ngModuleMeta.id) :
                  ctx.importExpr(ngModuleMeta.id);
              const registerFactoryStmt = importExpr(Identifiers.RegisterModuleFactoryFn)
                  .callFn([id, variable(ngModuleFactoryVar)])
                  .toStmt();
              ctx.statements.push(registerFactoryStmt);
          }
          return new NgModuleCompileResult(ngModuleFactoryVar);
      }
      createStub(ctx, ngModuleReference) {
          this._createNgModuleFactory(ctx, ngModuleReference, NULL_EXPR);
      }
      _createNgModuleFactory(ctx, reference, value) {
          const ngModuleFactoryVar = `${identifierName({ reference: reference })}NgFactory`;
          const ngModuleFactoryStmt = variable(ngModuleFactoryVar)
              .set(value)
              .toDeclStmt(importType(Identifiers.NgModuleFactory, [expressionType(ctx.importExpr(reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]);
          ctx.statements.push(ngModuleFactoryStmt);
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Resolves types to {@link NgModule}.
   */
  class NgModuleResolver {
      constructor(_reflector) {
          this._reflector = _reflector;
      }
      isNgModule(type) { return this._reflector.annotations(type).some(createNgModule.isTypeOf); }
      resolve(type, throwIfNotFound = true) {
          const ngModuleMeta = findLast(this._reflector.annotations(type), createNgModule.isTypeOf);
          if (ngModuleMeta) {
              return ngModuleMeta;
          }
          else {
              if (throwIfNotFound) {
                  throw new Error(`No NgModule metadata found for '${stringify(type)}'.`);
              }
              return null;
          }
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function debugOutputAstAsTypeScript(ast) {
      const converter = new _TsEmitterVisitor();
      const ctx = EmitterVisitorContext.createRoot();
      const asts = Array.isArray(ast) ? ast : [ast];
      asts.forEach((ast) => {
          if (ast instanceof Statement) {
              ast.visitStatement(converter, ctx);
          }
          else if (ast instanceof Expression) {
              ast.visitExpression(converter, ctx);
          }
          else if (ast instanceof Type$1) {
              ast.visitType(converter, ctx);
          }
          else {
              throw new Error(`Don't know how to print debug info for ${ast}`);
          }
      });
      return ctx.toSource();
  }
  class _TsEmitterVisitor extends AbstractEmitterVisitor {
      constructor(referenceFilter, importFilter) {
          super(false);
          this.referenceFilter = referenceFilter;
          this.importFilter = importFilter;
          this.typeExpression = 0;
          this.importsWithPrefixes = new Map();
          this.reexports = new Map();
      }
      visitType(t, ctx, defaultType = 'any') {
          if (t) {
              this.typeExpression++;
              t.visitType(this, ctx);
              this.typeExpression--;
          }
          else {
              ctx.print(null, defaultType);
          }
      }
      visitLiteralExpr(ast, ctx) {
          const value = ast.value;
          if (value == null && ast.type != INFERRED_TYPE) {
              ctx.print(ast, `(${value} as any)`);
              return null;
          }
          return super.visitLiteralExpr(ast, ctx);
      }
      // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.
      // In SNC mode, [] have the type never[], so we cast here to any[].
      // TODO: narrow the cast to a more explicit type, or use a pattern that does not
      // start with [].concat. see https://github.com/angular/angular/pull/11846
      visitLiteralArrayExpr(ast, ctx) {
          if (ast.entries.length === 0) {
              ctx.print(ast, '(');
          }
          const result = super.visitLiteralArrayExpr(ast, ctx);
          if (ast.entries.length === 0) {
              ctx.print(ast, ' as any[])');
          }
          return result;
      }
      visitExternalExpr(ast, ctx) {
          this._visitIdentifier(ast.value, ast.typeParams, ctx);
          return null;
      }
      visitAssertNotNullExpr(ast, ctx) {
          const result = super.visitAssertNotNullExpr(ast, ctx);
          ctx.print(ast, '!');
          return result;
      }
      visitDeclareVarStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr &&
              !stmt.type) {
              // check for a reexport
              const { name, moduleName } = stmt.value.value;
              if (moduleName) {
                  let reexports = this.reexports.get(moduleName);
                  if (!reexports) {
                      reexports = [];
                      this.reexports.set(moduleName, reexports);
                  }
                  reexports.push({ name: name, as: stmt.name });
                  return null;
              }
          }
          if (stmt.hasModifier(StmtModifier.Exported)) {
              ctx.print(stmt, `export `);
          }
          if (stmt.hasModifier(StmtModifier.Final)) {
              ctx.print(stmt, `const`);
          }
          else {
              ctx.print(stmt, `var`);
          }
          ctx.print(stmt, ` ${stmt.name}`);
          this._printColonType(stmt.type, ctx);
          if (stmt.value) {
              ctx.print(stmt, ` = `);
              stmt.value.visitExpression(this, ctx);
          }
          ctx.println(stmt, `;`);
          return null;
      }
      visitWrappedNodeExpr(ast, ctx) {
          throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');
      }
      visitCastExpr(ast, ctx) {
          ctx.print(ast, `(<`);
          ast.type.visitType(this, ctx);
          ctx.print(ast, `>`);
          ast.value.visitExpression(this, ctx);
          ctx.print(ast, `)`);
          return null;
      }
      visitInstantiateExpr(ast, ctx) {
          ctx.print(ast, `new `);
          this.typeExpression++;
          ast.classExpr.visitExpression(this, ctx);
          this.typeExpression--;
          ctx.print(ast, `(`);
          this.visitAllExpressions(ast.args, ctx, ',');
          ctx.print(ast, `)`);
          return null;
      }
      visitDeclareClassStmt(stmt, ctx) {
          ctx.pushClass(stmt);
          if (stmt.hasModifier(StmtModifier.Exported)) {
              ctx.print(stmt, `export `);
          }
          ctx.print(stmt, `class ${stmt.name}`);
          if (stmt.parent != null) {
              ctx.print(stmt, ` extends `);
              this.typeExpression++;
              stmt.parent.visitExpression(this, ctx);
              this.typeExpression--;
          }
          ctx.println(stmt, ` {`);
          ctx.incIndent();
          stmt.fields.forEach((field) => this._visitClassField(field, ctx));
          if (stmt.constructorMethod != null) {
              this._visitClassConstructor(stmt, ctx);
          }
          stmt.getters.forEach((getter) => this._visitClassGetter(getter, ctx));
          stmt.methods.forEach((method) => this._visitClassMethod(method, ctx));
          ctx.decIndent();
          ctx.println(stmt, `}`);
          ctx.popClass();
          return null;
      }
      _visitClassField(field, ctx) {
          if (field.hasModifier(StmtModifier.Private)) {
              // comment out as a workaround for #10967
              ctx.print(null, `/*private*/ `);
          }
          if (field.hasModifier(StmtModifier.Static)) {
              ctx.print(null, 'static ');
          }
          ctx.print(null, field.name);
          this._printColonType(field.type, ctx);
          if (field.initializer) {
              ctx.print(null, ' = ');
              field.initializer.visitExpression(this, ctx);
          }
          ctx.println(null, `;`);
      }
      _visitClassGetter(getter, ctx) {
          if (getter.hasModifier(StmtModifier.Private)) {
              ctx.print(null, `private `);
          }
          ctx.print(null, `get ${getter.name}()`);
          this._printColonType(getter.type, ctx);
          ctx.println(null, ` {`);
          ctx.incIndent();
          this.visitAllStatements(getter.body, ctx);
          ctx.decIndent();
          ctx.println(null, `}`);
      }
      _visitClassConstructor(stmt, ctx) {
          ctx.print(stmt, `constructor(`);
          this._visitParams(stmt.constructorMethod.params, ctx);
          ctx.println(stmt, `) {`);
          ctx.incIndent();
          this.visitAllStatements(stmt.constructorMethod.body, ctx);
          ctx.decIndent();
          ctx.println(stmt, `}`);
      }
      _visitClassMethod(method, ctx) {
          if (method.hasModifier(StmtModifier.Private)) {
              ctx.print(null, `private `);
          }
          ctx.print(null, `${method.name}(`);
          this._visitParams(method.params, ctx);
          ctx.print(null, `)`);
          this._printColonType(method.type, ctx, 'void');
          ctx.println(null, ` {`);
          ctx.incIndent();
          this.visitAllStatements(method.body, ctx);
          ctx.decIndent();
          ctx.println(null, `}`);
      }
      visitFunctionExpr(ast, ctx) {
          if (ast.name) {
              ctx.print(ast, 'function ');
              ctx.print(ast, ast.name);
          }
          ctx.print(ast, `(`);
          this._visitParams(ast.params, ctx);
          ctx.print(ast, `)`);
          this._printColonType(ast.type, ctx, 'void');
          if (!ast.name) {
              ctx.print(ast, ` => `);
          }
          ctx.println(ast, '{');
          ctx.incIndent();
          this.visitAllStatements(ast.statements, ctx);
          ctx.decIndent();
          ctx.print(ast, `}`);
          return null;
      }
      visitDeclareFunctionStmt(stmt, ctx) {
          if (stmt.hasModifier(StmtModifier.Exported)) {
              ctx.print(stmt, `export `);
          }
          ctx.print(stmt, `function ${stmt.name}(`);
          this._visitParams(stmt.params, ctx);
          ctx.print(stmt, `)`);
          this._printColonType(stmt.type, ctx, 'void');
          ctx.println(stmt, ` {`);
          ctx.incIndent();
          this.visitAllStatements(stmt.statements, ctx);
          ctx.decIndent();
          ctx.println(stmt, `}`);
          return null;
      }
      visitTryCatchStmt(stmt, ctx) {
          ctx.println(stmt, `try {`);
          ctx.incIndent();
          this.visitAllStatements(stmt.bodyStmts, ctx);
          ctx.decIndent();
          ctx.println(stmt, `} catch (${CATCH_ERROR_VAR$1.name}) {`);
          ctx.incIndent();
          const catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [
                  StmtModifier.Final
              ])].concat(stmt.catchStmts);
          this.visitAllStatements(catchStmts, ctx);
          ctx.decIndent();
          ctx.println(stmt, `}`);
          return null;
      }
      visitBuiltinType(type, ctx) {
          let typeStr;
          switch (type.name) {
              case BuiltinTypeName.Bool:
                  typeStr = 'boolean';
                  break;
              case BuiltinTypeName.Dynamic:
                  typeStr = 'any';
                  break;
              case BuiltinTypeName.Function:
                  typeStr = 'Function';
                  break;
              case BuiltinTypeName.Number:
                  typeStr = 'number';
                  break;
              case BuiltinTypeName.Int:
                  typeStr = 'number';
                  break;
              case BuiltinTypeName.String:
                  typeStr = 'string';
                  break;
              case BuiltinTypeName.None:
                  typeStr = 'never';
                  break;
              default:
                  throw new Error(`Unsupported builtin type ${type.name}`);
          }
          ctx.print(null, typeStr);
          return null;
      }
      visitExpressionType(ast, ctx) {
          ast.value.visitExpression(this, ctx);
          if (ast.typeParams !== null) {
              ctx.print(null, '<');
              this.visitAllObjects(type => this.visitType(type, ctx), ast.typeParams, ctx, ',');
              ctx.print(null, '>');
          }
          return null;
      }
      visitArrayType(type, ctx) {
          this.visitType(type.of, ctx);
          ctx.print(null, `[]`);
          return null;
      }
      visitMapType(type, ctx) {
          ctx.print(null, `{[key: string]:`);
          this.visitType(type.valueType, ctx);
          ctx.print(null, `}`);
          return null;
      }
      getBuiltinMethodName(method) {
          let name;
          switch (method) {
              case BuiltinMethod.ConcatArray:
                  name = 'concat';
                  break;
              case BuiltinMethod.SubscribeObservable:
                  name = 'subscribe';
                  break;
              case BuiltinMethod.Bind:
                  name = 'bind';
                  break;
              default:
                  throw new Error(`Unknown builtin method: ${method}`);
          }
          return name;
      }
      _visitParams(params, ctx) {
          this.visitAllObjects(param => {
              ctx.print(null, param.name);
              this._printColonType(param.type, ctx);
          }, params, ctx, ',');
      }
      _visitIdentifier(value, typeParams, ctx) {
          const { name, moduleName } = value;
          if (this.referenceFilter && this.referenceFilter(value)) {
              ctx.print(null, '(null as any)');
              return;
          }
          if (moduleName && (!this.importFilter || !this.importFilter(value))) {
              let prefix = this.importsWithPrefixes.get(moduleName);
              if (prefix == null) {
                  prefix = `i${this.importsWithPrefixes.size}`;
                  this.importsWithPrefixes.set(moduleName, prefix);
              }
              ctx.print(null, `${prefix}.`);
          }
          ctx.print(null, name);
          if (this.typeExpression > 0) {
              // If we are in a type expression that refers to a generic type then supply
              // the required type parameters. If there were not enough type parameters
              // supplied, supply any as the type. Outside a type expression the reference
              // should not supply type parameters and be treated as a simple value reference
              // to the constructor function itself.
              const suppliedParameters = typeParams || [];
              if (suppliedParameters.length > 0) {
                  ctx.print(null, `<`);
                  this.visitAllObjects(type => type.visitType(this, ctx), typeParams, ctx, ',');
                  ctx.print(null, `>`);
              }
          }
      }
      _printColonType(type, ctx, defaultType) {
          if (type !== INFERRED_TYPE) {
              ctx.print(null, ':');
              this.visitType(type, ctx, defaultType);
          }
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Resolve a `Type` for {@link Pipe}.
   *
   * This interface can be overridden by the application developer to create custom behavior.
   *
   * See {@link Compiler}
   */
  class PipeResolver {
      constructor(_reflector) {
          this._reflector = _reflector;
      }
      isPipe(type) {
          const typeMetadata = this._reflector.annotations(resolveForwardRef(type));
          return typeMetadata && typeMetadata.some(createPipe.isTypeOf);
      }
      /**
       * Return {@link Pipe} for a given `Type`.
       */
      resolve(type, throwIfNotFound = true) {
          const metas = this._reflector.annotations(resolveForwardRef(type));
          if (metas) {
              const annotation = findLast(metas, createPipe.isTypeOf);
              if (annotation) {
                  return annotation;
              }
          }
          if (throwIfNotFound) {
              throw new Error(`No Pipe decorator found on ${stringify(type)}`);
          }
          return null;
      }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // http://cldr.unicode.org/index/cldr-spec/plural-rules
  const PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];
  /**
   * Expands special forms into elements.
   *
   * For example,
   *
   * ```
   * { messages.length, plural,
   *   =0 {zero}
   *   =1 {one}
   *   other {more than one}
   * }
   * ```
   *
   * will be expanded into
   *
   * ```
   * <ng-container [ngPlural]="messages.length">
   *   <ng-template ngPluralCase="=0">zero</ng-template>
   *   <ng-template ngPluralCase="=1">one</ng-template>
   *   <ng-template ngPluralCase="other">more than one</ng-template>
   * </ng-container>
   * ```
   */
  function expandNodes(nodes) {
      const expander = new _Expander();
      return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);
  }
  class ExpansionResult {
      constructor(nodes, expanded, errors) {
          this.nodes = nodes;
          this.expanded = expanded;
          this.errors = errors;
      }
  }
  class ExpansionError extends ParseError {
      constructor(span, errorMsg) { super(span, errorMsg); }
  }
  /**
   * Expand expansion forms (plural, select) to directives
   *
   * @internal
   */
  class _Expander {
      constructor() {
          this.isExpanded = false;
          this.errors = [];
      }
      visitElement(element, context) {
          return new Element$1(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
      }
      visitAttribute(attribute, context) { return attribute; }
      visitText(text, context) { return text; }
      visitComment(comment, context) { return comment; }
      visitExpansion(icu, context) {
          this.isExpanded = true;
          return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :
              _expandDefaultForm(icu, this.errors);
      }
      visitExpansionCase(icuCase, context) {
          throw new Error('Should not be reached');
      }
  }
  // Plural forms are expanded to `NgPlural` and `NgPluralCase`s
  function _expandPluralForm(ast, errors) {
      const children = ast.cases.map(c => {
          if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\d+$/)) {
              errors.push(new ExpansionError(c.valueSourceSpan, `Plural cases should be "=<number>" or one of ${PLURAL_CASES.join(", ")}`));
          }
          const expansionResult = expandNodes(c.expression);
          errors.push(...expansionResult.errors);
          return new Element$1(`ng-template`, [new Attribute('ngPluralCase', `${c.value}`, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      });
      const switchAttr = new Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);
      return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }
  // ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s
  function _expandDefaultForm(ast, errors) {
      const children = ast.cases.map(c => {
          const expansionResult = expandNodes(c.expression);
          errors.push(...expansionResult.errors);
          if (c.value === 'other') {
              // other is the default case when no values match
              return new Element$1(`ng-template`, [new Attribute('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
          }
          return new Element$1(`ng-template`, [new Attribute('ngSwitchCase', `${c.value}`, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);
      });
      const switchAttr = new Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);
      return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const BIND_NAME_REGEXP$1 = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
  // Group 1 = "bind-"
  const KW_BIND_IDX$1 = 1;
  // Group 2 = "let-"
  const KW_LET_IDX$1 = 2;
  // Group 3 = "ref-/#"
  const KW_REF_IDX$1 = 3;
  // Group 4 = "on-"
  const KW_ON_IDX$1 = 4;
  // Group 5 = "bindon-"
  const KW_BINDON_IDX$1 = 5;
  // Group 6 = "@"
  const KW_AT_IDX$1 = 6;
  // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"
  const IDENT_KW_IDX$1 = 7;
  // Group 8 = identifier inside [()]
  const IDENT_BANANA_BOX_IDX$1 = 8;
  // Group 9 = identifier inside []
  const IDENT_PROPERTY_IDX$1 = 9;
  // Group 10 = identifier inside ()
  const IDENT_EVENT_IDX$1 = 10;
  const TEMPLATE_ATTR_PREFIX$1 = '*';
  const CLASS_ATTR = 'class';
  let _TEXT_CSS_SELECTOR;
  function TEXT_CSS_SELECTOR() {
      if (!_TEXT_CSS_SELECTOR) {
          _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];
      }
      return _TEXT_CSS_SELECTOR;
  }
  class TemplateParseError extends ParseError {
      constructor(message, span, level) {
          super(span, message, level);
      }
  }
  class TemplateParseResult {
      constructor(templateAst, usedPipes, errors) {
          this.templateAst = templateAst;
          this.usedPipes = usedPipes;
          this.errors = errors;
      }
  }
  class TemplateParser {
      constructor(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {
          this._config = _config;
          this._reflector = _reflector;
          this._exprParser = _exprParser;
          this._schemaRegistry = _schemaRegistry;
          this._htmlParser = _htmlParser;
          this._console = _console;
          this.transforms = transforms;
      }
      get expressionParser() { return this._exprParser; }
      parse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {
          const result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);
          const warnings = result.errors.filter(error$$1 => error$$1.level === ParseErrorLevel.WARNING);
          const errors = result.errors.filter(error$$1 => error$$1.level === ParseErrorLevel.ERROR);
          if (warnings.length > 0) {
              this._console.warn(`Template parse warnings:\n${warnings.join('\n')}`);
          }
          if (errors.length > 0) {
              const errorString = errors.join('\n');
              throw syntaxError(`Template parse errors:\n${errorString}`, errors);
          }
          return { template: result.templateAst, pipes: result.usedPipes };
      }
      tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {
          let htmlParseResult = typeof template === 'string' ?
              this._htmlParser.parse(template, templateUrl, {
                  tokenizeExpansionForms: true,
                  interpolationConfig: this.getInterpolationConfig(component)
              }) :
              template;
          if (!preserveWhitespaces) {
              htmlParseResult = removeWhitespaces(htmlParseResult);
          }
          return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);
      }
      tryParseHtml(htmlAstWithErrors, component, directives, pipes, schemas) {
          let result;
          const errors = htmlAstWithErrors.errors;
          const usedPipes = [];
          if (htmlAstWithErrors.rootNodes.length > 0) {
              const uniqDirectives = removeSummaryDuplicates(directives);
              const uniqPipes = removeSummaryDuplicates(pipes);
              const providerViewContext = new ProviderViewContext(this._reflector, component);
              let interpolationConfig = undefined;
              if (component.template && component.template.interpolation) {
                  interpolationConfig = {
                      start: component.template.interpolation[0],
                      end: component.template.interpolation[1]
                  };
              }
              const bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);
              const parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);
              result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);
              errors.push(...providerViewContext.errors);
              usedPipes.push(...bindingParser.getUsedPipes());
          }
          else {
              result = [];
          }
          this._assertNoReferenceDuplicationOnTemplate(result, errors);
          if (errors.length > 0) {
              return new TemplateParseResult(result, usedPipes, errors);
          }
          if (this.transforms) {
              this.transforms.forEach((transform) => { result = templateVisitAll(transform, result); });
          }
          return new TemplateParseResult(result, usedPipes, errors);
      }
      expandHtml(htmlAstWithErrors, forced = false) {
          const errors = htmlAstWithErrors.errors;
          if (errors.length == 0 || forced) {
              // Transform ICU messages to angular directives
              const expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);
              errors.push(...expandedHtmlAst.errors);
              htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);
          }
          return htmlAstWithErrors;
      }
      getInterpolationConfig(component) {
          if (component.template) {
              return InterpolationConfig.fromArray(component.template.interpolation);
          }
          return undefined;
      }
      /** @internal */
      _assertNoReferenceDuplicationOnTemplate(result, errors) {
          const existingReferences = [];
          result.filter(element => !!element.references)
              .forEach(element => element.references.forEach((reference) => {
              const name = reference.name;
              if (existingReferences.indexOf(name) < 0) {
                  existingReferences.push(name);
              }
              else {
                  const error$$1 = new TemplateParseError(`Reference "#${name}" is defined several times`, reference.sourceSpan, ParseErrorLevel.ERROR);
                  errors.push(error$$1);
              }
          }));
      }
  }
  class TemplateParseVisitor {
      constructor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {
          this.reflector = reflector;
          this.config = config;
          this.providerViewContext = providerViewContext;
          this._bindingParser = _bindingParser;
          this._schemaRegistry = _schemaRegistry;
          this._schemas = _schemas;
          this._targetErrors = _targetErrors;
          this.selectorMatcher = new SelectorMatcher();
          this.directivesIndex = new Map();
          this.ngContentCount = 0;
          // Note: queries start with id 1 so we can use the number in a Bloom filter!
          this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;
          directives.forEach((directive, index) => {
              const selector = CssSelector.parse(directive.selector);
              this.selectorMatcher.addSelectables(selector, directive);
              this.directivesIndex.set(directive, index);
          });
      }
      visitExpansion(expansion, context) { return null; }
      visitExpansionCase(expansionCase, context) { return null; }
      visitText(text, parent) {
          const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());
          const valueNoNgsp = replaceNgsp(text.value);
          const expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);
          return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) :
              new TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);
      }
      visitAttribute(attribute, context) {
          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
      }
      visitComment(comment, context) { return null; }
      visitElement(element, parent) {
          const queryStartIndex = this.contentQueryStartId;
          const elName = element.name;
          const preparsedElement = preparseElement(element);
          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
              preparsedElement.type === PreparsedElementType.STYLE) {
              // Skipping <script> for security reasons
              // Skipping <style> as we already processed them
              // in the StyleCompiler
              return null;
          }
          if (preparsedElement.type === PreparsedElementType.STYLESHEET &&
              isStyleUrlResolvable(preparsedElement.hrefAttr)) {
              // Skipping stylesheets with either relative urls or package scheme as we already processed
              // them in the StyleCompiler
              return null;
          }
          const matchableAttrs = [];
          const elementOrDirectiveProps = [];
          const elementOrDirectiveRefs = [];
          const elementVars = [];
          const events = [];
          const templateElementOrDirectiveProps = [];
          const templateMatchableAttrs = [];
          const templateElementVars = [];
          let hasInlineTemplates = false;
          const attrs = [];
          const isTemplateElement = isNgTemplate(element.name);
          element.attrs.forEach(attr => {
              const parsedVariables = [];
              const hasBinding = this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);
              elementVars.push(...parsedVariables.map(v => VariableAst.fromParsedVariable(v)));
              let templateValue;
              let templateKey;
              const normalizedName = this._normalizeAttributeName(attr.name);
              if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {
                  templateValue = attr.value;
                  templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);
              }
              const hasTemplateBinding = templateValue != null;
              if (hasTemplateBinding) {
                  if (hasInlineTemplates) {
                      this._reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attr.sourceSpan);
                  }
                  hasInlineTemplates = true;
                  const parsedVariables = [];
                  this._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, parsedVariables);
                  templateElementVars.push(...parsedVariables.map(v => VariableAst.fromParsedVariable(v)));
              }
              if (!hasBinding && !hasTemplateBinding) {
                  // don't include the bindings as attributes as well in the AST
                  attrs.push(this.visitAttribute(attr, null));
                  matchableAttrs.push([attr.name, attr.value]);
              }
          });
          const elementCssSelector = createElementCssSelector(elName, matchableAttrs);
          const { directives: directiveMetas, matchElement } = this._parseDirectives(this.selectorMatcher, elementCssSelector);
          const references = [];
          const boundDirectivePropNames = new Set();
          const directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);
          const elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);
          const isViewRoot = parent.isTemplateElement || hasInlineTemplates;
          const providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);
          const children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR$1 : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));
          providerContext.afterElement();
          // Override the actual selector when the `ngProjectAs` attribute is provided
          const projectionSelector = preparsedElement.projectAs != '' ?
              CssSelector.parse(preparsedElement.projectAs)[0] :
              elementCssSelector;
          const ngContentIndex = parent.findNgContentIndex(projectionSelector);
          let parsedElement;
          if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
              // `<ng-content>` element
              if (element.children && !element.children.every(_isEmptyTextNode)) {
                  this._reportError(`<ng-content> element cannot have content.`, element.sourceSpan);
              }
              parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
          }
          else if (isTemplateElement) {
              // `<ng-template>` element
              this._assertAllEventsPublishedByDirectives(directiveAsts, events);
              this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);
              parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);
          }
          else {
              // element other than `<ng-content>` and `<ng-template>`
              this._assertElementExists(matchElement, element);
              this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);
              const ngContentIndex = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);
              parsedElement = new ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan, element.endSourceSpan || null);
          }
          if (hasInlineTemplates) {
              // The element as a *-attribute
              const templateQueryStartIndex = this.contentQueryStartId;
              const templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);
              const { directives } = this._parseDirectives(this.selectorMatcher, templateSelector);
              const templateBoundDirectivePropNames = new Set();
              const templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);
              const templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);
              this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);
              const templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);
              templateProviderContext.afterElement();
              parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);
          }
          return parsedElement;
      }
      _parseAttr(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {
          const name = this._normalizeAttributeName(attr.name);
          const value = attr.value;
          const srcSpan = attr.sourceSpan;
          const boundEvents = [];
          const bindParts = name.match(BIND_NAME_REGEXP$1);
          let hasBinding = false;
          if (bindParts !== null) {
              hasBinding = true;
              if (bindParts[KW_BIND_IDX$1] != null) {
                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, targetMatchableAttrs, targetProps);
              }
              else if (bindParts[KW_LET_IDX$1]) {
                  if (isTemplateElement) {
                      const identifier = bindParts[IDENT_KW_IDX$1];
                      this._parseVariable(identifier, value, srcSpan, targetVars);
                  }
                  else {
                      this._reportError(`"let-" is only supported on ng-template elements.`, srcSpan);
                  }
              }
              else if (bindParts[KW_REF_IDX$1]) {
                  const identifier = bindParts[IDENT_KW_IDX$1];
                  this._parseReference(identifier, value, srcSpan, targetRefs);
              }
              else if (bindParts[KW_ON_IDX$1]) {
                  this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, targetMatchableAttrs, boundEvents);
              }
              else if (bindParts[KW_BINDON_IDX$1]) {
                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, targetMatchableAttrs, targetProps);
                  this._parseAssignmentEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, targetMatchableAttrs, boundEvents);
              }
              else if (bindParts[KW_AT_IDX$1]) {
                  this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);
              }
              else if (bindParts[IDENT_BANANA_BOX_IDX$1]) {
                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX$1], value, false, srcSpan, targetMatchableAttrs, targetProps);
                  this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX$1], value, srcSpan, targetMatchableAttrs, boundEvents);
              }
              else if (bindParts[IDENT_PROPERTY_IDX$1]) {
                  this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX$1], value, false, srcSpan, targetMatchableAttrs, targetProps);
              }
              else if (bindParts[IDENT_EVENT_IDX$1]) {
                  this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX$1], value, srcSpan, targetMatchableAttrs, boundEvents);
              }
          }
          else {
              hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);
          }
          if (!hasBinding) {
              this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);
          }
          targetEvents.push(...boundEvents.map(e => BoundEventAst.fromParsedEvent(e)));
          return hasBinding;
      }
      _normalizeAttributeName(attrName) {
          return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
      }
      _parseVariable(identifier, value, sourceSpan, targetVars) {
          if (identifier.indexOf('-') > -1) {
              this._reportError(`"-" is not allowed in variable names`, sourceSpan);
          }
          targetVars.push(new VariableAst(identifier, value, sourceSpan));
      }
      _parseReference(identifier, value, sourceSpan, targetRefs) {
          if (identifier.indexOf('-') > -1) {
              this._reportError(`"-" is not allowed in reference names`, sourceSpan);
          }
          targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));
      }
      _parseAssignmentEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {
          this._bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, targetMatchableAttrs, targetEvents);
      }
      _parseDirectives(selectorMatcher, elementCssSelector) {
          // Need to sort the directives so that we get consistent results throughout,
          // as selectorMatcher uses Maps inside.
          // Also deduplicate directives as they might match more than one time!
          const directives = new Array(this.directivesIndex.size);
          // Whether any directive selector matches on the element name
          let matchElement = false;
          selectorMatcher.match(elementCssSelector, (selector, directive) => {
              directives[this.directivesIndex.get(directive)] = directive;
              matchElement = matchElement || selector.hasElementSelector();
          });
          return {
              directives: directives.filter(dir => !!dir),
              matchElement,
          };
      }
      _createDirectiveAsts(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {
          const matchedReferences = new Set();
          let component = null;
          const directiveAsts = directives.map((directive) => {
              const sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, `Directive ${identifierName(directive.type)}`);
              if (directive.isComponent) {
                  component = directive;
              }
              const directiveProperties = [];
              const boundProperties = this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);
              let hostProperties = boundProperties.map(prop => BoundElementPropertyAst.fromBoundProperty(prop));
              // Note: We need to check the host properties here as well,
              // as we don't know the element name in the DirectiveWrapperCompiler yet.
              hostProperties = this._checkPropertiesInSchema(elementName, hostProperties);
              const parsedEvents = this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);
              this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);
              elementOrDirectiveRefs.forEach((elOrDirRef) => {
                  if ((elOrDirRef.value.length === 0 && directive.isComponent) ||
                      (elOrDirRef.isReferenceToDirective(directive))) {
                      targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));
                      matchedReferences.add(elOrDirRef.name);
                  }
              });
              const hostEvents = parsedEvents.map(e => BoundEventAst.fromParsedEvent(e));
              const contentQueryStartId = this.contentQueryStartId;
              this.contentQueryStartId += directive.queries.length;
              return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);
          });
          elementOrDirectiveRefs.forEach((elOrDirRef) => {
              if (elOrDirRef.value.length > 0) {
                  if (!matchedReferences.has(elOrDirRef.name)) {
                      this._reportError(`There is no directive with "exportAs" set to "${elOrDirRef.value}"`, elOrDirRef.sourceSpan);
                  }
              }
              else if (!component) {
                  let refToken = null;
                  if (isTemplateElement) {
                      refToken = createTokenForExternalReference(this.reflector, Identifiers.TemplateRef);
                  }
                  targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));
              }
          });
          return directiveAsts;
      }
      _createDirectivePropertyAsts(directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {
          if (directiveProperties) {
              const boundPropsByName = new Map();
              boundProps.forEach(boundProp => {
                  const prevValue = boundPropsByName.get(boundProp.name);
                  if (!prevValue || prevValue.isLiteral) {
                      // give [a]="b" a higher precedence than a="b" on the same element
                      boundPropsByName.set(boundProp.name, boundProp);
                  }
              });
              Object.keys(directiveProperties).forEach(dirProp => {
                  const elProp = directiveProperties[dirProp];
                  const boundProp = boundPropsByName.get(elProp);
                  // Bindings are optional, so this binding only needs to be set up if an expression is given.
                  if (boundProp) {
                      targetBoundDirectivePropNames.add(boundProp.name);
                      if (!isEmptyExpression(boundProp.expression)) {
                          targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));
                      }
                  }
              });
          }
      }
      _createElementPropertyAsts(elementName, props, boundDirectivePropNames) {
          const boundElementProps = [];
          props.forEach((prop) => {
              if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {
                  const boundProp = this._bindingParser.createBoundElementProperty(elementName, prop);
                  boundElementProps.push(BoundElementPropertyAst.fromBoundProperty(boundProp));
              }
          });
          return this._checkPropertiesInSchema(elementName, boundElementProps);
      }
      _findComponentDirectives(directives) {
          return directives.filter(directive => directive.directive.isComponent);
      }
      _findComponentDirectiveNames(directives) {
          return this._findComponentDirectives(directives)
              .map(directive => identifierName(directive.directive.type));
      }
      _assertOnlyOneComponent(directives, sourceSpan) {
          const componentTypeNames = this._findComponentDirectiveNames(directives);
          if (componentTypeNames.length > 1) {
              this._reportError(`More than one component matched on this element.\n` +
                  `Make sure that only one component's selector can match a given element.\n` +
                  `Conflicting components: ${componentTypeNames.join(',')}`, sourceSpan);
          }
      }
      /**
       * Make sure that non-angular tags conform to the schemas.
       *
       * Note: An element is considered an angular tag when at least one directive selector matches the
       * tag name.
       *
       * @param matchElement Whether any directive has matched on the tag name
       * @param element the html element
       */
      _assertElementExists(matchElement, element) {
          const elName = element.name.replace(/^:xhtml:/, '');
          if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {
              let errorMsg = `'${elName}' is not a known element:\n`;
              errorMsg +=
                  `1. If '${elName}' is an Angular component, then verify that it is part of this module.\n`;
              if (elName.indexOf('-') > -1) {
                  errorMsg +=
                      `2. If '${elName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;
              }
              else {
                  errorMsg +=
                      `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
              }
              this._reportError(errorMsg, element.sourceSpan);
          }
      }
      _assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, sourceSpan) {
          const componentTypeNames = this._findComponentDirectiveNames(directives);
          if (componentTypeNames.length > 0) {
              this._reportError(`Components on an embedded template: ${componentTypeNames.join(',')}`, sourceSpan);
          }
          elementProps.forEach(prop => {
              this._reportError(`Property binding ${prop.name} not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the "@NgModule.declarations".`, sourceSpan);
          });
      }
      _assertAllEventsPublishedByDirectives(directives, events) {
          const allDirectiveEvents = new Set();
          directives.forEach(directive => {
              Object.keys(directive.directive.outputs).forEach(k => {
                  const eventName = directive.directive.outputs[k];
                  allDirectiveEvents.add(eventName);
              });
          });
          events.forEach(event => {
              if (event.target != null || !allDirectiveEvents.has(event.name)) {
                  this._reportError(`Event binding ${event.fullName} not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the "@NgModule.declarations".`, event.sourceSpan);
              }
          });
      }
      _checkPropertiesInSchema(elementName, boundProps) {
          // Note: We can't filter out empty expressions before this method,
          // as we still want to validate them!
          return boundProps.filter((boundProp) => {
              if (boundProp.type === 0 /* Property */ &&
                  !this._schemaRegistry.hasProperty(elementName, boundProp.name, this._schemas)) {
                  let errorMsg = `Can't bind to '${boundProp.name}' since it isn't a known property of '${elementName}'.`;
                  if (elementName.startsWith('ng-')) {
                      errorMsg +=
                          `\n1. If '${boundProp.name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +
                              `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                  }
                  else if (elementName.indexOf('-') > -1) {
                      errorMsg +=
                          `\n1. If '${elementName}' is an Angular component and it has '${boundProp.name}' input, then verify that it is part of this module.` +
                              `\n2. If '${elementName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +
                              `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;
                  }
                  this._reportError(errorMsg, boundProp.sourceSpan);
              }
              return !isEmptyExpression(boundProp.value);
          });
      }
      _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {
          this._targetErrors.push(new ParseError(sourceSpan, message, level));
      }
  }
  class NonBindableVisitor$1 {
      visitElement(ast, parent) {
          const preparsedElement = preparseElement(ast);
          if (preparsedElement.type === PreparsedElementType.SCRIPT ||
              preparsedElement.type === PreparsedElementType.STYLE ||
              preparsedElement.type === PreparsedElementType.STYLESHEET) {
              // Skipping <script> for security reasons
              // Skipping <style> and stylesheets as we already processed them
              // in the StyleCompiler
              return null;
          }
          const attrNameAndValues = ast.attrs.map((attr) => [attr.name, attr.value]);
          const selector = createElementCssSelector(ast.name, attrNameAndValues);
          const ngContentIndex = parent.findNgContentIndex(selector);
          const children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);
          return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);
      }
      visitComment(comment, context) { return null; }
      visitAttribute(attribute, context) {
          return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);
      }
      visitText(text, parent) {
          const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());
          return new TextAst(text.value, ngContentIndex, text.sourceSpan);
      }
      visitExpansion(expansion, context) { return expansion; }
      visitExpansionCase(expansionCase, context) { return expansionCase; }
  }
  /**
   * A reference to an element or directive in a template. E.g., the reference in this template:
   *
   * <div #myMenu="coolMenu">
   *
   * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}
   */
  class ElementOrDirectiveRef {
      constructor(name, value, sourceSpan) {
          this.name = name;
          this.value = value;
          this.sourceSpan = sourceSpan;
      }
      /** Gets whether this is a reference to the given directive. */
      isReferenceToDirective(directive) {
          return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;
      }
  }
  /** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */
  function splitExportAs(exportAs) {
      return exportAs ? exportAs.split(',').map(e => e.trim()) : [];
  }
  function splitClasses(classAttrValue) {
      return classAttrValue.trim().split(/\s+/g);
  }
  class ElementContext {
      constructor(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {
          this.isTemplateElement = isTemplateElement;
          this._ngContentIndexMatcher = _ngContentIndexMatcher;
          this._wildcardNgContentIndex = _wildcardNgContentIndex;
          this.providerContext = providerContext;
      }
      static create(isTemplateElement, directives, providerContext) {
          const matcher = new SelectorMatcher();
          let wildcardNgContentIndex = null;
          const component = directives.find(directive => directive.directive.isComponent);
          if (component) {
              const ngContentSelectors = component.directive.template.ngContentSelectors;
              for (let i = 0; i < ngContentSelectors.length; i++) {
                  const selector = ngContentSelectors[i];
                  if (selector === '*') {
                      wildcardNgContentIndex = i;
                  }
                  else {
                      matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);
                  }
              }
          }
          return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);
      }
      findNgContentIndex(selector) {
          const ngContentIndices = [];
          this._ngContentIndexMatcher.match(selector, (selector, ngContentIndex) => { ngContentIndices.push(ngContentIndex); });
          ngContentIndices.sort();
          if (this._wildcardNgContentIndex != null) {
              ngContentIndices.push(this._wildcardNgContentIndex);
          }
          return ngContentIndices.length > 0 ? ngContentIndices[0] : null;
      }
  }
  function createElementCssSelector(elementName, attributes) {
      const cssSelector = new CssSelector();
      const elNameNoNs = splitNsName(elementName)[1];
      cssSelector.setElement(elNameNoNs);
      for (let i = 0; i < attributes.length; i++) {
          const attrName = attributes[i][0];
          const attrNameNoNs = splitNsName(attrName)[1];
          const attrValue = attributes[i][1];
          cssSelector.addAttribute(attrNameNoNs, attrValue);
          if (attrName.toLowerCase() == CLASS_ATTR) {
              const classes = splitClasses(attrValue);
              classes.forEach(className => cssSelector.addClassName(className));
          }
      }
      return cssSelector;
  }
  const EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);
  const NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();
  function _isEmptyTextNode(node) {
      return node instanceof Text$2 && node.value.trim().length == 0;
  }
  function removeSummaryDuplicates(items) {
      const map = new Map();
      items.forEach((item) => {
          if (!map.get(item.type.reference)) {
              map.set(item.type.reference, item);
          }
      });
      return Array.from(map.values());
  }
  function isEmptyExpression(ast) {
      if (ast instanceof ASTWithSource) {
          ast = ast.ast;
      }
      return ast instanceof EmptyExpr;
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  const CLASS_ATTR$1 = 'class';
  const STYLE_ATTR = 'style';
  const IMPLICIT_TEMPLATE_VAR = '\$implicit';
  class ViewCompileResult {
      constructor(viewClassVar, rendererTypeVar) {
          this.viewClassVar = viewClassVar;
          this.rendererTypeVar = rendererTypeVar;
      }
  }
  class ViewCompiler {
      constructor(_reflector) {
          this._reflector = _reflector;
      }
      compileComponent(outputCtx, component, template, styles, usedPipes) {
          let embeddedViewCount = 0;
          const staticQueryIds = findStaticQueryIds(template);
          let renderComponentVarName = undefined;
          if (!component.isHost) {
              const template = component.template;
              const customRenderData = [];
              if (template.animations && template.animations.length) {
                  customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, template.animations), true));
              }
              const renderComponentVar = variable(rendererTypeName(component.type.reference));
              renderComponentVarName = renderComponentVar.name;
              outputCtx.statements.push(renderComponentVar
                  .set(importExpr(Identifiers.createRendererType2).callFn([new LiteralMapExpr([
                      new LiteralMapEntry('encapsulation', literal(template.encapsulation), false),
                      new LiteralMapEntry('styles', styles, false),
                      new LiteralMapEntry('data', new LiteralMapExpr(customRenderData), false)
                  ])]))
                  .toDeclStmt(importType(Identifiers.RendererType2), [StmtModifier.Final, StmtModifier.Exported]));
          }
          const viewBuilderFactory = (parent) => {
              const embeddedViewIndex = embeddedViewCount++;
              return new ViewBuilder$1(this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory);
          };
          const visitor = viewBuilderFactory(null);
          visitor.visitAll([], template);
          outputCtx.statements.push(...visitor.build());
          return new ViewCompileResult(visitor.viewName, renderComponentVarName);
      }
  }
  const LOG_VAR$1 = variable('_l');
  const VIEW_VAR = variable('_v');
  const CHECK_VAR = variable('_ck');
  const COMP_VAR = variable('_co');
  const EVENT_NAME_VAR = variable('en');
  const ALLOW_DEFAULT_VAR = variable(`ad`);
  class ViewBuilder$1 {
      constructor(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory) {
          this.reflector = reflector;
          this.outputCtx = outputCtx;
          this.parent = parent;
          this.component = component;
          this.embeddedViewIndex = embeddedViewIndex;
          this.usedPipes = usedPipes;
          this.staticQueryIds = staticQueryIds;
          this.viewBuilderFactory = viewBuilderFactory;
          this.nodes = [];
          this.purePipeNodeIndices = Object.create(null);
          // Need Object.create so that we don't have builtin values...
          this.refNodeIndices = Object.create(null);
          this.variables = [];
          this.children = [];
          // TODO(tbosch): The old view compiler used to use an `any` type
          // for the context in any embedded view. We keep this behaivor for now
          // to be able to introduce the new view compiler without too many errors.
          this.compType = this.embeddedViewIndex > 0 ?
              DYNAMIC_TYPE :
              expressionType(outputCtx.importExpr(this.component.type.reference));
          this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);
      }
      visitAll(variables, astNodes) {
          this.variables = variables;
          // create the pipes for the pure pipes immediately, so that we know their indices.
          if (!this.parent) {
              this.usedPipes.forEach((pipe) => {
                  if (pipe.pure) {
                      this.purePipeNodeIndices[pipe.name] = this._createPipe(null, pipe);
                  }
              });
          }
          if (!this.parent) {
              const queryIds = staticViewQueryIds(this.staticQueryIds);
              this.component.viewQueries.forEach((query, queryIndex) => {
                  // Note: queries start with id 1 so we can use the number in a Bloom filter!
                  const queryId = queryIndex + 1;
                  const bindingType = query.first ? 0 /* First */ : 1 /* All */;
                  const flags = 134217728 /* TypeViewQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);
                  this.nodes.push(() => ({
                      sourceSpan: null,
                      nodeFlags: flags,
                      nodeDef: importExpr(Identifiers.queryDef).callFn([
                          literal(flags), literal(queryId),
                          new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])
                      ])
                  }));
              });
          }
          templateVisitAll(this, astNodes);
          if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {
              // if the view is an embedded view, then we need to add an additional root node in some cases
              this.nodes.push(() => ({
                  sourceSpan: null,
                  nodeFlags: 1 /* TypeElement */,
                  nodeDef: importExpr(Identifiers.anchorDef).callFn([
                      literal(0 /* None */), NULL_EXPR, NULL_EXPR, literal(0)
                  ])
              }));
          }
      }
      build(targetStatements = []) {
          this.children.forEach((child) => child.build(targetStatements));
          const { updateRendererStmts, updateDirectivesStmts, nodeDefExprs } = this._createNodeExpressions();
          const updateRendererFn = this._createUpdateFn(updateRendererStmts);
          const updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);
          let viewFlags = 0 /* None */;
          if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {
              viewFlags |= 2 /* OnPush */;
          }
          const viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(LOG_VAR$1.name)], [new ReturnStatement(importExpr(Identifiers.viewDef).callFn([
                  literal(viewFlags),
                  literalArr(nodeDefExprs),
                  updateDirectivesFn,
                  updateRendererFn,
              ]))], importType(Identifiers.ViewDefinition), this.embeddedViewIndex === 0 ? [StmtModifier.Exported] : []);
          targetStatements.push(viewFactory);
          return targetStatements;
      }
      _createUpdateFn(updateStmts) {
          let updateFn;
          if (updateStmts.length > 0) {
              const preStmts = [];
              if (!this.component.isHost && findReadVarNames(updateStmts).has(COMP_VAR.name)) {
                  preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));
              }
              updateFn = fn([
                  new FnParam(CHECK_VAR.name, INFERRED_TYPE),
                  new FnParam(VIEW_VAR.name, INFERRED_TYPE)
              ], [...preStmts, ...updateStmts], INFERRED_TYPE);
          }
          else {
              updateFn = NULL_EXPR;
          }
          return updateFn;
      }
      visitNgContent(ast, context) {
          // ngContentDef(ngContentIndex: number, index: number): NodeDef;
          this.nodes.push(() => ({
              sourceSpan: ast.sourceSpan,
              nodeFlags: 8 /* TypeNgContent */,
              nodeDef: importExpr(Identifiers.ngContentDef).callFn([
                  literal(ast.ngContentIndex), literal(ast.index)
              ])
          }));
      }
      visitText(ast, context) {
          // Static text nodes have no check function
          const checkIndex = -1;
          this.nodes.push(() => ({
              sourceSpan: ast.sourceSpan,
              nodeFlags: 2 /* TypeText */,
              nodeDef: importExpr(Identifiers.textDef).callFn([
                  literal(checkIndex),
                  literal(ast.ngContentIndex),
                  literalArr([literal(ast.value)]),
              ])
          }));
      }
      visitBoundText(ast, context) {
          const nodeIndex = this.nodes.length;
          // reserve the space in the nodeDefs array
          this.nodes.push(null);
          const astWithSource = ast.value;
          const inter = astWithSource.ast;
          const updateRendererExpressions = inter.expressions.map((expr, bindingIndex) => this._preprocessUpdateExpression({ nodeIndex, bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }));
          // Check index is the same as the node index during compilation
          // They might only differ at runtime
          const checkIndex = nodeIndex;
          this.nodes[nodeIndex] = () => ({
              sourceSpan: ast.sourceSpan,
              nodeFlags: 2 /* TypeText */,
              nodeDef: importExpr(Identifiers.textDef).callFn([
                  literal(checkIndex),
                  literal(ast.ngContentIndex),
                  literalArr(inter.strings.map(s => literal(s))),
              ]),
              updateRenderer: updateRendererExpressions
          });
      }
      visitEmbeddedTemplate(ast, context) {
          const nodeIndex = this.nodes.length;
          // reserve the space in the nodeDefs array
          this.nodes.push(null);
          const { flags, queryMatchesExpr, hostEvents } = this._visitElementOrTemplate(nodeIndex, ast);
          const childVisitor = this.viewBuilderFactory(this);
          this.children.push(childVisitor);
          childVisitor.visitAll(ast.variables, ast.children);
          const childCount = this.nodes.length - nodeIndex - 1;
          // anchorDef(
          //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,
          //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:
          //   ViewDefinitionFactory): NodeDef;
          this.nodes[nodeIndex] = () => ({
              sourceSpan: ast.sourceSpan,
              nodeFlags: 1 /* TypeElement */ | flags,
              nodeDef: importExpr(Identifiers.anchorDef).callFn([
                  literal(flags),
                  queryMatchesExpr,
                  literal(ast.ngContentIndex),
                  literal(childCount),
                  this._createElementHandleEventFn(nodeIndex, hostEvents),
                  variable(childVisitor.viewName),
              ])
          });
      }
      visitElement(ast, context) {
          const nodeIndex = this.nodes.length;
          // reserve the space in the nodeDefs array so we can add children
          this.nodes.push(null);
          // Using a null element name creates an anchor.
          const elName = isNgContainer(ast.name) ? null : ast.name;
          const { flags, usedEvents, queryMatchesExpr, hostBindings: dirHostBindings, hostEvents } = this._visitElementOrTemplate(nodeIndex, ast);
          let inputDefs = [];
          let updateRendererExpressions = [];
          let outputDefs = [];
          if (elName) {
              const hostBindings = ast.inputs
                  .map((inputAst) => ({
                  context: COMP_VAR,
                  inputAst,
                  dirAst: null,
              }))
                  .concat(dirHostBindings);
              if (hostBindings.length) {
                  updateRendererExpressions =
                      hostBindings.map((hostBinding, bindingIndex) => this._preprocessUpdateExpression({
                          context: hostBinding.context,
                          nodeIndex,
                          bindingIndex,
                          sourceSpan: hostBinding.inputAst.sourceSpan,
                          value: hostBinding.inputAst.value
                      }));
                  inputDefs = hostBindings.map(hostBinding => elementBindingDef(hostBinding.inputAst, hostBinding.dirAst));
              }
              outputDefs = usedEvents.map(([target, eventName]) => literalArr([literal(target), literal(eventName)]));
          }
          templateVisitAll(this, ast.children);
          const childCount = this.nodes.length - nodeIndex - 1;
          const compAst = ast.directives.find(dirAst => dirAst.directive.isComponent);
          let compRendererType = NULL_EXPR;
          let compView = NULL_EXPR;
          if (compAst) {
              compView = this.outputCtx.importExpr(compAst.directive.componentViewType);
              compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);
          }
          // Check index is the same as the node index during compilation
          // They might only differ at runtime
          const checkIndex = nodeIndex;
          this.nodes[nodeIndex] = () => ({
              sourceSpan: ast.sourceSpan,
              nodeFlags: 1 /* TypeElement */ | flags,
              nodeDef: importExpr(Identifiers.elementDef).callFn([
                  literal(checkIndex),
                  literal(flags),
                  queryMatchesExpr,
                  literal(ast.ngContentIndex),
                  literal(childCount),
                  literal(elName),
                  elName ? fixedAttrsDef(ast) : NULL_EXPR,
                  inputDefs.length ? literalArr(inputDefs) : NULL_EXPR,
                  outputDefs.length ? literalArr(outputDefs) : NULL_EXPR,
                  this._createElementHandleEventFn(nodeIndex, hostEvents),
                  compView,
                  compRendererType,
              ]),
              updateRenderer: updateRendererExpressions
          });
      }
      _visitElementOrTemplate(nodeIndex, ast) {
          let flags = 0 /* None */;
          if (ast.hasViewContainer) {
              flags |= 16777216 /* EmbeddedViews */;
          }
          const usedEvents = new Map();
          ast.outputs.forEach((event) => {
              const { name, target } = elementEventNameAndTarget(event, null);
              usedEvents.set(elementEventFullName(target, name), [target, name]);
          });
          ast.directives.forEach((dirAst) => {
              dirAst.hostEvents.forEach((event) => {
                  const { name, target } = elementEventNameAndTarget(event, dirAst);
                  usedEvents.set(elementEventFullName(target, name), [target, name]);
              });
          });
          const hostBindings = [];
          const hostEvents = [];
          this._visitComponentFactoryResolverProvider(ast.directives);
          ast.providers.forEach((providerAst, providerIndex) => {
              let dirAst = undefined;
              let dirIndex = undefined;
              ast.directives.forEach((localDirAst, i) => {
                  if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {
                      dirAst = localDirAst;
                      dirIndex = i;
                  }
              });
              if (dirAst) {
                  const { hostBindings: dirHostBindings, hostEvents: dirHostEvents } = this._visitDirective(providerAst, dirAst, dirIndex, nodeIndex, ast.references, ast.queryMatches, usedEvents, this.staticQueryIds.get(ast));
                  hostBindings.push(...dirHostBindings);
                  hostEvents.push(...dirHostEvents);
              }
              else {
                  this._visitProvider(providerAst, ast.queryMatches);
              }
          });
          let queryMatchExprs = [];
          ast.queryMatches.forEach((match) => {
              let valueType = undefined;
              if (tokenReference(match.value) ===
                  this.reflector.resolveExternalReference(Identifiers.ElementRef)) {
                  valueType = 0 /* ElementRef */;
              }
              else if (tokenReference(match.value) ===
                  this.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {
                  valueType = 3 /* ViewContainerRef */;
              }
              else if (tokenReference(match.value) ===
                  this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
                  valueType = 2 /* TemplateRef */;
              }
              if (valueType != null) {
                  queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));
              }
          });
          ast.references.forEach((ref) => {
              let valueType = undefined;
              if (!ref.value) {
                  valueType = 1 /* RenderElement */;
              }
              else if (tokenReference(ref.value) ===
                  this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {
                  valueType = 2 /* TemplateRef */;
              }
              if (valueType != null) {
                  this.refNodeIndices[ref.name] = nodeIndex;
                  queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));
              }
          });
          ast.outputs.forEach((outputAst) => {
              hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: null });
          });
          return {
              flags,
              usedEvents: Array.from(usedEvents.values()),
              queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,
              hostBindings,
              hostEvents: hostEvents
          };
      }
      _visitDirective(providerAst, dirAst, directiveIndex, elementNodeIndex, refs, queryMatches, usedEvents, queryIds) {
          const nodeIndex = this.nodes.length;
          // reserve the space in the nodeDefs array so we can add children
          this.nodes.push(null);
          dirAst.directive.queries.forEach((query, queryIndex) => {
              const queryId = dirAst.contentQueryStartId + queryIndex;
              const flags = 67108864 /* TypeContentQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);
              const bindingType = query.first ? 0 /* First */ : 1 /* All */;
              this.nodes.push(() => ({
                  sourceSpan: dirAst.sourceSpan,
                  nodeFlags: flags,
                  nodeDef: importExpr(Identifiers.queryDef).callFn([
                      literal(flags), literal(queryId),
                      new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])
                  ]),
              }));
          });
          // Note: the operation below might also create new nodeDefs,
          // but we don't want them to be a child of a directive,
          // as they might be a provider/pipe on their own.
          // I.e. we only allow queries as children of directives nodes.
          const childCount = this.nodes.length - nodeIndex - 1;
          let { flags, queryMatchExprs, providerExpr, depsExpr } = this._visitProviderOrDirective(providerAst, queryMatches);
          refs.forEach((ref) => {
              if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {
                  this.refNodeIndices[ref.name] = nodeIndex;
                  queryMatchExprs.push(literalArr([literal(ref.name), literal(4 /* Provider */)]));
              }
          });
          if (dirAst.directive.isComponent) {
              flags |= 32768 /* Component */;
          }
          const inputDefs = dirAst.inputs.map((inputAst, inputIndex) => {
              const mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);
              // Note: it's important to not quote the key so that we can capture renames by minifiers!
              return new LiteralMapEntry(inputAst.directiveName, mapValue, false);
          });
          const outputDefs = [];
          const dirMeta = dirAst.directive;
          Object.keys(dirMeta.outputs).forEach((propName) => {
              const eventName = dirMeta.outputs[propName];
              if (usedEvents.has(eventName)) {
                  // Note: it's important to not quote the key so that we can capture renames by minifiers!
                  outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));
              }
          });
          let updateDirectiveExpressions = [];
          if (dirAst.inputs.length || (flags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0) {
              updateDirectiveExpressions =
                  dirAst.inputs.map((input, bindingIndex) => this._preprocessUpdateExpression({
                      nodeIndex,
                      bindingIndex,
                      sourceSpan: input.sourceSpan,
                      context: COMP_VAR,
                      value: input.value
                  }));
          }
          const dirContextExpr = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);
          const hostBindings = dirAst.hostProperties.map((inputAst) => ({
              context: dirContextExpr,
              dirAst,
              inputAst,
          }));
          const hostEvents = dirAst.hostEvents.map((hostEventAst) => ({
              context: dirContextExpr,
              eventAst: hostEventAst, dirAst,
          }));
          // Check index is the same as the node index during compilation
          // They might only differ at runtime
          const checkIndex = nodeIndex;
          this.nodes[nodeIndex] = () => ({
              sourceSpan: dirAst.sourceSpan,
              nodeFlags: 16384 /* TypeDirective */ | flags,
              nodeDef: importExpr(Identifiers.directiveDef).callFn([
                  literal(checkIndex),
                  literal(flags),
                  queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,
                  literal(childCount),
                  providerExpr,
                  depsExpr,
                  inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR,
                  outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR,
              ]),
              updateDirectives: updateDirectiveExpressions,
              directive: dirAst.directive.type,
          });
          return { hostBindings, hostEvents };
      }
      _visitProvider(providerAst, queryMatches) {
          this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));
      }
      _visitComponentFactoryResolverProvider(directives) {
          const componentDirMeta = directives.find(dirAst => dirAst.directive.isComponent);
          if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {
              const { providerExpr, depsExpr, flags, tokenExpr } = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192 /* PrivateProvider */, componentDirMeta.directive.entryComponents);
              this._addProviderNode({
                  providerExpr,
                  depsExpr,
                  flags,
                  tokenExpr,
                  queryMatchExprs: [],
                  sourceSpan: componentDirMeta.sourceSpan
              });
          }
      }
      _addProviderNode(data) {
          const nodeIndex = this.nodes.length;
          // providerDef(
          //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,
          //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;
          this.nodes.push(() => ({
              sourceSpan: data.sourceSpan,
              nodeFlags: data.flags,
              nodeDef: importExpr(Identifiers.providerDef).callFn([
                  literal(data.flags),
                  data.queryMatchExprs.length ? literalArr(data.queryMatchExprs) : NULL_EXPR,
                  data.tokenExpr, data.providerExpr, data.depsExpr
              ])
          }));
      }
      _visitProviderOrDirective(providerAst, queryMatches) {
          let flags = 0 /* None */;
          let queryMatchExprs = [];
          queryMatches.forEach((match) => {
              if (tokenReference(match.value) === tokenReference(providerAst.token)) {
                  queryMatchExprs.push(literalArr([literal(match.queryId), literal(4 /* Provider */)]));
              }
          });
          const { providerExpr, depsExpr, flags: providerFlags, tokenExpr } = providerDef(this.outputCtx, providerAst);
          return {
              flags: flags | providerFlags,
              queryMatchExprs,
              providerExpr,
              depsExpr,
              tokenExpr,
              sourceSpan: providerAst.sourceSpan
          };
      }
      getLocal(name) {
          if (name == EventHandlerVars.event.name) {
              return EventHandlerVars.event;
          }
          let currViewExpr = VIEW_VAR;
          for (let currBuilder = this; currBuilder; currBuilder = currBuilder.parent, currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {
              // check references
              const refNodeIndex = currBuilder.refNodeIndices[name];
              if (refNodeIndex != null) {
                  return importExpr(Identifiers.nodeValue).callFn([currViewExpr, literal(refNodeIndex)]);
              }
              // check variables
              const varAst = currBuilder.variables.find((varAst) => varAst.name === name);
              if (varAst) {
                  const varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;
                  return currViewExpr.prop('context').prop(varValue);
              }
          }
          return null;
      }
      _createLiteralArrayConverter(sourceSpan, argCount) {
          if (argCount === 0) {
              const valueExpr = importExpr(Identifiers.EMPTY_ARRAY);
              return () => valueExpr;
          }
          const checkIndex = this.nodes.length;
          this.nodes.push(() => ({
              sourceSpan,
              nodeFlags: 32 /* TypePureArray */,
              nodeDef: importExpr(Identifiers.pureArrayDef).callFn([
                  literal(checkIndex),
                  literal(argCount),
              ])
          }));
          return (args) => callCheckStmt(checkIndex, args);
      }
      _createLiteralMapConverter(sourceSpan, keys) {
          if (keys.length === 0) {
              const valueExpr = importExpr(Identifiers.EMPTY_MAP);
              return () => valueExpr;
          }
          const map = literalMap(keys.map((e, i) => (Object.assign({}, e, { value: literal(i) }))));
          const checkIndex = this.nodes.length;
          this.nodes.push(() => ({
              sourceSpan,
              nodeFlags: 64 /* TypePureObject */,
              nodeDef: importExpr(Identifiers.pureObjectDef).callFn([
                  literal(checkIndex),
                  map,
              ])
          }));
          return (args) => callCheckStmt(checkIndex, args);
      }
      _createPipeConverter(expression, name, argCount) {
          const pipe = this.usedPipes.find((pipeSummary) => pipeSummary.name === name);
          if (pipe.pure) {
              const checkIndex = this.nodes.length;
              this.nodes.push(() => ({
                  sourceSpan: expression.sourceSpan,
                  nodeFlags: 128 /* TypePurePipe */,
                  nodeDef: importExpr(Identifiers.purePipeDef).callFn([
                      literal(checkIndex),
                      literal(argCount),
                  ])
              }));
              // find underlying pipe in the component view
              let compViewExpr = VIEW_VAR;
              let compBuilder = this;
              while (compBuilder.parent) {
                  compBuilder = compBuilder.parent;
                  compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);
              }
              const pipeNodeIndex = compBuilder.purePipeNodeIndices[name];
              const pipeValueExpr = importExpr(Identifiers.nodeValue).callFn([compViewExpr, literal(pipeNodeIndex)]);
              return (args) => callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(checkIndex, [pipeValueExpr].concat(args)));
          }
          else {
              const nodeIndex = this._createPipe(expression.sourceSpan, pipe);
              const nodeValueExpr = importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);
              return (args) => callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr.callMethod('transform', args));
          }
      }
      _createPipe(sourceSpan, pipe) {
          const nodeIndex = this.nodes.length;
          let flags = 0 /* None */;
          pipe.type.lifecycleHooks.forEach((lifecycleHook) => {
              // for pipes, we only support ngOnDestroy
              if (lifecycleHook === LifecycleHooks.OnDestroy) {
                  flags |= lifecycleHookToNodeFlag(lifecycleHook);
              }
          });
          const depExprs = pipe.type.diDeps.map((diDep) => depDef(this.outputCtx, diDep));
          // function pipeDef(
          //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef
          this.nodes.push(() => ({
              sourceSpan,
              nodeFlags: 16 /* TypePipe */,
              nodeDef: importExpr(Identifiers.pipeDef).callFn([
                  literal(flags), this.outputCtx.importExpr(pipe.type.reference), literalArr(depExprs)
              ])
          }));
          return nodeIndex;
      }
      /**
       * For the AST in `UpdateExpression.value`:
       * - create nodes for pipes, literal arrays and, literal maps,
       * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.
       *
       * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!
       */
      _preprocessUpdateExpression(expression) {
          return {
              nodeIndex: expression.nodeIndex,
              bindingIndex: expression.bindingIndex,
              sourceSpan: expression.sourceSpan,
              context: expression.context,
              value: convertPropertyBindingBuiltins({
                  createLiteralArrayConverter: (argCount) => this._createLiteralArrayConverter(expression.sourceSpan, argCount),
                  createLiteralMapConverter: (keys) => this._createLiteralMapConverter(expression.sourceSpan, keys),
                  createPipeConverter: (name, argCount) => this._createPipeConverter(expression, name, argCount)
              }, expression.value)
          };
      }
      _createNodeExpressions() {
          const self = this;
          let updateBindingCount = 0;
          const updateRendererStmts = [];
          const updateDirectivesStmts = [];
          const nodeDefExprs = this.nodes.map((factory, nodeIndex) => {
              const { nodeDef, nodeFlags, updateDirectives, updateRenderer, sourceSpan } = factory();
              if (updateRenderer) {
                  updateRendererStmts.push(...createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));
              }
              if (updateDirectives) {
                  updateDirectivesStmts.push(...createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0));
              }
              // We use a comma expression to call the log function before
              // the nodeDef function, but still use the result of the nodeDef function
              // as the value.
              // Note: We only add the logger to elements / text nodes,
              // so we don't generate too much code.
              const logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?
                  new CommaExpr([LOG_VAR$1.callFn([]).callFn([]), nodeDef]) :
                  nodeDef;
              return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);
          });
          return { updateRendererStmts, updateDirectivesStmts, nodeDefExprs };
          function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {
              const updateStmts = [];
              const exprs = expressions.map(({ sourceSpan, context, value }) => {
                  const bindingId = `${updateBindingCount++}`;
                  const nameResolver = context === COMP_VAR ? self : null;
                  const { stmts, currValExpr } = convertPropertyBinding(nameResolver, context, value, bindingId, BindingForm.General);
                  updateStmts.push(...stmts.map((stmt) => applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));
                  return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);
              });
              if (expressions.length || allowEmptyExprs) {
                  updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));
              }
              return updateStmts;
          }
      }
      _createElementHandleEventFn(nodeIndex, handlers) {
          const handleEventStmts = [];
          let handleEventBindingCount = 0;
          handlers.forEach(({ context, eventAst, dirAst }) => {
              const bindingId = `${handleEventBindingCount++}`;
              const nameResolver = context === COMP_VAR ? this : null;
              const { stmts, allowDefault } = convertActionBinding(nameResolver, context, eventAst.handler, bindingId);
              const trueStmts = stmts;
              if (allowDefault) {
                  trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());
              }
              const { target: eventTarget, name: eventName } = elementEventNameAndTarget(eventAst, dirAst);
              const fullEventName = elementEventFullName(eventTarget, eventName);
              handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));
          });
          let handleEventFn;
          if (handleEventStmts.length > 0) {
              const preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];
              if (!this.component.isHost && findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {
                  preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));
              }
              handleEventFn = fn([
                  new FnParam(VIEW_VAR.name, INFERRED_TYPE),
                  new FnParam(EVENT_NAME_VAR.name, INFERRED_TYPE),
                  new FnParam(EventHandlerVars.event.name, INFERRED_TYPE)
              ], [...preStmts, ...handleEventStmts, new ReturnStatement(ALLOW_DEFAULT_VAR)], INFERRED_TYPE);
          }
          else {
              handleEventFn = NULL_EXPR;
          }
          return handleEventFn;
      }
      visitDirective(ast, context) { }
      visitDirectiveProperty(ast, context) { }
      visitReference(ast, context) { }
      visitVariable(ast, context) { }
      visitEvent(ast, context) { }
      visitElementProperty(ast, context) { }
      visitAttr(ast, context) { }
  }
  function needsAdditionalRootNode(astNodes) {
      const lastAstNode = astNodes[astNodes.length - 1];
      if (lastAstNode instanceof EmbeddedTemplateAst) {
          return lastAstNode.hasViewContainer;
      }
      if (lastAstNode instanceof ElementAst) {
          if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {
              return needsAdditionalRootNode(lastAstNode.children);
          }
          return lastAstNode.hasViewContainer;
      }
      return lastAstNode instanceof NgContentAst;
  }
  function elementBindingDef(inputAst, dirAst) {
      const inputType = inputAst.type;
      switch (inputType) {
          case 1 /* Attribute */:
              return literalArr([
                  literal(1 /* TypeElementAttribute */), literal(inputAst.name),
                  literal(inputAst.securityContext)
              ]);
          case 0 /* Property */:
              return literalArr([
                  literal(8 /* TypeProperty */), literal(inputAst.name),
                  literal(inputAst.securityContext)
              ]);
          case 4 /* Animation */:
              const bindingType = 8 /* TypeProperty */ |
                  (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :
                      16 /* SyntheticProperty */);
              return literalArr([
                  literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)
              ]);
          case 2 /* Class */:
              return literalArr([literal(2 /* TypeElementClass */), literal(inputAst.name), NULL_EXPR]);
          case 3 /* Style */:
              return literalArr([
                  literal(4 /* TypeElementStyle */), literal(inputAst.name), literal(inputAst.unit)
              ]);
          default:
              // This default case is not needed by TypeScript compiler, as the switch is exhaustive.
              // However Closure Compiler does not understand that and reports an error in typed mode.
              // The `throw new Error` below works around the problem, and the unexpected: never variable
              // makes sure tsc still checks this code is unreachable.
              const unexpected = inputType;
              throw new Error(`unexpected ${unexpected}`);
      }
  }
  function fixedAttrsDef(elementAst) {
      const mapResult = Object.create(null);
      elementAst.attrs.forEach(attrAst => { mapResult[attrAst.name] = attrAst.value; });
      elementAst.directives.forEach(dirAst => {
          Object.keys(dirAst.directive.hostAttributes).forEach(name => {
              const value = dirAst.directive.hostAttributes[name];
              const prevValue = mapResult[name];
              mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;
          });
      });
      // Note: We need to sort to get a defined output order
      // for tests and for caching generated artifacts...
      return literalArr(Object.keys(mapResult).sort().map((attrName) => literalArr([literal(attrName), literal(mapResult[attrName])])));
  }
  function mergeAttributeValue(attrName, attrValue1, attrValue2) {
      if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {
          return `${attrValue1} ${attrValue2}`;
      }
      else {
          return attrValue2;
      }
  }
  function callCheckStmt(nodeIndex, exprs) {
      if (exprs.length > 10) {
          return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1 /* Dynamic */), literalArr(exprs)]);
      }
      else {
          return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0 /* Inline */), ...exprs]);
      }
  }
  function callUnwrapValue(nodeIndex, bindingIdx, expr) {
      return importExpr(Identifiers.unwrapValue).callFn([
          VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr
      ]);
  }
  function findStaticQueryIds(nodes, result = new Map()) {
      nodes.forEach((node) => {
          const staticQueryIds = new Set();
          const dynamicQueryIds = new Set();
          let queryMatches = undefined;
          if (node instanceof ElementAst) {
              findStaticQueryIds(node.children, result);
              node.children.forEach((child) => {
                  const childData = result.get(child);
                  childData.staticQueryIds.forEach(queryId => staticQueryIds.add(queryId));
                  childData.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));
              });
              queryMatches = node.queryMatches;
          }
          else if (node instanceof EmbeddedTemplateAst) {
              findStaticQueryIds(node.children, result);
              node.children.forEach((child) => {
                  const childData = result.get(child);
                  childData.staticQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));
                  childData.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));
              });
              queryMatches = node.queryMatches;
          }
          if (queryMatches) {
              queryMatches.forEach((match) => staticQueryIds.add(match.queryId));
          }
          dynamicQueryIds.forEach(queryId => staticQueryIds.delete(queryId));
          result.set(node, { staticQueryIds, dynamicQueryIds });
      });
      return result;
  }
  function staticViewQueryIds(nodeStaticQueryIds) {
      const staticQueryIds = new Set();
      const dynamicQueryIds = new Set();
      Array.from(nodeStaticQueryIds.values()).forEach((entry) => {
          entry.staticQueryIds.forEach(queryId => staticQueryIds.add(queryId));
          entry.dynamicQueryIds.forEach(queryId => dynamicQueryIds.add(queryId));
      });
      dynamicQueryIds.forEach(queryId => staticQueryIds.delete(queryId));
      return { staticQueryIds, dynamicQueryIds };
  }
  function elementEventNameAndTarget(eventAst, dirAst) {
      if (eventAst.isAnimation) {
          return {
              name: `@${eventAst.name}.${eventAst.phase}`,
              target: dirAst && dirAst.directive.isComponent ? 'component' : null
          };
      }
      else {
          return eventAst;
      }
  }
  function calcStaticDynamicQueryFlags(queryIds, queryId, isFirst) {
      let flags = 0 /* None */;
      // Note: We only make queries static that query for a single item.
      // This is because of backwards compatibility with the old view compiler...
      if (isFirst && (queryIds.staticQueryIds.has(queryId) || !queryIds.dynamicQueryIds.has(queryId))) {
          flags |= 268435456 /* StaticQuery */;
      }
      else {
          flags |= 536870912 /* DynamicQuery */;
      }
      return flags;
  }
  function elementEventFullName(target, name) {
      return target ? `${target}:${name}` : name;
  }

  class SummaryResolver {
  }
  class JitSummaryResolver {
      constructor() {
          this._summaries = new Map();
      }
      isLibraryFile() { return false; }
      toSummaryFileName(fileName) { return fileName; }
      fromSummaryFileName(fileName) { return fileName; }
      resolveSummary(reference) {
          return this._summaries.get(reference) || null;
      }
      getSymbolsOf() { return []; }
      getImportAs(reference) { return reference; }
      getKnownModuleName(fileName) { return null; }
      addSummary(summary) { this._summaries.set(summary.symbol, summary); }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  function interpretStatements(statements, reflector) {
      const ctx = new _ExecutionContext(null, null, null, new Map());
      const visitor = new StatementInterpreter(reflector);
      visitor.visitAllStatements(statements, ctx);
      const result = {};
      ctx.exports.forEach((exportName) => { result[exportName] = ctx.vars.get(exportName); });
      return result;
  }
  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {
      const childCtx = ctx.createChildWihtLocalVars();
      for (let i = 0; i < varNames.length; i++) {
          childCtx.vars.set(varNames[i], varValues[i]);
      }
      const result = visitor.visitAllStatements(statements, childCtx);
      return result ? result.value : null;
  }
  class _ExecutionContext {
      constructor(parent, instance, className, vars) {
          this.parent = parent;
          this.instance = instance;
          this.className = className;
          this.vars = vars;
          this.exports = [];
      }
      createChildWihtLocalVars() {
          return new _ExecutionContext(this, this.instance, this.className, new Map());
      }
  }
  class ReturnValue {
      constructor(value) {
          this.value = value;
      }
  }
  function createDynamicClass(_classStmt, _ctx, _visitor) {
      const propertyDescriptors = {};
      _classStmt.getters.forEach((getter) => {
          // Note: use `function` instead of arrow function to capture `this`
          propertyDescriptors[getter.name] = {
              configurable: false,
              get: function () {
                  const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
                  return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);
              }
          };
      });
      _classStmt.methods.forEach(function (method) {
          const paramNames = method.params.map(param => param.name);
          // Note: use `function` instead of arrow function to capture `this`
          propertyDescriptors[method.name] = {
              writable: false,
              configurable: false,
              value: function (...args) {
                  const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
                  return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);
              }
          };
      });
      const ctorParamNames = _classStmt.constructorMethod.params.map(param => param.name);
      // Note: use `function` instead of arrow function to capture `this`
      const ctor = function (...args) {
          const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);
          _classStmt.fields.forEach((field) => { this[field.name] = undefined; });
          _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);
      };
      const superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;
      ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);
      return ctor;
  }
  class StatementInterpreter {
      constructor(reflector) {
          this.reflector = reflector;
      }
      debugAst(ast) { return debugOutputAstAsTypeScript(ast); }
      visitDeclareVarStmt(stmt, ctx) {
          const initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;
          ctx.vars.set(stmt.name, initialValue);
          if (stmt.hasModifier(StmtModifier.Exported)) {
              ctx.exports.push(stmt.name);
          }
          return null;
      }
      visitWriteVarExpr(expr, ctx) {
          const value = expr.value.visitExpression(this, ctx);
          let currCtx = ctx;
          while (currCtx != null) {
              if (currCtx.vars.has(expr.name)) {
                  currCtx.vars.set(expr.name, value);
                  return value;
              }
              currCtx = currCtx.parent;
          }
          throw new Error(`Not declared variable ${expr.name}`);
      }
      visitWrappedNodeExpr(ast, ctx) {
          throw new Error('Cannot interpret a WrappedNodeExpr.');
      }
      visitTypeofExpr(ast, ctx) {
          throw new Error('Cannot interpret a TypeofExpr');
      }
      visitReadVarExpr(ast, ctx) {
          let varName = ast.name;
          if (ast.builtin != null) {
              switch (ast.builtin) {
                  case BuiltinVar.Super:
                      return ctx.instance.__proto__;
                  case BuiltinVar.This:
                      return ctx.instance;
                  case BuiltinVar.CatchError:
                      varName = CATCH_ERROR_VAR$2;
                      break;
                  case BuiltinVar.CatchStack:
                      varName = CATCH_STACK_VAR$2;
                      break;
                  default:
                      throw new Error(`Unknown builtin variable ${ast.builtin}`);
              }
          }
          let currCtx = ctx;
          while (currCtx != null) {
              if (currCtx.vars.has(varName)) {
                  return currCtx.vars.get(varName);
              }
              currCtx = currCtx.parent;
          }
          throw new Error(`Not declared variable ${varName}`);
      }
      visitWriteKeyExpr(expr, ctx) {
          const receiver = expr.receiver.visitExpression(this, ctx);
          const index = expr.index.visitExpression(this, ctx);
          const value = expr.value.visitExpression(this, ctx);
          receiver[index] = value;
          return value;
      }
      visitWritePropExpr(expr, ctx) {
          const receiver = expr.receiver.visitExpression(this, ctx);
          const value = expr.value.visitExpression(this, ctx);
          receiver[expr.name] = value;
          return value;
      }
      visitInvokeMethodExpr(expr, ctx) {
          const receiver = expr.receiver.visitExpression(this, ctx);
          const args = this.visitAllExpressions(expr.args, ctx);
          let result;
          if (expr.builtin != null) {
              switch (expr.builtin) {
                  case BuiltinMethod.ConcatArray:
                      result = receiver.concat(...args);
                      break;
                  case BuiltinMethod.SubscribeObservable:
                      result = receiver.subscribe({ next: args[0] });
                      break;
                  case BuiltinMethod.Bind:
                      result = receiver.bind(...args);
                      break;
                  default:
                      throw new Error(`Unknown builtin method ${expr.builtin}`);
              }
          }
          else {
              result = receiver[expr.name].apply(receiver, args);
          }
          return result;
      }
      visitInvokeFunctionExpr(stmt, ctx) {
          const args = this.visitAllExpressions(stmt.args, ctx);
          const fnExpr = stmt.fn;
          if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {
              ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);
              return null;
          }
          else {
              const fn$$1 = stmt.fn.visitExpression(this, ctx);
              return fn$$1.apply(null, args);
          }
      }
      visitReturnStmt(stmt, ctx) {
          return new ReturnValue(stmt.value.visitExpression(this, ctx));
      }
      visitDeclareClassStmt(stmt, ctx) {
          const clazz = createDynamicClass(stmt, ctx, this);
          ctx.vars.set(stmt.name, clazz);
          if (stmt.hasModifier(StmtModifier.Exported)) {
              ctx.exports.push(stmt.name);
          }
          return null;
      }
      visitExpressionStmt(stmt, ctx) {
          return stmt.expr.visitExpression(this, ctx);
      }
      visitIfStmt(stmt, ctx) {
          const condition = stmt.condition.visitExpression(this, ctx);
          if (condition) {
              return this.visitAllStatements(stmt.trueCase, ctx);
          }
          else if (stmt.falseCase != null) {
              return this.visitAllStatements(stmt.falseCase, ctx);
          }
          return null;
      }
      visitTryCatchStmt(stmt, ctx) {
          try {
              return this.visitAllStatements(stmt.bodyStmts, ctx);
          }
          catch (e) {
              const childCtx = ctx.createChildWihtLocalVars();
              childCtx.vars.set(CATCH_ERROR_VAR$2, e);
              childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);
              return this.visitAllStatements(stmt.catchStmts, childCtx);
          }
      }
      visitThrowStmt(stmt, ctx) {
          throw stmt.error.visitExpression(this, ctx);
      }
      visitCommentStmt(stmt, context) { return null; }
      visitJSDocCommentStmt(stmt, context) { return null; }
      visitInstantiateExpr(ast, ctx) {
          const args = this.visitAllExpressions(ast.args, ctx);
          const clazz = ast.classExpr.visitExpression(this, ctx);
          return new clazz(...args);
      }
      visitLiteralExpr(ast, ctx) { return ast.value; }
      visitExternalExpr(ast, ctx) {
          return this.reflector.resolveExternalReference(ast.value);
      }
      visitConditionalExpr(ast, ctx) {
          if (ast.condition.visitExpression(this, ctx)) {
              return ast.trueCase.visitExpression(this, ctx);
          }
          else if (ast.falseCase != null) {
              return ast.falseCase.visitExpression(this, ctx);
          }
          return null;
      }
      visitNotExpr(ast, ctx) {
          return !ast.condition.visitExpression(this, ctx);
      }
      visitAssertNotNullExpr(ast, ctx) {
          return ast.condition.visitExpression(this, ctx);
      }
      visitCastExpr(ast, ctx) {
          return ast.value.visitExpression(this, ctx);
      }
      visitFunctionExpr(ast, ctx) {
          const paramNames = ast.params.map((param) => param.name);
          return _declareFn(paramNames, ast.statements, ctx, this);
      }
      visitDeclareFunctionStmt(stmt, ctx) {
          const paramNames = stmt.params.map((param) => param.name);
          ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));
          if (stmt.hasModifier(StmtModifier.Exported)) {
              ctx.exports.push(stmt.name);
          }
          return null;
      }
      visitBinaryOperatorExpr(ast, ctx) {
          const lhs = () => ast.lhs.visitExpression(this, ctx);
          const rhs = () => ast.rhs.visitExpression(this, ctx);
          switch (ast.operator) {
              case BinaryOperator.Equals:
                  return lhs() == rhs();
              case BinaryOperator.Identical:
                  return lhs() === rhs();
              case BinaryOperator.NotEquals:
                  return lhs() != rhs();
              case BinaryOperator.NotIdentical:
                  return lhs() !== rhs();
              case BinaryOperator.And:
                  return lhs() && rhs();
              case BinaryOperator.Or:
                  return lhs() || rhs();
              case BinaryOperator.Plus:
                  return lhs() + rhs();
              case BinaryOperator.Minus:
                  return lhs() - rhs();
              case BinaryOperator.Divide:
                  return lhs() / rhs();
              case BinaryOperator.Multiply:
                  return lhs() * rhs();
              case BinaryOperator.Modulo:
                  return lhs() % rhs();
              case BinaryOperator.Lower:
                  return lhs() < rhs();
              case BinaryOperator.LowerEquals:
                  return lhs() <= rhs();
              case BinaryOperator.Bigger:
                  return lhs() > rhs();
              case BinaryOperator.BiggerEquals:
                  return lhs() >= rhs();
              default:
                  throw new Error(`Unknown operator ${ast.operator}`);
          }
      }
      visitReadPropExpr(ast, ctx) {
          let result;
          const receiver = ast.receiver.visitExpression(this, ctx);
          result = receiver[ast.name];
          return result;
      }
      visitReadKeyExpr(ast, ctx) {
          const receiver = ast.receiver.visitExpression(this, ctx);
          const prop = ast.index.visitExpression(this, ctx);
          return receiver[prop];
      }
      visitLiteralArrayExpr(ast, ctx) {
          return this.visitAllExpressions(ast.entries, ctx);
      }
      visitLiteralMapExpr(ast, ctx) {
          const result = {};
          ast.entries.forEach(entry => result[entry.key] = entry.value.visitExpression(this, ctx));
          return result;
      }
      visitCommaExpr(ast, context) {
          const values = this.visitAllExpressions(ast.parts, context);
          return values[values.length - 1];
      }
      visitAllExpressions(expressions, ctx) {
          return expressions.map((expr) => expr.visitExpression(this, ctx));
      }
      visitAllStatements(statements, ctx) {
          for (let i = 0; i < statements.length; i++) {
              const stmt = statements[i];
              const val = stmt.visitStatement(this, ctx);
              if (val instanceof ReturnValue) {
                  return val;
              }
          }
          return null;
      }
  }
  function _declareFn(varNames, statements, ctx, visitor) {
      return (...args) => _executeFunctionStatements(varNames, args, statements, ctx, visitor);
  }
  const CATCH_ERROR_VAR$2 = 'error';
  const CATCH_STACK_VAR$2 = 'stack';

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * An internal module of the Angular compiler that begins with component types,
   * extracts templates, and eventually produces a compiled version of the component
   * ready for linking into an application.
   *
   * @security  When compiling templates at runtime, you must ensure that the entire template comes
   * from a trusted source. Attacker-controlled data introduced by a template could expose your
   * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
   */
  class JitCompiler {
      constructor(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _reflector, _compilerConfig, _console, getExtraNgModuleProviders) {
          this._metadataResolver = _metadataResolver;
          this._templateParser = _templateParser;
          this._styleCompiler = _styleCompiler;
          this._viewCompiler = _viewCompiler;
          this._ngModuleCompiler = _ngModuleCompiler;
          this._summaryResolver = _summaryResolver;
          this._reflector = _reflector;
          this._compilerConfig = _compilerConfig;
          this._console = _console;
          this.getExtraNgModuleProviders = getExtraNgModuleProviders;
          this._compiledTemplateCache = new Map();
          this._compiledHostTemplateCache = new Map();
          this._compiledDirectiveWrapperCache = new Map();
          this._compiledNgModuleCache = new Map();
          this._sharedStylesheetCount = 0;
          this._addedAotSummaries = new Set();
      }
      compileModuleSync(moduleType) {
          return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));
      }
      compileModuleAsync(moduleType) {
          return Promise.resolve(this._compileModuleAndComponents(moduleType, false));
      }
      compileModuleAndAllComponentsSync(moduleType) {
          return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));
      }
      compileModuleAndAllComponentsAsync(moduleType) {
          return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));
      }
      getComponentFactory(component) {
          const summary = this._metadataResolver.getDirectiveSummary(component);
          return summary.componentFactory;
      }
      loadAotSummaries(summaries) {
          this.clearCache();
          this._addAotSummaries(summaries);
      }
      _addAotSummaries(fn$$1) {
          if (this._addedAotSummaries.has(fn$$1)) {
              return;
          }
          this._addedAotSummaries.add(fn$$1);
          const summaries = fn$$1();
          for (let i = 0; i < summaries.length; i++) {
              const entry = summaries[i];
              if (typeof entry === 'function') {
                  this._addAotSummaries(entry);
              }
              else {
                  const summary = entry;
                  this._summaryResolver.addSummary({ symbol: summary.type.reference, metadata: null, type: summary });
              }
          }
      }
      hasAotSummary(ref) { return !!this._summaryResolver.resolveSummary(ref); }
      _filterJitIdentifiers(ids) {
          return ids.map(mod => mod.reference).filter((ref) => !this.hasAotSummary(ref));
      }
      _compileModuleAndComponents(moduleType, isSync) {
          return SyncAsync.then(this._loadModules(moduleType, isSync), () => {
              this._compileComponents(moduleType, null);
              return this._compileModule(moduleType);
          });
      }
      _compileModuleAndAllComponents(moduleType, isSync) {
          return SyncAsync.then(this._loadModules(moduleType, isSync), () => {
              const componentFactories = [];
              this._compileComponents(moduleType, componentFactories);
              return {
                  ngModuleFactory: this._compileModule(moduleType),
                  componentFactories: componentFactories
              };
          });
      }
      _loadModules(mainModule, isSync) {
          const loading = [];
          const mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule);
          // Note: for runtime compilation, we want to transitively compile all modules,
          // so we also need to load the declared directives / pipes for all nested modules.
          this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach((nestedNgModule) => {
              // getNgModuleMetadata only returns null if the value passed in is not an NgModule
              const moduleMeta = this._metadataResolver.getNgModuleMetadata(nestedNgModule);
              this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach((ref) => {
                  const promise = this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);
                  if (promise) {
                      loading.push(promise);
                  }
              });
              this._filterJitIdentifiers(moduleMeta.declaredPipes)
                  .forEach((ref) => this._metadataResolver.getOrLoadPipeMetadata(ref));
          });
          return SyncAsync.all(loading);
      }
      _compileModule(moduleType) {
          let ngModuleFactory = this._compiledNgModuleCache.get(moduleType);
          if (!ngModuleFactory) {
              const moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType);
              // Always provide a bound Compiler
              const extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);
              const outputCtx = createOutputContext();
              const compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);
              ngModuleFactory = this._interpretOrJit(ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];
              this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);
          }
          return ngModuleFactory;
      }
      /**
       * @internal
       */
      _compileComponents(mainModule, allComponentFactories) {
          const ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);
          const moduleByJitDirective = new Map();
          const templates = new Set();
          const transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);
          transJitModules.forEach((localMod) => {
              const localModuleMeta = this._metadataResolver.getNgModuleMetadata(localMod);
              this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {
                  moduleByJitDirective.set(dirRef, localModuleMeta);
                  const dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);
                  if (dirMeta.isComponent) {
                      templates.add(this._createCompiledTemplate(dirMeta, localModuleMeta));
                      if (allComponentFactories) {
                          const template = this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);
                          templates.add(template);
                          allComponentFactories.push(dirMeta.componentFactory);
                      }
                  }
              });
          });
          transJitModules.forEach((localMod) => {
              const localModuleMeta = this._metadataResolver.getNgModuleMetadata(localMod);
              this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {
                  const dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);
                  if (dirMeta.isComponent) {
                      dirMeta.entryComponents.forEach((entryComponentType) => {
                          const moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);
                          templates.add(this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));
                      });
                  }
              });
              localModuleMeta.entryComponents.forEach((entryComponentType) => {
                  if (!this.hasAotSummary(entryComponentType.componentType)) {
                      const moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);
                      templates.add(this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));
                  }
              });
          });
          templates.forEach((template) => this._compileTemplate(template));
      }
      clearCacheFor(type) {
          this._compiledNgModuleCache.delete(type);
          this._metadataResolver.clearCacheFor(type);
          this._compiledHostTemplateCache.delete(type);
          const compiledTemplate = this._compiledTemplateCache.get(type);
          if (compiledTemplate) {
              this._compiledTemplateCache.delete(type);
          }
      }
      clearCache() {
          // Note: don't clear the _addedAotSummaries, as they don't change!
          this._metadataResolver.clearCache();
          this._compiledTemplateCache.clear();
          this._compiledHostTemplateCache.clear();
          this._compiledNgModuleCache.clear();
      }
      _createCompiledHostTemplate(compType, ngModule) {
          if (!ngModule) {
              throw new Error(`Component ${stringify(compType)} is not part of any NgModule or the module has not been imported into your module.`);
          }
          let compiledTemplate = this._compiledHostTemplateCache.get(compType);
          if (!compiledTemplate) {
              const compMeta = this._metadataResolver.getDirectiveMetadata(compType);
              assertComponent(compMeta);
              const hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta, compMeta.componentFactory.viewDefFactory);
              compiledTemplate =
                  new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);
              this._compiledHostTemplateCache.set(compType, compiledTemplate);
          }
          return compiledTemplate;
      }
      _createCompiledTemplate(compMeta, ngModule) {
          let compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);
          if (!compiledTemplate) {
              assertComponent(compMeta);
              compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);
              this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);
          }
          return compiledTemplate;
      }
      _compileTemplate(template) {
          if (template.isCompiled) {
              return;
          }
          const compMeta = template.compMeta;
          const externalStylesheetsByModuleUrl = new Map();
          const outputContext = createOutputContext();
          const componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);
          compMeta.template.externalStylesheets.forEach((stylesheetMeta) => {
              const compiledStylesheet = this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);
              externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl, compiledStylesheet);
          });
          this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);
          const pipes = template.ngModule.transitiveModule.pipes.map(pipe => this._metadataResolver.getPipeSummary(pipe.reference));
          const { template: parsedTemplate, pipes: usedPipes } = this._parseTemplate(compMeta, template.ngModule, template.directives);
          const compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, variable(componentStylesheet.stylesVar), usedPipes);
          const evalResult = this._interpretOrJit(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);
          const viewClass = evalResult[compileResult.viewClassVar];
          const rendererType = evalResult[compileResult.rendererTypeVar];
          template.compiled(viewClass, rendererType);
      }
      _parseTemplate(compMeta, ngModule, directiveIdentifiers) {
          // Note: ! is ok here as components always have a template.
          const preserveWhitespaces = compMeta.template.preserveWhitespaces;
          const directives = directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));
          const pipes = ngModule.transitiveModule.pipes.map(pipe => this._metadataResolver.getPipeSummary(pipe.reference));
          return this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);
      }
      _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl) {
          result.dependencies.forEach((dep, i) => {
              const nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);
              const nestedStylesArr = this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);
              dep.setValue(nestedStylesArr);
          });
      }
      _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl) {
          this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
          return this._interpretOrJit(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];
      }
      _interpretOrJit(sourceUrl, statements) {
          if (!this._compilerConfig.useJit) {
              return interpretStatements(statements, this._reflector);
          }
          else {
              return jitStatements(sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);
          }
      }
  }
  class CompiledTemplate {
      constructor(isHost, compType, compMeta, ngModule, directives) {
          this.isHost = isHost;
          this.compType = compType;
          this.compMeta = compMeta;
          this.ngModule = ngModule;
          this.directives = directives;
          this._viewClass = null;
          this.isCompiled = false;
      }
      compiled(viewClass, rendererType) {
          this._viewClass = viewClass;
          this.compMeta.componentViewType.setDelegate(viewClass);
          for (let prop in rendererType) {
              this.compMeta.rendererType[prop] = rendererType[prop];
          }
          this.isCompiled = true;
      }
  }
  function assertComponent(meta) {
      if (!meta.isComponent) {
          throw new Error(`Could not compile '${identifierName(meta.type)}' because it is not a component.`);
      }
  }
  function createOutputContext() {
      const importExpr$$1 = (symbol) => importExpr({ name: identifierName(symbol), moduleName: null, runtime: symbol });
      return { statements: [], genFilePath: '', importExpr: importExpr$$1, constantPool: new ConstantPool() };
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Provides access to reflection data about symbols that the compiler needs.
   */
  class CompileReflector {
  }
  const UrlResolver = class UrlResolverImpl {
      constructor(_packagePrefix = null) {
          this._packagePrefix = _packagePrefix;
      }
      /**
       * Resolves the `url` given the `baseUrl`:
       * - when the `url` is null, the `baseUrl` is returned,
       * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
       * `baseUrl` and `url`,
       * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
       * returned as is (ignoring the `baseUrl`)
       */
      resolve(baseUrl, url) {
          let resolvedUrl = url;
          if (baseUrl != null && baseUrl.length > 0) {
              resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);
          }
          const resolvedParts = _split(resolvedUrl);
          let prefix = this._packagePrefix;
          if (prefix != null && resolvedParts != null &&
              resolvedParts[_ComponentIndex.Scheme] == 'package') {
              let path = resolvedParts[_ComponentIndex.Path];
              prefix = prefix.replace(/\/+$/, '');
              path = path.replace(/^\/+/, '');
              return `${prefix}/${path}`;
          }
          return resolvedUrl;
      }
  };
  /**
   * Extract the scheme of a URL.
   */
  function getUrlScheme(url) {
      const match = _split(url);
      return (match && match[_ComponentIndex.Scheme]) || '';
  }
  // The code below is adapted from Traceur:
  // https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
  /**
   * Builds a URI string from already-encoded parts.
   *
   * No encoding is performed.  Any component may be omitted as either null or
   * undefined.
   *
   * @param opt_scheme The scheme such as 'http'.
   * @param opt_userInfo The user name before the '@'.
   * @param opt_domain The domain such as 'www.google.com', already
   *     URI-encoded.
   * @param opt_port The port number.
   * @param opt_path The path, already URI-encoded.  If it is not
   *     empty, it must begin with a slash.
   * @param opt_queryData The URI-encoded query data.
   * @param opt_fragment The URI-encoded fragment identifier.
   * @return The fully combined URI.
   */
  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
      const out = [];
      if (opt_scheme != null) {
          out.push(opt_scheme + ':');
      }
      if (opt_domain != null) {
          out.push('//');
          if (opt_userInfo != null) {
              out.push(opt_userInfo + '@');
          }
          out.push(opt_domain);
          if (opt_port != null) {
              out.push(':' + opt_port);
          }
      }
      if (opt_path != null) {
          out.push(opt_path);
      }
      if (opt_queryData != null) {
          out.push('?' + opt_queryData);
      }
      if (opt_fragment != null) {
          out.push('#' + opt_fragment);
      }
      return out.join('');
  }
  /**
   * A regular expression for breaking a URI into its component parts.
   *
   * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
   * As the "first-match-wins" algorithm is identical to the "greedy"
   * disambiguation method used by POSIX regular expressions, it is natural and
   * commonplace to use a regular expression for parsing the potential five
   * components of a URI reference.
   *
   * The following line is the regular expression for breaking-down a
   * well-formed URI reference into its components.
   *
   * <pre>
   * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
   *  12            3  4          5       6  7        8 9
   * </pre>
   *
   * The numbers in the second line above are only to assist readability; they
   * indicate the reference points for each subexpression (i.e., each paired
   * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
   * For example, matching the above expression to
   * <pre>
   *     http://www.ics.uci.edu/pub/ietf/uri/#Related
   * </pre>
   * results in the following subexpression matches:
   * <pre>
   *    $1 = http:
   *    $2 = http
   *    $3 = //www.ics.uci.edu
   *    $4 = www.ics.uci.edu
   *    $5 = /pub/ietf/uri/
   *    $6 = <undefined>
   *    $7 = <undefined>
   *    $8 = #Related
   *    $9 = Related
   * </pre>
   * where <undefined> indicates that the component is not present, as is the
   * case for the query component in the above example. Therefore, we can
   * determine the value of the five components as
   * <pre>
   *    scheme    = $2
   *    authority = $4
   *    path      = $5
   *    query     = $7
   *    fragment  = $9
   * </pre>
   *
   * The regular expression has been modified slightly to expose the
   * userInfo, domain, and port separately from the authority.
   * The modified version yields
   * <pre>
   *    $1 = http              scheme
   *    $2 = <undefined>       userInfo -\
   *    $3 = www.ics.uci.edu   domain     | authority
   *    $4 = <undefined>       port     -/
   *    $5 = /pub/ietf/uri/    path
   *    $6 = <undefined>       query without ?
   *    $7 = Related           fragment without #
   * </pre>
   * @internal
   */
  const _splitRe = new RegExp('^' +
      '(?:' +
      '([^:/?#.]+)' + // scheme - ignore special characters
      // used by other URL parts such as :,
      // ?, /, #, and .
      ':)?' +
      '(?://' +
      '(?:([^/?#]*)@)?' + // userInfo
      '([\\w\\d\\-\\u0100-\\uffff.%]*)' + // domain - restrict to letters,
      // digits, dashes, dots, percent
      // escapes, and unicode characters.
      '(?::([0-9]+))?' + // port
      ')?' +
      '([^?#]+)?' + // path
      '(?:\\?([^#]*))?' + // query
      '(?:#(.*))?' + // fragment
      '$');
  /**
   * The index of each URI component in the return value of goog.uri.utils.split.
   * @enum {number}
   */
  var _ComponentIndex;
  (function (_ComponentIndex) {
      _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
      _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
      _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
      _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
      _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
      _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
      _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
  })(_ComponentIndex || (_ComponentIndex = {}));
  /**
   * Splits a URI into its component parts.
   *
   * Each component can be accessed via the component indices; for example:
   * <pre>
   * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
   * </pre>
   *
   * @param uri The URI string to examine.
   * @return Each component still URI-encoded.
   *     Each component that is present will contain the encoded value, whereas
   *     components that are not present will be undefined or empty, depending
   *     on the browser's regular expression implementation.  Never null, since
   *     arbitrary strings may still look like path names.
   */
  function _split(uri) {
      return uri.match(_splitRe);
  }
  /**
    * Removes dot segments in given path component, as described in
    * RFC 3986, section 5.2.4.
    *
    * @param path A non-empty path component.
    * @return Path component with removed dot segments.
    */
  function _removeDotSegments(path) {
      if (path == '/')
          return '/';
      const leadingSlash = path[0] == '/' ? '/' : '';
      const trailingSlash = path[path.length - 1] === '/' ? '/' : '';
      const segments = path.split('/');
      const out = [];
      let up = 0;
      for (let pos = 0; pos < segments.length; pos++) {
          const segment = segments[pos];
          switch (segment) {
              case '':
              case '.':
                  break;
              case '..':
                  if (out.length > 0) {
                      out.pop();
                  }
                  else {
                      up++;
                  }
                  break;
              default:
                  out.push(segment);
          }
      }
      if (leadingSlash == '') {
          while (up-- > 0) {
              out.unshift('..');
          }
          if (out.length === 0)
              out.push('.');
      }
      return leadingSlash + out.join('/') + trailingSlash;
  }
  /**
   * Takes an array of the parts from split and canonicalizes the path part
   * and then joins all the parts.
   */
  function _joinAndCanonicalizePath(parts) {
      let path = parts[_ComponentIndex.Path];
      path = path == null ? '' : _removeDotSegments(path);
      parts[_ComponentIndex.Path] = path;
      return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
  }
  /**
   * Resolves a URL.
   * @param base The URL acting as the base URL.
   * @param to The URL to resolve.
   */
  function _resolveUrl(base, url) {
      const parts = _split(encodeURI(url));
      const baseParts = _split(base);
      if (parts[_ComponentIndex.Scheme] != null) {
          return _joinAndCanonicalizePath(parts);
      }
      else {
          parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
      }
      for (let i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
          if (parts[i] == null) {
              parts[i] = baseParts[i];
          }
      }
      if (parts[_ComponentIndex.Path][0] == '/') {
          return _joinAndCanonicalizePath(parts);
      }
      let path = baseParts[_ComponentIndex.Path];
      if (path == null)
          path = '/';
      const index = path.lastIndexOf('/');
      path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
      parts[_ComponentIndex.Path] = path;
      return _joinAndCanonicalizePath(parts);
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * An interface for retrieving documents by URL that the compiler uses
   * to load templates.
   */
  class ResourceLoader {
      get(url) { return ''; }
  }

  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // This file only reexports content of the `src` folder. Keep it that way.
  // This function call has a global side effects and publishes the compiler into global namespace for
  // the late binding of the Compiler to the @angular/core for jit compilation.
  publishFacade(_global);

  function isFunction(x) {
      return typeof x === 'function';
  }

  let _enable_super_gross_mode_that_will_cause_bad_things = false;
  const config = {
      Promise: undefined,
      set useDeprecatedSynchronousErrorHandling(value) {
          if (value) {
              const error = new Error();
              console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
          }
          else if (_enable_super_gross_mode_that_will_cause_bad_things) {
              console.log('RxJS: Back to a better error behavior. Thank you. <3');
          }
          _enable_super_gross_mode_that_will_cause_bad_things = value;
      },
      get useDeprecatedSynchronousErrorHandling() {
          return _enable_super_gross_mode_that_will_cause_bad_things;
      },
  };

  function hostReportError(err) {
      setTimeout(() => { throw err; });
  }

  const empty = {
      closed: true,
      next(value) { },
      error(err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
              throw err;
          }
          else {
              hostReportError(err);
          }
      },
      complete() { }
  };

  const isArray = Array.isArray || ((x) => x && typeof x.length === 'number');

  function isObject(x) {
      return x != null && typeof x === 'object';
  }

  const errorObject = { e: {} };

  let tryCatchTarget;
  function tryCatcher() {
      try {
          return tryCatchTarget.apply(this, arguments);
      }
      catch (e) {
          errorObject.e = e;
          return errorObject;
      }
  }
  function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
  }

  function UnsubscriptionErrorImpl(errors) {
      Error.call(this);
      this.message = errors ?
          `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\n  ')}` : '';
      this.name = 'UnsubscriptionError';
      this.errors = errors;
      return this;
  }
  UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
  const UnsubscriptionError = UnsubscriptionErrorImpl;

  class Subscription {
      constructor(unsubscribe) {
          this.closed = false;
          this._parent = null;
          this._parents = null;
          this._subscriptions = null;
          if (unsubscribe) {
              this._unsubscribe = unsubscribe;
          }
      }
      unsubscribe() {
          let hasErrors = false;
          let errors;
          if (this.closed) {
              return;
          }
          let { _parent, _parents, _unsubscribe, _subscriptions } = this;
          this.closed = true;
          this._parent = null;
          this._parents = null;
          this._subscriptions = null;
          let index = -1;
          let len = _parents ? _parents.length : 0;
          while (_parent) {
              _parent.remove(this);
              _parent = ++index < len && _parents[index] || null;
          }
          if (isFunction(_unsubscribe)) {
              let trial = tryCatch(_unsubscribe).call(this);
              if (trial === errorObject) {
                  hasErrors = true;
                  errors = errors || (errorObject.e instanceof UnsubscriptionError ?
                      flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
              }
          }
          if (isArray(_subscriptions)) {
              index = -1;
              len = _subscriptions.length;
              while (++index < len) {
                  const sub = _subscriptions[index];
                  if (isObject(sub)) {
                      let trial = tryCatch(sub.unsubscribe).call(sub);
                      if (trial === errorObject) {
                          hasErrors = true;
                          errors = errors || [];
                          let err = errorObject.e;
                          if (err instanceof UnsubscriptionError) {
                              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                          }
                          else {
                              errors.push(err);
                          }
                      }
                  }
              }
          }
          if (hasErrors) {
              throw new UnsubscriptionError(errors);
          }
      }
      add(teardown) {
          if (!teardown || (teardown === Subscription.EMPTY)) {
              return Subscription.EMPTY;
          }
          if (teardown === this) {
              return this;
          }
          let subscription = teardown;
          switch (typeof teardown) {
              case 'function':
                  subscription = new Subscription(teardown);
              case 'object':
                  if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                      return subscription;
                  }
                  else if (this.closed) {
                      subscription.unsubscribe();
                      return subscription;
                  }
                  else if (typeof subscription._addParent !== 'function') {
                      const tmp = subscription;
                      subscription = new Subscription();
                      subscription._subscriptions = [tmp];
                  }
                  break;
              default:
                  throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
          }
          const subscriptions = this._subscriptions || (this._subscriptions = []);
          subscriptions.push(subscription);
          subscription._addParent(this);
          return subscription;
      }
      remove(subscription) {
          const subscriptions = this._subscriptions;
          if (subscriptions) {
              const subscriptionIndex = subscriptions.indexOf(subscription);
              if (subscriptionIndex !== -1) {
                  subscriptions.splice(subscriptionIndex, 1);
              }
          }
      }
      _addParent(parent) {
          let { _parent, _parents } = this;
          if (!_parent || _parent === parent) {
              this._parent = parent;
          }
          else if (!_parents) {
              this._parents = [parent];
          }
          else if (_parents.indexOf(parent) === -1) {
              _parents.push(parent);
          }
      }
  }
  Subscription.EMPTY = (function (empty) {
      empty.closed = true;
      return empty;
  }(new Subscription()));
  function flattenUnsubscriptionErrors(errors) {
      return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);
  }

  const rxSubscriber = typeof Symbol === 'function'
      ? Symbol('rxSubscriber')
      : '@@rxSubscriber_' + Math.random();

  class Subscriber extends Subscription {
      constructor(destinationOrNext, error, complete) {
          super();
          this.syncErrorValue = null;
          this.syncErrorThrown = false;
          this.syncErrorThrowable = false;
          this.isStopped = false;
          this._parentSubscription = null;
          switch (arguments.length) {
              case 0:
                  this.destination = empty;
                  break;
              case 1:
                  if (!destinationOrNext) {
                      this.destination = empty;
                      break;
                  }
                  if (typeof destinationOrNext === 'object') {
                      if (destinationOrNext instanceof Subscriber) {
                          this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                          this.destination = destinationOrNext;
                          destinationOrNext.add(this);
                      }
                      else {
                          this.syncErrorThrowable = true;
                          this.destination = new SafeSubscriber(this, destinationOrNext);
                      }
                      break;
                  }
              default:
                  this.syncErrorThrowable = true;
                  this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                  break;
          }
      }
      [rxSubscriber]() { return this; }
      static create(next, error, complete) {
          const subscriber = new Subscriber(next, error, complete);
          subscriber.syncErrorThrowable = false;
          return subscriber;
      }
      next(value) {
          if (!this.isStopped) {
              this._next(value);
          }
      }
      error(err) {
          if (!this.isStopped) {
              this.isStopped = true;
              this._error(err);
          }
      }
      complete() {
          if (!this.isStopped) {
              this.isStopped = true;
              this._complete();
          }
      }
      unsubscribe() {
          if (this.closed) {
              return;
          }
          this.isStopped = true;
          super.unsubscribe();
      }
      _next(value) {
          this.destination.next(value);
      }
      _error(err) {
          this.destination.error(err);
          this.unsubscribe();
      }
      _complete() {
          this.destination.complete();
          this.unsubscribe();
      }
      _unsubscribeAndRecycle() {
          const { _parent, _parents } = this;
          this._parent = null;
          this._parents = null;
          this.unsubscribe();
          this.closed = false;
          this.isStopped = false;
          this._parent = _parent;
          this._parents = _parents;
          this._parentSubscription = null;
          return this;
      }
  }
  class SafeSubscriber extends Subscriber {
      constructor(_parentSubscriber, observerOrNext, error, complete) {
          super();
          this._parentSubscriber = _parentSubscriber;
          let next;
          let context = this;
          if (isFunction(observerOrNext)) {
              next = observerOrNext;
          }
          else if (observerOrNext) {
              next = observerOrNext.next;
              error = observerOrNext.error;
              complete = observerOrNext.complete;
              if (observerOrNext !== empty) {
                  context = Object.create(observerOrNext);
                  if (isFunction(context.unsubscribe)) {
                      this.add(context.unsubscribe.bind(context));
                  }
                  context.unsubscribe = this.unsubscribe.bind(this);
              }
          }
          this._context = context;
          this._next = next;
          this._error = error;
          this._complete = complete;
      }
      next(value) {
          if (!this.isStopped && this._next) {
              const { _parentSubscriber } = this;
              if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                  this.__tryOrUnsub(this._next, value);
              }
              else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                  this.unsubscribe();
              }
          }
      }
      error(err) {
          if (!this.isStopped) {
              const { _parentSubscriber } = this;
              const { useDeprecatedSynchronousErrorHandling } = config;
              if (this._error) {
                  if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                      this.__tryOrUnsub(this._error, err);
                      this.unsubscribe();
                  }
                  else {
                      this.__tryOrSetError(_parentSubscriber, this._error, err);
                      this.unsubscribe();
                  }
              }
              else if (!_parentSubscriber.syncErrorThrowable) {
                  this.unsubscribe();
                  if (useDeprecatedSynchronousErrorHandling) {
                      throw err;
                  }
                  hostReportError(err);
              }
              else {
                  if (useDeprecatedSynchronousErrorHandling) {
                      _parentSubscriber.syncErrorValue = err;
                      _parentSubscriber.syncErrorThrown = true;
                  }
                  else {
                      hostReportError(err);
                  }
                  this.unsubscribe();
              }
          }
      }
      complete() {
          if (!this.isStopped) {
              const { _parentSubscriber } = this;
              if (this._complete) {
                  const wrappedComplete = () => this._complete.call(this._context);
                  if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                      this.__tryOrUnsub(wrappedComplete);
                      this.unsubscribe();
                  }
                  else {
                      this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                      this.unsubscribe();
                  }
              }
              else {
                  this.unsubscribe();
              }
          }
      }
      __tryOrUnsub(fn, value) {
          try {
              fn.call(this._context, value);
          }
          catch (err) {
              this.unsubscribe();
              if (config.useDeprecatedSynchronousErrorHandling) {
                  throw err;
              }
              else {
                  hostReportError(err);
              }
          }
      }
      __tryOrSetError(parent, fn, value) {
          if (!config.useDeprecatedSynchronousErrorHandling) {
              throw new Error('bad call');
          }
          try {
              fn.call(this._context, value);
          }
          catch (err) {
              if (config.useDeprecatedSynchronousErrorHandling) {
                  parent.syncErrorValue = err;
                  parent.syncErrorThrown = true;
                  return true;
              }
              else {
                  hostReportError(err);
                  return true;
              }
          }
          return false;
      }
      _unsubscribe() {
          const { _parentSubscriber } = this;
          this._context = null;
          this._parentSubscriber = null;
          _parentSubscriber.unsubscribe();
      }
  }

  function canReportError(observer) {
      while (observer) {
          const { closed, destination, isStopped } = observer;
          if (closed || isStopped) {
              return false;
          }
          else if (destination && destination instanceof Subscriber) {
              observer = destination;
          }
          else {
              observer = null;
          }
      }
      return true;
  }

  function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
          if (nextOrObserver instanceof Subscriber) {
              return nextOrObserver;
          }
          if (nextOrObserver[rxSubscriber]) {
              return nextOrObserver[rxSubscriber]();
          }
      }
      if (!nextOrObserver && !error && !complete) {
          return new Subscriber(empty);
      }
      return new Subscriber(nextOrObserver, error, complete);
  }

  const observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

  function noop() { }

  function pipeFromArray(fns) {
      if (!fns) {
          return noop;
      }
      if (fns.length === 1) {
          return fns[0];
      }
      return function piped(input) {
          return fns.reduce((prev, fn) => fn(prev), input);
      };
  }

  class Observable {
      constructor(subscribe) {
          this._isScalar = false;
          if (subscribe) {
              this._subscribe = subscribe;
          }
      }
      lift(operator) {
          const observable$$1 = new Observable();
          observable$$1.source = this;
          observable$$1.operator = operator;
          return observable$$1;
      }
      subscribe(observerOrNext, error, complete) {
          const { operator } = this;
          const sink = toSubscriber(observerOrNext, error, complete);
          if (operator) {
              operator.call(sink, this.source);
          }
          else {
              sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                  this._subscribe(sink) :
                  this._trySubscribe(sink));
          }
          if (config.useDeprecatedSynchronousErrorHandling) {
              if (sink.syncErrorThrowable) {
                  sink.syncErrorThrowable = false;
                  if (sink.syncErrorThrown) {
                      throw sink.syncErrorValue;
                  }
              }
          }
          return sink;
      }
      _trySubscribe(sink) {
          try {
              return this._subscribe(sink);
          }
          catch (err) {
              if (config.useDeprecatedSynchronousErrorHandling) {
                  sink.syncErrorThrown = true;
                  sink.syncErrorValue = err;
              }
              if (canReportError(sink)) {
                  sink.error(err);
              }
              else {
                  console.warn(err);
              }
          }
      }
      forEach(next, promiseCtor) {
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor((resolve, reject) => {
              let subscription;
              subscription = this.subscribe((value) => {
                  try {
                      next(value);
                  }
                  catch (err) {
                      reject(err);
                      if (subscription) {
                          subscription.unsubscribe();
                      }
                  }
              }, reject, resolve);
          });
      }
      _subscribe(subscriber) {
          const { source } = this;
          return source && source.subscribe(subscriber);
      }
      [observable]() {
          return this;
      }
      pipe(...operations) {
          if (operations.length === 0) {
              return this;
          }
          return pipeFromArray(operations)(this);
      }
      toPromise(promiseCtor) {
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor((resolve, reject) => {
              let value;
              this.subscribe((x) => value = x, (err) => reject(err), () => resolve(value));
          });
      }
  }
  Observable.create = (subscribe) => {
      return new Observable(subscribe);
  };
  function getPromiseCtor(promiseCtor) {
      if (!promiseCtor) {
          promiseCtor = config.Promise || Promise;
      }
      if (!promiseCtor) {
          throw new Error('no Promise impl found');
      }
      return promiseCtor;
  }

  function ObjectUnsubscribedErrorImpl() {
      Error.call(this);
      this.message = 'object unsubscribed';
      this.name = 'ObjectUnsubscribedError';
      return this;
  }
  ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
  const ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

  class SubjectSubscription extends Subscription {
      constructor(subject, subscriber) {
          super();
          this.subject = subject;
          this.subscriber = subscriber;
          this.closed = false;
      }
      unsubscribe() {
          if (this.closed) {
              return;
          }
          this.closed = true;
          const subject = this.subject;
          const observers = subject.observers;
          this.subject = null;
          if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
              return;
          }
          const subscriberIndex = observers.indexOf(this.subscriber);
          if (subscriberIndex !== -1) {
              observers.splice(subscriberIndex, 1);
          }
      }
  }

  class SubjectSubscriber extends Subscriber {
      constructor(destination) {
          super(destination);
          this.destination = destination;
      }
  }
  class Subject extends Observable {
      constructor() {
          super();
          this.observers = [];
          this.closed = false;
          this.isStopped = false;
          this.hasError = false;
          this.thrownError = null;
      }
      [rxSubscriber]() {
          return new SubjectSubscriber(this);
      }
      lift(operator) {
          const subject = new AnonymousSubject(this, this);
          subject.operator = operator;
          return subject;
      }
      next(value) {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          if (!this.isStopped) {
              const { observers } = this;
              const len = observers.length;
              const copy = observers.slice();
              for (let i = 0; i < len; i++) {
                  copy[i].next(value);
              }
          }
      }
      error(err) {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          this.hasError = true;
          this.thrownError = err;
          this.isStopped = true;
          const { observers } = this;
          const len = observers.length;
          const copy = observers.slice();
          for (let i = 0; i < len; i++) {
              copy[i].error(err);
          }
          this.observers.length = 0;
      }
      complete() {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          this.isStopped = true;
          const { observers } = this;
          const len = observers.length;
          const copy = observers.slice();
          for (let i = 0; i < len; i++) {
              copy[i].complete();
          }
          this.observers.length = 0;
      }
      unsubscribe() {
          this.isStopped = true;
          this.closed = true;
          this.observers = null;
      }
      _trySubscribe(subscriber) {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          else {
              return super._trySubscribe(subscriber);
          }
      }
      _subscribe(subscriber) {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          else if (this.hasError) {
              subscriber.error(this.thrownError);
              return Subscription.EMPTY;
          }
          else if (this.isStopped) {
              subscriber.complete();
              return Subscription.EMPTY;
          }
          else {
              this.observers.push(subscriber);
              return new SubjectSubscription(this, subscriber);
          }
      }
      asObservable() {
          const observable = new Observable();
          observable.source = this;
          return observable;
      }
  }
  Subject.create = (destination, source) => {
      return new AnonymousSubject(destination, source);
  };
  class AnonymousSubject extends Subject {
      constructor(destination, source) {
          super();
          this.destination = destination;
          this.source = source;
      }
      next(value) {
          const { destination } = this;
          if (destination && destination.next) {
              destination.next(value);
          }
      }
      error(err) {
          const { destination } = this;
          if (destination && destination.error) {
              this.destination.error(err);
          }
      }
      complete() {
          const { destination } = this;
          if (destination && destination.complete) {
              this.destination.complete();
          }
      }
      _subscribe(subscriber) {
          const { source } = this;
          if (source) {
              return this.source.subscribe(subscriber);
          }
          else {
              return Subscription.EMPTY;
          }
      }
  }

  function refCount() {
      return function refCountOperatorFunction(source) {
          return source.lift(new RefCountOperator(source));
      };
  }
  class RefCountOperator {
      constructor(connectable) {
          this.connectable = connectable;
      }
      call(subscriber, source) {
          const { connectable } = this;
          connectable._refCount++;
          const refCounter = new RefCountSubscriber(subscriber, connectable);
          const subscription = source.subscribe(refCounter);
          if (!refCounter.closed) {
              refCounter.connection = connectable.connect();
          }
          return subscription;
      }
  }
  class RefCountSubscriber extends Subscriber {
      constructor(destination, connectable) {
          super(destination);
          this.connectable = connectable;
      }
      _unsubscribe() {
          const { connectable } = this;
          if (!connectable) {
              this.connection = null;
              return;
          }
          this.connectable = null;
          const refCount = connectable._refCount;
          if (refCount <= 0) {
              this.connection = null;
              return;
          }
          connectable._refCount = refCount - 1;
          if (refCount > 1) {
              this.connection = null;
              return;
          }
          const { connection } = this;
          const sharedConnection = connectable._connection;
          this.connection = null;
          if (sharedConnection && (!connection || sharedConnection === connection)) {
              sharedConnection.unsubscribe();
          }
      }
  }

  class ConnectableObservable extends Observable {
      constructor(source, subjectFactory) {
          super();
          this.source = source;
          this.subjectFactory = subjectFactory;
          this._refCount = 0;
          this._isComplete = false;
      }
      _subscribe(subscriber) {
          return this.getSubject().subscribe(subscriber);
      }
      getSubject() {
          const subject = this._subject;
          if (!subject || subject.isStopped) {
              this._subject = this.subjectFactory();
          }
          return this._subject;
      }
      connect() {
          let connection = this._connection;
          if (!connection) {
              this._isComplete = false;
              connection = this._connection = new Subscription();
              connection.add(this.source
                  .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
              if (connection.closed) {
                  this._connection = null;
                  connection = Subscription.EMPTY;
              }
              else {
                  this._connection = connection;
              }
          }
          return connection;
      }
      refCount() {
          return refCount()(this);
      }
  }
  const connectableProto = ConnectableObservable.prototype;
  const connectableObservableDescriptor = {
      operator: { value: null },
      _refCount: { value: 0, writable: true },
      _subject: { value: null, writable: true },
      _connection: { value: null, writable: true },
      _subscribe: { value: connectableProto._subscribe },
      _isComplete: { value: connectableProto._isComplete, writable: true },
      getSubject: { value: connectableProto.getSubject },
      connect: { value: connectableProto.connect },
      refCount: { value: connectableProto.refCount }
  };
  class ConnectableSubscriber extends SubjectSubscriber {
      constructor(destination, connectable) {
          super(destination);
          this.connectable = connectable;
      }
      _error(err) {
          this._unsubscribe();
          super._error(err);
      }
      _complete() {
          this.connectable._isComplete = true;
          this._unsubscribe();
          super._complete();
      }
      _unsubscribe() {
          const connectable = this.connectable;
          if (connectable) {
              this.connectable = null;
              const connection = connectable._connection;
              connectable._refCount = 0;
              connectable._subject = null;
              connectable._connection = null;
              if (connection) {
                  connection.unsubscribe();
              }
          }
      }
  }

  class Action extends Subscription {
      constructor(scheduler, work) {
          super();
      }
      schedule(state, delay = 0) {
          return this;
      }
  }

  class AsyncAction extends Action {
      constructor(scheduler, work) {
          super(scheduler, work);
          this.scheduler = scheduler;
          this.work = work;
          this.pending = false;
      }
      schedule(state, delay = 0) {
          if (this.closed) {
              return this;
          }
          this.state = state;
          const id = this.id;
          const scheduler = this.scheduler;
          if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, delay);
          }
          this.pending = true;
          this.delay = delay;
          this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
          return this;
      }
      requestAsyncId(scheduler, id, delay = 0) {
          return setInterval(scheduler.flush.bind(scheduler, this), delay);
      }
      recycleAsyncId(scheduler, id, delay = 0) {
          if (delay !== null && this.delay === delay && this.pending === false) {
              return id;
          }
          clearInterval(id);
      }
      execute(state, delay) {
          if (this.closed) {
              return new Error('executing a cancelled action');
          }
          this.pending = false;
          const error = this._execute(state, delay);
          if (error) {
              return error;
          }
          else if (this.pending === false && this.id != null) {
              this.id = this.recycleAsyncId(this.scheduler, this.id, null);
          }
      }
      _execute(state, delay) {
          let errored = false;
          let errorValue = undefined;
          try {
              this.work(state);
          }
          catch (e) {
              errored = true;
              errorValue = !!e && e || new Error(e);
          }
          if (errored) {
              this.unsubscribe();
              return errorValue;
          }
      }
      _unsubscribe() {
          const id = this.id;
          const scheduler = this.scheduler;
          const actions = scheduler.actions;
          const index = actions.indexOf(this);
          this.work = null;
          this.state = null;
          this.pending = false;
          this.scheduler = null;
          if (index !== -1) {
              actions.splice(index, 1);
          }
          if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
      }
  }

  class QueueAction extends AsyncAction {
      constructor(scheduler, work) {
          super(scheduler, work);
          this.scheduler = scheduler;
          this.work = work;
      }
      schedule(state, delay = 0) {
          if (delay > 0) {
              return super.schedule(state, delay);
          }
          this.delay = delay;
          this.state = state;
          this.scheduler.flush(this);
          return this;
      }
      execute(state, delay) {
          return (delay > 0 || this.closed) ?
              super.execute(state, delay) :
              this._execute(state, delay);
      }
      requestAsyncId(scheduler, id, delay = 0) {
          if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
              return super.requestAsyncId(scheduler, id, delay);
          }
          return scheduler.flush(this);
      }
  }

  class Scheduler {
      constructor(SchedulerAction, now = Scheduler.now) {
          this.SchedulerAction = SchedulerAction;
          this.now = now;
      }
      schedule(work, delay = 0, state) {
          return new this.SchedulerAction(this, work).schedule(state, delay);
      }
  }
  Scheduler.now = () => Date.now();

  class AsyncScheduler extends Scheduler {
      constructor(SchedulerAction, now = Scheduler.now) {
          super(SchedulerAction, () => {
              if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
                  return AsyncScheduler.delegate.now();
              }
              else {
                  return now();
              }
          });
          this.actions = [];
          this.active = false;
          this.scheduled = undefined;
      }
      schedule(work, delay = 0, state) {
          if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
              return AsyncScheduler.delegate.schedule(work, delay, state);
          }
          else {
              return super.schedule(work, delay, state);
          }
      }
      flush(action) {
          const { actions } = this;
          if (this.active) {
              actions.push(action);
              return;
          }
          let error;
          this.active = true;
          do {
              if (error = action.execute(action.state, action.delay)) {
                  break;
              }
          } while (action = actions.shift());
          this.active = false;
          if (error) {
              while (action = actions.shift()) {
                  action.unsubscribe();
              }
              throw error;
          }
      }
  }

  class QueueScheduler extends AsyncScheduler {
  }

  const queue = new QueueScheduler(QueueAction);

  function isScheduler(value) {
      return value && typeof value.schedule === 'function';
  }

  const subscribeToArray = (array) => (subscriber) => {
      for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {
          subscriber.next(array[i]);
      }
      if (!subscriber.closed) {
          subscriber.complete();
      }
  };

  function fromArray(input, scheduler) {
      if (!scheduler) {
          return new Observable(subscribeToArray(input));
      }
      else {
          return new Observable(subscriber => {
              const sub = new Subscription();
              let i = 0;
              sub.add(scheduler.schedule(function () {
                  if (i === input.length) {
                      subscriber.complete();
                      return;
                  }
                  subscriber.next(input[i++]);
                  if (!subscriber.closed) {
                      sub.add(this.schedule());
                  }
              }));
              return sub;
          });
      }
  }

  let nextHandle = 1;
  const tasksByHandle = {};
  function runIfPresent(handle) {
      const cb = tasksByHandle[handle];
      if (cb) {
          cb();
      }
  }
  const Immediate = {
      setImmediate(cb) {
          const handle = nextHandle++;
          tasksByHandle[handle] = cb;
          Promise.resolve().then(() => runIfPresent(handle));
          return handle;
      },
      clearImmediate(handle) {
          delete tasksByHandle[handle];
      },
  };

  class AsapAction extends AsyncAction {
      constructor(scheduler, work) {
          super(scheduler, work);
          this.scheduler = scheduler;
          this.work = work;
      }
      requestAsyncId(scheduler, id, delay = 0) {
          if (delay !== null && delay > 0) {
              return super.requestAsyncId(scheduler, id, delay);
          }
          scheduler.actions.push(this);
          return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
      }
      recycleAsyncId(scheduler, id, delay = 0) {
          if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
              return super.recycleAsyncId(scheduler, id, delay);
          }
          if (scheduler.actions.length === 0) {
              Immediate.clearImmediate(id);
              scheduler.scheduled = undefined;
          }
          return undefined;
      }
  }

  class AsapScheduler extends AsyncScheduler {
      flush(action) {
          this.active = true;
          this.scheduled = undefined;
          const { actions } = this;
          let error;
          let index = -1;
          let count = actions.length;
          action = action || actions.shift();
          do {
              if (error = action.execute(action.state, action.delay)) {
                  break;
              }
          } while (++index < count && (action = actions.shift()));
          this.active = false;
          if (error) {
              while (++index < count && (action = actions.shift())) {
                  action.unsubscribe();
              }
              throw error;
          }
      }
  }

  const asap = new AsapScheduler(AsapAction);

  const async = new AsyncScheduler(AsyncAction);

  class AnimationFrameAction extends AsyncAction {
      constructor(scheduler, work) {
          super(scheduler, work);
          this.scheduler = scheduler;
          this.work = work;
      }
      requestAsyncId(scheduler, id, delay = 0) {
          if (delay !== null && delay > 0) {
              return super.requestAsyncId(scheduler, id, delay);
          }
          scheduler.actions.push(this);
          return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));
      }
      recycleAsyncId(scheduler, id, delay = 0) {
          if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
              return super.recycleAsyncId(scheduler, id, delay);
          }
          if (scheduler.actions.length === 0) {
              cancelAnimationFrame(id);
              scheduler.scheduled = undefined;
          }
          return undefined;
      }
  }

  class AnimationFrameScheduler extends AsyncScheduler {
      flush(action) {
          this.active = true;
          this.scheduled = undefined;
          const { actions } = this;
          let error;
          let index = -1;
          let count = actions.length;
          action = action || actions.shift();
          do {
              if (error = action.execute(action.state, action.delay)) {
                  break;
              }
          } while (++index < count && (action = actions.shift()));
          this.active = false;
          if (error) {
              while (++index < count && (action = actions.shift())) {
                  action.unsubscribe();
              }
              throw error;
          }
      }
  }

  const animationFrame = new AnimationFrameScheduler(AnimationFrameAction);

  function identity(x) {
      return x;
  }

  function map(project, thisArg) {
      return function mapOperation(source) {
          if (typeof project !== 'function') {
              throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
          }
          return source.lift(new MapOperator(project, thisArg));
      };
  }
  class MapOperator {
      constructor(project, thisArg) {
          this.project = project;
          this.thisArg = thisArg;
      }
      call(subscriber, source) {
          return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      }
  }
  class MapSubscriber extends Subscriber {
      constructor(destination, project, thisArg) {
          super(destination);
          this.project = project;
          this.count = 0;
          this.thisArg = thisArg || this;
      }
      _next(value) {
          let result;
          try {
              result = this.project.call(this.thisArg, value, this.count++);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.destination.next(result);
      }
  }

  class OuterSubscriber extends Subscriber {
      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
      }
      notifyError(error, innerSub) {
          this.destination.error(error);
      }
      notifyComplete(innerSub) {
          this.destination.complete();
      }
  }

  class InnerSubscriber extends Subscriber {
      constructor(parent, outerValue, outerIndex) {
          super();
          this.parent = parent;
          this.outerValue = outerValue;
          this.outerIndex = outerIndex;
          this.index = 0;
      }
      _next(value) {
          this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      }
      _error(error) {
          this.parent.notifyError(error, this);
          this.unsubscribe();
      }
      _complete() {
          this.parent.notifyComplete(this);
          this.unsubscribe();
      }
  }

  const subscribeToPromise = (promise) => (subscriber) => {
      promise.then((value) => {
          if (!subscriber.closed) {
              subscriber.next(value);
              subscriber.complete();
          }
      }, (err) => subscriber.error(err))
          .then(null, hostReportError);
      return subscriber;
  };

  function getSymbolIterator() {
      if (typeof Symbol !== 'function' || !Symbol.iterator) {
          return '@@iterator';
      }
      return Symbol.iterator;
  }
  const iterator = getSymbolIterator();

  const subscribeToIterable = (iterable) => (subscriber) => {
      const iterator$$1 = iterable[iterator]();
      do {
          const item = iterator$$1.next();
          if (item.done) {
              subscriber.complete();
              break;
          }
          subscriber.next(item.value);
          if (subscriber.closed) {
              break;
          }
      } while (true);
      if (typeof iterator$$1.return === 'function') {
          subscriber.add(() => {
              if (iterator$$1.return) {
                  iterator$$1.return();
              }
          });
      }
      return subscriber;
  };

  const subscribeToObservable = (obj) => (subscriber) => {
      const obs = obj[observable]();
      if (typeof obs.subscribe !== 'function') {
          throw new TypeError('Provided object does not correctly implement Symbol.observable');
      }
      else {
          return obs.subscribe(subscriber);
      }
  };

  const isArrayLike = ((x) => x && typeof x.length === 'number' && typeof x !== 'function');

  function isPromise$1(value) {
      return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
  }

  const subscribeTo = (result) => {
      if (result instanceof Observable) {
          return (subscriber) => {
              if (result._isScalar) {
                  subscriber.next(result.value);
                  subscriber.complete();
                  return undefined;
              }
              else {
                  return result.subscribe(subscriber);
              }
          };
      }
      else if (result && typeof result[observable] === 'function') {
          return subscribeToObservable(result);
      }
      else if (isArrayLike(result)) {
          return subscribeToArray(result);
      }
      else if (isPromise$1(result)) {
          return subscribeToPromise(result);
      }
      else if (result && typeof result[iterator] === 'function') {
          return subscribeToIterable(result);
      }
      else {
          const value = isObject(result) ? 'an invalid object' : `'${result}'`;
          const msg = `You provided ${value} where a stream was expected.`
              + ' You can provide an Observable, Promise, Array, or Iterable.';
          throw new TypeError(msg);
      }
  };

  function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex)) {
      if (destination.closed) {
          return;
      }
      return subscribeTo(result)(destination);
  }

  function isInteropObservable(input) {
      return input && typeof input[observable] === 'function';
  }

  function isIterable(input) {
      return input && typeof input[iterator] === 'function';
  }

  function fromPromise(input, scheduler) {
      if (!scheduler) {
          return new Observable(subscribeToPromise(input));
      }
      else {
          return new Observable(subscriber => {
              const sub = new Subscription();
              sub.add(scheduler.schedule(() => input.then(value => {
                  sub.add(scheduler.schedule(() => {
                      subscriber.next(value);
                      sub.add(scheduler.schedule(() => subscriber.complete()));
                  }));
              }, err => {
                  sub.add(scheduler.schedule(() => subscriber.error(err)));
              })));
              return sub;
          });
      }
  }

  function fromIterable(input, scheduler) {
      if (!input) {
          throw new Error('Iterable cannot be null');
      }
      if (!scheduler) {
          return new Observable(subscribeToIterable(input));
      }
      else {
          return new Observable(subscriber => {
              const sub = new Subscription();
              let iterator$$1;
              sub.add(() => {
                  if (iterator$$1 && typeof iterator$$1.return === 'function') {
                      iterator$$1.return();
                  }
              });
              sub.add(scheduler.schedule(() => {
                  iterator$$1 = input[iterator]();
                  sub.add(scheduler.schedule(function () {
                      if (subscriber.closed) {
                          return;
                      }
                      let value;
                      let done;
                      try {
                          const result = iterator$$1.next();
                          value = result.value;
                          done = result.done;
                      }
                      catch (err) {
                          subscriber.error(err);
                          return;
                      }
                      if (done) {
                          subscriber.complete();
                      }
                      else {
                          subscriber.next(value);
                          this.schedule();
                      }
                  }));
              }));
              return sub;
          });
      }
  }

  function fromObservable(input, scheduler) {
      if (!scheduler) {
          return new Observable(subscribeToObservable(input));
      }
      else {
          return new Observable(subscriber => {
              const sub = new Subscription();
              sub.add(scheduler.schedule(() => {
                  const observable$$1 = input[observable]();
                  sub.add(observable$$1.subscribe({
                      next(value) { sub.add(scheduler.schedule(() => subscriber.next(value))); },
                      error(err) { sub.add(scheduler.schedule(() => subscriber.error(err))); },
                      complete() { sub.add(scheduler.schedule(() => subscriber.complete())); },
                  }));
              }));
              return sub;
          });
      }
  }

  function from(input, scheduler) {
      if (!scheduler) {
          if (input instanceof Observable) {
              return input;
          }
          return new Observable(subscribeTo(input));
      }
      if (input != null) {
          if (isInteropObservable(input)) {
              return fromObservable(input, scheduler);
          }
          else if (isPromise$1(input)) {
              return fromPromise(input, scheduler);
          }
          else if (isArrayLike(input)) {
              return fromArray(input, scheduler);
          }
          else if (isIterable(input) || typeof input === 'string') {
              return fromIterable(input, scheduler);
          }
      }
      throw new TypeError((input !== null && typeof input || input) + ' is not observable');
  }

  function mergeMap(project, resultSelector, concurrent = Number.POSITIVE_INFINITY) {
      if (typeof resultSelector === 'function') {
          return (source) => source.pipe(mergeMap((a, i) => from(project(a, i)).pipe(map((b, ii) => resultSelector(a, b, i, ii))), concurrent));
      }
      else if (typeof resultSelector === 'number') {
          concurrent = resultSelector;
      }
      return (source) => source.lift(new MergeMapOperator(project, concurrent));
  }
  class MergeMapOperator {
      constructor(project, concurrent = Number.POSITIVE_INFINITY) {
          this.project = project;
          this.concurrent = concurrent;
      }
      call(observer, source) {
          return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      }
  }
  class MergeMapSubscriber extends OuterSubscriber {
      constructor(destination, project, concurrent = Number.POSITIVE_INFINITY) {
          super(destination);
          this.project = project;
          this.concurrent = concurrent;
          this.hasCompleted = false;
          this.buffer = [];
          this.active = 0;
          this.index = 0;
      }
      _next(value) {
          if (this.active < this.concurrent) {
              this._tryNext(value);
          }
          else {
              this.buffer.push(value);
          }
      }
      _tryNext(value) {
          let result;
          const index = this.index++;
          try {
              result = this.project(value, index);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.active++;
          this._innerSub(result, value, index);
      }
      _innerSub(ish, value, index) {
          const innerSubscriber = new InnerSubscriber(this, undefined, undefined);
          const destination = this.destination;
          destination.add(innerSubscriber);
          subscribeToResult(this, ish, value, index, innerSubscriber);
      }
      _complete() {
          this.hasCompleted = true;
          if (this.active === 0 && this.buffer.length === 0) {
              this.destination.complete();
          }
          this.unsubscribe();
      }
      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
      }
      notifyComplete(innerSub) {
          const buffer = this.buffer;
          this.remove(innerSub);
          this.active--;
          if (buffer.length > 0) {
              this._next(buffer.shift());
          }
          else if (this.active === 0 && this.hasCompleted) {
              this.destination.complete();
          }
      }
  }

  function mergeAll(concurrent = Number.POSITIVE_INFINITY) {
      return mergeMap(identity, concurrent);
  }

  function merge(...observables) {
      let concurrent = Number.POSITIVE_INFINITY;
      let scheduler = null;
      let last = observables[observables.length - 1];
      if (isScheduler(last)) {
          scheduler = observables.pop();
          if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
              concurrent = observables.pop();
          }
      }
      else if (typeof last === 'number') {
          concurrent = observables.pop();
      }
      if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
          return observables[0];
      }
      return mergeAll(concurrent)(fromArray(observables, scheduler));
  }

  function multicast(subjectOrSubjectFactory, selector) {
      return function multicastOperatorFunction(source) {
          let subjectFactory;
          if (typeof subjectOrSubjectFactory === 'function') {
              subjectFactory = subjectOrSubjectFactory;
          }
          else {
              subjectFactory = function subjectFactory() {
                  return subjectOrSubjectFactory;
              };
          }
          if (typeof selector === 'function') {
              return source.lift(new MulticastOperator(subjectFactory, selector));
          }
          const connectable = Object.create(source, connectableObservableDescriptor);
          connectable.source = source;
          connectable.subjectFactory = subjectFactory;
          return connectable;
      };
  }
  class MulticastOperator {
      constructor(subjectFactory, selector) {
          this.subjectFactory = subjectFactory;
          this.selector = selector;
      }
      call(subscriber, source) {
          const { selector } = this;
          const subject = this.subjectFactory();
          const subscription = selector(subject).subscribe(subscriber);
          subscription.add(source.subscribe(subject));
          return subscription;
      }
  }

  function shareSubjectFactory() {
      return new Subject();
  }
  function share() {
      return (source) => refCount()(multicast(shareSubjectFactory)(source));
  }

  /**
   * @license Angular v7.2.8
   * (c) 2010-2019 Google LLC. https://angular.io/
   * License: MIT
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @template T
   * @param {?} objWithPropertyToExtract
   * @return {?}
   */
  function getClosureSafeProperty(objWithPropertyToExtract) {
      for (let key in objWithPropertyToExtract) {
          if (objWithPropertyToExtract[key] === (/** @type {?} */ (getClosureSafeProperty))) {
              return key;
          }
      }
      throw Error('Could not find renamed property on target object.');
  }
  /**
   * Sets properties on a target object from a source object, but only if
   * the property doesn't already exist on the target object.
   * @param {?} target The target to set properties on
   * @param {?} source The source of the property keys and values to set
   * @return {?}
   */
  function fillProperties(target, source) {
      for (const key in source) {
          if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
              target[key] = source[key];
          }
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const NG_COMPONENT_DEF = getClosureSafeProperty({ ngComponentDef: getClosureSafeProperty });
  /** @type {?} */
  const NG_DIRECTIVE_DEF = getClosureSafeProperty({ ngDirectiveDef: getClosureSafeProperty });
  /** @type {?} */
  const NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });
  /** @type {?} */
  const NG_INJECTOR_DEF = getClosureSafeProperty({ ngInjectorDef: getClosureSafeProperty });
  /** @type {?} */
  const NG_PIPE_DEF = getClosureSafeProperty({ ngPipeDef: getClosureSafeProperty });
  /** @type {?} */
  const NG_MODULE_DEF = getClosureSafeProperty({ ngModuleDef: getClosureSafeProperty });
  /** @type {?} */
  const NG_BASE_DEF = getClosureSafeProperty({ ngBaseDef: getClosureSafeProperty });
  /**
   * If a directive is diPublic, bloomAdd sets a property on the type with this constant as
   * the key and the directive's unique ID as the value. This allows us to map directives to their
   * bloom filter bit for DI.
   * @type {?}
   */
  const NG_ELEMENT_ID = getClosureSafeProperty({ __NG_ELEMENT_ID__: getClosureSafeProperty });

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and
   * in which injectors (if any) it will be available.
   *
   * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an
   * `InjectableType`.
   *
   * Options:
   * * `providedIn` determines which injectors will include the injectable, by either associating it
   *   with an `\@NgModule` or other `InjectorType`, or by specifying that this injectable should be
   *   provided in the `'root'` injector, which will be the application-level injector in most apps.
   * * `factory` gives the zero argument function which will create an instance of the injectable.
   *   The factory can call `inject` to access the `Injector` and request injection of dependencies.
   *
   * \@publicApi
   * @template T
   * @param {?} opts
   * @return {?}
   */
  function defineInjectable(opts) {
      return (/** @type {?} */ (((/** @type {?} */ ({
          providedIn: (/** @type {?} */ (opts.providedIn)) || null, factory: opts.factory, value: undefined,
      })))));
  }
  /**
   * Construct an `InjectorDef` which configures an injector.
   *
   * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an
   * `InjectorType`.
   *
   * Options:
   *
   * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to
   *   create the type must be provided. If that factory function needs to inject arguments, it can
   *   use the `inject` function.
   * * `providers`: an optional array of providers to add to the injector. Each provider must
   *   either have a factory or point to a type which has an `ngInjectableDef` static property (the
   *   type must be an `InjectableType`).
   * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s
   *   whose providers will also be added to the injector. Locally provided types will override
   *   providers from imports.
   *
   * \@publicApi
   * @param {?} options
   * @return {?}
   */
  function defineInjector(options) {
      return (/** @type {?} */ (((/** @type {?} */ ({
          factory: options.factory, providers: options.providers || [], imports: options.imports || [],
      })))));
  }
  /**
   * Read the `ngInjectableDef` type in a way which is immune to accidentally reading inherited value.
   *
   * @template T
   * @param {?} type type which may have `ngInjectableDef`
   * @return {?}
   */
  function getInjectableDef(type) {
      return type && type.hasOwnProperty(NG_INJECTABLE_DEF) ? ((/** @type {?} */ (type)))[NG_INJECTABLE_DEF] : null;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Creates a token that can be used in a DI Provider.
   *
   * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
   * runtime representation) such as when injecting an interface, callable type, array or
   * parameterized type.
   *
   * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
   * the `Injector`. This provides additional level of type safety.
   *
   * ```
   * interface MyInterface {...}
   * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
   * // myInterface is inferred to be MyInterface.
   * ```
   *
   * When creating an `InjectionToken`, you can optionally specify a factory function which returns
   * (possibly by creating) a default value of the parameterized type `T`. This sets up the
   * `InjectionToken` using this factory as a provider as if it was defined explicitly in the
   * application's root injector. If the factory function, which takes zero arguments, needs to inject
   * dependencies, it can do so using the `inject` function. See below for an example.
   *
   * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which
   * overrides the above behavior and marks the token as belonging to a particular `\@NgModule`. As
   * mentioned above, `'root'` is the default value for `providedIn`.
   *
   * \@usageNotes
   * ### Basic Example
   *
   * ### Plain InjectionToken
   *
   * {\@example core/di/ts/injector_spec.ts region='InjectionToken'}
   *
   * ### Tree-shakable InjectionToken
   *
   * {\@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}
   *
   *
   * \@publicApi
   * @template T
   */
  class InjectionToken {
      /**
       * @param {?} _desc
       * @param {?=} options
       */
      constructor(_desc, options) {
          this._desc = _desc;
          /**
           * \@internal
           */
          this.ngMetadataName = 'InjectionToken';
          if (options !== undefined) {
              /** @nocollapse */ this.ngInjectableDef = defineInjectable({
                  providedIn: options.providedIn || 'root',
                  factory: options.factory,
              });
          }
          else {
              /** @nocollapse */ this.ngInjectableDef = undefined;
          }
      }
      /**
       * @return {?}
       */
      toString() { return `InjectionToken ${this._desc}`; }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const ANNOTATIONS = '__annotations__';
  /** @type {?} */
  const PARAMETERS = '__parameters__';
  /** @type {?} */
  const PROP_METADATA = '__prop__metadata__';
  /**
   * @suppress {globalThis}
   * @template T
   * @param {?} name
   * @param {?=} props
   * @param {?=} parentClass
   * @param {?=} additionalProcessing
   * @param {?=} typeFn
   * @return {?}
   */
  function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
      /** @type {?} */
      const metaCtor = makeMetadataCtor(props);
      /**
       * @param {...?} args
       * @return {?}
       */
      function DecoratorFactory(...args) {
          if (this instanceof DecoratorFactory) {
              metaCtor.call(this, ...args);
              return this;
          }
          /** @type {?} */
          const annotationInstance = new ((/** @type {?} */ (DecoratorFactory)))(...args);
          return function TypeDecorator(cls) {
              if (typeFn)
                  typeFn(cls, ...args);
              // Use of Object.defineProperty is important since it creates non-enumerable property which
              // prevents the property is copied during subclassing.
              /** @type {?} */
              const annotations = cls.hasOwnProperty(ANNOTATIONS) ?
                  ((/** @type {?} */ (cls)))[ANNOTATIONS] :
                  Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
              annotations.push(annotationInstance);
              if (additionalProcessing)
                  additionalProcessing(cls);
              return cls;
          };
      }
      if (parentClass) {
          DecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      DecoratorFactory.prototype.ngMetadataName = name;
      ((/** @type {?} */ (DecoratorFactory))).annotationCls = DecoratorFactory;
      return (/** @type {?} */ (DecoratorFactory));
  }
  /**
   * @param {?=} props
   * @return {?}
   */
  function makeMetadataCtor(props) {
      return function ctor(...args) {
          if (props) {
              /** @type {?} */
              const values = props(...args);
              for (const propName in values) {
                  this[propName] = values[propName];
              }
          }
      };
  }
  /**
   * @param {?} name
   * @param {?=} props
   * @param {?=} parentClass
   * @return {?}
   */
  function makeParamDecorator(name, props, parentClass) {
      /** @type {?} */
      const metaCtor = makeMetadataCtor(props);
      /**
       * @param {...?} args
       * @return {?}
       */
      function ParamDecoratorFactory(...args) {
          if (this instanceof ParamDecoratorFactory) {
              metaCtor.apply(this, args);
              return this;
          }
          /** @type {?} */
          const annotationInstance = new ((/** @type {?} */ (ParamDecoratorFactory)))(...args);
          ((/** @type {?} */ (ParamDecorator))).annotation = annotationInstance;
          return ParamDecorator;
          /**
           * @param {?} cls
           * @param {?} unusedKey
           * @param {?} index
           * @return {?}
           */
          function ParamDecorator(cls, unusedKey, index) {
              // Use of Object.defineProperty is important since it creates non-enumerable property which
              // prevents the property is copied during subclassing.
              /** @type {?} */
              const parameters = cls.hasOwnProperty(PARAMETERS) ?
                  ((/** @type {?} */ (cls)))[PARAMETERS] :
                  Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
              // there might be gaps if some in between parameters do not have annotations.
              // we pad with nulls.
              while (parameters.length <= index) {
                  parameters.push(null);
              }
              (parameters[index] = parameters[index] || []).push(annotationInstance);
              return cls;
          }
      }
      if (parentClass) {
          ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      ParamDecoratorFactory.prototype.ngMetadataName = name;
      ((/** @type {?} */ (ParamDecoratorFactory))).annotationCls = ParamDecoratorFactory;
      return ParamDecoratorFactory;
  }
  /**
   * @param {?} name
   * @param {?=} props
   * @param {?=} parentClass
   * @param {?=} additionalProcessing
   * @return {?}
   */
  function makePropDecorator(name, props, parentClass, additionalProcessing) {
      /** @type {?} */
      const metaCtor = makeMetadataCtor(props);
      /**
       * @param {...?} args
       * @return {?}
       */
      function PropDecoratorFactory(...args) {
          if (this instanceof PropDecoratorFactory) {
              metaCtor.apply(this, args);
              return this;
          }
          /** @type {?} */
          const decoratorInstance = new ((/** @type {?} */ (PropDecoratorFactory)))(...args);
          /**
           * @param {?} target
           * @param {?} name
           * @return {?}
           */
          function PropDecorator(target, name) {
              /** @type {?} */
              const constructor = target.constructor;
              // Use of Object.defineProperty is important since it creates non-enumerable property which
              // prevents the property is copied during subclassing.
              /** @type {?} */
              const meta = constructor.hasOwnProperty(PROP_METADATA) ?
                  ((/** @type {?} */ (constructor)))[PROP_METADATA] :
                  Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
              meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
              meta[name].unshift(decoratorInstance);
              if (additionalProcessing)
                  additionalProcessing(target, name, ...args);
          }
          return PropDecorator;
      }
      if (parentClass) {
          PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }
      PropDecoratorFactory.prototype.ngMetadataName = name;
      ((/** @type {?} */ (PropDecoratorFactory))).annotationCls = PropDecoratorFactory;
      return PropDecoratorFactory;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A DI token that you can use to create a virtual [provider](guide/glossary#provider)
   * that will populate the `entryComponents` field of components and NgModules
   * based on its `useValue` property value.
   * All components that are referenced in the `useValue` value (either directly
   * or in a nested array or map) are added to the `entryComponents` property.
   *
   * \@usageNotes
   *
   * The following example shows how the router can populate the `entryComponents`
   * field of an NgModule based on a router configuration that refers
   * to components.
   *
   * ```typescript
   * // helper function inside the router
   * function provideRoutes(routes) {
   *   return [
   *     {provide: ROUTES, useValue: routes},
   *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
   *   ];
   * }
   *
   * // user code
   * let routes = [
   *   {path: '/root', component: RootComp},
   *   {path: '/teams', component: TeamsComp}
   * ];
   *
   * \@NgModule({
   *   providers: [provideRoutes(routes)]
   * })
   * class ModuleWithRoutes {}
   * ```
   *
   * \@publicApi
   * @type {?}
   */
  const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Attribute decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Attribute$1 = makeParamDecorator('Attribute', (attributeName) => ({ attributeName }));
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Base class for query metadata.
   *
   * @see `ContentChildren`.
   * @see `ContentChild`.
   * @see `ViewChildren`.
   * @see `ViewChild`.
   *
   * \@publicApi
   * @abstract
   */
  class Query {
  }
  /**
   * ContentChildren decorator and metadata.
   *
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const ContentChildren = makePropDecorator('ContentChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: false, descendants: false }, data)), Query);
  /**
   * ContentChild decorator and metadata.
   *
   *
   * \@Annotation
   *
   * \@publicApi
   * @type {?}
   */
  const ContentChild = makePropDecorator('ContentChild', (selector, data = {}) => (Object.assign({ selector, first: true, isViewQuery: false, descendants: true }, data)), Query);
  /**
   * ViewChildren decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const ViewChildren = makePropDecorator('ViewChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: true, descendants: true }, data)), Query);
  /**
   * ViewChild decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const ViewChild = makePropDecorator('ViewChild', (selector, data) => (Object.assign({ selector, first: true, isViewQuery: true, descendants: true }, data)), Query);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @enum {number} */
  const ChangeDetectionStrategy$1 = {
      /**
       * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated
       * until reactivated by setting the strategy to `Default` (`CheckAlways`).
       * Change detection can still be explicitly invoked.
       */
      OnPush: 0,
      /**
       * Use the default `CheckAlways` strategy, in which change detection is automatic until
       * explicitly deactivated.
       */
      Default: 1,
  };
  ChangeDetectionStrategy$1[ChangeDetectionStrategy$1.OnPush] = 'OnPush';
  ChangeDetectionStrategy$1[ChangeDetectionStrategy$1.Default] = 'Default';

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @type {?} */
  const __window$1 = typeof window !== 'undefined' && window;
  /** @type {?} */
  const __self$1 = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
      self instanceof WorkerGlobalScope && self;
  /** @type {?} */
  const __global$1 = typeof global !== 'undefined' && global;
  // Check __global first, because in Node tests both __global and __window may be defined and _global
  // should be __global in that case.
  /** @type {?} */
  const _global$1 = __global$1 || __window$1 || __self$1;
  /** @type {?} */
  const promise = Promise.resolve(0);
  /** @type {?} */
  let _symbolIterator = null;
  /**
   * @return {?}
   */
  function getSymbolIterator$1() {
      if (!_symbolIterator) {
          /** @type {?} */
          const Symbol = _global$1['Symbol'];
          if (Symbol && Symbol.iterator) {
              _symbolIterator = Symbol.iterator;
          }
          else {
              // es6-shim specific logic
              /** @type {?} */
              const keys = Object.getOwnPropertyNames(Map.prototype);
              for (let i = 0; i < keys.length; ++i) {
                  /** @type {?} */
                  const key = keys[i];
                  if (key !== 'entries' && key !== 'size' &&
                      ((/** @type {?} */ (Map))).prototype[key] === Map.prototype['entries']) {
                      _symbolIterator = key;
                  }
              }
          }
      }
      return _symbolIterator;
  }
  /**
   * @param {?} fn
   * @return {?}
   */
  function scheduleMicroTask(fn) {
      if (typeof Zone === 'undefined') {
          // use promise to schedule microTask instead of use Zone
          promise.then(() => { fn && fn.apply(null, null); });
      }
      else {
          Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
      }
  }
  // JS has NaN !== NaN
  /**
   * @param {?} a
   * @param {?} b
   * @return {?}
   */
  function looseIdentical(a, b) {
      return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
  }
  /**
   * @param {?} token
   * @return {?}
   */
  function stringify$1(token) {
      if (typeof token === 'string') {
          return token;
      }
      if (token instanceof Array) {
          return '[' + token.map(stringify$1).join(', ') + ']';
      }
      if (token == null) {
          return '' + token;
      }
      if (token.overriddenName) {
          return `${token.overriddenName}`;
      }
      if (token.name) {
          return `${token.name}`;
      }
      /** @type {?} */
      const res = token.toString();
      if (res == null) {
          return '' + res;
      }
      /** @type {?} */
      const newLineIndex = res.indexOf('\n');
      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
  /**
   * Allows to refer to references which are not yet defined.
   *
   * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
   * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
   * a query is not yet defined.
   *
   * \@usageNotes
   * ### Example
   * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
   * \@publicApi
   * @param {?} forwardRefFn
   * @return {?}
   */
  function forwardRef(forwardRefFn) {
      ((/** @type {?} */ (forwardRefFn))).__forward_ref__ = forwardRef;
      ((/** @type {?} */ (forwardRefFn))).toString = function () { return stringify$1(this()); };
      return ((/** @type {?} */ ((/** @type {?} */ (forwardRefFn)))));
  }
  /**
   * Lazily retrieves the reference value from a forwardRef.
   *
   * Acts as the identity function when given a non-forward-ref value.
   *
   * \@usageNotes
   * ### Example
   *
   * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
   *
   * @see `forwardRef`
   * \@publicApi
   * @template T
   * @param {?} type
   * @return {?}
   */
  function resolveForwardRef$1(type) {
      /** @type {?} */
      const fn = type;
      if (typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&
          fn.__forward_ref__ === forwardRef) {
          return fn();
      }
      else {
          return type;
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @enum {number} */
  const ViewEncapsulation$1 = {
      /**
       * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
       * Element and pre-processing the style rules provided via {@link Component#styles styles} or
       * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all
       * selectors.
       *
       * This is the default option.
       */
      Emulated: 0,
      /**
       * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.
       * Use the native encapsulation mechanism of the renderer.
       *
       * For the DOM this means using the deprecated [Shadow DOM
       * v0](https://w3c.github.io/webcomponents/spec/shadow/) and
       * creating a ShadowRoot for Component's Host Element.
       */
      Native: 1,
      /**
       * Don't provide any template or style encapsulation.
       */
      None: 2,
      /**
       * Use Shadow DOM to encapsulate styles.
       *
       * For the DOM this means using modern [Shadow
       * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
       * creating a ShadowRoot for Component's Host Element.
       */
      ShadowDom: 3,
  };
  ViewEncapsulation$1[ViewEncapsulation$1.Emulated] = 'Emulated';
  ViewEncapsulation$1[ViewEncapsulation$1.Native] = 'Native';
  ViewEncapsulation$1[ViewEncapsulation$1.None] = 'None';
  ViewEncapsulation$1[ViewEncapsulation$1.ShadowDom] = 'ShadowDom';

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @return {?}
   */
  function ngDevModeResetPerfCounters() {
      /** @type {?} */
      const newCounters = {
          firstTemplatePass: 0,
          tNode: 0,
          tView: 0,
          rendererCreateTextNode: 0,
          rendererSetText: 0,
          rendererCreateElement: 0,
          rendererAddEventListener: 0,
          rendererSetAttribute: 0,
          rendererRemoveAttribute: 0,
          rendererSetProperty: 0,
          rendererSetClassName: 0,
          rendererAddClass: 0,
          rendererRemoveClass: 0,
          rendererSetStyle: 0,
          rendererRemoveStyle: 0,
          rendererDestroy: 0,
          rendererDestroyNode: 0,
          rendererMoveNode: 0,
          rendererRemoveNode: 0,
          rendererCreateComment: 0,
      };
      // NOTE: Under Ivy we may have both window & global defined in the Node
      //    environment since ensureDocument() in render3.ts sets global.window.
      if (typeof window != 'undefined') {
          // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.
          ((/** @type {?} */ (window)))['ngDevMode'] = newCounters;
      }
      if (typeof global != 'undefined') {
          // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.
          ((/** @type {?} */ (global)))['ngDevMode'] = newCounters;
      }
      if (typeof self != 'undefined') {
          // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.
          ((/** @type {?} */ (self)))['ngDevMode'] = newCounters;
      }
      return newCounters;
  }
  /**
   * This checks to see if the `ngDevMode` has been set. If yes,
   * than we honor it, otherwise we default to dev mode with additional checks.
   *
   * The idea is that unless we are doing production build where we explicitly
   * set `ngDevMode == false` we should be helping the developer by providing
   * as much early warning and errors as possible.
   */
  if (typeof ngDevMode === 'undefined' || ngDevMode) {
      ngDevModeResetPerfCounters();
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * This file contains reuseable "empty" symbols that can be used as default return values
   * in different parts of the rendering code. Because the same symbols are returned, this
   * allows for identity checks against these values to be consistently used by the framework
   * code.
   * @type {?}
   */
  const EMPTY_OBJ = {};
  /** @type {?} */
  const EMPTY_ARRAY$1 = [];
  // freezing the values prevents any code from accidentally inserting new values in
  if (typeof ngDevMode !== 'undefined' && ngDevMode) {
      Object.freeze(EMPTY_OBJ);
      Object.freeze(EMPTY_ARRAY$1);
  }
  /**
   * The following getter methods retrieve the definition form the type. Currently the retrieval
   * honors inheritance, but in the future we may change the rule to require that definitions are
   * explicit. This would require some sort of migration strategy.
   * @template T
   * @param {?} type
   * @return {?}
   */
  function getComponentDef(type) {
      return ((/** @type {?} */ (type)))[NG_COMPONENT_DEF] || null;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @template T
   * @param {?} actual
   * @param {?} expected
   * @param {?} msg
   * @return {?}
   */
  function assertEqual(actual, expected, msg) {
      if (actual != expected) {
          throwError$1(msg);
      }
  }
  /**
   * @template T
   * @param {?} actual
   * @param {?} expected
   * @param {?} msg
   * @return {?}
   */
  function assertNotEqual(actual, expected, msg) {
      if (actual == expected) {
          throwError$1(msg);
      }
  }
  /**
   * @template T
   * @param {?} actual
   * @param {?} expected
   * @param {?} msg
   * @return {?}
   */
  function assertLessThan(actual, expected, msg) {
      if (actual >= expected) {
          throwError$1(msg);
      }
  }
  /**
   * @template T
   * @param {?} actual
   * @param {?} expected
   * @param {?} msg
   * @return {?}
   */
  function assertGreaterThan(actual, expected, msg) {
      if (actual <= expected) {
          throwError$1(msg);
      }
  }
  /**
   * @template T
   * @param {?} actual
   * @param {?} msg
   * @return {?}
   */
  function assertDefined(actual, msg) {
      if (actual == null) {
          throwError$1(msg);
      }
  }
  /**
   * @param {?} actual
   * @param {?=} msg
   * @return {?}
   */
  function assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \'ngComponentDef\' property.') {
      if (!getComponentDef(actual)) {
          throwError$1(msg);
      }
  }
  /**
   * @param {?} msg
   * @return {?}
   */
  function throwError$1(msg) {
      // tslint:disable-next-line
      debugger; // Left intentionally for better debugger experience.
      throw new Error(`ASSERTION ERROR: ${msg}`);
  }
  /**
   * @param {?} isParent
   * @return {?}
   */
  function assertPreviousIsParent(isParent) {
      assertEqual(isParent, true, 'previousOrParentTNode should be a parent');
  }
  /**
   * @param {?} arr
   * @param {?} index
   * @return {?}
   */
  function assertDataInRange(arr, index) {
      assertLessThan(index, arr ? arr.length : 0, 'index expected to be a valid data index');
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // Below are constants for LView indices to help us look up LView members
  // without having to remember the specific indices.
  // Uglify will inline these when minifying so there shouldn't be a cost.
  /** @type {?} */
  const TVIEW = 0;
  /** @type {?} */
  const FLAGS = 1;
  /** @type {?} */
  const PARENT = 2;
  /** @type {?} */
  const NEXT = 3;
  /** @type {?} */
  const HOST = 5;
  /** @type {?} */
  const HOST_NODE = 6;
  // Rename to `T_HOST`?
  /** @type {?} */
  const BINDING_INDEX = 7;
  /** @type {?} */
  const CLEANUP = 8;
  /** @type {?} */
  const CONTEXT = 9;
  /** @type {?} */
  const INJECTOR = 10;
  /** @type {?} */
  const RENDERER_FACTORY = 11;
  /** @type {?} */
  const RENDERER = 12;
  /** @type {?} */
  const SANITIZER = 13;
  /** @type {?} */
  const TAIL = 14;
  /** @type {?} */
  const CONTAINER_INDEX = 15;
  /** @type {?} */
  const DECLARATION_VIEW = 17;
  /**
   * Size of LView's header. Necessary to adjust for it when setting slots.
   * @type {?}
   */
  const HEADER_OFFSET = 18;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Below are constants for LContainer indices to help us look up LContainer members
   * without having to remember the specific indices.
   * Uglify will inline these when minifying so there shouldn't be a cost.
   * @type {?}
   */
  const ACTIVE_INDEX = 0;
  /** @type {?} */
  const VIEWS = 1;
  // PARENT, NEXT, QUERIES, and HOST are indices 2, 3, 4, and 5.
  // As we already have these constants in LView, we don't need to re-create them.
  /** @type {?} */
  const NATIVE = 6;
  /** @type {?} */
  const RENDER_PARENT = 7;
  // Because interfaces in TS/JS cannot be instanceof-checked this means that we
  // need to rely on predictable characteristics of data-structures to check if they
  // are what we expect for them to be. The `LContainer` interface code below has a
  // fixed length and the constant value below references that. Using the length value
  // below we can predictably gaurantee that we are dealing with an `LContainer` array.
  // This value MUST be kept up to date with the length of the `LContainer` array
  // interface below so that runtime type checking can work.
  /** @type {?} */
  const LCONTAINER_LENGTH = 8;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * This property will be monkey-patched on elements, components and directives
   * @type {?}
   */
  const MONKEY_PATCH_KEY_NAME = '__ngContext__';

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @type {?} */
  const TNODE = 8;
  /** @type {?} */
  const PARENT_INJECTOR = 8;
  /** @type {?} */
  const INJECTOR_BLOOM_PARENT_SIZE = 9;
  /** @type {?} */
  const NO_PARENT_INJECTOR = (/** @type {?} */ (-1));
  /**
   * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in
   * `TView.data`. This allows us to store information about the current node's tokens (which
   * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be
   * shared, so they live in `LView`).
   *
   * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter
   * determines whether a directive is available on the associated node or not. This prevents us
   * from searching the directives array at this level unless it's probable the directive is in it.
   *
   * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.
   *
   * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed
   * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`
   * will differ based on where it is flattened into the main array, so it's not possible to know
   * the indices ahead of time and save their types here. The interfaces are still included here
   * for documentation purposes.
   *
   * export interface LInjector extends Array<any> {
   *
   *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)
   *    [0]: number;
   *
   *    // Cumulative bloom for directive IDs 32-63
   *    [1]: number;
   *
   *    // Cumulative bloom for directive IDs 64-95
   *    [2]: number;
   *
   *    // Cumulative bloom for directive IDs 96-127
   *    [3]: number;
   *
   *    // Cumulative bloom for directive IDs 128-159
   *    [4]: number;
   *
   *    // Cumulative bloom for directive IDs 160 - 191
   *    [5]: number;
   *
   *    // Cumulative bloom for directive IDs 192 - 223
   *    [6]: number;
   *
   *    // Cumulative bloom for directive IDs 224 - 255
   *    [7]: number;
   *
   *    // We need to store a reference to the injector's parent so DI can keep looking up
   *    // the injector tree until it finds the dependency it's looking for.
   *    [PARENT_INJECTOR]: number;
   * }
   *
   * export interface TInjector extends Array<any> {
   *
   *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)
   *    [0]: number;
   *
   *    // Shared node bloom for directive IDs 32-63
   *    [1]: number;
   *
   *    // Shared node bloom for directive IDs 64-95
   *    [2]: number;
   *
   *    // Shared node bloom for directive IDs 96-127
   *    [3]: number;
   *
   *    // Shared node bloom for directive IDs 128-159
   *    [4]: number;
   *
   *    // Shared node bloom for directive IDs 160 - 191
   *    [5]: number;
   *
   *    // Shared node bloom for directive IDs 192 - 223
   *    [6]: number;
   *
   *    // Shared node bloom for directive IDs 224 - 255
   *    [7]: number;
   *
   *    // Necessary to find directive indices for a particular node.
   *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;
   *  }
   */
  /**
   * Factory for creating instances of injectors in the NodeInjector.
   *
   * This factory is complicated by the fact that it can resolve `multi` factories as well.
   *
   * NOTE: Some of the fields are optional which means that this class has two hidden classes.
   * - One without `multi` support (most common)
   * - One with `multi` values, (rare).
   *
   * Since VMs can cache up to 4 inline hidden classes this is OK.
   *
   * - Single factory: Only `resolving` and `factory` is defined.
   * - `providers` factory: `componentProviders` is a number and `index = -1`.
   * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.
   */
  class NodeInjectorFactory {
      /**
       * @param {?} factory
       * @param {?} isViewProvider
       * @param {?} injectImplementation
       */
      constructor(factory, 
      /**
       * Set to `true` if the token is declared in `viewProviders` (or if it is component).
       */
      isViewProvider, injectImplementation) {
          this.factory = factory;
          /**
           * Marker set to true during factory invocation to see if we get into recursive loop.
           * Recursive loop causes an error to be displayed.
           */
          this.resolving = false;
          this.canSeeViewProviders = isViewProvider;
          this.injectImpl = injectImplementation;
      }
  }
  /** @type {?} */
  const FactoryPrototype = NodeInjectorFactory.prototype;
  /**
   * @param {?} obj
   * @return {?}
   */
  function isFactory(obj) {
      // See: https://jsperf.com/instanceof-vs-getprototypeof
      return obj != null && typeof obj == 'object' && Object.getPrototypeOf(obj) == FactoryPrototype;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function stringify$1$1(value) {
      if (typeof value == 'function')
          return value.name || value;
      if (typeof value == 'string')
          return value;
      if (value == null)
          return '';
      if (typeof value == 'object' && typeof value.type == 'function')
          return value.type.name || value.type;
      return '' + value;
  }
  /**
   * Flattens an array in non-recursive way. Input arrays are not modified.
   * @param {?} list
   * @return {?}
   */
  function flatten$1(list) {
      /** @type {?} */
      const result = [];
      /** @type {?} */
      let i = 0;
      while (i < list.length) {
          /** @type {?} */
          const item = list[i];
          if (Array.isArray(item)) {
              if (item.length > 0) {
                  list = item.concat(list.slice(i + 1));
                  i = 0;
              }
              else {
                  i++;
              }
          }
          else {
              result.push(item);
              i++;
          }
      }
      return result;
  }
  /**
   * Takes the value of a slot in `LView` and returns the element node.
   *
   * Normally, element nodes are stored flat, but if the node has styles/classes on it,
   * it might be wrapped in a styling context. Or if that node has a directive that injects
   * ViewContainerRef, it may be wrapped in an LContainer. Or if that node is a component,
   * it will be wrapped in LView. It could even have all three, so we keep looping
   * until we find something that isn't an array.
   *
   * @param {?} value The initial value in `LView`
   * @return {?}
   */
  function readElementValue(value) {
      while (Array.isArray(value)) {
          value = (/** @type {?} */ (value[HOST]));
      }
      return value;
  }
  /**
   * @param {?} tNode
   * @param {?} hostView
   * @return {?}
   */
  function getNativeByTNode(tNode, hostView) {
      return readElementValue(hostView[tNode.index]);
  }
  /**
   * @param {?} index
   * @param {?} view
   * @return {?}
   */
  function getTNode(index, view) {
      ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');
      ngDevMode && assertLessThan(index, view[TVIEW].data.length, 'wrong index for TNode');
      return (/** @type {?} */ (view[TVIEW].data[index + HEADER_OFFSET]));
  }
  /**
   * @param {?} nodeIndex
   * @param {?} hostView
   * @return {?}
   */
  function getComponentViewByIndex(nodeIndex, hostView) {
      // Could be an LView or an LContainer. If LContainer, unwrap to find LView.
      /** @type {?} */
      const slotValue = hostView[nodeIndex];
      return slotValue.length >= HEADER_OFFSET ? slotValue : slotValue[HOST];
  }
  /**
   * @param {?} tNode
   * @return {?}
   */
  function isComponent(tNode) {
      return (tNode.flags & 1 /* isComponent */) === 1 /* isComponent */;
  }
  /**
   * @template T
   * @param {?} def
   * @return {?}
   */
  function isComponentDef(def) {
      return ((/** @type {?} */ (def))).template !== null;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function isLContainer(value) {
      // Styling contexts are also arrays, but their first index contains an element node
      return Array.isArray(value) && value.length === LCONTAINER_LENGTH;
  }
  /**
   * Retrieve the root view from any component by walking the parent `LView` until
   * reaching the root `LView`.
   *
   * @param {?} target
   * @return {?}
   */
  function getRootView(target) {
      ngDevMode && assertDefined(target, 'component');
      /** @type {?} */
      let lView = Array.isArray(target) ? ((/** @type {?} */ (target))) : (/** @type {?} */ (readPatchedLView(target)));
      while (lView && !(lView[FLAGS] & 128 /* IsRoot */)) {
          lView = (/** @type {?} */ (lView[PARENT]));
      }
      return lView;
  }
  /**
   * @param {?} viewOrComponent
   * @return {?}
   */
  function getRootContext(viewOrComponent) {
      /** @type {?} */
      const rootView = getRootView(viewOrComponent);
      ngDevMode &&
          assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');
      return (/** @type {?} */ (rootView[CONTEXT]));
  }
  /**
   * Returns the monkey-patch value data present on the target (which could be
   * a component, directive or a DOM node).
   * @param {?} target
   * @return {?}
   */
  function readPatchedData(target) {
      ngDevMode && assertDefined(target, 'Target expected');
      return target[MONKEY_PATCH_KEY_NAME];
  }
  /**
   * @param {?} target
   * @return {?}
   */
  function readPatchedLView(target) {
      /** @type {?} */
      const value = readPatchedData(target);
      if (value) {
          return Array.isArray(value) ? value : ((/** @type {?} */ (value))).lView;
      }
      return null;
  }
  /**
   * @param {?} parentLocation
   * @return {?}
   */
  function hasParentInjector(parentLocation) {
      return parentLocation !== NO_PARENT_INJECTOR;
  }
  /**
   * @param {?} parentLocation
   * @return {?}
   */
  function getParentInjectorIndex(parentLocation) {
      return ((/** @type {?} */ ((/** @type {?} */ (parentLocation))))) & 32767 /* InjectorIndexMask */;
  }
  /**
   * @param {?} parentLocation
   * @return {?}
   */
  function getParentInjectorViewOffset(parentLocation) {
      return ((/** @type {?} */ ((/** @type {?} */ (parentLocation))))) >> 16 /* ViewOffsetShift */;
  }
  /**
   * Unwraps a parent injector location number to find the view offset from the current injector,
   * then walks up the declaration view tree until the view is found that contains the parent
   * injector.
   *
   * @param {?} location The location of the parent injector, which contains the view offset
   * @param {?} startView The LView instance from which to start walking up the view tree
   * @return {?} The LView instance that contains the parent injector
   */
  function getParentInjectorView(location, startView) {
      /** @type {?} */
      let viewOffset = getParentInjectorViewOffset(location);
      /** @type {?} */
      let parentView = startView;
      // For most cases, the parent injector can be found on the host node (e.g. for component
      // or container), but we must keep the loop here to support the rarer case of deeply nested
      // <ng-template> tags or inline views, where the parent injector might live many views
      // above the child injector.
      while (viewOffset > 0) {
          parentView = (/** @type {?} */ (parentView[DECLARATION_VIEW]));
          viewOffset--;
      }
      return parentView;
  }
  /** @type {?} */
  const defaultScheduler = (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame || // browser only
      setTimeout // everything else
  ).bind(_global$1);
  /**
   * Given a current view, finds the nearest component's host (LElement).
   *
   * @param {?} lView LView for which we want a host element node
   * @return {?} The host node
   */
  function findComponentView(lView) {
      /** @type {?} */
      let rootTNode = lView[HOST_NODE];
      while (rootTNode && rootTNode.type === 2 /* View */) {
          ngDevMode && assertDefined(lView[DECLARATION_VIEW], 'lView[DECLARATION_VIEW]');
          lView = (/** @type {?} */ (lView[DECLARATION_VIEW]));
          rootTNode = lView[HOST_NODE];
      }
      return lView;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Inject decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Inject = makeParamDecorator('Inject', (token) => ({ token }));
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Optional decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Optional = makeParamDecorator('Optional');
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Self decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Self = makeParamDecorator('Self');
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * SkipSelf decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const SkipSelf = makeParamDecorator('SkipSelf');
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Host decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Host = makeParamDecorator('Host');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @enum {number} */
  const InjectFlags = {
      // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.
      Default: 0,
      /**
       * Specifies that an injector should retrieve a dependency from any injector until reaching the
       * host element of the current component. (Only used with Element Injector)
       */
      Host: 1,
      /** Don't descend into ancestors of the node requesting injection. */
      Self: 2,
      /** Skip the node that is requesting injection. */
      SkipSelf: 4,
      /** Inject `defaultValue` instead if token not found. */
      Optional: 8,
  };
  InjectFlags[InjectFlags.Default] = 'Default';
  InjectFlags[InjectFlags.Host] = 'Host';
  InjectFlags[InjectFlags.Self] = 'Self';
  InjectFlags[InjectFlags.SkipSelf] = 'SkipSelf';
  InjectFlags[InjectFlags.Optional] = 'Optional';
  /**
   * Current injector value used by `inject`.
   * - `undefined`: it is an error to call `inject`
   * - `null`: `inject` can be called but there is no injector (limp-mode).
   * - Injector instance: Use the injector for resolution.
   * @type {?}
   */
  let _currentInjector = undefined;
  /**
   * @param {?} injector
   * @return {?}
   */
  function setCurrentInjector(injector) {
      /** @type {?} */
      const former = _currentInjector;
      _currentInjector = injector;
      return former;
  }
  /**
   * Current implementation of inject.
   *
   * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed
   * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this
   * way for two reasons:
   *  1. `Injector` should not depend on ivy logic.
   *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.
   * @type {?}
   */
  let _injectImplementation;
  /**
   * Sets the current inject implementation.
   * @param {?} impl
   * @return {?}
   */
  function setInjectImplementation(impl) {
      /** @type {?} */
      const previous = _injectImplementation;
      _injectImplementation = impl;
      return previous;
  }
  /**
   * @template T
   * @param {?} token
   * @param {?=} flags
   * @return {?}
   */
  function injectInjectorOnly(token, flags = InjectFlags.Default) {
      if (_currentInjector === undefined) {
          throw new Error(`inject() must be called from an injection context`);
      }
      else if (_currentInjector === null) {
          return injectRootLimpMode(token, undefined, flags);
      }
      else {
          return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);
      }
  }
  /**
   * @template T
   * @param {?} token
   * @param {?=} flags
   * @return {?}
   */
  function inject(token, flags = InjectFlags.Default) {
      return (_injectImplementation || injectInjectorOnly)(token, flags);
  }
  /**
   * Injects `root` tokens in limp mode.
   *
   * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to
   * `"root"`. This is known as the limp mode injection. In such case the value is stored in the
   * `InjectableDef`.
   * @template T
   * @param {?} token
   * @param {?} notFoundValue
   * @param {?} flags
   * @return {?}
   */
  function injectRootLimpMode(token, notFoundValue, flags) {
      /** @type {?} */
      const injectableDef = getInjectableDef(token);
      if (injectableDef && injectableDef.providedIn == 'root') {
          return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :
              injectableDef.value;
      }
      if (flags & InjectFlags.Optional)
          return null;
      if (notFoundValue !== undefined)
          return notFoundValue;
      throw new Error(`Injector: NOT_FOUND [${stringify$1(token)}]`);
  }
  /**
   * @param {?} types
   * @return {?}
   */
  function injectArgs(types) {
      /** @type {?} */
      const args = [];
      for (let i = 0; i < types.length; i++) {
          /** @type {?} */
          const arg = types[i];
          if (Array.isArray(arg)) {
              if (arg.length === 0) {
                  throw new Error('Arguments array must have arguments.');
              }
              /** @type {?} */
              let type = undefined;
              /** @type {?} */
              let flags = InjectFlags.Default;
              for (let j = 0; j < arg.length; j++) {
                  /** @type {?} */
                  const meta = arg[j];
                  if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {
                      flags |= InjectFlags.Optional;
                  }
                  else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {
                      flags |= InjectFlags.SkipSelf;
                  }
                  else if (meta instanceof Self || meta.ngMetadataName === 'Self') {
                      flags |= InjectFlags.Self;
                  }
                  else if (meta instanceof Inject) {
                      type = meta.token;
                  }
                  else {
                      type = meta;
                  }
              }
              args.push(inject((/** @type {?} */ (type)), flags));
          }
          else {
              args.push(inject(arg));
          }
      }
      return args;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} tNode
   * @param {?} type
   * @return {?}
   */
  function assertNodeType(tNode, type) {
      assertDefined(tNode, 'should be called with a TNode');
      assertEqual(tNode.type, type, `should be a ${typeName(type)}`);
  }
  /**
   * @param {?} type
   * @return {?}
   */
  function typeName(type) {
      if (type == 1 /* Projection */)
          return 'Projection';
      if (type == 0 /* Container */)
          return 'Container';
      if (type == 2 /* View */)
          return 'View';
      if (type == 3 /* Element */)
          return 'Element';
      if (type == 4 /* ElementContainer */)
          return 'ElementContainer';
      return '<unknown>';
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * If this is the first template pass, any ngOnInit or ngDoCheck hooks will be queued into
   * TView.initHooks during directiveCreate.
   *
   * The directive index and hook type are encoded into one number (1st bit: type, remaining bits:
   * directive index), then saved in the even indices of the initHooks array. The odd indices
   * hold the hook functions themselves.
   *
   * @param {?} index The index of the directive in LView
   * @param {?} onInit
   * @param {?} doCheck
   * @param {?} tView The current TView
   * @return {?}
   */
  function queueInitHooks(index, onInit, doCheck, tView) {
      ngDevMode &&
          assertEqual(tView.firstTemplatePass, true, 'Should only be called on first template pass');
      if (onInit) {
          (tView.initHooks || (tView.initHooks = [])).push(index, onInit);
      }
      if (doCheck) {
          (tView.initHooks || (tView.initHooks = [])).push(index, doCheck);
          (tView.checkHooks || (tView.checkHooks = [])).push(index, doCheck);
      }
  }
  /**
   * Loops through the directives on a node and queues all their hooks except ngOnInit
   * and ngDoCheck, which are queued separately in directiveCreate.
   * @param {?} tView
   * @param {?} tNode
   * @return {?}
   */
  function queueLifecycleHooks(tView, tNode) {
      if (tView.firstTemplatePass) {
          // It's necessary to loop through the directives at elementEnd() (rather than processing in
          // directiveCreate) so we can preserve the current hook order. Content, view, and destroy
          // hooks for projected components and directives must be called *before* their hosts.
          for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
              /** @type {?} */
              const def = (/** @type {?} */ (tView.data[i]));
              queueContentHooks(def, tView, i);
              queueViewHooks(def, tView, i);
              queueDestroyHooks(def, tView, i);
          }
      }
  }
  /**
   * Queues afterContentInit and afterContentChecked hooks on TView
   * @param {?} def
   * @param {?} tView
   * @param {?} i
   * @return {?}
   */
  function queueContentHooks(def, tView, i) {
      if (def.afterContentInit) {
          (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentInit);
      }
      if (def.afterContentChecked) {
          (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentChecked);
          (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, def.afterContentChecked);
      }
  }
  /**
   * Queues afterViewInit and afterViewChecked hooks on TView
   * @param {?} def
   * @param {?} tView
   * @param {?} i
   * @return {?}
   */
  function queueViewHooks(def, tView, i) {
      if (def.afterViewInit) {
          (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewInit);
      }
      if (def.afterViewChecked) {
          (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewChecked);
          (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, def.afterViewChecked);
      }
  }
  /**
   * Queues onDestroy hooks on TView
   * @param {?} def
   * @param {?} tView
   * @param {?} i
   * @return {?}
   */
  function queueDestroyHooks(def, tView, i) {
      if (def.onDestroy != null) {
          (tView.destroyHooks || (tView.destroyHooks = [])).push(i, def.onDestroy);
      }
  }
  /**
   * Calls onInit and doCheck calls if they haven't already been called.
   *
   * @param {?} currentView The current view
   * @param {?} tView
   * @param {?} checkNoChangesMode
   * @return {?}
   */
  function executeInitHooks(currentView, tView, checkNoChangesMode) {
      if (!checkNoChangesMode && currentView[FLAGS] & 32 /* RunInit */) {
          executeHooks(currentView, tView.initHooks, tView.checkHooks, checkNoChangesMode);
          currentView[FLAGS] &= ~32 /* RunInit */;
      }
  }
  /**
   * Iterates over afterViewInit and afterViewChecked functions and calls them.
   *
   * @param {?} currentView The current view
   * @param {?} allHooks
   * @param {?} checkHooks
   * @param {?} checkNoChangesMode
   * @return {?}
   */
  function executeHooks(currentView, allHooks, checkHooks, checkNoChangesMode) {
      if (checkNoChangesMode)
          return;
      /** @type {?} */
      const hooksToCall = currentView[FLAGS] & 2 /* FirstLViewPass */ ? allHooks : checkHooks;
      if (hooksToCall) {
          callHooks(currentView, hooksToCall);
      }
  }
  /**
   * Calls lifecycle hooks with their contexts, skipping init hooks if it's not
   * the first LView pass.
   *
   * @param {?} currentView The current view
   * @param {?} arr The array in which the hooks are found
   * @return {?}
   */
  function callHooks(currentView, arr) {
      for (let i = 0; i < arr.length; i += 2) {
          ((/** @type {?} */ (arr[i + 1]))).call(currentView[(/** @type {?} */ (arr[i]))]);
      }
  }
  /**
   * @return {?}
   */
  function getLView() {
      return lView;
  }
  /**
   * Used to set the parent property when nodes are created and track query results.
   * @type {?}
   */
  let previousOrParentTNode;
  /**
   * @return {?}
   */
  function getPreviousOrParentTNode() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return previousOrParentTNode;
  }
  /**
   * @param {?} tNode
   * @return {?}
   */
  function setPreviousOrParentTNode(tNode) {
      previousOrParentTNode = tNode;
  }
  /**
   * @param {?} tNode
   * @param {?} view
   * @return {?}
   */
  function setTNodeAndViewData(tNode, view) {
      previousOrParentTNode = tNode;
      lView = view;
  }
  /**
   * If `isParent` is:
   *  - `true`: then `previousOrParentTNode` points to a parent node.
   *  - `false`: then `previousOrParentTNode` points to previous node (sibling).
   * @type {?}
   */
  let isParent;
  /**
   * @return {?}
   */
  function getIsParent() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return isParent;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function setIsParent(value) {
      isParent = value;
  }
  /**
   * Checks whether a given view is in creation mode
   * @param {?=} view
   * @return {?}
   */
  function isCreationMode(view = lView) {
      return (view[FLAGS] & 1 /* CreationMode */) === 1 /* CreationMode */;
  }
  /**
   * State of the current view being processed.
   *
   * An array of nodes (text, element, container, etc), pipes, their bindings, and
   * any local variables that need to be stored between invocations.
   * @type {?}
   */
  let lView;
  /**
   * The last viewData retrieved by nextContext().
   * Allows building nextContext() and reference() calls.
   *
   * e.g. const inner = x().$implicit; const outer = x().$implicit;
   * @type {?}
   */
  let contextLView = (/** @type {?} */ (null));
  /**
   * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.
   *
   * Necessary to support ChangeDetectorRef.checkNoChanges().
   * @type {?}
   */
  let checkNoChangesMode = false;
  /**
   * @return {?}
   */
  function getCheckNoChangesMode() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return checkNoChangesMode;
  }
  /**
   * @param {?} mode
   * @return {?}
   */
  function setCheckNoChangesMode(mode) {
      checkNoChangesMode = mode;
  }
  /**
   * Whether or not this is the first time the current view has been processed.
   * @type {?}
   */
  let firstTemplatePass = true;
  /**
   * @return {?}
   */
  function getFirstTemplatePass() {
      return firstTemplatePass;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function setFirstTemplatePass(value) {
      firstTemplatePass = value;
  }
  /**
   * The root index from which pure function instructions should calculate their binding
   * indices. In component views, this is TView.bindingStartIndex. In a host binding
   * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.
   * @type {?}
   */
  let bindingRootIndex = -1;
  /**
   * @param {?} value
   * @return {?}
   */
  function setBindingRoot(value) {
      bindingRootIndex = value;
  }
  /**
   * Swap the current state with a new state.
   *
   * For performance reasons we store the state in the top level of the module.
   * This way we minimize the number of properties to read. Whenever a new view
   * is entered we have to store the state for later, and when the view is
   * exited the state has to be restored
   *
   * @param {?} newView New state to become active
   * @param {?} hostTNode
   * @return {?} the previous state;
   */
  function enterView(newView, hostTNode) {
      /** @type {?} */
      const oldView = lView;
      if (newView) {
          /** @type {?} */
          const tView = newView[TVIEW];
          firstTemplatePass = tView.firstTemplatePass;
          bindingRootIndex = tView.bindingStartIndex;
      }
      previousOrParentTNode = (/** @type {?} */ (hostTNode));
      isParent = true;
      lView = contextLView = newView;
      return oldView;
  }
  /**
   * Resets the application state.
   * @return {?}
   */
  function resetComponentState() {
      isParent = false;
      previousOrParentTNode = (/** @type {?} */ (null));
  }
  /**
   * Used in lieu of enterView to make it clear when we are exiting a child view. This makes
   * the direction of traversal (up or down the view tree) a bit clearer.
   *
   * @param {?} newView New state to become active
   * @return {?}
   */
  function leaveView(newView) {
      /** @type {?} */
      const tView = lView[TVIEW];
      if (isCreationMode(lView)) {
          lView[FLAGS] &= ~1 /* CreationMode */;
      }
      else {
          executeHooks(lView, tView.viewHooks, tView.viewCheckHooks, checkNoChangesMode);
          // Views are clean and in update mode after being checked, so these bits are cleared
          lView[FLAGS] &= ~(8 /* Dirty */ | 2 /* FirstLViewPass */);
          lView[FLAGS] |= 32 /* RunInit */;
          lView[BINDING_INDEX] = tView.bindingStartIndex;
      }
      enterView(newView, null);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Defines if the call to `inject` should include `viewProviders` in its resolution.
   *
   * This is set to true when we try to instantiate a component. This value is reset in
   * `getNodeInjectable` to a value which matches the declaration location of the token about to be
   * instantiated. This is done so that if we are injecting a token which was declared outside of
   * `viewProviders` we don't accidentally pull `viewProviders` in.
   *
   * Example:
   *
   * ```
   * \@Injectable()
   * class MyService {
   *   constructor(public value: String) {}
   * }
   *
   * \@Component({
   *   providers: [
   *     MyService,
   *     {provide: String, value: 'providers' }
   *   ]
   *   viewProviders: [
   *     {provide: String, value: 'viewProviders'}
   *   ]
   * })
   * class MyComponent {
   *   constructor(myService: MyService, value: String) {
   *     // We expect that Component can see into `viewProviders`.
   *     expect(value).toEqual('viewProviders');
   *     // `MyService` was not declared in `viewProviders` hence it can't see it.
   *     expect(myService.value).toEqual('providers');
   *   }
   * }
   *
   * ```
   * @type {?}
   */
  let includeViewProviders = true;
  /**
   * @param {?} v
   * @return {?}
   */
  function setIncludeViewProviders(v) {
      /** @type {?} */
      const oldValue = includeViewProviders;
      includeViewProviders = v;
      return oldValue;
  }
  /**
   * The number of slots in each bloom filter (used by DI). The larger this number, the fewer
   * directives that will share slots, and thus, the fewer false positives when checking for
   * the existence of a directive.
   * @type {?}
   */
  const BLOOM_SIZE = 256;
  /** @type {?} */
  const BLOOM_MASK = BLOOM_SIZE - 1;
  /**
   * Counter used to generate unique IDs for directives.
   * @type {?}
   */
  let nextNgElementId = 0;
  /**
   * Registers this directive as present in its node's injector by flipping the directive's
   * corresponding bit in the injector's bloom filter.
   *
   * @param {?} injectorIndex The index of the node injector where this token should be registered
   * @param {?} tView The TView for the injector's bloom filters
   * @param {?} type The directive token to register
   * @return {?}
   */
  function bloomAdd(injectorIndex, tView, type) {
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'expected firstTemplatePass to be true');
      /** @type {?} */
      let id = typeof type !== 'string' ? ((/** @type {?} */ (type)))[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;
      // Set a unique ID on the directive type, so if something tries to inject the directive,
      // we can easily retrieve the ID and hash it into the bloom bit that should be checked.
      if (id == null) {
          id = ((/** @type {?} */ (type)))[NG_ELEMENT_ID] = nextNgElementId++;
      }
      // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),
      // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.
      /** @type {?} */
      const bloomBit = id & BLOOM_MASK;
      // Create a mask that targets the specific bit associated with the directive.
      // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding
      // to bit positions 0 - 31 in a 32 bit integer.
      /** @type {?} */
      const mask = 1 << bloomBit;
      // Use the raw bloomBit number to determine which bloom filter bucket we should check
      // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc
      /** @type {?} */
      const b7 = bloomBit & 0x80;
      /** @type {?} */
      const b6 = bloomBit & 0x40;
      /** @type {?} */
      const b5 = bloomBit & 0x20;
      /** @type {?} */
      const tData = (/** @type {?} */ (tView.data));
      if (b7) {
          b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :
              (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));
      }
      else {
          b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :
              (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));
      }
  }
  /**
   * Creates (or gets an existing) injector for a given element or container.
   *
   * @param {?} tNode for which an injector should be retrieved / created.
   * @param {?} hostView View where the node is stored
   * @return {?} Node injector
   */
  function getOrCreateNodeInjectorForNode(tNode, hostView) {
      /** @type {?} */
      const existingInjectorIndex = getInjectorIndex(tNode, hostView);
      if (existingInjectorIndex !== -1) {
          return existingInjectorIndex;
      }
      /** @type {?} */
      const tView = hostView[TVIEW];
      if (tView.firstTemplatePass) {
          tNode.injectorIndex = hostView.length;
          insertBloom(tView.data, tNode); // foundation for node bloom
          insertBloom(hostView, null); // foundation for cumulative bloom
          insertBloom(tView.blueprint, null);
          ngDevMode && assertEqual(tNode.flags === 0 || tNode.flags === 1 /* isComponent */, true, 'expected tNode.flags to not be initialized');
      }
      /** @type {?} */
      const parentLoc = getParentInjectorLocation(tNode, hostView);
      /** @type {?} */
      const parentIndex = getParentInjectorIndex(parentLoc);
      /** @type {?} */
      const parentLView = getParentInjectorView(parentLoc, hostView);
      /** @type {?} */
      const injectorIndex = tNode.injectorIndex;
      // If a parent injector can't be found, its location is set to -1.
      // In that case, we don't need to set up a cumulative bloom
      if (hasParentInjector(parentLoc)) {
          /** @type {?} */
          const parentData = (/** @type {?} */ (parentLView[TVIEW].data));
          // Creates a cumulative bloom filter that merges the parent's bloom filter
          // and its own cumulative bloom (which contains tokens for all ancestors)
          for (let i = 0; i < 8; i++) {
              hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
          }
      }
      hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;
      return injectorIndex;
  }
  /**
   * @param {?} arr
   * @param {?} footer
   * @return {?}
   */
  function insertBloom(arr, footer) {
      arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
  }
  /**
   * @param {?} tNode
   * @param {?} hostView
   * @return {?}
   */
  function getInjectorIndex(tNode, hostView) {
      if (tNode.injectorIndex === -1 ||
          // If the injector index is the same as its parent's injector index, then the index has been
          // copied down from the parent node. No injector has been created yet on this node.
          (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||
          // After the first template pass, the injector index might exist but the parent values
          // might not have been calculated yet for this instance
          hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {
          return -1;
      }
      else {
          return tNode.injectorIndex;
      }
  }
  /**
   * Finds the index of the parent injector, with a view offset if applicable. Used to set the
   * parent injector initially.
   *
   * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`
   * @param {?} tNode
   * @param {?} view
   * @return {?}
   */
  function getParentInjectorLocation(tNode, view) {
      if (tNode.parent && tNode.parent.injectorIndex !== -1) {
          return (/** @type {?} */ (tNode.parent.injectorIndex)); // ViewOffset is 0
      }
      // For most cases, the parent injector index can be found on the host node (e.g. for component
      // or container), so this loop will be skipped, but we must keep the loop here to support
      // the rarer case of deeply nested <ng-template> tags or inline views.
      /** @type {?} */
      let hostTNode = view[HOST_NODE];
      /** @type {?} */
      let viewOffset = 1;
      while (hostTNode && hostTNode.injectorIndex === -1) {
          view = (/** @type {?} */ (view[DECLARATION_VIEW]));
          hostTNode = view ? view[HOST_NODE] : null;
          viewOffset++;
      }
      return hostTNode ?
          hostTNode.injectorIndex | (viewOffset << 16 /* ViewOffsetShift */) :
          (/** @type {?} */ (-1));
  }
  /**
   * Makes a type or an injection token public to the DI system by adding it to an
   * injector's bloom filter.
   *
   * @param {?} injectorIndex
   * @param {?} view
   * @param {?} token The type or the injection token to be made public
   * @return {?}
   */
  function diPublicInInjector(injectorIndex, view, token) {
      bloomAdd(injectorIndex, view[TVIEW], token);
  }
  /**
   * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.
   *
   * Look for the injector providing the token by walking up the node injector tree and then
   * the module injector tree.
   *
   * @template T
   * @param {?} tNode The Node where the search for the injector should start
   * @param {?} lView The `LView` that contains the `tNode`
   * @param {?} token The token to look for
   * @param {?=} flags Injection flags
   * @param {?=} notFoundValue The value to return when the injection flags is `InjectFlags.Optional`
   * @return {?} the value from the injector, `null` when not found, or `notFoundValue` if provided
   */
  function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
      if (tNode) {
          /** @type {?} */
          const bloomHash = bloomHashBitOrFactory(token);
          // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef
          // so just call the factory function to create it.
          if (typeof bloomHash === 'function') {
              /** @type {?} */
              const savePreviousOrParentTNode = getPreviousOrParentTNode();
              /** @type {?} */
              const saveLView = getLView();
              setTNodeAndViewData(tNode, lView);
              try {
                  /** @type {?} */
                  const value = bloomHash();
                  if (value == null && !(flags & InjectFlags.Optional)) {
                      throw new Error(`No provider for ${stringify$1$1(token)}!`);
                  }
                  else {
                      return value;
                  }
              }
              finally {
                  setTNodeAndViewData(savePreviousOrParentTNode, saveLView);
              }
          }
          else if (typeof bloomHash == 'number') {
              // If the token has a bloom hash, then it is a token which could be in NodeInjector.
              // A reference to the previous injector TView that was found while climbing the element
              // injector tree. This is used to know if viewProviders can be accessed on the current
              // injector.
              /** @type {?} */
              let previousTView = null;
              /** @type {?} */
              let injectorIndex = getInjectorIndex(tNode, lView);
              /** @type {?} */
              let parentLocation = NO_PARENT_INJECTOR;
              /** @type {?} */
              let hostTElementNode = flags & InjectFlags.Host ? findComponentView(lView)[HOST_NODE] : null;
              // If we should skip this injector, or if there is no injector on this node, start by
              // searching
              // the parent injector.
              if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
                  parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :
                      lView[injectorIndex + PARENT_INJECTOR];
                  if (!shouldSearchParent(flags, false)) {
                      injectorIndex = -1;
                  }
                  else {
                      previousTView = lView[TVIEW];
                      injectorIndex = getParentInjectorIndex(parentLocation);
                      lView = getParentInjectorView(parentLocation, lView);
                  }
              }
              // Traverse up the injector tree until we find a potential match or until we know there
              // *isn't* a match.
              while (injectorIndex !== -1) {
                  parentLocation = lView[injectorIndex + PARENT_INJECTOR];
                  // Check the current injector. If it matches, see if it contains token.
                  /** @type {?} */
                  const tView = lView[TVIEW];
                  if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                      // At this point, we have an injector which *may* contain the token, so we step through
                      // the providers and directives associated with the injector's corresponding node to get
                      // the instance.
                      /** @type {?} */
                      const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
                      if (instance !== NOT_FOUND) {
                          return instance;
                      }
                  }
                  if (shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) &&
                      bloomHasToken(bloomHash, injectorIndex, lView)) {
                      // The def wasn't found anywhere on this node, so it was a false positive.
                      // Traverse up the tree and continue searching.
                      previousTView = tView;
                      injectorIndex = getParentInjectorIndex(parentLocation);
                      lView = getParentInjectorView(parentLocation, lView);
                  }
                  else {
                      // If we should not search parent OR If the ancestor bloom filter value does not have the
                      // bit corresponding to the directive we can give up on traversing up to find the specific
                      // injector.
                      injectorIndex = -1;
                  }
              }
          }
      }
      if (flags & InjectFlags.Optional && notFoundValue === undefined) {
          // This must be set or the NullInjector will throw for optional deps
          notFoundValue = null;
      }
      if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
          /** @type {?} */
          const moduleInjector = lView[INJECTOR];
          if (moduleInjector) {
              return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
          }
          else {
              return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
          }
      }
      if (flags & InjectFlags.Optional) {
          return notFoundValue;
      }
      else {
          throw new Error(`NodeInjector: NOT_FOUND [${stringify$1$1(token)}]`);
      }
  }
  /** @type {?} */
  const NOT_FOUND = {};
  /**
   * @template T
   * @param {?} injectorIndex
   * @param {?} lView
   * @param {?} token
   * @param {?} previousTView
   * @param {?} flags
   * @param {?} hostTElementNode
   * @return {?}
   */
  function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
      /** @type {?} */
      const currentTView = lView[TVIEW];
      /** @type {?} */
      const tNode = (/** @type {?} */ (currentTView.data[injectorIndex + TNODE]));
      // First, we need to determine if view providers can be accessed by the starting element.
      // There are two possibities
      /** @type {?} */
      const canAccessViewProviders = previousTView == null ?
          // 1) This is the first invocation `previousTView == null` which means that we are at the
          // `TNode` of where injector is starting to look. In such a case the only time we are allowed
          // to look into the ViewProviders is if:
          // - we are on a component
          // - AND the injector set `includeViewProviders` to true (implying that the token can see
          // ViewProviders because it is the Component or a Service which itself was declared in
          // ViewProviders)
          (isComponent(tNode) && includeViewProviders) :
          // 2) `previousTView != null` which means that we are now walking across the parent nodes.
          // In such a case we are only allowed to look into the ViewProviders if:
          // - We just crossed from child View to Parent View `previousTView != currentTView`
          // - AND the parent TNode is an Element.
          // This means that we just came from the Component's View and therefore are allowed to see
          // into the ViewProviders.
          (previousTView != currentTView && (tNode.type === 3 /* Element */));
      // This special case happens when there is a @host on the inject and when we are searching
      // on the host element node.
      /** @type {?} */
      const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;
      /** @type {?} */
      const injectableIdx = locateDirectiveOrProvider(tNode, lView, token, canAccessViewProviders, isHostSpecialCase);
      if (injectableIdx !== null) {
          return getNodeInjectable(currentTView.data, lView, injectableIdx, (/** @type {?} */ (tNode)));
      }
      else {
          return NOT_FOUND;
      }
  }
  /**
   * Searches for the given token among the node's directives and providers.
   *
   * @template T
   * @param {?} tNode TNode on which directives are present.
   * @param {?} lView The view we are currently processing
   * @param {?} token Provider token or type of a directive to look for.
   * @param {?} canAccessViewProviders Whether view providers should be considered.
   * @param {?} isHostSpecialCase Whether the host special case applies.
   * @return {?} Index of a found directive or provider, or null when none found.
   */
  function locateDirectiveOrProvider(tNode, lView, token, canAccessViewProviders, isHostSpecialCase) {
      /** @type {?} */
      const tView = lView[TVIEW];
      /** @type {?} */
      const nodeProviderIndexes = tNode.providerIndexes;
      /** @type {?} */
      const tInjectables = tView.data;
      /** @type {?} */
      const injectablesStart = nodeProviderIndexes & 65535 /* ProvidersStartIndexMask */;
      /** @type {?} */
      const directivesStart = tNode.directiveStart;
      /** @type {?} */
      const directiveEnd = tNode.directiveEnd;
      /** @type {?} */
      const cptViewProvidersCount = nodeProviderIndexes >> 16 /* CptViewProvidersCountShift */;
      /** @type {?} */
      const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;
      // When the host special case applies, only the viewProviders and the component are visible
      /** @type {?} */
      const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
      for (let i = startingIndex; i < endIndex; i++) {
          /** @type {?} */
          const providerTokenOrDef = (/** @type {?} */ (tInjectables[i]));
          if (i < directivesStart && token === providerTokenOrDef ||
              i >= directivesStart && ((/** @type {?} */ (providerTokenOrDef))).type === token) {
              return i;
          }
      }
      if (isHostSpecialCase) {
          /** @type {?} */
          const dirDef = (/** @type {?} */ (tInjectables[directivesStart]));
          if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
              return directivesStart;
          }
      }
      return null;
  }
  /**
   * Retrieve or instantiate the injectable from the `lData` at particular `index`.
   *
   * This function checks to see if the value has already been instantiated and if so returns the
   * cached `injectable`. Otherwise if it detects that the value is still a factory it
   * instantiates the `injectable` and caches the value.
   * @param {?} tData
   * @param {?} lData
   * @param {?} index
   * @param {?} tNode
   * @return {?}
   */
  function getNodeInjectable(tData, lData, index, tNode) {
      /** @type {?} */
      let value = lData[index];
      if (isFactory(value)) {
          /** @type {?} */
          const factory = value;
          if (factory.resolving) {
              throw new Error(`Circular dep for ${stringify$1$1(tData[index])}`);
          }
          /** @type {?} */
          const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
          factory.resolving = true;
          /** @type {?} */
          let previousInjectImplementation;
          if (factory.injectImpl) {
              previousInjectImplementation = setInjectImplementation(factory.injectImpl);
          }
          /** @type {?} */
          const savePreviousOrParentTNode = getPreviousOrParentTNode();
          /** @type {?} */
          const saveLView = getLView();
          setTNodeAndViewData(tNode, lData);
          try {
              value = lData[index] = factory.factory(null, tData, lData, tNode);
          }
          finally {
              if (factory.injectImpl)
                  setInjectImplementation(previousInjectImplementation);
              setIncludeViewProviders(previousIncludeViewProviders);
              factory.resolving = false;
              setTNodeAndViewData(savePreviousOrParentTNode, saveLView);
          }
      }
      return value;
  }
  /**
   * Returns the bit in an injector's bloom filter that should be used to determine whether or not
   * the directive might be provided by the injector.
   *
   * When a directive is public, it is added to the bloom filter and given a unique ID that can be
   * retrieved on the Type. When the directive isn't public or the token is not a directive `null`
   * is returned as the node injector can not possibly provide that token.
   *
   * @param {?} token the injection token
   * @return {?} the matching bit to check in the bloom filter or `null` if the token is not known.
   */
  function bloomHashBitOrFactory(token) {
      ngDevMode && assertDefined(token, 'token must be defined');
      if (typeof token === 'string') {
          return token.charCodeAt(0) || 0;
      }
      /** @type {?} */
      const tokenId = ((/** @type {?} */ (token)))[NG_ELEMENT_ID];
      return typeof tokenId === 'number' ? tokenId & BLOOM_MASK : tokenId;
  }
  /**
   * @param {?} bloomHash
   * @param {?} injectorIndex
   * @param {?} injectorView
   * @return {?}
   */
  function bloomHasToken(bloomHash, injectorIndex, injectorView) {
      // Create a mask that targets the specific bit associated with the directive we're looking for.
      // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding
      // to bit positions 0 - 31 in a 32 bit integer.
      /** @type {?} */
      const mask = 1 << bloomHash;
      /** @type {?} */
      const b7 = bloomHash & 0x80;
      /** @type {?} */
      const b6 = bloomHash & 0x40;
      /** @type {?} */
      const b5 = bloomHash & 0x20;
      // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:
      // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.
      // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.
      /** @type {?} */
      let value;
      if (b7) {
          value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :
              (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);
      }
      else {
          value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :
              (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);
      }
      // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,
      // this injector is a potential match.
      return !!(value & mask);
  }
  /**
   * Returns true if flags prevent parent injector from being searched for tokens
   * @param {?} flags
   * @param {?} isFirstHostTNode
   * @return {?}
   */
  function shouldSearchParent(flags, isFirstHostTNode) {
      return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
  }
  class NodeInjector {
      /**
       * @param {?} _tNode
       * @param {?} _lView
       */
      constructor(_tNode, _lView) {
          this._tNode = _tNode;
          this._lView = _lView;
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */
      get(token, notFoundValue) {
          return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);
      }
  }
  /**
   * Creates an empty instance of a `LContext` context
   * @param {?} lView
   * @param {?} nodeIndex
   * @param {?} native
   * @return {?}
   */
  function createLContext(lView, nodeIndex, native) {
      return {
          lView,
          nodeIndex,
          native,
          component: undefined,
          directives: undefined,
          localRefs: undefined,
      };
  }
  /**
   * Takes a component instance and returns the view for that component.
   *
   * @param {?} componentInstance
   * @return {?} The component's view
   */
  function getComponentViewByInstance(componentInstance) {
      /** @type {?} */
      let lView = readPatchedData(componentInstance);
      /** @type {?} */
      let view;
      if (Array.isArray(lView)) {
          /** @type {?} */
          const nodeIndex = findViaComponent(lView, componentInstance);
          view = getComponentViewByIndex(nodeIndex, lView);
          /** @type {?} */
          const context = createLContext(lView, nodeIndex, (/** @type {?} */ (view[HOST])));
          context.component = componentInstance;
          attachPatchData(componentInstance, context);
          attachPatchData(context.native, context);
      }
      else {
          /** @type {?} */
          const context = (/** @type {?} */ ((/** @type {?} */ (lView))));
          view = getComponentViewByIndex(context.nodeIndex, context.lView);
      }
      return view;
  }
  /**
   * Assigns the given data to the given target (which could be a component,
   * directive or DOM node instance) using monkey-patching.
   * @param {?} target
   * @param {?} data
   * @return {?}
   */
  function attachPatchData(target, data) {
      target[MONKEY_PATCH_KEY_NAME] = data;
  }
  /**
   * Locates the component within the given LView and returns the matching index
   * @param {?} lView
   * @param {?} componentInstance
   * @return {?}
   */
  function findViaComponent(lView, componentInstance) {
      /** @type {?} */
      const componentIndices = lView[TVIEW].components;
      if (componentIndices) {
          for (let i = 0; i < componentIndices.length; i++) {
              /** @type {?} */
              const elementComponentIndex = componentIndices[i];
              /** @type {?} */
              const componentView = getComponentViewByIndex(elementComponentIndex, lView);
              if (componentView[CONTEXT] === componentInstance) {
                  return elementComponentIndex;
              }
          }
      }
      else {
          /** @type {?} */
          const rootComponentView = getComponentViewByIndex(HEADER_OFFSET, lView);
          /** @type {?} */
          const rootComponent = rootComponentView[CONTEXT];
          if (rootComponent === componentInstance) {
              // we are dealing with the root element here therefore we know that the
              // element is the very first element after the HEADER data in the lView
              return HEADER_OFFSET;
          }
      }
      return -1;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @param {?} name
   * @return {?}
   */
  function normalizeDebugBindingName(name) {
      // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers
      name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
      return `ng-reflect-${name}`;
  }
  /** @type {?} */
  const CAMEL_CASE_REGEXP = /([A-Z])/g;
  /**
   * @param {?} input
   * @return {?}
   */
  function camelCaseToDashCase(input) {
      return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function normalizeDebugBindingValue(value) {
      try {
          // Limit the size of the value as otherwise the DOM just gets polluted.
          return value != null ? value.toString().slice(0, 30) : value;
      }
      catch (e) {
          return '[ERROR] Exception while trying to serialize the value';
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} a
   * @param {?} b
   * @return {?}
   */
  function devModeEqual(a, b) {
      /** @type {?} */
      const isListLikeIterableA = isListLikeIterable(a);
      /** @type {?} */
      const isListLikeIterableB = isListLikeIterable(b);
      if (isListLikeIterableA && isListLikeIterableB) {
          return areIterablesEqual(a, b, devModeEqual);
      }
      else {
          /** @type {?} */
          const isAObject = a && (typeof a === 'object' || typeof a === 'function');
          /** @type {?} */
          const isBObject = b && (typeof b === 'object' || typeof b === 'function');
          if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
              return true;
          }
          else {
              return looseIdentical(a, b);
          }
      }
  }
  /**
   * Indicates that the result of a {\@link Pipe} transformation has changed even though the
   * reference has not changed.
   *
   * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value
   * is stored.
   *
   * Example:
   *
   * ```
   * if (this._latestValue === this._latestReturnedValue) {
   *    return this._latestReturnedValue;
   *  } else {
   *    this._latestReturnedValue = this._latestValue;
   *    return WrappedValue.wrap(this._latestValue); // this will force update
   *  }
   * ```
   *
   * \@publicApi
   */
  class WrappedValue {
      /**
       * @param {?} value
       */
      constructor(value) { this.wrapped = value; }
      /**
       * Creates a wrapped value.
       * @param {?} value
       * @return {?}
       */
      static wrap(value) { return new WrappedValue(value); }
      /**
       * Returns the underlying value of a wrapped value.
       * Returns the given `value` when it is not wrapped.
       *
       * @param {?} value
       * @return {?}
       */
      static unwrap(value) { return WrappedValue.isWrapped(value) ? value.wrapped : value; }
      /**
       * Returns true if `value` is a wrapped value.
       * @param {?} value
       * @return {?}
       */
      static isWrapped(value) { return value instanceof WrappedValue; }
  }
  /**
   * Represents a basic change from a previous to a new value.
   *
   * \@publicApi
   */
  class SimpleChange {
      /**
       * @param {?} previousValue
       * @param {?} currentValue
       * @param {?} firstChange
       */
      constructor(previousValue, currentValue, firstChange) {
          this.previousValue = previousValue;
          this.currentValue = currentValue;
          this.firstChange = firstChange;
      }
      /**
       * Check whether the new value is the first value assigned.
       * @return {?}
       */
      isFirstChange() { return this.firstChange; }
  }
  /**
   * @param {?} obj
   * @return {?}
   */
  function isListLikeIterable(obj) {
      if (!isJsObject(obj))
          return false;
      return Array.isArray(obj) ||
          (!(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
              getSymbolIterator$1() in obj); // JS Iterable have a Symbol.iterator prop
  }
  /**
   * @param {?} a
   * @param {?} b
   * @param {?} comparator
   * @return {?}
   */
  function areIterablesEqual(a, b, comparator) {
      /** @type {?} */
      const iterator1 = a[getSymbolIterator$1()]();
      /** @type {?} */
      const iterator2 = b[getSymbolIterator$1()]();
      while (true) {
          /** @type {?} */
          const item1 = iterator1.next();
          /** @type {?} */
          const item2 = iterator2.next();
          if (item1.done && item2.done)
              return true;
          if (item1.done || item2.done)
              return false;
          if (!comparator(item1.value, item2.value))
              return false;
      }
  }
  /**
   * @param {?} obj
   * @param {?} fn
   * @return {?}
   */
  function iterateListLike(obj, fn) {
      if (Array.isArray(obj)) {
          for (let i = 0; i < obj.length; i++) {
              fn(obj[i]);
          }
      }
      else {
          /** @type {?} */
          const iterator = obj[getSymbolIterator$1()]();
          /** @type {?} */
          let item;
          while (!((item = iterator.next()).done)) {
              fn(item.value);
          }
      }
  }
  /**
   * @param {?} o
   * @return {?}
   */
  function isJsObject(o) {
      return o !== null && (typeof o === 'function' || typeof o === 'object');
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * A special value which designates that a value has not changed.
   * @type {?}
   */
  const NO_CHANGE = (/** @type {?} */ ({}));

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';
  /**
   * Returns whether the `renderer` is a `ProceduralRenderer3`
   * @param {?} renderer
   * @return {?}
   */
  function isProceduralRenderer(renderer) {
      return !!(((/** @type {?} */ (renderer))).listen);
  }
  /** @type {?} */
  const domRendererFactory3 = {
      createRenderer: (hostElement, rendererType) => { return document; }
  };
  /**
   * @param {?} tNode
   * @param {?} embeddedView
   * @return {?}
   */
  function getLContainer(tNode, embeddedView) {
      if (tNode.index === -1) {
          // This is a dynamically created view inside a dynamic container.
          // If the host index is -1, the view has not yet been inserted, so it has no parent.
          /** @type {?} */
          const containerHostIndex = embeddedView[CONTAINER_INDEX];
          return containerHostIndex > -1 ? (/** @type {?} */ (embeddedView[PARENT]))[containerHostIndex] : null;
      }
      else {
          // This is a inline view node (e.g. embeddedViewStart)
          return (/** @type {?} */ ((/** @type {?} */ (embeddedView[PARENT]))[(/** @type {?} */ (tNode.parent)).index]));
      }
  }
  /**
   * Stack used to keep track of projection nodes in walkTNodeTree.
   *
   * This is deliberately created outside of walkTNodeTree to avoid allocating
   * a new array each time the function is called. Instead the array will be
   * re-used by each invocation. This works because the function is not reentrant.
   * @type {?}
   */
  const projectionNodeStack = [];
  /**
   * Walks a tree of TNodes, applying a transformation on the element nodes, either only on the first
   * one found, or on all of them.
   *
   * @param {?} viewToWalk the view to walk
   * @param {?} action identifies the action to be performed on the elements
   * @param {?} renderer the current renderer.
   * @param {?} renderParent Optional the render parent node to be set in all LContainers found,
   * required for action modes Insert and Destroy.
   * @param {?=} beforeNode Optional the node before which elements should be added, required for action
   * Insert.
   * @return {?}
   */
  function walkTNodeTree(viewToWalk, action, renderer, renderParent, beforeNode) {
      /** @type {?} */
      const rootTNode = (/** @type {?} */ (viewToWalk[TVIEW].node));
      /** @type {?} */
      let projectionNodeIndex = -1;
      /** @type {?} */
      let currentView = viewToWalk;
      /** @type {?} */
      let tNode = (/** @type {?} */ (rootTNode.child));
      while (tNode) {
          /** @type {?} */
          let nextTNode = null;
          if (tNode.type === 3 /* Element */) {
              executeNodeAction(action, renderer, renderParent, getNativeByTNode(tNode, currentView), beforeNode);
              /** @type {?} */
              const nodeOrContainer = currentView[tNode.index];
              if (isLContainer(nodeOrContainer)) {
                  // This element has an LContainer, and its comment needs to be handled
                  executeNodeAction(action, renderer, renderParent, nodeOrContainer[NATIVE], beforeNode);
              }
          }
          else if (tNode.type === 0 /* Container */) {
              /** @type {?} */
              const lContainer = (/** @type {?} */ ((/** @type {?} */ (currentView))[tNode.index]));
              executeNodeAction(action, renderer, renderParent, lContainer[NATIVE], beforeNode);
              if (renderParent)
                  lContainer[RENDER_PARENT] = renderParent;
              if (lContainer[VIEWS].length) {
                  currentView = lContainer[VIEWS][0];
                  nextTNode = currentView[TVIEW].node;
                  // When the walker enters a container, then the beforeNode has to become the local native
                  // comment node.
                  beforeNode = lContainer[NATIVE];
              }
          }
          else if (tNode.type === 1 /* Projection */) {
              /** @type {?} */
              const componentView = findComponentView((/** @type {?} */ (currentView)));
              /** @type {?} */
              const componentHost = (/** @type {?} */ (componentView[HOST_NODE]));
              /** @type {?} */
              const head = ((/** @type {?} */ (componentHost.projection)))[(/** @type {?} */ (tNode.projection))];
              // Must store both the TNode and the view because this projection node could be nested
              // deeply inside embedded views, and we need to get back down to this particular nested view.
              projectionNodeStack[++projectionNodeIndex] = tNode;
              projectionNodeStack[++projectionNodeIndex] = (/** @type {?} */ (currentView));
              if (head) {
                  currentView = (/** @type {?} */ (componentView[PARENT]));
                  nextTNode = (/** @type {?} */ (currentView[TVIEW].data[head.index]));
              }
          }
          else {
              // Otherwise, this is a View or an ElementContainer
              nextTNode = tNode.child;
          }
          if (nextTNode === null) {
              // this last node was projected, we need to get back down to its projection node
              if (tNode.next === null && (tNode.flags & 2 /* isProjected */)) {
                  currentView = (/** @type {?} */ (projectionNodeStack[projectionNodeIndex--]));
                  tNode = (/** @type {?} */ (projectionNodeStack[projectionNodeIndex--]));
              }
              nextTNode = tNode.next;
              /**
               * Find the next node in the TNode tree, taking into account the place where a node is
               * projected (in the shadow DOM) rather than where it comes from (in the light DOM).
               *
               * If there is no sibling node, then it goes to the next sibling of the parent node...
               * until it reaches rootNode (at which point null is returned).
               */
              while (!nextTNode) {
                  // If parent is null, we're crossing the view boundary, so we should get the host TNode.
                  tNode = tNode.parent || currentView[TVIEW].node;
                  if (tNode === null || tNode === rootTNode)
                      return null;
                  // When exiting a container, the beforeNode must be restored to the previous value
                  if (tNode.type === 0 /* Container */) {
                      currentView = (/** @type {?} */ (currentView[PARENT]));
                      beforeNode = currentView[tNode.index][NATIVE];
                  }
                  if (tNode.type === 2 /* View */ && currentView[NEXT]) {
                      currentView = (/** @type {?} */ (currentView[NEXT]));
                      nextTNode = currentView[TVIEW].node;
                  }
                  else {
                      nextTNode = tNode.next;
                  }
              }
          }
          tNode = nextTNode;
      }
  }
  /**
   * NOTE: for performance reasons, the possible actions are inlined within the function instead of
   * being passed as an argument.
   * @param {?} action
   * @param {?} renderer
   * @param {?} parent
   * @param {?} node
   * @param {?=} beforeNode
   * @return {?}
   */
  function executeNodeAction(action, renderer, parent, node, beforeNode) {
      if (action === 0 /* Insert */) {
          isProceduralRenderer((/** @type {?} */ (renderer))) ?
              ((/** @type {?} */ (renderer))).insertBefore((/** @type {?} */ (parent)), node, (/** @type {?} */ (beforeNode))) :
              (/** @type {?} */ (parent)).insertBefore(node, (/** @type {?} */ (beforeNode)), true);
      }
      else if (action === 1 /* Detach */) {
          isProceduralRenderer((/** @type {?} */ (renderer))) ?
              ((/** @type {?} */ (renderer))).removeChild((/** @type {?} */ (parent)), node) :
              (/** @type {?} */ (parent)).removeChild(node);
      }
      else if (action === 2 /* Destroy */) {
          ngDevMode && ngDevMode.rendererDestroyNode++;
          (/** @type {?} */ (((/** @type {?} */ (renderer))).destroyNode))(node);
      }
  }
  /**
   * Traverses down and up the tree of views and containers to remove listeners and
   * call onDestroy callbacks.
   *
   * Notes:
   *  - Because it's used for onDestroy calls, it needs to be bottom-up.
   *  - Must process containers instead of their views to avoid splicing
   *  when views are destroyed and re-added.
   *  - Using a while loop because it's faster than recursion
   *  - Destroy only called on movement to sibling or movement to parent (laterally or up)
   *
   * @param {?} rootView The view to destroy
   * @return {?}
   */
  function destroyViewTree(rootView) {
      // If the view has no children, we can clean it up and return early.
      if (rootView[TVIEW].childIndex === -1) {
          return cleanUpView(rootView);
      }
      /** @type {?} */
      let viewOrContainer = getLViewChild(rootView);
      while (viewOrContainer) {
          /** @type {?} */
          let next = null;
          if (viewOrContainer.length >= HEADER_OFFSET) {
              // If LView, traverse down to child.
              /** @type {?} */
              const view = (/** @type {?} */ (viewOrContainer));
              if (view[TVIEW].childIndex > -1)
                  next = getLViewChild(view);
          }
          else {
              // If container, traverse down to its first LView.
              /** @type {?} */
              const container = (/** @type {?} */ (viewOrContainer));
              if (container[VIEWS].length)
                  next = container[VIEWS][0];
          }
          if (next == null) {
              // Only clean up view when moving to the side or up, as destroy hooks
              // should be called in order from the bottom up.
              while (viewOrContainer && !(/** @type {?} */ (viewOrContainer))[NEXT] && viewOrContainer !== rootView) {
                  cleanUpView(viewOrContainer);
                  viewOrContainer = getParentState(viewOrContainer, rootView);
              }
              cleanUpView(viewOrContainer || rootView);
              next = viewOrContainer && (/** @type {?} */ (viewOrContainer))[NEXT];
          }
          viewOrContainer = next;
      }
  }
  /**
   * Gets the child of the given LView
   * @param {?} lView
   * @return {?}
   */
  function getLViewChild(lView) {
      /** @type {?} */
      const childIndex = lView[TVIEW].childIndex;
      return childIndex === -1 ? null : lView[childIndex];
  }
  /**
   * A standalone function which destroys an LView,
   * conducting cleanup (e.g. removing listeners, calling onDestroys).
   *
   * @param {?} view The view to be destroyed.
   * @return {?}
   */
  function destroyLView(view) {
      /** @type {?} */
      const renderer = view[RENDERER];
      if (isProceduralRenderer(renderer) && renderer.destroyNode) {
          walkTNodeTree(view, 2 /* Destroy */, renderer, null);
      }
      destroyViewTree(view);
      // Sets the destroyed flag
      view[FLAGS] |= 64 /* Destroyed */;
  }
  /**
   * Determines which LViewOrLContainer to jump to when traversing back up the
   * tree in destroyViewTree.
   *
   * Normally, the view's parent LView should be checked, but in the case of
   * embedded views, the container (which is the view node's parent, but not the
   * LView's parent) needs to be checked for a possible next property.
   *
   * @param {?} state The LViewOrLContainer for which we need a parent state
   * @param {?} rootView The rootView, so we don't propagate too far up the view tree
   * @return {?} The correct parent LViewOrLContainer
   */
  function getParentState(state, rootView) {
      /** @type {?} */
      let tNode;
      if (state.length >= HEADER_OFFSET && (tNode = (/** @type {?} */ (((/** @type {?} */ (state)))))[HOST_NODE]) &&
          tNode.type === 2 /* View */) {
          // if it's an embedded view, the state needs to go up to the container, in case the
          // container has a next
          return (/** @type {?} */ (getLContainer((/** @type {?} */ (tNode)), (/** @type {?} */ (state)))));
      }
      else {
          // otherwise, use parent view for containers or component views
          return state[PARENT] === rootView ? null : state[PARENT];
      }
  }
  /**
   * Calls onDestroys hooks for all directives and pipes in a given view and then removes all
   * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks
   * can be propagated to \@Output listeners.
   *
   * @param {?} viewOrContainer
   * @return {?}
   */
  function cleanUpView(viewOrContainer) {
      if (((/** @type {?} */ (viewOrContainer))).length >= HEADER_OFFSET) {
          /** @type {?} */
          const view = (/** @type {?} */ (viewOrContainer));
          executeOnDestroys(view);
          executePipeOnDestroys(view);
          removeListeners(view);
          /** @type {?} */
          const hostTNode = view[HOST_NODE];
          // For component views only, the local renderer is destroyed as clean up time.
          if (hostTNode && hostTNode.type === 3 /* Element */ && isProceduralRenderer(view[RENDERER])) {
              ngDevMode && ngDevMode.rendererDestroy++;
              ((/** @type {?} */ (view[RENDERER]))).destroy();
          }
      }
  }
  /**
   * Removes listeners and unsubscribes from output subscriptions
   * @param {?} lView
   * @return {?}
   */
  function removeListeners(lView) {
      /** @type {?} */
      const tCleanup = (/** @type {?} */ (lView[TVIEW].cleanup));
      if (tCleanup != null) {
          /** @type {?} */
          const lCleanup = (/** @type {?} */ (lView[CLEANUP]));
          for (let i = 0; i < tCleanup.length - 1; i += 2) {
              if (typeof tCleanup[i] === 'string') {
                  // This is a listener with the native renderer
                  /** @type {?} */
                  const idx = tCleanup[i + 1];
                  /** @type {?} */
                  const listener = lCleanup[tCleanup[i + 2]];
                  /** @type {?} */
                  const native = readElementValue(lView[idx]);
                  /** @type {?} */
                  const useCaptureOrSubIdx = tCleanup[i + 3];
                  if (typeof useCaptureOrSubIdx === 'boolean') {
                      // DOM listener
                      native.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);
                  }
                  else {
                      if (useCaptureOrSubIdx >= 0) {
                          // unregister
                          lCleanup[useCaptureOrSubIdx]();
                      }
                      else {
                          // Subscription
                          lCleanup[-useCaptureOrSubIdx].unsubscribe();
                      }
                  }
                  i += 2;
              }
              else if (typeof tCleanup[i] === 'number') {
                  // This is a listener with renderer2 (cleanup fn can be found by index)
                  /** @type {?} */
                  const cleanupFn = lCleanup[tCleanup[i]];
                  cleanupFn();
              }
              else {
                  // This is a cleanup function that is grouped with the index of its context
                  /** @type {?} */
                  const context = lCleanup[tCleanup[i + 1]];
                  tCleanup[i].call(context);
              }
          }
          lView[CLEANUP] = null;
      }
  }
  /**
   * Calls onDestroy hooks for this view
   * @param {?} view
   * @return {?}
   */
  function executeOnDestroys(view) {
      /** @type {?} */
      const tView = view[TVIEW];
      /** @type {?} */
      let destroyHooks;
      if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
          callHooks(view, destroyHooks);
      }
  }
  /**
   * Calls pipe destroy hooks for this view
   * @param {?} lView
   * @return {?}
   */
  function executePipeOnDestroys(lView) {
      /** @type {?} */
      const pipeDestroyHooks = lView[TVIEW] && lView[TVIEW].pipeDestroyHooks;
      if (pipeDestroyHooks) {
          callHooks((/** @type {?} */ (lView)), pipeDestroyHooks);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const ANIMATION_PROP_PREFIX = '@';
  /**
   * @param {?} name
   * @return {?}
   */
  function isAnimationProp(name) {
      return name[0] === ANIMATION_PROP_PREFIX;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A permanent marker promise which signifies that the current CD tree is
   * clean.
   * @type {?}
   */
  const _CLEAN_PROMISE = Promise.resolve(null);
  /**
   * Refreshes the view, executing the following steps in that order:
   * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host
   * bindings, refreshes child components.
   * Note: view hooks are triggered later when leaving the view.
   * @param {?} lView
   * @return {?}
   */
  function refreshDescendantViews(lView) {
      /** @type {?} */
      const tView = lView[TVIEW];
      // This needs to be set before children are processed to support recursive components
      tView.firstTemplatePass = false;
      setFirstTemplatePass(false);
      // If this is a creation pass, we should not call lifecycle hooks or evaluate bindings.
      // This will be done in the update pass.
      if (!isCreationMode(lView)) {
          /** @type {?} */
          const checkNoChangesMode = getCheckNoChangesMode();
          executeInitHooks(lView, tView, checkNoChangesMode);
          refreshDynamicEmbeddedViews(lView);
          // Content query results must be refreshed before content hooks are called.
          refreshContentQueries(tView);
          executeHooks(lView, tView.contentHooks, tView.contentCheckHooks, checkNoChangesMode);
          setHostBindings(tView, lView);
      }
      refreshChildComponents(tView.components);
  }
  /**
   * Sets the host bindings for the current view.
   * @param {?} tView
   * @param {?} viewData
   * @return {?}
   */
  function setHostBindings(tView, viewData) {
      if (tView.expandoInstructions) {
          /** @type {?} */
          let bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;
          setBindingRoot(bindingRootIndex);
          /** @type {?} */
          let currentDirectiveIndex = -1;
          /** @type {?} */
          let currentElementIndex = -1;
          for (let i = 0; i < tView.expandoInstructions.length; i++) {
              /** @type {?} */
              const instruction = tView.expandoInstructions[i];
              if (typeof instruction === 'number') {
                  if (instruction <= 0) {
                      // Negative numbers mean that we are starting new EXPANDO block and need to update
                      // the current element and directive index.
                      currentElementIndex = -instruction;
                      // Injector block and providers are taken into account.
                      /** @type {?} */
                      const providerCount = ((/** @type {?} */ (tView.expandoInstructions[++i])));
                      bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;
                      currentDirectiveIndex = bindingRootIndex;
                  }
                  else {
                      // This is either the injector size (so the binding root can skip over directives
                      // and get to the first set of host bindings on this node) or the host var count
                      // (to get to the next set of host bindings on this node).
                      bindingRootIndex += instruction;
                  }
                  setBindingRoot(bindingRootIndex);
              }
              else {
                  // If it's not a number, it's a host binding function that needs to be executed.
                  if (instruction !== null) {
                      viewData[BINDING_INDEX] = bindingRootIndex;
                      instruction(2 /* Update */, readElementValue(viewData[currentDirectiveIndex]), currentElementIndex);
                  }
                  currentDirectiveIndex++;
              }
          }
      }
  }
  /**
   * Refreshes content queries for all directives in the given view.
   * @param {?} tView
   * @return {?}
   */
  function refreshContentQueries(tView) {
      if (tView.contentQueries != null) {
          for (let i = 0; i < tView.contentQueries.length; i += 2) {
              /** @type {?} */
              const directiveDefIdx = tView.contentQueries[i];
              /** @type {?} */
              const directiveDef = (/** @type {?} */ (tView.data[directiveDefIdx]));
              (/** @type {?} */ (directiveDef.contentQueriesRefresh))(directiveDefIdx - HEADER_OFFSET, tView.contentQueries[i + 1]);
          }
      }
  }
  /**
   * Refreshes child components in the current view.
   * @param {?} components
   * @return {?}
   */
  function refreshChildComponents(components) {
      if (components != null) {
          for (let i = 0; i < components.length; i++) {
              componentRefresh(components[i]);
          }
      }
  }
  /**
   * @template T
   * @param {?} parentLView
   * @param {?} tView
   * @param {?} context
   * @param {?} flags
   * @param {?=} rendererFactory
   * @param {?=} renderer
   * @param {?=} sanitizer
   * @param {?=} injector
   * @return {?}
   */
  function createLView(parentLView, tView, context, flags, rendererFactory, renderer, sanitizer, injector) {
      /** @type {?} */
      const lView = (/** @type {?} */ (tView.blueprint.slice()));
      lView[FLAGS] = flags | 1 /* CreationMode */ | 16 /* Attached */ | 32 /* RunInit */ |
          2 /* FirstLViewPass */;
      lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
      lView[CONTEXT] = context;
      lView[RENDERER_FACTORY] = (/** @type {?} */ ((rendererFactory || parentLView && parentLView[RENDERER_FACTORY])));
      ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');
      lView[RENDERER] = (/** @type {?} */ ((renderer || parentLView && parentLView[RENDERER])));
      ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');
      lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || (/** @type {?} */ (null));
      lView[(/** @type {?} */ (INJECTOR))] = injector || parentLView && parentLView[INJECTOR] || null;
      return lView;
  }
  /**
   * @param {?} index
   * @param {?} type
   * @param {?} native
   * @param {?} name
   * @param {?} attrs
   * @return {?}
   */
  function createNodeAtIndex(index, type, native, name, attrs) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */
      const tView = lView[TVIEW];
      /** @type {?} */
      const adjustedIndex = index + HEADER_OFFSET;
      ngDevMode &&
          assertLessThan(adjustedIndex, lView.length, `Slot should have been initialized with null`);
      lView[adjustedIndex] = native;
      /** @type {?} */
      let tNode = (/** @type {?} */ (tView.data[adjustedIndex]));
      if (tNode == null) {
          // TODO(misko): Refactor createTNode so that it does not depend on LView.
          tNode = tView.data[adjustedIndex] = createTNode(lView, type, adjustedIndex, name, attrs, null);
      }
      // Now link ourselves into the tree.
      // We need this even if tNode exists, otherwise we might end up pointing to unexisting tNodes when
      // we use i18n (especially with ICU expressions that update the DOM during the update phase).
      /** @type {?} */
      const previousOrParentTNode = getPreviousOrParentTNode();
      /** @type {?} */
      const isParent = getIsParent();
      if (previousOrParentTNode) {
          if (isParent && previousOrParentTNode.child == null &&
              (tNode.parent !== null || previousOrParentTNode.type === 2 /* View */)) {
              // We are in the same view, which means we are adding content node to the parent view.
              previousOrParentTNode.child = tNode;
          }
          else if (!isParent) {
              previousOrParentTNode.next = tNode;
          }
      }
      if (tView.firstChild == null) {
          tView.firstChild = tNode;
      }
      setPreviousOrParentTNode(tNode);
      setIsParent(true);
      return (/** @type {?} */ (tNode));
  }
  /**
   * @param {?} index
   * @param {?} view
   * @return {?}
   */
  function createViewNode(index, view) {
      // View nodes are not stored in data because they can be added / removed at runtime (which
      // would cause indices to change). Their TNodes are instead stored in tView.node.
      if (view[TVIEW].node == null) {
          view[TVIEW].node = (/** @type {?} */ (createTNode(view, 2 /* View */, index, null, null, null)));
      }
      return view[HOST_NODE] = (/** @type {?} */ (view[TVIEW].node));
  }
  /**
   * Used for rendering embedded views (e.g. dynamically created views)
   *
   * Dynamically created views must store/retrieve their TViews differently from component views
   * because their template functions are nested in the template functions of their hosts, creating
   * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside
   * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we
   * can't store TViews in the template function itself (as we do for comps). Instead, we store the
   * TView for dynamically created views on their host TNode, which only has one instance.
   * @template T
   * @param {?} viewToRender
   * @param {?} tView
   * @param {?} context
   * @return {?}
   */
  function renderEmbeddedTemplate(viewToRender, tView, context) {
      /** @type {?} */
      const _isParent = getIsParent();
      /** @type {?} */
      const _previousOrParentTNode = getPreviousOrParentTNode();
      setIsParent(true);
      setPreviousOrParentTNode((/** @type {?} */ (null)));
      /** @type {?} */
      let oldView;
      if (viewToRender[FLAGS] & 128 /* IsRoot */) {
          // This is a root view inside the view tree
          tickRootContext(getRootContext(viewToRender));
      }
      else {
          try {
              setIsParent(true);
              setPreviousOrParentTNode((/** @type {?} */ (null)));
              oldView = enterView(viewToRender, viewToRender[HOST_NODE]);
              namespaceHTML();
              (/** @type {?} */ (tView.template))(getRenderFlags(viewToRender), context);
              // This must be set to false immediately after the first creation run because in an
              // ngFor loop, all the views will be created together before update mode runs and turns
              // off firstTemplatePass. If we don't set it here, instances will perform directive
              // matching, etc again and again.
              viewToRender[TVIEW].firstTemplatePass = false;
              setFirstTemplatePass(false);
              refreshDescendantViews(viewToRender);
          }
          finally {
              leaveView((/** @type {?} */ (oldView)));
              setIsParent(_isParent);
              setPreviousOrParentTNode(_previousOrParentTNode);
          }
      }
  }
  /**
   * @template T
   * @param {?} hostView
   * @param {?} context
   * @param {?=} templateFn
   * @return {?}
   */
  function renderComponentOrTemplate(hostView, context, templateFn) {
      /** @type {?} */
      const rendererFactory = hostView[RENDERER_FACTORY];
      /** @type {?} */
      const oldView = enterView(hostView, hostView[HOST_NODE]);
      /** @type {?} */
      const normalExecutionPath = !getCheckNoChangesMode();
      try {
          if (normalExecutionPath && rendererFactory.begin) {
              rendererFactory.begin();
          }
          if (isCreationMode(hostView)) {
              // creation mode pass
              if (templateFn) {
                  namespaceHTML();
                  templateFn(1 /* Create */, (/** @type {?} */ (context)));
              }
              refreshDescendantViews(hostView);
              hostView[FLAGS] &= ~1 /* CreationMode */;
          }
          // update mode pass
          templateFn && templateFn(2 /* Update */, (/** @type {?} */ (context)));
          refreshDescendantViews(hostView);
      }
      finally {
          if (normalExecutionPath && rendererFactory.end) {
              rendererFactory.end();
          }
          leaveView(oldView);
      }
  }
  /**
   * This function returns the default configuration of rendering flags depending on when the
   * template is in creation mode or update mode. Update block and create block are
   * always run separately.
   * @param {?} view
   * @return {?}
   */
  function getRenderFlags(view) {
      return isCreationMode(view) ? 1 /* Create */ : 2 /* Update */;
  }
  //////////////////////////
  //// Namespace
  //////////////////////////
  /** @type {?} */
  let _currentNamespace = null;
  /**
   * @return {?}
   */
  function namespaceHTML() {
      _currentNamespace = null;
  }
  /**
   * Creates a native element from a tag name, using a renderer.
   * @param {?} name the tag name
   * @param {?=} overriddenRenderer Optional A renderer to override the default one
   * @return {?} the element created
   */
  function elementCreate(name, overriddenRenderer) {
      /** @type {?} */
      let native;
      /** @type {?} */
      const rendererToUse = overriddenRenderer || getLView()[RENDERER];
      if (isProceduralRenderer(rendererToUse)) {
          native = rendererToUse.createElement(name, _currentNamespace);
      }
      else {
          if (_currentNamespace === null) {
              native = rendererToUse.createElement(name);
          }
          else {
              native = rendererToUse.createElementNS(_currentNamespace, name);
          }
      }
      return native;
  }
  /**
   * Gets TView from a template function or creates a new TView
   * if it doesn't already exist.
   *
   * @param {?} templateFn The template from which to get static data
   * @param {?} consts The number of nodes, local refs, and pipes in this view
   * @param {?} vars The number of bindings and pure function bindings in this view
   * @param {?} directives Directive defs that should be saved on TView
   * @param {?} pipes Pipe defs that should be saved on TView
   * @param {?} viewQuery
   * @return {?} TView
   */
  function getOrCreateTView(templateFn, consts, vars, directives, pipes, viewQuery) {
      // TODO(misko): reading `ngPrivateData` here is problematic for two reasons
      // 1. It is a megamorphic call on each invocation.
      // 2. For nested embedded views (ngFor inside ngFor) the template instance is per
      //    outer template invocation, which means that no such property will exist
      // Correct solution is to only put `ngPrivateData` on the Component template
      // and not on embedded templates.
      return templateFn.ngPrivateData ||
          (templateFn.ngPrivateData =
              (/** @type {?} */ (createTView(-1, templateFn, consts, vars, directives, pipes, viewQuery))));
  }
  /**
   * Creates a TView instance
   *
   * @param {?} viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic
   * @param {?} templateFn Template function
   * @param {?} consts The number of nodes, local refs, and pipes in this template
   * @param {?} vars
   * @param {?} directives Registry of directives for this view
   * @param {?} pipes Registry of pipes for this view
   * @param {?} viewQuery
   * @return {?}
   */
  function createTView(viewIndex, templateFn, consts, vars, directives, pipes, viewQuery) {
      ngDevMode && ngDevMode.tView++;
      /** @type {?} */
      const bindingStartIndex = HEADER_OFFSET + consts;
      // This length does not yet contain host bindings from child directives because at this point,
      // we don't know which directives are active on this template. As soon as a directive is matched
      // that has a host binding, we will update the blueprint with that def's hostVars count.
      /** @type {?} */
      const initialViewLength = bindingStartIndex + vars;
      /** @type {?} */
      const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
      return blueprint[(/** @type {?} */ (TVIEW))] = {
          id: viewIndex,
          blueprint: blueprint,
          template: templateFn,
          viewQuery: viewQuery,
          node: (/** @type {?} */ (null)),
          data: blueprint.slice(),
          // Fill in to match HEADER_OFFSET in LView
          childIndex: -1,
          // Children set in addToViewTree(), if any
          bindingStartIndex: bindingStartIndex,
          expandoStartIndex: initialViewLength,
          expandoInstructions: null,
          firstTemplatePass: true,
          initHooks: null,
          checkHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          pipeDestroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: typeof directives === 'function' ? directives() : directives,
          pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,
          firstChild: null,
      };
  }
  /**
   * @param {?} bindingStartIndex
   * @param {?} initialViewLength
   * @return {?}
   */
  function createViewBlueprint(bindingStartIndex, initialViewLength) {
      /** @type {?} */
      const blueprint = (/** @type {?} */ (new Array(initialViewLength)
          .fill(null, 0, bindingStartIndex)
          .fill(NO_CHANGE, bindingStartIndex)));
      blueprint[CONTAINER_INDEX] = -1;
      blueprint[BINDING_INDEX] = bindingStartIndex;
      return blueprint;
  }
  /**
   * @param {?} native
   * @param {?} attrs
   * @return {?}
   */
  function setUpAttributes(native, attrs) {
      /** @type {?} */
      const renderer = getLView()[RENDERER];
      /** @type {?} */
      const isProc = isProceduralRenderer(renderer);
      /** @type {?} */
      let i = 0;
      while (i < attrs.length) {
          /** @type {?} */
          const attrName = attrs[i++];
          if (typeof attrName == 'number') {
              if (attrName === 0 /* NamespaceURI */) {
                  // Namespaced attributes
                  /** @type {?} */
                  const namespaceURI = (/** @type {?} */ (attrs[i++]));
                  /** @type {?} */
                  const attrName = (/** @type {?} */ (attrs[i++]));
                  /** @type {?} */
                  const attrVal = (/** @type {?} */ (attrs[i++]));
                  ngDevMode && ngDevMode.rendererSetAttribute++;
                  isProc ?
                      ((/** @type {?} */ (renderer)))
                          .setAttribute(native, attrName, attrVal, namespaceURI) :
                      native.setAttributeNS(namespaceURI, attrName, attrVal);
              }
              else {
                  // All other `AttributeMarker`s are ignored here.
                  break;
              }
          }
          else {
              /// attrName is string;
              /** @type {?} */
              const attrVal = attrs[i++];
              if (attrName !== NG_PROJECT_AS_ATTR_NAME) {
                  // Standard attributes
                  ngDevMode && ngDevMode.rendererSetAttribute++;
                  if (isAnimationProp(attrName)) {
                      if (isProc) {
                          ((/** @type {?} */ (renderer))).setProperty(native, attrName, attrVal);
                      }
                  }
                  else {
                      isProc ?
                          ((/** @type {?} */ (renderer)))
                              .setAttribute(native, (/** @type {?} */ (attrName)), (/** @type {?} */ (attrVal))) :
                          native.setAttribute((/** @type {?} */ (attrName)), (/** @type {?} */ (attrVal)));
                  }
              }
          }
      }
  }
  /**
   * @param {?} text
   * @param {?} token
   * @return {?}
   */
  function createError(text, token) {
      return new Error(`Renderer: ${text} [${stringify$1$1(token)}]`);
  }
  /**
   * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.
   *
   * @param {?} factory
   * @param {?} elementOrSelector Render element or CSS selector to locate the element.
   * @return {?}
   */
  function locateHostElement(factory, elementOrSelector) {
      /** @type {?} */
      const defaultRenderer = factory.createRenderer(null, null);
      /** @type {?} */
      const rNode = typeof elementOrSelector === 'string' ?
          (isProceduralRenderer(defaultRenderer) ?
              defaultRenderer.selectRootElement(elementOrSelector) :
              defaultRenderer.querySelector(elementOrSelector)) :
          elementOrSelector;
      if (ngDevMode && !rNode) {
          if (typeof elementOrSelector === 'string') {
              throw createError('Host node with selector not found:', elementOrSelector);
          }
          else {
              throw createError('Host node is required:', elementOrSelector);
          }
      }
      return rNode;
  }
  /**
   * Saves the cleanup function itself in LView.cleanupInstances.
   *
   * This is necessary for functions that are wrapped with their contexts, like in renderer2
   * listeners.
   *
   * On the first template pass, the index of the cleanup function is saved in TView.
   * @param {?} view
   * @param {?} cleanupFn
   * @return {?}
   */
  function storeCleanupFn(view, cleanupFn) {
      getCleanup(view).push(cleanupFn);
      if (view[TVIEW].firstTemplatePass) {
          getTViewCleanup(view).push((/** @type {?} */ (view[CLEANUP])).length - 1, null);
      }
  }
  /**
   * Constructs a TNode object from the arguments.
   *
   * @param {?} lView
   * @param {?} type The type of the node
   * @param {?} adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET
   * @param {?} tagName The tag name of the node
   * @param {?} attrs The attributes defined on this node
   * @param {?} tViews Any TViews attached to this node
   * @return {?} the TNode object
   */
  function createTNode(lView, type, adjustedIndex, tagName, attrs, tViews) {
      /** @type {?} */
      const previousOrParentTNode = getPreviousOrParentTNode();
      ngDevMode && ngDevMode.tNode++;
      /** @type {?} */
      const parent = getIsParent() ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;
      // Parents cannot cross component boundaries because components will be used in multiple places,
      // so it's only set if the view is the same.
      /** @type {?} */
      const parentInSameView = parent && lView && parent !== lView[HOST_NODE];
      /** @type {?} */
      const tParent = parentInSameView ? (/** @type {?} */ (parent)) : null;
      return {
          type: type,
          index: adjustedIndex,
          injectorIndex: tParent ? tParent.injectorIndex : -1,
          directiveStart: -1,
          directiveEnd: -1,
          flags: 0,
          providerIndexes: 0,
          tagName: tagName,
          attrs: attrs,
          localNames: null,
          initialInputs: undefined,
          inputs: undefined,
          outputs: undefined,
          tViews: tViews,
          next: null,
          child: null,
          parent: tParent,
          detached: null,
          stylingTemplate: null,
          projection: null
      };
  }
  //////////////////////////
  //// Directive
  //////////////////////////
  /**
   * Instantiate a root component.
   * @template T
   * @param {?} tView
   * @param {?} viewData
   * @param {?} def
   * @return {?}
   */
  function instantiateRootComponent(tView, viewData, def) {
      /** @type {?} */
      const rootTNode = getPreviousOrParentTNode();
      if (tView.firstTemplatePass) {
          if (def.providersResolver)
              def.providersResolver(def);
          generateExpandoInstructionBlock(tView, rootTNode, 1);
          baseResolveDirective(tView, viewData, def, def.factory);
      }
      /** @type {?} */
      const directive = getNodeInjectable(tView.data, viewData, viewData.length - 1, (/** @type {?} */ (rootTNode)));
      postProcessBaseDirective(viewData, rootTNode, directive, (/** @type {?} */ (def)));
      return directive;
  }
  /**
   * Generates a new block in TView.expandoInstructions for this node.
   *
   * Each expando block starts with the element index (turned negative so we can distinguish
   * it from the hostVar count) and the directive count. See more in VIEW_DATA.md.
   * @param {?} tView
   * @param {?} tNode
   * @param {?} directiveCount
   * @return {?}
   */
  function generateExpandoInstructionBlock(tView, tNode, directiveCount) {
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'Expando block should only be generated on first template pass.');
      /** @type {?} */
      const elementIndex = -(tNode.index - HEADER_OFFSET);
      /** @type {?} */
      const providerStartIndex = tNode.providerIndexes & 65535 /* ProvidersStartIndexMask */;
      /** @type {?} */
      const providerCount = tView.data.length - providerStartIndex;
      (tView.expandoInstructions || (tView.expandoInstructions = [])).push(elementIndex, providerCount, directiveCount);
  }
  /**
   * A lighter version of postProcessDirective() that is used for the root component.
   * @template T
   * @param {?} lView
   * @param {?} previousOrParentTNode
   * @param {?} directive
   * @param {?} def
   * @return {?}
   */
  function postProcessBaseDirective(lView, previousOrParentTNode, directive, def) {
      /** @type {?} */
      const native = getNativeByTNode(previousOrParentTNode, lView);
      ngDevMode && assertEqual(lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex, 'directives should be created before any bindings');
      ngDevMode && assertPreviousIsParent(getIsParent());
      attachPatchData(directive, lView);
      if (native) {
          attachPatchData(native, lView);
      }
      // TODO(misko): setUpAttributes should be a feature for better treeshakability.
      if (def.attributes != null && previousOrParentTNode.type == 3 /* Element */) {
          setUpAttributes((/** @type {?} */ (native)), (/** @type {?} */ (def.attributes)));
      }
  }
  /**
   * Stores index of component's host element so it will be queued for view refresh during CD.
   * @param {?} previousOrParentTNode
   * @return {?}
   */
  function queueComponentIndexForCheck(previousOrParentTNode) {
      ngDevMode &&
          assertEqual(getFirstTemplatePass(), true, 'Should only be called in first template pass.');
      /** @type {?} */
      const tView = getLView()[TVIEW];
      (tView.components || (tView.components = [])).push(previousOrParentTNode.index);
  }
  /**
   * Initializes the flags on the current node, setting all indices to the initial index,
   * the directive count to 0, and adding the isComponent flag.
   * @param {?} tNode
   * @param {?} index the initial index
   * @param {?} numberOfDirectives
   * @return {?}
   */
  function initNodeFlags(tNode, index, numberOfDirectives) {
      ngDevMode && assertEqual(getFirstTemplatePass(), true, 'expected firstTemplatePass to be true');
      /** @type {?} */
      const flags = tNode.flags;
      ngDevMode && assertEqual(flags === 0 || flags === 1 /* isComponent */, true, 'expected node flags to not be initialized');
      ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives');
      // When the first directive is created on a node, save the index
      tNode.flags = flags & 1 /* isComponent */;
      tNode.directiveStart = index;
      tNode.directiveEnd = index + numberOfDirectives;
      tNode.providerIndexes = index;
  }
  /**
   * @template T
   * @param {?} tView
   * @param {?} viewData
   * @param {?} def
   * @param {?} directiveFactory
   * @return {?}
   */
  function baseResolveDirective(tView, viewData, def, directiveFactory) {
      tView.data.push(def);
      /** @type {?} */
      const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
      tView.blueprint.push(nodeInjectorFactory);
      viewData.push(nodeInjectorFactory);
  }
  /**
   * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes them
   * by executing an associated template function.
   * @param {?} lView
   * @return {?}
   */
  function refreshDynamicEmbeddedViews(lView) {
      for (let current = getLViewChild(lView); current !== null; current = current[NEXT]) {
          // Note: current can be an LView or an LContainer instance, but here we are only interested
          // in LContainer. We can tell it's an LContainer because its length is less than the LView
          // header.
          if (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === -1) {
              /** @type {?} */
              const container = (/** @type {?} */ (current));
              for (let i = 0; i < container[VIEWS].length; i++) {
                  /** @type {?} */
                  const dynamicViewData = container[VIEWS][i];
                  // The directives and pipes are not needed here as an existing view is only being refreshed.
                  ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');
                  renderEmbeddedTemplate(dynamicViewData, dynamicViewData[TVIEW], (/** @type {?} */ (dynamicViewData[CONTEXT])));
              }
          }
      }
  }
  /////////////
  /**
   * Refreshes components by entering the component view and processing its bindings, queries, etc.
   *
   * @template T
   * @param {?} adjustedElementIndex  Element index in LView[] (adjusted for HEADER_OFFSET)
   * @return {?}
   */
  function componentRefresh(adjustedElementIndex) {
      /** @type {?} */
      const lView = getLView();
      ngDevMode && assertDataInRange(lView, adjustedElementIndex);
      /** @type {?} */
      const hostView = getComponentViewByIndex(adjustedElementIndex, lView);
      ngDevMode && assertNodeType((/** @type {?} */ (lView[TVIEW].data[adjustedElementIndex])), 3 /* Element */);
      // Only attached CheckAlways components or attached, dirty OnPush components should be checked
      if (viewAttached(hostView) && hostView[FLAGS] & (4 /* CheckAlways */ | 8 /* Dirty */)) {
          syncViewWithBlueprint(hostView);
          checkView(hostView, hostView[CONTEXT]);
      }
  }
  /**
   * Syncs an LView instance with its blueprint if they have gotten out of sync.
   *
   * Typically, blueprints and their view instances should always be in sync, so the loop here
   * will be skipped. However, consider this case of two components side-by-side:
   *
   * App template:
   * ```
   * <comp></comp>
   * <comp></comp>
   * ```
   *
   * The following will happen:
   * 1. App template begins processing.
   * 2. First <comp> is matched as a component and its LView is created.
   * 3. Second <comp> is matched as a component and its LView is created.
   * 4. App template completes processing, so it's time to check child templates.
   * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.
   * 6. Second <comp> template is checked. Its blueprint has been updated by the first
   * <comp> template, but its LView was created before this update, so it is out of sync.
   *
   * Note that embedded views inside ngFor loops will never be out of sync because these views
   * are processed as soon as they are created.
   *
   * @param {?} componentView The view to sync
   * @return {?}
   */
  function syncViewWithBlueprint(componentView) {
      /** @type {?} */
      const componentTView = componentView[TVIEW];
      for (let i = componentView.length; i < componentTView.blueprint.length; i++) {
          componentView[i] = componentTView.blueprint[i];
      }
  }
  /**
   * Returns a boolean for whether the view is attached
   * @param {?} view
   * @return {?}
   */
  function viewAttached(view) {
      return (view[FLAGS] & 16 /* Attached */) === 16 /* Attached */;
  }
  /**
   * Adds LView or LContainer to the end of the current view tree.
   *
   * This structure will be used to traverse through nested views to remove listeners
   * and call onDestroy callbacks.
   *
   * @template T
   * @param {?} lView The view where LView or LContainer should be added
   * @param {?} adjustedHostIndex Index of the view's host node in LView[], adjusted for header
   * @param {?} state The LView or LContainer to add to the view tree
   * @return {?} The state passed in
   */
  function addToViewTree(lView, adjustedHostIndex, state) {
      /** @type {?} */
      const tView = lView[TVIEW];
      /** @type {?} */
      const firstTemplatePass = getFirstTemplatePass();
      if (lView[TAIL]) {
          (/** @type {?} */ (lView[TAIL]))[NEXT] = state;
      }
      else if (firstTemplatePass) {
          tView.childIndex = adjustedHostIndex;
      }
      lView[TAIL] = state;
      return state;
  }
  /**
   * Marks current view and all ancestors dirty
   * @param {?} lView
   * @return {?}
   */
  function markViewDirty(lView) {
      while (lView && !(lView[FLAGS] & 128 /* IsRoot */)) {
          lView[FLAGS] |= 8 /* Dirty */;
          lView = (/** @type {?} */ (lView[PARENT]));
      }
      lView[FLAGS] |= 8 /* Dirty */;
      ngDevMode && assertDefined(lView[CONTEXT], 'rootContext should be defined');
      /** @type {?} */
      const rootContext = (/** @type {?} */ (lView[CONTEXT]));
      scheduleTick(rootContext, 1 /* DetectChanges */);
  }
  /**
   * Used to schedule change detection on the whole application.
   *
   * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.
   * It is usually called indirectly by calling `markDirty` when the view needs to be
   * re-rendered.
   *
   * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple
   * `scheduleTick` requests. The scheduling function can be overridden in
   * `renderComponent`'s `scheduler` option.
   * @template T
   * @param {?} rootContext
   * @param {?} flags
   * @return {?}
   */
  function scheduleTick(rootContext, flags) {
      /** @type {?} */
      const nothingScheduled = rootContext.flags === 0 /* Empty */;
      rootContext.flags |= flags;
      if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {
          /** @type {?} */
          let res;
          rootContext.clean = new Promise((r) => res = r);
          rootContext.scheduler(() => {
              if (rootContext.flags & 1 /* DetectChanges */) {
                  rootContext.flags &= ~1 /* DetectChanges */;
                  tickRootContext(rootContext);
              }
              if (rootContext.flags & 2 /* FlushPlayers */) {
                  rootContext.flags &= ~2 /* FlushPlayers */;
                  /** @type {?} */
                  const playerHandler = rootContext.playerHandler;
                  if (playerHandler) {
                      playerHandler.flushPlayers();
                  }
              }
              rootContext.clean = _CLEAN_PROMISE;
              (/** @type {?} */ (res))(null);
          });
      }
  }
  /**
   * @param {?} rootContext
   * @return {?}
   */
  function tickRootContext(rootContext) {
      for (let i = 0; i < rootContext.components.length; i++) {
          /** @type {?} */
          const rootComponent = rootContext.components[i];
          renderComponentOrTemplate((/** @type {?} */ (readPatchedLView(rootComponent))), rootComponent);
      }
  }
  /**
   * Synchronously perform change detection on a component (and possibly its sub-components).
   *
   * This function triggers change detection in a synchronous way on a component. There should
   * be very little reason to call this function directly since a preferred way to do change
   * detection is to {\@link markDirty} the component and wait for the scheduler to call this method
   * at some future point in time. This is because a single user action often results in many
   * components being invalidated and calling change detection on each component synchronously
   * would be inefficient. It is better to wait until all components are marked as dirty and
   * then perform single change detection across all of the components
   *
   * @template T
   * @param {?} component The component which the change detection should be performed on.
   * @return {?}
   */
  function detectChanges(component) {
      /** @type {?} */
      const view = (/** @type {?} */ (getComponentViewByInstance(component)));
      detectChangesInternal(view, component);
  }
  /**
   * @template T
   * @param {?} view
   * @param {?} context
   * @return {?}
   */
  function detectChangesInternal(view, context) {
      /** @type {?} */
      const rendererFactory = view[RENDERER_FACTORY];
      if (rendererFactory.begin)
          rendererFactory.begin();
      if (isCreationMode(view)) {
          checkView(view, context); // creation mode pass
      }
      checkView(view, context); // update mode pass
      if (rendererFactory.end)
          rendererFactory.end();
  }
  /**
   * Synchronously perform change detection on a root view and its components.
   *
   * @param {?} lView The view which the change detection should be performed on.
   * @return {?}
   */
  function detectChangesInRootView(lView) {
      tickRootContext((/** @type {?} */ (lView[CONTEXT])));
  }
  /**
   * Checks the change detector and its children, and throws if any changes are detected.
   *
   * This is used in development mode to verify that running change detection doesn't
   * introduce other changes.
   * @template T
   * @param {?} component
   * @return {?}
   */
  function checkNoChanges(component) {
      setCheckNoChangesMode(true);
      try {
          detectChanges(component);
      }
      finally {
          setCheckNoChangesMode(false);
      }
  }
  /**
   * Checks the change detector on a root view and its components, and throws if any changes are
   * detected.
   *
   * This is used in development mode to verify that running change detection doesn't
   * introduce other changes.
   *
   * @param {?} lView The view which the change detection should be checked on.
   * @return {?}
   */
  function checkNoChangesInRootView(lView) {
      setCheckNoChangesMode(true);
      try {
          detectChangesInRootView(lView);
      }
      finally {
          setCheckNoChangesMode(false);
      }
  }
  /**
   * Checks the view of the component provided. Does not gate on dirty checks or execute doCheck.
   * @template T
   * @param {?} hostView
   * @param {?} component
   * @return {?}
   */
  function checkView(hostView, component) {
      /** @type {?} */
      const hostTView = hostView[TVIEW];
      /** @type {?} */
      const oldView = enterView(hostView, hostView[HOST_NODE]);
      /** @type {?} */
      const templateFn = (/** @type {?} */ (hostTView.template));
      /** @type {?} */
      const viewQuery = hostTView.viewQuery;
      try {
          namespaceHTML();
          createViewQuery(viewQuery, hostView, component);
          templateFn(getRenderFlags(hostView), component);
          refreshDescendantViews(hostView);
          updateViewQuery(viewQuery, hostView, component);
      }
      finally {
          leaveView(oldView);
      }
  }
  /**
   * @template T
   * @param {?} viewQuery
   * @param {?} view
   * @param {?} component
   * @return {?}
   */
  function createViewQuery(viewQuery, view, component) {
      if (viewQuery && isCreationMode(view)) {
          viewQuery(1 /* Create */, component);
      }
  }
  /**
   * @template T
   * @param {?} viewQuery
   * @param {?} view
   * @param {?} component
   * @return {?}
   */
  function updateViewQuery(viewQuery, view, component) {
      if (viewQuery && !isCreationMode(view)) {
          viewQuery(2 /* Update */, component);
      }
  }
  /** @type {?} */
  const CLEAN_PROMISE = _CLEAN_PROMISE;
  /**
   * @param {?} view
   * @return {?}
   */
  function getCleanup(view) {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return view[CLEANUP] || (view[CLEANUP] = []);
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function getTViewCleanup(view) {
      return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);
  }
  /**
   * Creates the root component view and the root component node.
   *
   * @param {?} rNode Render host element.
   * @param {?} def ComponentDef
   * @param {?} rootView The parent view where the host node is stored
   * @param {?} rendererFactory
   * @param {?} renderer The current renderer
   * @param {?=} sanitizer The sanitizer, if provided
   *
   * @return {?} Component view created
   */
  function createRootComponentView(rNode, def, rootView, rendererFactory, renderer, sanitizer) {
      resetComponentState();
      /** @type {?} */
      const tView = rootView[TVIEW];
      /** @type {?} */
      const componentView = createLView(rootView, getOrCreateTView(def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery), null, def.onPush ? 8 /* Dirty */ : 4 /* CheckAlways */, rendererFactory, renderer, sanitizer);
      /** @type {?} */
      const tNode = createNodeAtIndex(0, 3 /* Element */, rNode, null, null);
      if (tView.firstTemplatePass) {
          diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), rootView, def.type);
          tNode.flags = 1 /* isComponent */;
          initNodeFlags(tNode, rootView.length, 1);
          queueComponentIndexForCheck(tNode);
      }
      // Store component view at node index, with node as the HOST
      componentView[HOST] = rootView[HEADER_OFFSET];
      componentView[HOST_NODE] = (/** @type {?} */ (tNode));
      return rootView[HEADER_OFFSET] = componentView;
  }
  /**
   * Creates a root component and sets it up with features and host bindings. Shared by
   * renderComponent() and ViewContainerRef.createComponent().
   * @template T
   * @param {?} componentView
   * @param {?} componentDef
   * @param {?} rootView
   * @param {?} rootContext
   * @param {?} hostFeatures
   * @return {?}
   */
  function createRootComponent(componentView, componentDef, rootView, rootContext, hostFeatures) {
      /** @type {?} */
      const tView = rootView[TVIEW];
      // Create directive instance with factory() and store at next index in viewData
      /** @type {?} */
      const component = instantiateRootComponent(tView, rootView, componentDef);
      rootContext.components.push(component);
      componentView[CONTEXT] = component;
      hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));
      if (tView.firstTemplatePass && componentDef.hostBindings) {
          /** @type {?} */
          const rootTNode = getPreviousOrParentTNode();
          componentDef.hostBindings(1 /* Create */, component, rootTNode.index - HEADER_OFFSET);
      }
      return component;
  }
  /**
   * @param {?=} scheduler
   * @param {?=} playerHandler
   * @return {?}
   */
  function createRootContext(scheduler, playerHandler) {
      return {
          components: [],
          scheduler: scheduler || defaultScheduler,
          clean: CLEAN_PROMISE,
          playerHandler: playerHandler || null,
          flags: 0 /* Empty */
      };
  }
  /**
   * Used to enable lifecycle hooks on the root component.
   *
   * Include this feature when calling `renderComponent` if the root component
   * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't
   * be called properly.
   *
   * Example:
   *
   * ```
   * renderComponent(AppComponent, {features: [RootLifecycleHooks]});
   * ```
   * @param {?} component
   * @param {?} def
   * @return {?}
   */
  function LifecycleHooksFeature(component, def) {
      /** @type {?} */
      const rootTView = (/** @type {?} */ (readPatchedLView(component)))[TVIEW];
      /** @type {?} */
      const dirIndex = rootTView.data.length - 1;
      queueInitHooks(dirIndex, def.onInit, def.doCheck, rootTView);
      // TODO(misko): replace `as TNode` with createTNode call. (needs refactoring to lose dep on
      // LNode).
      queueLifecycleHooks(rootTView, (/** @type {?} */ ({ directiveStart: dirIndex, directiveEnd: dirIndex + 1 })));
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @param {...?} args
   * @return {?}
   */
  function noop$1(...args) {
      // Do nothing.
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const SOURCE = '__source';
  /** @type {?} */
  const _THROW_IF_NOT_FOUND = new Object();
  /** @type {?} */
  const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  /**
   * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
   *
   * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
   * project.
   *
   * \@publicApi
   * @type {?}
   */
  const INJECTOR$1 = new InjectionToken('INJECTOR');
  class NullInjector {
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */
      get(token, notFoundValue = _THROW_IF_NOT_FOUND) {
          if (notFoundValue === _THROW_IF_NOT_FOUND) {
              // Intentionally left behind: With dev tools open the debugger will stop here. There is no
              // reason why correctly written application should cause this exception.
              // TODO(misko): uncomment the next line once `ngDevMode` works with closure.
              // if(ngDevMode) debugger;
              throw new Error(`NullInjectorError: No provider for ${stringify$1(token)}!`);
          }
          return notFoundValue;
      }
  }
  /**
   * Concrete injectors implement this interface.
   *
   * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
   *
   * \@usageNotes
   * ### Example
   *
   * {\@example core/di/ts/injector_spec.ts region='Injector'}
   *
   * `Injector` returns itself when given `Injector` as a token:
   *
   * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
   *
   * \@publicApi
   * @abstract
   */
  class Injector {
      /**
       * Create a new Injector which is configure using `StaticProvider`s.
       *
       * \@usageNotes
       * ### Example
       *
       * {\@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
       * @param {?} options
       * @param {?=} parent
       * @return {?}
       */
      static create(options, parent) {
          if (Array.isArray(options)) {
              return new StaticInjector(options, parent);
          }
          else {
              return new StaticInjector(options.providers, options.parent, options.name || null);
          }
      }
  }
  Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
  Injector.NULL = new NullInjector();
  /** @nocollapse */
  /** @nocollapse */ Injector.ngInjectableDef = defineInjectable({
      providedIn: (/** @type {?} */ ('any')),
      factory: () => inject(INJECTOR$1),
  });
  /**
   * \@internal
   */
  Injector.__NG_ELEMENT_ID__ = () => SWITCH_INJECTOR_FACTORY();
  /** @type {?} */
  const SWITCH_INJECTOR_FACTORY__PRE_R3__ = noop$1;
  /** @type {?} */
  const SWITCH_INJECTOR_FACTORY = SWITCH_INJECTOR_FACTORY__PRE_R3__;
  /** @type {?} */
  const IDENT = function (value) {
      return value;
  };
  /** @type {?} */
  const EMPTY$1 = (/** @type {?} */ ([]));
  /** @type {?} */
  const CIRCULAR = IDENT;
  /** @type {?} */
  const MULTI_PROVIDER_FN = function () {
      return Array.prototype.slice.call(arguments);
  };
  /** @type {?} */
  const USE_VALUE$2 = getClosureSafeProperty({ provide: String, useValue: getClosureSafeProperty });
  /** @type {?} */
  const NG_TOKEN_PATH = 'ngTokenPath';
  /** @type {?} */
  const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';
  /** @type {?} */
  const NULL_INJECTOR$1 = Injector.NULL;
  /** @type {?} */
  const NEW_LINE = /\n/gm;
  /** @type {?} */
  const NO_NEW_LINE = 'ɵ';
  class StaticInjector {
      /**
       * @param {?} providers
       * @param {?=} parent
       * @param {?=} source
       */
      constructor(providers, parent = NULL_INJECTOR$1, source = null) {
          this.parent = parent;
          this.source = source;
          /** @type {?} */
          const records = this._records = new Map();
          records.set(Injector, (/** @type {?} */ ({ token: Injector, fn: IDENT, deps: EMPTY$1, value: this, useNew: false })));
          records.set(INJECTOR$1, (/** @type {?} */ ({ token: INJECTOR$1, fn: IDENT, deps: EMPTY$1, value: this, useNew: false })));
          recursivelyProcessProviders(records, providers);
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @param {?=} flags
       * @return {?}
       */
      get(token, notFoundValue, flags = InjectFlags.Default) {
          /** @type {?} */
          const record = this._records.get(token);
          try {
              return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);
          }
          catch (e) {
              /** @type {?} */
              const tokenPath = e[NG_TEMP_TOKEN_PATH];
              if (token[SOURCE]) {
                  tokenPath.unshift(token[SOURCE]);
              }
              e.message = formatError('\n' + e.message, tokenPath, this.source);
              e[NG_TOKEN_PATH] = tokenPath;
              e[NG_TEMP_TOKEN_PATH] = null;
              throw e;
          }
      }
      /**
       * @return {?}
       */
      toString() {
          /** @type {?} */
          const tokens = (/** @type {?} */ ([]));
          /** @type {?} */
          const records = this._records;
          records.forEach((v, token) => tokens.push(stringify$1(token)));
          return `StaticInjector[${tokens.join(', ')}]`;
      }
  }
  /**
   * @param {?} provider
   * @return {?}
   */
  function resolveProvider(provider) {
      /** @type {?} */
      const deps = computeDeps(provider);
      /** @type {?} */
      let fn = IDENT;
      /** @type {?} */
      let value = EMPTY$1;
      /** @type {?} */
      let useNew = false;
      /** @type {?} */
      let provide = resolveForwardRef$1(provider.provide);
      if (USE_VALUE$2 in provider) {
          // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
          value = ((/** @type {?} */ (provider))).useValue;
      }
      else if (((/** @type {?} */ (provider))).useFactory) {
          fn = ((/** @type {?} */ (provider))).useFactory;
      }
      else if (((/** @type {?} */ (provider))).useExisting) ;
      else if (((/** @type {?} */ (provider))).useClass) {
          useNew = true;
          fn = resolveForwardRef$1(((/** @type {?} */ (provider))).useClass);
      }
      else if (typeof provide == 'function') {
          useNew = true;
          fn = provide;
      }
      else {
          throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);
      }
      return { deps, fn, useNew, value };
  }
  /**
   * @param {?} token
   * @return {?}
   */
  function multiProviderMixError(token) {
      return staticError('Cannot mix multi providers and regular providers', token);
  }
  /**
   * @param {?} records
   * @param {?} provider
   * @return {?}
   */
  function recursivelyProcessProviders(records, provider) {
      if (provider) {
          provider = resolveForwardRef$1(provider);
          if (provider instanceof Array) {
              // if we have an array recurse into the array
              for (let i = 0; i < provider.length; i++) {
                  recursivelyProcessProviders(records, provider[i]);
              }
          }
          else if (typeof provider === 'function') {
              // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
              // error messages
              throw staticError('Function/Class not supported', provider);
          }
          else if (provider && typeof provider === 'object' && provider.provide) {
              // At this point we have what looks like a provider: {provide: ?, ....}
              /** @type {?} */
              let token = resolveForwardRef$1(provider.provide);
              /** @type {?} */
              const resolvedProvider = resolveProvider(provider);
              if (provider.multi === true) {
                  // This is a multi provider.
                  /** @type {?} */
                  let multiProvider = records.get(token);
                  if (multiProvider) {
                      if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                          throw multiProviderMixError(token);
                      }
                  }
                  else {
                      // Create a placeholder factory which will look up the constituents of the multi provider.
                      records.set(token, multiProvider = (/** @type {?} */ ({
                          token: provider.provide,
                          deps: [],
                          useNew: false,
                          fn: MULTI_PROVIDER_FN,
                          value: EMPTY$1
                      })));
                  }
                  // Treat the provider as the token.
                  token = provider;
                  multiProvider.deps.push({ token, options: 6 /* Default */ });
              }
              /** @type {?} */
              const record = records.get(token);
              if (record && record.fn == MULTI_PROVIDER_FN) {
                  throw multiProviderMixError(token);
              }
              records.set(token, resolvedProvider);
          }
          else {
              throw staticError('Unexpected provider', provider);
          }
      }
  }
  /**
   * @param {?} token
   * @param {?} record
   * @param {?} records
   * @param {?} parent
   * @param {?} notFoundValue
   * @param {?} flags
   * @return {?}
   */
  function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
      try {
          return resolveToken(token, record, records, parent, notFoundValue, flags);
      }
      catch (e) {
          // ensure that 'e' is of type Error.
          if (!(e instanceof Error)) {
              e = new Error(e);
          }
          /** @type {?} */
          const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
          path.unshift(token);
          if (record && record.value == CIRCULAR) {
              // Reset the Circular flag.
              record.value = EMPTY$1;
          }
          throw e;
      }
  }
  /**
   * @param {?} token
   * @param {?} record
   * @param {?} records
   * @param {?} parent
   * @param {?} notFoundValue
   * @param {?} flags
   * @return {?}
   */
  function resolveToken(token, record, records, parent, notFoundValue, flags) {
      /** @type {?} */
      let value;
      if (record && !(flags & InjectFlags.SkipSelf)) {
          // If we don't have a record, this implies that we don't own the provider hence don't know how
          // to resolve it.
          value = record.value;
          if (value == CIRCULAR) {
              throw Error(NO_NEW_LINE + 'Circular dependency');
          }
          else if (value === EMPTY$1) {
              record.value = CIRCULAR;
              /** @type {?} */
              let obj = undefined;
              /** @type {?} */
              let useNew = record.useNew;
              /** @type {?} */
              let fn = record.fn;
              /** @type {?} */
              let depRecords = record.deps;
              /** @type {?} */
              let deps = EMPTY$1;
              if (depRecords.length) {
                  deps = [];
                  for (let i = 0; i < depRecords.length; i++) {
                      /** @type {?} */
                      const depRecord = depRecords[i];
                      /** @type {?} */
                      const options = depRecord.options;
                      /** @type {?} */
                      const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                      deps.push(tryResolveToken(
                      // Current Token to resolve
                      depRecord.token, 
                      // A record which describes how to resolve the token.
                      // If undefined, this means we don't have such a record
                      childRecord, 
                      // Other records we know about.
                      records, 
                      // If we don't know how to resolve dependency and we should not check parent for it,
                      // than pass in Null injector.
                      !childRecord && !(options & 4 /* CheckParent */) ? NULL_INJECTOR$1 : parent, options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                  }
              }
              record.value = value = useNew ? new ((/** @type {?} */ (fn)))(...deps) : fn.apply(obj, deps);
          }
      }
      else if (!(flags & InjectFlags.Self)) {
          value = parent.get(token, notFoundValue, InjectFlags.Default);
      }
      return value;
  }
  /**
   * @param {?} provider
   * @return {?}
   */
  function computeDeps(provider) {
      /** @type {?} */
      let deps = EMPTY$1;
      /** @type {?} */
      const providerDeps = ((/** @type {?} */ (provider))).deps;
      if (providerDeps && providerDeps.length) {
          deps = [];
          for (let i = 0; i < providerDeps.length; i++) {
              /** @type {?} */
              let options = 6 /* Default */;
              /** @type {?} */
              let token = resolveForwardRef$1(providerDeps[i]);
              if (token instanceof Array) {
                  for (let j = 0, annotations = token; j < annotations.length; j++) {
                      /** @type {?} */
                      const annotation = annotations[j];
                      if (annotation instanceof Optional || annotation == Optional) {
                          options = options | 1 /* Optional */;
                      }
                      else if (annotation instanceof SkipSelf || annotation == SkipSelf) {
                          options = options & ~2 /* CheckSelf */;
                      }
                      else if (annotation instanceof Self || annotation == Self) {
                          options = options & ~4 /* CheckParent */;
                      }
                      else if (annotation instanceof Inject) {
                          token = ((/** @type {?} */ (annotation))).token;
                      }
                      else {
                          token = resolveForwardRef$1(annotation);
                      }
                  }
              }
              deps.push({ token, options });
          }
      }
      else if (((/** @type {?} */ (provider))).useExisting) {
          /** @type {?} */
          const token = resolveForwardRef$1(((/** @type {?} */ (provider))).useExisting);
          deps = [{ token, options: 6 /* Default */ }];
      }
      else if (!providerDeps && !(USE_VALUE$2 in provider)) {
          // useValue & useExisting are the only ones which are exempt from deps all others need it.
          throw staticError('\'deps\' required', provider);
      }
      return deps;
  }
  /**
   * @param {?} text
   * @param {?} obj
   * @param {?=} source
   * @return {?}
   */
  function formatError(text, obj, source = null) {
      text = text && text.charAt(0) === '\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
      /** @type {?} */
      let context = stringify$1(obj);
      if (obj instanceof Array) {
          context = obj.map(stringify$1).join(' -> ');
      }
      else if (typeof obj === 'object') {
          /** @type {?} */
          let parts = (/** @type {?} */ ([]));
          for (let key in obj) {
              if (obj.hasOwnProperty(key)) {
                  /** @type {?} */
                  let value = obj[key];
                  parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify$1(value)));
              }
          }
          context = `{${parts.join(', ')}}`;
      }
      return `StaticInjectorError${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\n  ')}`;
  }
  /**
   * @param {?} text
   * @param {?} obj
   * @return {?}
   */
  function staticError(text, obj) {
      return new Error(formatError(text, obj));
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * An internal token whose presence in an injector indicates that the injector should treat itself
   * as a root scoped injector when processing requests for unknown tokens which may indicate
   * they are provided in the root scope.
   * @type {?}
   */
  const APP_ROOT = new InjectionToken('The presence of this token marks an injector as being the root injector.');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Represents a component created by a `ComponentFactory`.
   * Provides access to the component instance and related objects,
   * and provides the means of destroying the instance.
   *
   * \@publicApi
   * @abstract
   * @template C
   */
  class ComponentRef {
  }
  /**
   * \@publicApi
   * @abstract
   * @template C
   */
  class ComponentFactory {
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} component
   * @return {?}
   */
  function noComponentFactoryError(component) {
      /** @type {?} */
      const error = Error(`No component factory found for ${stringify$1(component)}. Did you add it to @NgModule.entryComponents?`);
      ((/** @type {?} */ (error)))[ERROR_COMPONENT] = component;
      return error;
  }
  /** @type {?} */
  const ERROR_COMPONENT = 'ngComponent';
  class _NullComponentFactoryResolver {
      /**
       * @template T
       * @param {?} component
       * @return {?}
       */
      resolveComponentFactory(component) {
          throw noComponentFactoryError(component);
      }
  }
  /**
   * \@publicApi
   * @abstract
   */
  class ComponentFactoryResolver {
  }
  ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
  class CodegenComponentFactoryResolver {
      /**
       * @param {?} factories
       * @param {?} _parent
       * @param {?} _ngModule
       */
      constructor(factories, _parent, _ngModule) {
          this._parent = _parent;
          this._ngModule = _ngModule;
          this._factories = new Map();
          for (let i = 0; i < factories.length; i++) {
              /** @type {?} */
              const factory = factories[i];
              this._factories.set(factory.componentType, factory);
          }
      }
      /**
       * @template T
       * @param {?} component
       * @return {?}
       */
      resolveComponentFactory(component) {
          /** @type {?} */
          let factory = this._factories.get(component);
          if (!factory && this._parent) {
              factory = this._parent.resolveComponentFactory(component);
          }
          if (!factory) {
              throw noComponentFactoryError(component);
          }
          return new ComponentFactoryBoundToModule(factory, this._ngModule);
      }
  }
  /**
   * @template C
   */
  class ComponentFactoryBoundToModule extends ComponentFactory {
      /**
       * @param {?} factory
       * @param {?} ngModule
       */
      constructor(factory, ngModule) {
          super();
          this.factory = factory;
          this.ngModule = ngModule;
          this.selector = factory.selector;
          this.componentType = factory.componentType;
          this.ngContentSelectors = factory.ngContentSelectors;
          this.inputs = factory.inputs;
          this.outputs = factory.outputs;
      }
      /**
       * @param {?} injector
       * @param {?=} projectableNodes
       * @param {?=} rootSelectorOrNode
       * @param {?=} ngModule
       * @return {?}
       */
      create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
          return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Represents an instance of an NgModule created via a {\@link NgModuleFactory}.
   *
   * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
   * NgModule Instance.
   *
   * \@publicApi
   * @abstract
   * @template T
   */
  class NgModuleRef {
  }
  /**
   * \@publicApi
   * @abstract
   * @template T
   */
  class NgModuleFactory {
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @template T
   */
  class ViewRef {
      /**
       * @param {?} _lView
       * @param {?} _context
       * @param {?} _componentIndex
       */
      constructor(_lView, _context, _componentIndex) {
          this._context = _context;
          this._componentIndex = _componentIndex;
          this._appRef = null;
          this._viewContainerRef = null;
          /**
           * \@internal
           */
          this._tViewNode = null;
          this._lView = _lView;
      }
      /**
       * @return {?}
       */
      get rootNodes() {
          if (this._lView[HOST] == null) {
              /** @type {?} */
              const tView = (/** @type {?} */ (this._lView[HOST_NODE]));
              return collectNativeNodes(this._lView, tView, []);
          }
          return [];
      }
      /**
       * @return {?}
       */
      get context() { return this._context ? this._context : this._lookUpContext(); }
      /**
       * @return {?}
       */
      get destroyed() {
          return (this._lView[FLAGS] & 64 /* Destroyed */) === 64 /* Destroyed */;
      }
      /**
       * @return {?}
       */
      destroy() {
          if (this._appRef) {
              this._appRef.detachView(this);
          }
          else if (this._viewContainerRef) {
              /** @type {?} */
              const index = this._viewContainerRef.indexOf(this);
              if (index > -1) {
                  this._viewContainerRef.detach(index);
              }
              this._viewContainerRef = null;
          }
          destroyLView(this._lView);
      }
      /**
       * @param {?} callback
       * @return {?}
       */
      onDestroy(callback) { storeCleanupFn(this._lView, callback); }
      /**
       * Marks a view and all of its ancestors dirty.
       *
       * It also triggers change detection by calling `scheduleTick` internally, which coalesces
       * multiple `markForCheck` calls to into one change detection run.
       *
       * This can be used to ensure an {\@link ChangeDetectionStrategy#OnPush OnPush} component is
       * checked when it needs to be re-rendered but the two normal triggers haven't marked it
       * dirty (i.e. inputs haven't changed and events haven't fired in the view).
       *
       * <!-- TODO: Add a link to a chapter on OnPush components -->
       *
       * \@usageNotes
       * ### Example
       *
       * ```typescript
       * \@Component({
       *   selector: 'my-app',
       *   template: `Number of ticks: {{numberOfTicks}}`
       *   changeDetection: ChangeDetectionStrategy.OnPush,
       * })
       * class AppComponent {
       *   numberOfTicks = 0;
       *
       *   constructor(private ref: ChangeDetectorRef) {
       *     setInterval(() => {
       *       this.numberOfTicks++;
       *       // the following is required, otherwise the view will not be updated
       *       this.ref.markForCheck();
       *     }, 1000);
       *   }
       * }
       * ```
       * @return {?}
       */
      markForCheck() { markViewDirty(this._lView); }
      /**
       * Detaches the view from the change detection tree.
       *
       * Detached views will not be checked during change detection runs until they are
       * re-attached, even if they are dirty. `detach` can be used in combination with
       * {\@link ChangeDetectorRef#detectChanges detectChanges} to implement local change
       * detection checks.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
       *
       * \@usageNotes
       * ### Example
       *
       * The following example defines a component with a large list of readonly data.
       * Imagine the data changes constantly, many times per second. For performance reasons,
       * we want to check and update the list every five seconds. We can do that by detaching
       * the component's change detector and doing a local check every five seconds.
       *
       * ```typescript
       * class DataProvider {
       *   // in a real application the returned data will be different every time
       *   get data() {
       *     return [1,2,3,4,5];
       *   }
       * }
       *
       * \@Component({
       *   selector: 'giant-list',
       *   template: `
       *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
       *   `,
       * })
       * class GiantList {
       *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
       *     ref.detach();
       *     setInterval(() => {
       *       this.ref.detectChanges();
       *     }, 5000);
       *   }
       * }
       *  /
       *   selector: 'app',
       *   providers: [DataProvider],
       *   template: `
       *     <giant-list><giant-list>
       *   `,
       * })
       * class App {
       * }
       * ```
       * @return {?}
       */
      detach() { this._lView[FLAGS] &= ~16 /* Attached */; }
      /**
       * Re-attaches a view to the change detection tree.
       *
       * This can be used to re-attach views that were previously detached from the tree
       * using {\@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       *
       * \@usageNotes
       * ### Example
       *
       * The following example creates a component displaying `live` data. The component will detach
       * its change detector from the main change detector tree when the component's live property
       * is set to false.
       *
       * ```typescript
       * class DataProvider {
       *   data = 1;
       *
       *   constructor() {
       *     setInterval(() => {
       *       this.data = this.data * 2;
       *     }, 500);
       *   }
       * }
       *
       * \@Component({
       *   selector: 'live-data',
       *   inputs: ['live'],
       *   template: 'Data: {{dataProvider.data}}'
       * })
       * class LiveData {
       *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
       *
       *   set live(value) {
       *     if (value) {
       *       this.ref.reattach();
       *     } else {
       *       this.ref.detach();
       *     }
       *   }
       * }
       *  /
       *   selector: 'my-app',
       *   providers: [DataProvider],
       *   template: `
       *     Live Update: <input type="checkbox" [(ngModel)]="live">
       *     <live-data [live]="live"><live-data>
       *   `,
       * })
       * class AppComponent {
       *   live = true;
       * }
       * ```
       * @return {?}
       */
      reattach() { this._lView[FLAGS] |= 16 /* Attached */; }
      /**
       * Checks the view and its children.
       *
       * This can also be used in combination with {\@link ChangeDetectorRef#detach detach} to implement
       * local change detection checks.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
       *
       * \@usageNotes
       * ### Example
       *
       * The following example defines a component with a large list of readonly data.
       * Imagine, the data changes constantly, many times per second. For performance reasons,
       * we want to check and update the list every five seconds.
       *
       * We can do that by detaching the component's change detector and doing a local change detection
       * check every five seconds.
       *
       * See {\@link ChangeDetectorRef#detach detach} for more information.
       * @return {?}
       */
      detectChanges() { detectChangesInternal(this._lView, this.context); }
      /**
       * Checks the change detector and its children, and throws if any changes are detected.
       *
       * This is used in development mode to verify that running change detection doesn't
       * introduce other changes.
       * @return {?}
       */
      checkNoChanges() { checkNoChanges(this.context); }
      /**
       * @param {?} vcRef
       * @return {?}
       */
      attachToViewContainerRef(vcRef) {
          if (this._appRef) {
              throw new Error('This view is already attached directly to the ApplicationRef!');
          }
          this._viewContainerRef = vcRef;
      }
      /**
       * @return {?}
       */
      detachFromAppRef() { this._appRef = null; }
      /**
       * @param {?} appRef
       * @return {?}
       */
      attachToAppRef(appRef) {
          if (this._viewContainerRef) {
              throw new Error('This view is already attached to a ViewContainer!');
          }
          this._appRef = appRef;
      }
      /**
       * @private
       * @return {?}
       */
      _lookUpContext() {
          return this._context = (/** @type {?} */ ((/** @type {?} */ (this._lView[PARENT]))[this._componentIndex]));
      }
  }
  /**
   * \@internal
   * @template T
   */
  class RootViewRef extends ViewRef {
      /**
       * @param {?} _view
       */
      constructor(_view) {
          super(_view, null, -1);
          this._view = _view;
      }
      /**
       * @return {?}
       */
      detectChanges() { detectChangesInRootView(this._view); }
      /**
       * @return {?}
       */
      checkNoChanges() { checkNoChangesInRootView(this._view); }
      /**
       * @return {?}
       */
      get context() { return (/** @type {?} */ (null)); }
  }
  /**
   * @param {?} lView
   * @param {?} parentTNode
   * @param {?} result
   * @return {?}
   */
  function collectNativeNodes(lView, parentTNode, result) {
      /** @type {?} */
      let tNodeChild = parentTNode.child;
      while (tNodeChild) {
          result.push(getNativeByTNode(tNodeChild, lView));
          if (tNodeChild.type === 4 /* ElementContainer */) {
              collectNativeNodes(lView, tNodeChild, result);
          }
          tNodeChild = tNodeChild.next;
      }
      return result;
  }
  /** @type {?} */
  let R3ElementRef;
  /**
   * Creates an ElementRef given a node.
   *
   * @param {?} ElementRefToken The ElementRef type
   * @param {?} tNode The node for which you'd like an ElementRef
   * @param {?} view The view to which the node belongs
   * @return {?} The ElementRef instance to use
   */
  function createElementRef(ElementRefToken, tNode, view) {
      if (!R3ElementRef) {
          // TODO: Fix class name, should be ElementRef, but there appears to be a rollup bug
          R3ElementRef = class ElementRef_ extends ElementRefToken {
          };
      }
      return new R3ElementRef(getNativeByTNode(tNode, view));
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A wrapper around a native element inside of a View.
   *
   * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
   * element.
   *
   * \@security Permitting direct access to the DOM can make your application more vulnerable to
   * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
   * [Security Guide](http://g.co/ng/security).
   *
   * \@publicApi
   * @template T
   */
  // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
  // i.e. users have to ask for what they need. With that, we can build better analysis tools
  // and could do better codegen in the future.
  class ElementRef {
      /**
       * @param {?} nativeElement
       */
      constructor(nativeElement) { this.nativeElement = nativeElement; }
  }
  /**
   * \@internal
   */
  ElementRef.__NG_ELEMENT_ID__ = () => SWITCH_ELEMENT_REF_FACTORY(ElementRef);
  /** @type {?} */
  const SWITCH_ELEMENT_REF_FACTORY__PRE_R3__ = noop$1;
  /** @type {?} */
  const SWITCH_ELEMENT_REF_FACTORY = SWITCH_ELEMENT_REF_FACTORY__PRE_R3__;
  /**
   * @deprecated Use the `Renderer2` instead.
   * \@publicApi
   * @abstract
   */
  class Renderer {
  }
  /** @type {?} */
  const Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');
  /**
   * Creates and initializes a custom renderer that implements the `Renderer2` base class.
   *
   * \@publicApi
   * @abstract
   */
  class RendererFactory2 {
  }
  /** @enum {number} */
  const RendererStyleFlags2 = {
      /**
       * Marks a style as important.
       */
      Important: 1,
      /**
       * Marks a style as using dash case naming (this-is-dash-case).
       */
      DashCase: 2,
  };
  RendererStyleFlags2[RendererStyleFlags2.Important] = 'Important';
  RendererStyleFlags2[RendererStyleFlags2.DashCase] = 'DashCase';
  /**
   * Extend this base class to implement custom rendering. By default, Angular
   * renders a template into DOM. You can use custom rendering to intercept
   * rendering calls, or to render to something other than DOM.
   *
   * Create your custom renderer using `RendererFactory2`.
   *
   * Use a custom renderer to bypass Angular's templating and
   * make custom UI changes that can't be expressed declaratively.
   * For example if you need to set a property or an attribute whose name is
   * not statically known, use the `setProperty()` or
   * `setAttribute()` method.
   *
   * \@publicApi
   * @abstract
   */
  class Renderer2 {
  }
  /**
   * \@internal
   */
  Renderer2.__NG_ELEMENT_ID__ = () => SWITCH_RENDERER2_FACTORY();
  /** @type {?} */
  const SWITCH_RENDERER2_FACTORY__PRE_R3__ = noop$1;
  /** @type {?} */
  const SWITCH_RENDERER2_FACTORY = SWITCH_RENDERER2_FACTORY__PRE_R3__;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @enum {number} */
  const SecurityContext$1 = {
      NONE: 0,
      HTML: 1,
      STYLE: 2,
      SCRIPT: 3,
      URL: 4,
      RESOURCE_URL: 5,
  };
  SecurityContext$1[SecurityContext$1.NONE] = 'NONE';
  SecurityContext$1[SecurityContext$1.HTML] = 'HTML';
  SecurityContext$1[SecurityContext$1.STYLE] = 'STYLE';
  SecurityContext$1[SecurityContext$1.SCRIPT] = 'SCRIPT';
  SecurityContext$1[SecurityContext$1.URL] = 'URL';
  SecurityContext$1[SecurityContext$1.RESOURCE_URL] = 'RESOURCE_URL';
  /**
   * Sanitizer is used by the views to sanitize potentially dangerous values.
   *
   * \@publicApi
   * @abstract
   */
  class Sanitizer {
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * \@description Represents the version of Angular
   *
   * \@publicApi
   */
  class Version$1 {
      /**
       * @param {?} full
       */
      constructor(full) {
          this.full = full;
          this.major = full.split('.')[0];
          this.minor = full.split('.')[1];
          this.patch = full.split('.').slice(2).join('.');
      }
  }
  /**
   * \@publicApi
   * @type {?}
   */
  const VERSION$2 = new Version$1('7.2.8');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class ComponentFactoryResolver$1 extends ComponentFactoryResolver {
      /**
       * @param {?=} ngModule The NgModuleRef to which all resolved factories are bound.
       */
      constructor(ngModule) {
          super();
          this.ngModule = ngModule;
      }
      /**
       * @template T
       * @param {?} component
       * @return {?}
       */
      resolveComponentFactory(component) {
          ngDevMode && assertComponentType(component);
          /** @type {?} */
          const componentDef = (/** @type {?} */ (getComponentDef(component)));
          return new ComponentFactory$1(componentDef, this.ngModule);
      }
  }
  /**
   * @param {?} map
   * @return {?}
   */
  function toRefArray(map$$1) {
      /** @type {?} */
      const array = [];
      for (let nonMinified in map$$1) {
          if (map$$1.hasOwnProperty(nonMinified)) {
              /** @type {?} */
              const minified = map$$1[nonMinified];
              array.push({ propName: minified, templateName: nonMinified });
          }
      }
      return array;
  }
  /**
   * Default {\@link RootContext} for all components rendered with {\@link renderComponent}.
   * @type {?}
   */
  const ROOT_CONTEXT = new InjectionToken('ROOT_CONTEXT_TOKEN', { providedIn: 'root', factory: () => createRootContext(inject(SCHEDULER)) });
  /**
   * A change detection scheduler token for {\@link RootContext}. This token is the default value used
   * for the default `RootContext` found in the {\@link ROOT_CONTEXT} token.
   * @type {?}
   */
  const SCHEDULER = new InjectionToken('SCHEDULER_TOKEN', {
      providedIn: 'root',
      factory: () => defaultScheduler,
  });
  /** @type {?} */
  const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
  /**
   * @param {?} rootViewInjector
   * @param {?} moduleInjector
   * @return {?}
   */
  function createChainedInjector(rootViewInjector, moduleInjector) {
      return {
          get: (token, notFoundValue) => {
              /** @type {?} */
              const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);
              if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||
                  notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
                  // Return the value from the root element injector when
                  // - it provides it
                  //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
                  // - the module injector should not be checked
                  //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
                  return value;
              }
              return moduleInjector.get(token, notFoundValue);
          }
      };
  }
  /**
   * Render3 implementation of {\@link viewEngine_ComponentFactory}.
   * @template T
   */
  class ComponentFactory$1 extends ComponentFactory {
      /**
       * @param {?} componentDef The component definition.
       * @param {?=} ngModule The NgModuleRef to which the factory is bound.
       */
      constructor(componentDef, ngModule) {
          super();
          this.componentDef = componentDef;
          this.ngModule = ngModule;
          this.componentType = componentDef.type;
          this.selector = (/** @type {?} */ (componentDef.selectors[0][0]));
          this.ngContentSelectors = [];
      }
      /**
       * @return {?}
       */
      get inputs() {
          return toRefArray(this.componentDef.inputs);
      }
      /**
       * @return {?}
       */
      get outputs() {
          return toRefArray(this.componentDef.outputs);
      }
      /**
       * @param {?} injector
       * @param {?=} projectableNodes
       * @param {?=} rootSelectorOrNode
       * @param {?=} ngModule
       * @return {?}
       */
      create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
          /** @type {?} */
          const isInternalRootView = rootSelectorOrNode === undefined;
          ngModule = ngModule || this.ngModule;
          /** @type {?} */
          const rootViewInjector = ngModule ? createChainedInjector(injector, ngModule.injector) : injector;
          /** @type {?} */
          const rendererFactory = (/** @type {?} */ (rootViewInjector.get(RendererFactory2, domRendererFactory3)));
          /** @type {?} */
          const sanitizer = rootViewInjector.get(Sanitizer, null);
          /** @type {?} */
          const hostRNode = isInternalRootView ?
              elementCreate(this.selector, rendererFactory.createRenderer(null, this.componentDef)) :
              locateHostElement(rendererFactory, rootSelectorOrNode);
          /** @type {?} */
          const rootFlags = this.componentDef.onPush ? 8 /* Dirty */ | 128 /* IsRoot */ :
              4 /* CheckAlways */ | 128 /* IsRoot */;
          /** @type {?} */
          const rootContext = !isInternalRootView ? rootViewInjector.get(ROOT_CONTEXT) : createRootContext();
          /** @type {?} */
          const renderer = rendererFactory.createRenderer(hostRNode, this.componentDef);
          if (rootSelectorOrNode && hostRNode) {
              ngDevMode && ngDevMode.rendererSetAttribute++;
              isProceduralRenderer(renderer) ?
                  renderer.setAttribute(hostRNode, 'ng-version', VERSION$2.full) :
                  hostRNode.setAttribute('ng-version', VERSION$2.full);
          }
          // Create the root view. Uses empty TView and ContentTemplate.
          /** @type {?} */
          const rootLView = createLView(null, createTView(-1, null, 1, 0, null, null, null), rootContext, rootFlags, rendererFactory, renderer, sanitizer, rootViewInjector);
          // rootView is the parent when bootstrapping
          /** @type {?} */
          const oldLView = enterView(rootLView, null);
          /** @type {?} */
          let component;
          /** @type {?} */
          let tElementNode;
          try {
              if (rendererFactory.begin)
                  rendererFactory.begin();
              /** @type {?} */
              const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, renderer);
              tElementNode = (/** @type {?} */ (getTNode(0, rootLView)));
              // Transform the arrays of native nodes into a structure that can be consumed by the
              // projection instruction. This is needed to support the reprojection of these nodes.
              if (projectableNodes) {
                  /** @type {?} */
                  let index = 0;
                  /** @type {?} */
                  const tView = rootLView[TVIEW];
                  /** @type {?} */
                  const projection$$1 = tElementNode.projection = [];
                  for (let i = 0; i < projectableNodes.length; i++) {
                      /** @type {?} */
                      const nodeList = projectableNodes[i];
                      /** @type {?} */
                      let firstTNode = null;
                      /** @type {?} */
                      let previousTNode = null;
                      for (let j = 0; j < nodeList.length; j++) {
                          if (tView.firstTemplatePass) {
                              // For dynamically created components such as ComponentRef, we create a new TView for
                              // each insert. This is not ideal since we should be sharing the TViews.
                              // Also the logic here should be shared with `component.ts`'s `renderComponent`
                              // method.
                              tView.expandoStartIndex++;
                              tView.blueprint.splice(++index + HEADER_OFFSET, 0, null);
                              tView.data.splice(index + HEADER_OFFSET, 0, null);
                              rootLView.splice(index + HEADER_OFFSET, 0, null);
                          }
                          /** @type {?} */
                          const tNode = createNodeAtIndex(index, 3 /* Element */, (/** @type {?} */ (nodeList[j])), null, null);
                          previousTNode ? (previousTNode.next = tNode) : (firstTNode = tNode);
                          previousTNode = tNode;
                      }
                      projection$$1.push((/** @type {?} */ (firstTNode)));
                  }
              }
              // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and
              // executed here?
              // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref
              component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);
              addToViewTree(rootLView, HEADER_OFFSET, componentView);
              refreshDescendantViews(rootLView);
          }
          finally {
              leaveView(oldLView);
              if (rendererFactory.end)
                  rendererFactory.end();
          }
          /** @type {?} */
          const componentRef = new ComponentRef$1(this.componentType, component, createElementRef(ElementRef, tElementNode, rootLView), rootLView, tElementNode);
          if (isInternalRootView) {
              // The host element of the internal root view is attached to the component's host view node
              (/** @type {?} */ (componentRef.hostView._tViewNode)).child = tElementNode;
          }
          return componentRef;
      }
  }
  /** @type {?} */
  const componentFactoryResolver = new ComponentFactoryResolver$1();
  /**
   * Represents an instance of a Component created via a {\@link ComponentFactory}.
   *
   * `ComponentRef` provides access to the Component Instance as well other objects related to this
   * Component Instance and allows you to destroy the Component Instance via the {\@link #destroy}
   * method.
   *
   * @template T
   */
  class ComponentRef$1 extends ComponentRef {
      /**
       * @param {?} componentType
       * @param {?} instance
       * @param {?} location
       * @param {?} _rootLView
       * @param {?} _tNode
       */
      constructor(componentType, instance, location, _rootLView, _tNode) {
          super();
          this.location = location;
          this._rootLView = _rootLView;
          this._tNode = _tNode;
          this.destroyCbs = [];
          this.instance = instance;
          this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
          this.hostView._tViewNode = createViewNode(-1, _rootLView);
          this.componentType = componentType;
      }
      /**
       * @return {?}
       */
      get injector() { return new NodeInjector(this._tNode, this._rootLView); }
      /**
       * @return {?}
       */
      destroy() {
          ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');
          (/** @type {?} */ (this.destroyCbs)).forEach(fn => fn());
          this.destroyCbs = null;
          this.hostView.destroy();
      }
      /**
       * @param {?} callback
       * @return {?}
       */
      onDestroy(callback) {
          ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');
          (/** @type {?} */ (this.destroyCbs)).push(callback);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.
   *
   * For more information on how to run and debug tests with either Ivy or View Engine (legacy),
   * please see [BAZEL.md](./docs/BAZEL.md).
   */
  /** @type {?} */
  let _devMode = true;
  /**
   * Returns whether Angular is in development mode. After called once,
   * the value is locked and won't change any more.
   *
   * By default, this is true, unless a user calls `enableProdMode` before calling this.
   *
   * \@publicApi
   * @return {?}
   */
  function isDevMode() {
      return _devMode;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML
   * that needs sanitizing.
   * Depending upon browser support we must use one of three strategies for doing this.
   * Support: Safari 10.x -> XHR strategy
   * Support: Firefox -> DomParser strategy
   * Default: InertDocument strategy
   */
  class InertBodyHelper {
      /**
       * @param {?} defaultDoc
       */
      constructor(defaultDoc) {
          this.defaultDoc = defaultDoc;
          this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');
          this.inertBodyElement = this.inertDocument.body;
          if (this.inertBodyElement == null) {
              // usually there should be only one body element in the document, but IE doesn't have any, so
              // we need to create one.
              /** @type {?} */
              const inertHtml = this.inertDocument.createElement('html');
              this.inertDocument.appendChild(inertHtml);
              this.inertBodyElement = this.inertDocument.createElement('body');
              inertHtml.appendChild(this.inertBodyElement);
          }
          this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>';
          if (this.inertBodyElement.querySelector && !this.inertBodyElement.querySelector('svg')) {
              // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element
              // so use the XHR strategy.
              this.getInertBodyElement = this.getInertBodyElement_XHR;
              return;
          }
          this.inertBodyElement.innerHTML =
              '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">';
          if (this.inertBodyElement.querySelector && this.inertBodyElement.querySelector('svg img')) {
              // We just hit the Firefox bug - which prevents the inner img JS from being sanitized
              // so use the DOMParser strategy, if it is available.
              // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we
              // fall through to the default strategy below.
              if (isDOMParserAvailable()) {
                  this.getInertBodyElement = this.getInertBodyElement_DOMParser;
                  return;
              }
          }
          // None of the bugs were hit so it is safe for us to use the default InertDocument strategy
          this.getInertBodyElement = this.getInertBodyElement_InertDocument;
      }
      /**
       * Use XHR to create and fill an inert body element (on Safari 10.1)
       * See
       * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449
       * @private
       * @param {?} html
       * @return {?}
       */
      getInertBodyElement_XHR(html) {
          // We add these extra elements to ensure that the rest of the content is parsed as expected
          // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the
          // `<head>` tag.
          html = '<body><remove></remove>' + html + '</body>';
          try {
              html = encodeURI(html);
          }
          catch (_a) {
              return null;
          }
          /** @type {?} */
          const xhr = new XMLHttpRequest();
          xhr.responseType = 'document';
          xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);
          xhr.send(undefined);
          /** @type {?} */
          const body = xhr.response.body;
          body.removeChild((/** @type {?} */ (body.firstChild)));
          return body;
      }
      /**
       * Use DOMParser to create and fill an inert body element (on Firefox)
       * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7
       *
       * @private
       * @param {?} html
       * @return {?}
       */
      getInertBodyElement_DOMParser(html) {
          // We add these extra elements to ensure that the rest of the content is parsed as expected
          // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the
          // `<head>` tag.
          html = '<body><remove></remove>' + html + '</body>';
          try {
              /** @type {?} */
              const body = (/** @type {?} */ (new ((/** @type {?} */ (window)))
                  .DOMParser()
                  .parseFromString(html, 'text/html')
                  .body));
              body.removeChild((/** @type {?} */ (body.firstChild)));
              return body;
          }
          catch (_a) {
              return null;
          }
      }
      /**
       * Use an HTML5 `template` element, if supported, or an inert body element created via
       * `createHtmlDocument` to create and fill an inert DOM element.
       * This is the default sane strategy to use if the browser does not require one of the specialised
       * strategies above.
       * @private
       * @param {?} html
       * @return {?}
       */
      getInertBodyElement_InertDocument(html) {
          // Prefer using <template> element if supported.
          /** @type {?} */
          const templateEl = this.inertDocument.createElement('template');
          if ('content' in templateEl) {
              templateEl.innerHTML = html;
              return templateEl;
          }
          this.inertBodyElement.innerHTML = html;
          // Support: IE 9-11 only
          // strip custom-namespaced attributes on IE<=11
          if (((/** @type {?} */ (this.defaultDoc))).documentMode) {
              this.stripCustomNsAttrs(this.inertBodyElement);
          }
          return this.inertBodyElement;
      }
      /**
       * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
       * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.
       * 'ns1:xlink:foo').
       *
       * This is undesirable since we don't want to allow any of these custom attributes. This method
       * strips them all.
       * @private
       * @param {?} el
       * @return {?}
       */
      stripCustomNsAttrs(el) {
          /** @type {?} */
          const elAttrs = el.attributes;
          // loop backwards so that we can support removals.
          for (let i = elAttrs.length - 1; 0 < i; i--) {
              /** @type {?} */
              const attrib = elAttrs.item(i);
              /** @type {?} */
              const attrName = (/** @type {?} */ (attrib)).name;
              if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
                  el.removeAttribute(attrName);
              }
          }
          /** @type {?} */
          let childNode = (/** @type {?} */ (el.firstChild));
          while (childNode) {
              if (childNode.nodeType === Node.ELEMENT_NODE)
                  this.stripCustomNsAttrs((/** @type {?} */ (childNode)));
              childNode = childNode.nextSibling;
          }
      }
  }
  /**
   * We need to determine whether the DOMParser exists in the global context.
   * The try-catch is because, on some browsers, trying to access this property
   * on window can actually throw an error.
   *
   * @suppress {uselessCode}
   * @return {?}
   */
  function isDOMParserAvailable() {
      try {
          return !!((/** @type {?} */ (window))).DOMParser;
      }
      catch (_a) {
          return false;
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A pattern that recognizes a commonly useful subset of URLs that are safe.
   *
   * This regular expression matches a subset of URLs that will not cause script
   * execution if used in URL context within a HTML document. Specifically, this
   * regular expression matches if (comment from here on and regex copied from
   * Soy's EscapingConventions):
   * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
   * (2) or no protocol.  A protocol must be followed by a colon. The below
   *     allows that by allowing colons only after one of the characters [/?#].
   *     A colon after a hash (#) must be in the fragment.
   *     Otherwise, a colon after a (?) must be in a query.
   *     Otherwise, a colon after a single solidus (/) must be in a path.
   *     Otherwise, a colon after a double solidus (//) must be in the authority
   *     (before port).
   *
   * The pattern disallows &, used in HTML entity declarations before
   * one of the characters in [/?#]. This disallows HTML entities used in the
   * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
   * It also disallows HTML entities in the first path part of a relative path,
   * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
   * that. More importantly, it disallows masking of a colon,
   * e.g. "javascript&#58;...".
   *
   * This regular expression was taken from the Closure sanitization library.
   * @type {?}
   */
  const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   * @type {?}
   */
  const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
  /**
   * @param {?} url
   * @return {?}
   */
  function _sanitizeUrl(url) {
      url = String(url);
      if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
          return url;
      if (isDevMode()) {
          console.warn(`WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`);
      }
      return 'unsafe:' + url;
  }
  /**
   * @param {?} srcset
   * @return {?}
   */
  function sanitizeSrcset(srcset) {
      srcset = String(srcset);
      return srcset.split(',').map((srcset) => _sanitizeUrl(srcset.trim())).join(', ');
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} tags
   * @return {?}
   */
  function tagSet(tags) {
      /** @type {?} */
      const res = {};
      for (const t of tags.split(','))
          res[t] = true;
      return res;
  }
  /**
   * @param {...?} sets
   * @return {?}
   */
  function merge$1$1(...sets) {
      /** @type {?} */
      const res = {};
      for (const s of sets) {
          for (const v in s) {
              if (s.hasOwnProperty(v))
                  res[v] = true;
          }
      }
      return res;
  }
  // Good source of info about elements and attributes
  // http://dev.w3.org/html5/spec/Overview.html#semantics
  // http://simon.html5.org/html-elements
  // Safe Void Elements - HTML5
  // http://dev.w3.org/html5/spec/Overview.html#void-elements
  /** @type {?} */
  const VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
  // Elements that you can, intentionally, leave open (and which close themselves)
  // http://dev.w3.org/html5/spec/Overview.html#optional-tags
  /** @type {?} */
  const OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
  /** @type {?} */
  const OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
  /** @type {?} */
  const OPTIONAL_END_TAG_ELEMENTS = merge$1$1(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
  // Safe Block Elements - HTML5
  /** @type {?} */
  const BLOCK_ELEMENTS = merge$1$1(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
      'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
      'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
  // Inline Elements - HTML5
  /** @type {?} */
  const INLINE_ELEMENTS = merge$1$1(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
      'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
      'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
  /** @type {?} */
  const VALID_ELEMENTS = merge$1$1(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
  // Attributes that have href and hence need to be sanitized
  /** @type {?} */
  const URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
  // Attributes that have special href set hence need to be sanitized
  /** @type {?} */
  const SRCSET_ATTRS = tagSet('srcset');
  /** @type {?} */
  const HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
      'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
      'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
      'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
      'valign,value,vspace,width');
  // NB: This currently consciously doesn't support SVG. SVG sanitization has had several security
  // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
  // innerHTML is required, SVG attributes should be added here.
  // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
  // can be sanitized, but they increase security surface area without a legitimate use case, so they
  // are left out here.
  /** @type {?} */
  const VALID_ATTRS = merge$1$1(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
  // Elements whose content should not be traversed/preserved, if the elements themselves are invalid.
  //
  // Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)
  // `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we
  // don't want to preserve the content, if the elements themselves are going to be removed.
  /** @type {?} */
  const SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');
  /**
   * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
   * attributes.
   */
  class SanitizingHtmlSerializer {
      constructor() {
          // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
          // because characters were re-encoded.
          this.sanitizedSomething = false;
          this.buf = [];
      }
      /**
       * @param {?} el
       * @return {?}
       */
      sanitizeChildren(el) {
          // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
          // However this code never accesses properties off of `document` before deleting its contents
          // again, so it shouldn't be vulnerable to DOM clobbering.
          /** @type {?} */
          let current = (/** @type {?} */ (el.firstChild));
          /** @type {?} */
          let traverseContent = true;
          while (current) {
              if (current.nodeType === Node.ELEMENT_NODE) {
                  traverseContent = this.startElement((/** @type {?} */ (current)));
              }
              else if (current.nodeType === Node.TEXT_NODE) {
                  this.chars((/** @type {?} */ (current.nodeValue)));
              }
              else {
                  // Strip non-element, non-text nodes.
                  this.sanitizedSomething = true;
              }
              if (traverseContent && current.firstChild) {
                  current = (/** @type {?} */ (current.firstChild));
                  continue;
              }
              while (current) {
                  // Leaving the element. Walk up and to the right, closing tags as we go.
                  if (current.nodeType === Node.ELEMENT_NODE) {
                      this.endElement((/** @type {?} */ (current)));
                  }
                  /** @type {?} */
                  let next = this.checkClobberedElement(current, (/** @type {?} */ (current.nextSibling)));
                  if (next) {
                      current = next;
                      break;
                  }
                  current = this.checkClobberedElement(current, (/** @type {?} */ (current.parentNode)));
              }
          }
          return this.buf.join('');
      }
      /**
       * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
       * be traversed. Element content must always be traversed (even if the element itself is not
       * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
       *
       * @private
       * @param {?} element The element to sanitize.
       * @return {?} True if the element's contents should be traversed.
       */
      startElement(element) {
          /** @type {?} */
          const tagName = element.nodeName.toLowerCase();
          if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
              this.sanitizedSomething = true;
              return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
          }
          this.buf.push('<');
          this.buf.push(tagName);
          /** @type {?} */
          const elAttrs = element.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
              /** @type {?} */
              const elAttr = elAttrs.item(i);
              /** @type {?} */
              const attrName = (/** @type {?} */ (elAttr)).name;
              /** @type {?} */
              const lower = attrName.toLowerCase();
              if (!VALID_ATTRS.hasOwnProperty(lower)) {
                  this.sanitizedSomething = true;
                  continue;
              }
              /** @type {?} */
              let value = (/** @type {?} */ (elAttr)).value;
              // TODO(martinprobst): Special case image URIs for data:image/...
              if (URI_ATTRS[lower])
                  value = _sanitizeUrl(value);
              if (SRCSET_ATTRS[lower])
                  value = sanitizeSrcset(value);
              this.buf.push(' ', attrName, '="', encodeEntities(value), '"');
          }
          this.buf.push('>');
          return true;
      }
      /**
       * @private
       * @param {?} current
       * @return {?}
       */
      endElement(current) {
          /** @type {?} */
          const tagName = current.nodeName.toLowerCase();
          if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
              this.buf.push('</');
              this.buf.push(tagName);
              this.buf.push('>');
          }
      }
      /**
       * @private
       * @param {?} chars
       * @return {?}
       */
      chars(chars) { this.buf.push(encodeEntities(chars)); }
      /**
       * @param {?} node
       * @param {?} nextNode
       * @return {?}
       */
      checkClobberedElement(node, nextNode) {
          if (nextNode &&
              (node.compareDocumentPosition(nextNode) &
                  Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {
              throw new Error(`Failed to sanitize html because the element is clobbered: ${((/** @type {?} */ (node))).outerHTML}`);
          }
          return nextNode;
      }
  }
  // Regular Expressions for parsing tags and attributes
  /** @type {?} */
  const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  // ! to ~ is the ASCII range.
  /** @type {?} */
  const NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
  /**
   * Escapes all potentially dangerous characters, so that the
   * resulting string can be safely inserted into attribute or
   * element text.
   * @param {?} value
   * @return {?}
   */
  function encodeEntities(value) {
      return value.replace(/&/g, '&amp;')
          .replace(SURROGATE_PAIR_REGEXP, function (match) {
          /** @type {?} */
          const hi = match.charCodeAt(0);
          /** @type {?} */
          const low = match.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
      })
          .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
  }
  /** @type {?} */
  let inertBodyHelper;
  /**
   * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
   * the DOM in a browser environment.
   * @param {?} defaultDoc
   * @param {?} unsafeHtmlInput
   * @return {?}
   */
  function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
      /** @type {?} */
      let inertBodyElement = null;
      try {
          inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);
          // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
          /** @type {?} */
          let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
          inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
          // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
          // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
          /** @type {?} */
          let mXSSAttempts = 5;
          /** @type {?} */
          let parsedHtml = unsafeHtml;
          do {
              if (mXSSAttempts === 0) {
                  throw new Error('Failed to sanitize html because the input is unstable');
              }
              mXSSAttempts--;
              unsafeHtml = parsedHtml;
              parsedHtml = (/** @type {?} */ (inertBodyElement)).innerHTML;
              inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
          } while (unsafeHtml !== parsedHtml);
          /** @type {?} */
          const sanitizer = new SanitizingHtmlSerializer();
          /** @type {?} */
          const safeHtml = sanitizer.sanitizeChildren((/** @type {?} */ (getTemplateContent((/** @type {?} */ (inertBodyElement))))) || inertBodyElement);
          if (isDevMode() && sanitizer.sanitizedSomething) {
              console.warn('WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss');
          }
          return safeHtml;
      }
      finally {
          // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
          if (inertBodyElement) {
              /** @type {?} */
              const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
              while (parent.firstChild) {
                  parent.removeChild(parent.firstChild);
              }
          }
      }
  }
  /**
   * @param {?} el
   * @return {?}
   */
  function getTemplateContent(el) {
      return 'content' in ((/** @type {?} */ (el))) && isTemplateElement(el) ?
          el.content :
          null;
  }
  /**
   * @param {?} el
   * @return {?}
   */
  function isTemplateElement(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Use in directives and components to emit custom events synchronously
   * or asynchronously, and register handlers for those events by subscribing
   * to an instance.
   *
   * \@usageNotes
   *
   * In the following example, a component defines two output properties
   * that create event emitters. When the title is clicked, the emitter
   * emits an open or close event to toggle the current visibility state.
   *
   * ```
   * \@Component({
   *   selector: 'zippy',
   *   template: `
   *   <div class="zippy">
   *     <div (click)="toggle()">Toggle</div>
   *     <div [hidden]="!visible">
   *       <ng-content></ng-content>
   *     </div>
   *  </div>`})
   * export class Zippy {
   *   visible: boolean = true;
   * \@Output() open: EventEmitter<any> = new EventEmitter();
   * \@Output() close: EventEmitter<any> = new EventEmitter();
   *
   *   toggle() {
   *     this.visible = !this.visible;
   *     if (this.visible) {
   *       this.open.emit(null);
   *     } else {
   *       this.close.emit(null);
   *     }
   *   }
   * }
   * ```
   *
   * Access the event object with the `$event` argument passed to the output event
   * handler:
   *
   * ```
   * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
   * ```
   *
   * ### Notes
   *
   * Uses Rx.Observable but provides an adapter to make it work as specified here:
   * https://github.com/jhusain/observable-spec
   *
   * Once a reference implementation of the spec is available, switch to it.
   *
   * \@publicApi
   * @template T
   */
  class EventEmitter extends Subject {
      // tslint:disable-line
      /**
       * Creates an instance of this class that can
       * deliver events synchronously or asynchronously.
       *
       * @param {?=} isAsync When true, deliver events asynchronously.
       *
       */
      constructor(isAsync = false) {
          super();
          this.__isAsync = isAsync;
      }
      /**
       * Emits an event containing a given value.
       * @param {?=} value The value to emit.
       * @return {?}
       */
      emit(value) { super.next(value); }
      /**
       * Registers handlers for events emitted by this instance.
       * @param {?=} generatorOrNext When supplied, a custom handler for emitted events.
       * @param {?=} error When supplied, a custom handler for an error notification
       * from this emitter.
       * @param {?=} complete When supplied, a custom handler for a completion
       * notification from this emitter.
       * @return {?}
       */
      subscribe(generatorOrNext, error, complete) {
          /** @type {?} */
          let schedulerFn;
          /** @type {?} */
          let errorFn = (err) => null;
          /** @type {?} */
          let completeFn = () => null;
          if (generatorOrNext && typeof generatorOrNext === 'object') {
              schedulerFn = this.__isAsync ? (value) => {
                  setTimeout(() => generatorOrNext.next(value));
              } : (value) => { generatorOrNext.next(value); };
              if (generatorOrNext.error) {
                  errorFn = this.__isAsync ? (err) => { setTimeout(() => generatorOrNext.error(err)); } :
                      (err) => { generatorOrNext.error(err); };
              }
              if (generatorOrNext.complete) {
                  completeFn = this.__isAsync ? () => { setTimeout(() => generatorOrNext.complete()); } :
                      () => { generatorOrNext.complete(); };
              }
          }
          else {
              schedulerFn = this.__isAsync ? (value) => { setTimeout(() => generatorOrNext(value)); } :
                  (value) => { generatorOrNext(value); };
              if (error) {
                  errorFn =
                      this.__isAsync ? (err) => { setTimeout(() => error(err)); } : (err) => { error(err); };
              }
              if (complete) {
                  completeFn =
                      this.__isAsync ? () => { setTimeout(() => complete()); } : () => { complete(); };
              }
          }
          /** @type {?} */
          const sink = super.subscribe(schedulerFn, errorFn, completeFn);
          if (generatorOrNext instanceof Subscription) {
              generatorOrNext.add(sink);
          }
          return sink;
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Represents an embedded template that can be used to instantiate embedded views.
   * To instantiate embedded views based on a template, use the `ViewContainerRef`
   * method `createEmbeddedView()`.
   *
   * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`
   * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view
   * is injected into the constructor of the directive,
   * using the `TemplateRef` token.
   *
   * You can also use a `Query` to find a `TemplateRef` associated with
   * a component or a directive.
   *
   * @see `ViewContainerRef`
   * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)
   *
   * \@publicApi
   * @abstract
   * @template C
   */
  class TemplateRef {
  }
  /**
   * \@internal
   */
  TemplateRef.__NG_ELEMENT_ID__ = () => SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef);
  /** @type {?} */
  const SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__ = noop$1;
  /** @type {?} */
  const SWITCH_TEMPLATE_REF_FACTORY = SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__;
  /**
   * @template T
   */
  class QueryList_ {
      constructor() {
          this.dirty = true;
          this.changes = new EventEmitter();
          this._values = [];
          /**
           * \@internal
           */
          this._valuesTree = [];
      }
      /**
       * @return {?}
       */
      get length() { return this._values.length; }
      /**
       * @return {?}
       */
      get first() {
          /** @type {?} */
          let values = this._values;
          return values.length ? values[0] : null;
      }
      /**
       * @return {?}
       */
      get last() {
          /** @type {?} */
          let values = this._values;
          return values.length ? values[values.length - 1] : null;
      }
      /**
       * See
       * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
       * @template U
       * @param {?} fn
       * @return {?}
       */
      map(fn) { return this._values.map(fn); }
      /**
       * See
       * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
       * @param {?} fn
       * @return {?}
       */
      filter(fn) {
          return this._values.filter(fn);
      }
      /**
       * See
       * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
       * @param {?} fn
       * @return {?}
       */
      find(fn) {
          return this._values.find(fn);
      }
      /**
       * See
       * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
       * @template U
       * @param {?} fn
       * @param {?} init
       * @return {?}
       */
      reduce(fn, init) {
          return this._values.reduce(fn, init);
      }
      /**
       * See
       * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
       * @param {?} fn
       * @return {?}
       */
      forEach(fn) { this._values.forEach(fn); }
      /**
       * See
       * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
       * @param {?} fn
       * @return {?}
       */
      some(fn) {
          return this._values.some(fn);
      }
      /**
       * @return {?}
       */
      toArray() { return this._values.slice(0); }
      /**
       * @return {?}
       */
      [getSymbolIterator$1()]() { return ((/** @type {?} */ (this._values)))[getSymbolIterator$1()](); }
      /**
       * @return {?}
       */
      toString() { return this._values.toString(); }
      /**
       * @param {?} res
       * @return {?}
       */
      reset(res) {
          this._values = flatten$1(res);
          ((/** @type {?} */ (this))).dirty = false;
      }
      /**
       * @return {?}
       */
      notifyOnChanges() { ((/** @type {?} */ (this.changes))).emit(this); }
      /**
       * @return {?}
       */
      setDirty() { ((/** @type {?} */ (this))).dirty = true; }
      /**
       * @return {?}
       */
      destroy() {
          ((/** @type {?} */ (this.changes))).complete();
          ((/** @type {?} */ (this.changes))).unsubscribe();
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Regular expression for safe style values.
   *
   * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
   *
   * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
   * font-family) and hence could allow multiple values to get injected, but that should pose no risk
   * of XSS.
   *
   * The function expression checks only for XSS safety, not for CSS validity.
   *
   * This regular expression was taken from the Closure sanitization library, and augmented for
   * transformation values.
   * @type {?}
   */
  const VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
  /** @type {?} */
  const TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
  /** @type {?} */
  const COLOR_FNS = '(?:rgb|hsl)a?';
  /** @type {?} */
  const GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';
  /** @type {?} */
  const CSS3_FNS = '(?:calc|attr)';
  /** @type {?} */
  const FN_ARGS = '\\([-0-9.%, #a-zA-Z]+\\)';
  /** @type {?} */
  const SAFE_STYLE_VALUE = new RegExp(`^(${VALUES}|` +
      `(?:${TRANSFORMATION_FNS}|${COLOR_FNS}|${GRADIENTS}|${CSS3_FNS})` +
      `${FN_ARGS})$`, 'g');
  /**
   * Matches a `url(...)` value with an arbitrary argument as long as it does
   * not contain parentheses.
   *
   * The URL value still needs to be sanitized separately.
   *
   * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
   * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
   * by observing whether scroll bars are displayed, or character ranges used by a font face
   * definition.
   *
   * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
   * binding a URL value without further cooperation from the page will cause an information leak, and
   * if so, it is just a leak, not a full blown XSS vulnerability.
   *
   * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
   * code is permissive and allows URLs that sanitize otherwise.
   * @type {?}
   */
  const URL_RE = /^url\(([^)]+)\)$/;
  /**
   * Checks that quotes (" and ') are properly balanced inside a string. Assumes
   * that neither escape (\) nor any other character that could result in
   * breaking out of a string parsing context are allowed;
   * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
   *
   * This code was taken from the Closure sanitization library.
   * @param {?} value
   * @return {?}
   */
  function hasBalancedQuotes(value) {
      /** @type {?} */
      let outsideSingle = true;
      /** @type {?} */
      let outsideDouble = true;
      for (let i = 0; i < value.length; i++) {
          /** @type {?} */
          const c = value.charAt(i);
          if (c === '\'' && outsideDouble) {
              outsideSingle = !outsideSingle;
          }
          else if (c === '"' && outsideSingle) {
              outsideDouble = !outsideDouble;
          }
      }
      return outsideSingle && outsideDouble;
  }
  /**
   * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
   * value) and returns a value that is safe to use in a browser environment.
   * @param {?} value
   * @return {?}
   */
  function _sanitizeStyle(value) {
      value = String(value).trim(); // Make sure it's actually a string.
      if (!value)
          return '';
      // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
      // reasoning behind this.
      /** @type {?} */
      const urlMatch = value.match(URL_RE);
      if ((urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
          value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
          return value; // Safe style values.
      }
      if (isDevMode()) {
          console.warn(`WARNING: sanitizing unsafe style value ${value} (see http://g.co/ng/security#xss).`);
      }
      return 'unsafe';
  }
  /**
   * Map of module-id to the corresponding NgModule.
   * - In pre Ivy we track NgModuleFactory,
   * - In post Ivy we track the NgModuleType
   * @type {?}
   */
  const modules = new Map();
  /**
   * Registers a loaded module. Should only be called from generated NgModuleFactory code.
   * \@publicApi
   * @param {?} id
   * @param {?} factory
   * @return {?}
   */
  function registerModuleFactory(id, factory) {
      /** @type {?} */
      const existing = (/** @type {?} */ (modules.get(id)));
      assertNotExisting(id, existing && existing.moduleType);
      modules.set(id, factory);
  }
  /**
   * @param {?} id
   * @param {?} type
   * @return {?}
   */
  function assertNotExisting(id, type) {
      if (type) {
          throw new Error(`Duplicate module registered for ${id} - ${stringify$1(type)} vs ${stringify$1(type.name)}`);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * \@description
   *
   * Represents a type that a Component or other object is instances of.
   *
   * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
   * the `MyCustomComponent` constructor function.
   *
   * \@publicApi
   * @type {?}
   */
  const Type$2 = Function;
  /**
   * @param {?} v
   * @return {?}
   */
  function isType(v) {
      return typeof v === 'function';
  }
  // WARNING: interface has both a type and a value, skipping emit

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Attention: These regex has to hold even if the code is minified!
   * @type {?}
   */
  const DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*arguments\)/;
  /** @type {?} */
  const INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
  /** @type {?} */
  const INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
  class ReflectionCapabilities {
      /**
       * @param {?=} reflect
       */
      constructor(reflect) { this._reflect = reflect || _global$1['Reflect']; }
      /**
       * @return {?}
       */
      isReflectionEnabled() { return true; }
      /**
       * @template T
       * @param {?} t
       * @return {?}
       */
      factory(t) { return (...args) => new t(...args); }
      /**
       * \@internal
       * @param {?} paramTypes
       * @param {?} paramAnnotations
       * @return {?}
       */
      _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
          /** @type {?} */
          let result;
          if (typeof paramTypes === 'undefined') {
              result = new Array(paramAnnotations.length);
          }
          else {
              result = new Array(paramTypes.length);
          }
          for (let i = 0; i < result.length; i++) {
              // TS outputs Object for parameters without types, while Traceur omits
              // the annotations. For now we preserve the Traceur behavior to aid
              // migration, but this can be revisited.
              if (typeof paramTypes === 'undefined') {
                  result[i] = [];
              }
              else if (paramTypes[i] != Object) {
                  result[i] = [paramTypes[i]];
              }
              else {
                  result[i] = [];
              }
              if (paramAnnotations && paramAnnotations[i] != null) {
                  result[i] = result[i].concat(paramAnnotations[i]);
              }
          }
          return result;
      }
      /**
       * @private
       * @param {?} type
       * @param {?} parentCtor
       * @return {?}
       */
      _ownParameters(type, parentCtor) {
          /** @type {?} */
          const typeStr = type.toString();
          // If we have no decorators, we only have function.length as metadata.
          // In that case, to detect whether a child class declared an own constructor or not,
          // we need to look inside of that constructor to check whether it is
          // just calling the parent.
          // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
          // that sets 'design:paramtypes' to []
          // if a class inherits from another class but has no ctor declared itself.
          if (DELEGATE_CTOR.exec(typeStr) ||
              (INHERITED_CLASS.exec(typeStr) && !INHERITED_CLASS_WITH_CTOR.exec(typeStr))) {
              return null;
          }
          // Prefer the direct API.
          if (((/** @type {?} */ (type))).parameters && ((/** @type {?} */ (type))).parameters !== parentCtor.parameters) {
              return ((/** @type {?} */ (type))).parameters;
          }
          // API of tsickle for lowering decorators to properties on the class.
          /** @type {?} */
          const tsickleCtorParams = ((/** @type {?} */ (type))).ctorParameters;
          if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
              // Newer tsickle uses a function closure
              // Retain the non-function case for compatibility with older tsickle
              /** @type {?} */
              const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
              /** @type {?} */
              const paramTypes = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);
              /** @type {?} */
              const paramAnnotations = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
              return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
          }
          // API for metadata created by invoking the decorators.
          /** @type {?} */
          const paramAnnotations = type.hasOwnProperty(PARAMETERS) && ((/** @type {?} */ (type)))[PARAMETERS];
          /** @type {?} */
          const paramTypes = this._reflect && this._reflect.getOwnMetadata &&
              this._reflect.getOwnMetadata('design:paramtypes', type);
          if (paramTypes || paramAnnotations) {
              return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
          }
          // If a class has no decorators, at least create metadata
          // based on function.length.
          // Note: We know that this is a real constructor as we checked
          // the content of the constructor above.
          return new Array(((/** @type {?} */ (type.length)))).fill(undefined);
      }
      /**
       * @param {?} type
       * @return {?}
       */
      parameters(type) {
          // Note: only report metadata if we have at least one class decorator
          // to stay in sync with the static reflector.
          if (!isType(type)) {
              return [];
          }
          /** @type {?} */
          const parentCtor = getParentCtor(type);
          /** @type {?} */
          let parameters = this._ownParameters(type, parentCtor);
          if (!parameters && parentCtor !== Object) {
              parameters = this.parameters(parentCtor);
          }
          return parameters || [];
      }
      /**
       * @private
       * @param {?} typeOrFunc
       * @param {?} parentCtor
       * @return {?}
       */
      _ownAnnotations(typeOrFunc, parentCtor) {
          // Prefer the direct API.
          if (((/** @type {?} */ (typeOrFunc))).annotations && ((/** @type {?} */ (typeOrFunc))).annotations !== parentCtor.annotations) {
              /** @type {?} */
              let annotations = ((/** @type {?} */ (typeOrFunc))).annotations;
              if (typeof annotations === 'function' && annotations.annotations) {
                  annotations = annotations.annotations;
              }
              return annotations;
          }
          // API of tsickle for lowering decorators to properties on the class.
          if (((/** @type {?} */ (typeOrFunc))).decorators && ((/** @type {?} */ (typeOrFunc))).decorators !== parentCtor.decorators) {
              return convertTsickleDecoratorIntoMetadata(((/** @type {?} */ (typeOrFunc))).decorators);
          }
          // API for metadata created by invoking the decorators.
          if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
              return ((/** @type {?} */ (typeOrFunc)))[ANNOTATIONS];
          }
          return null;
      }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      annotations(typeOrFunc) {
          if (!isType(typeOrFunc)) {
              return [];
          }
          /** @type {?} */
          const parentCtor = getParentCtor(typeOrFunc);
          /** @type {?} */
          const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
          /** @type {?} */
          const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
          return parentAnnotations.concat(ownAnnotations);
      }
      /**
       * @private
       * @param {?} typeOrFunc
       * @param {?} parentCtor
       * @return {?}
       */
      _ownPropMetadata(typeOrFunc, parentCtor) {
          // Prefer the direct API.
          if (((/** @type {?} */ (typeOrFunc))).propMetadata &&
              ((/** @type {?} */ (typeOrFunc))).propMetadata !== parentCtor.propMetadata) {
              /** @type {?} */
              let propMetadata = ((/** @type {?} */ (typeOrFunc))).propMetadata;
              if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
                  propMetadata = propMetadata.propMetadata;
              }
              return propMetadata;
          }
          // API of tsickle for lowering decorators to properties on the class.
          if (((/** @type {?} */ (typeOrFunc))).propDecorators &&
              ((/** @type {?} */ (typeOrFunc))).propDecorators !== parentCtor.propDecorators) {
              /** @type {?} */
              const propDecorators = ((/** @type {?} */ (typeOrFunc))).propDecorators;
              /** @type {?} */
              const propMetadata = (/** @type {?} */ ({}));
              Object.keys(propDecorators).forEach(prop => {
                  propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
              });
              return propMetadata;
          }
          // API for metadata created by invoking the decorators.
          if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
              return ((/** @type {?} */ (typeOrFunc)))[PROP_METADATA];
          }
          return null;
      }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      propMetadata(typeOrFunc) {
          if (!isType(typeOrFunc)) {
              return {};
          }
          /** @type {?} */
          const parentCtor = getParentCtor(typeOrFunc);
          /** @type {?} */
          const propMetadata = {};
          if (parentCtor !== Object) {
              /** @type {?} */
              const parentPropMetadata = this.propMetadata(parentCtor);
              Object.keys(parentPropMetadata).forEach((propName) => {
                  propMetadata[propName] = parentPropMetadata[propName];
              });
          }
          /** @type {?} */
          const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
          if (ownPropMetadata) {
              Object.keys(ownPropMetadata).forEach((propName) => {
                  /** @type {?} */
                  const decorators = [];
                  if (propMetadata.hasOwnProperty(propName)) {
                      decorators.push(...propMetadata[propName]);
                  }
                  decorators.push(...ownPropMetadata[propName]);
                  propMetadata[propName] = decorators;
              });
          }
          return propMetadata;
      }
      /**
       * @param {?} type
       * @param {?} lcProperty
       * @return {?}
       */
      hasLifecycleHook(type, lcProperty) {
          return type instanceof Type$2 && lcProperty in type.prototype;
      }
      /**
       * @param {?} type
       * @return {?}
       */
      guards(type) { return {}; }
      /**
       * @param {?} name
       * @return {?}
       */
      getter(name) { return (/** @type {?} */ (new Function('o', 'return o.' + name + ';'))); }
      /**
       * @param {?} name
       * @return {?}
       */
      setter(name) {
          return (/** @type {?} */ (new Function('o', 'v', 'return o.' + name + ' = v;')));
      }
      /**
       * @param {?} name
       * @return {?}
       */
      method(name) {
          /** @type {?} */
          const functionBody = `if (!o.${name}) throw new Error('"${name}" is undefined');
        return o.${name}.apply(o, args);`;
          return (/** @type {?} */ (new Function('o', 'args', functionBody)));
      }
      // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
      /**
       * @param {?} type
       * @return {?}
       */
      importUri(type) {
          // StaticSymbol
          if (typeof type === 'object' && type['filePath']) {
              return type['filePath'];
          }
          // Runtime type
          return `./${stringify$1(type)}`;
      }
      /**
       * @param {?} type
       * @return {?}
       */
      resourceUri(type) { return `./${stringify$1(type)}`; }
      /**
       * @param {?} name
       * @param {?} moduleUrl
       * @param {?} members
       * @param {?} runtime
       * @return {?}
       */
      resolveIdentifier(name, moduleUrl, members, runtime) {
          return runtime;
      }
      /**
       * @param {?} enumIdentifier
       * @param {?} name
       * @return {?}
       */
      resolveEnum(enumIdentifier, name) { return enumIdentifier[name]; }
  }
  /**
   * @param {?} decoratorInvocations
   * @return {?}
   */
  function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
      if (!decoratorInvocations) {
          return [];
      }
      return decoratorInvocations.map(decoratorInvocation => {
          /** @type {?} */
          const decoratorType = decoratorInvocation.type;
          /** @type {?} */
          const annotationCls = decoratorType.annotationCls;
          /** @type {?} */
          const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
          return new annotationCls(...annotationArgs);
      });
  }
  /**
   * @param {?} ctor
   * @return {?}
   */
  function getParentCtor(ctor) {
      /** @type {?} */
      const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
      /** @type {?} */
      const parentCtor = parentProto ? parentProto.constructor : null;
      // Note: We always use `Object` as the null value
      // to simplify checking later on.
      return parentCtor || Object;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Type of the Directive metadata.
   *
   * \@publicApi
   * @type {?}
   */
  const Directive = makeDecorator('Directive', (dir = {}) => dir, undefined, undefined, (type, meta) => SWITCH_COMPILE_DIRECTIVE(type, meta));
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Component decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Component = makeDecorator('Component', (c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy$1.Default }, c)), Directive, undefined, (type, meta) => SWITCH_COMPILE_COMPONENT(type, meta));
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Pipe = makeDecorator('Pipe', (p) => (Object.assign({ pure: true }, p)), undefined, undefined, (type, meta) => SWITCH_COMPILE_PIPE(type, meta));
  // WARNING: interface has both a type and a value, skipping emit
  /** @type {?} */
  const initializeBaseDef = (target) => {
      /** @type {?} */
      const constructor = target.constructor;
      /** @nocollapse @type {?} */
      const inheritedBaseDef = constructor.ngBaseDef;
      /** @type {?} */
      const baseDef = constructor.ngBaseDef = {
          inputs: {},
          outputs: {},
          declaredInputs: {},
      };
      if (inheritedBaseDef) {
          fillProperties(baseDef.inputs, inheritedBaseDef.inputs);
          fillProperties(baseDef.outputs, inheritedBaseDef.outputs);
          fillProperties(baseDef.declaredInputs, inheritedBaseDef.declaredInputs);
      }
  };
  /**
   * Does the work of creating the `ngBaseDef` property for the `Input` and `Output` decorators.
   * \@param key "inputs" or "outputs"
   * @type {?}
   */
  const updateBaseDefFromIOProp = (getProp) => (target, name, ...args) => {
      /** @type {?} */
      const constructor = target.constructor;
      if (!constructor.hasOwnProperty(NG_BASE_DEF)) {
          initializeBaseDef(target);
      }
      /** @nocollapse @type {?} */
      const baseDef = constructor.ngBaseDef;
      /** @type {?} */
      const defProp = getProp(baseDef);
      defProp[name] = args[0];
  };
  /**
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Input = makePropDecorator('Input', (bindingPropertyName) => ({ bindingPropertyName }), undefined, updateBaseDefFromIOProp(baseDef => baseDef.inputs || {}));
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Output = makePropDecorator('Output', (bindingPropertyName) => ({ bindingPropertyName }), undefined, updateBaseDefFromIOProp(baseDef => baseDef.outputs || {}));
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const HostBinding = makePropDecorator('HostBinding', (hostPropertyName) => ({ hostPropertyName }));
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Binds a CSS event to a host listener and supplies configuration metadata.
   * Angular invokes the supplied handler method when the host element emits the specified event,
   * and updates the bound element with the result.
   * If the handler method returns false, applies `preventDefault` on the bound element.
   *
   * \@usageNotes
   *
   * The following example declares a directive
   * that attaches a click listener to a button and counts clicks.
   *
   * ```
   * \@Directive({selector: 'button[counting]'})
   * class CountClicks {
   *   numberOfClicks = 0;
   *
   * \@HostListener('click', ['$event.target'])
   *   onClick(btn) {
   *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
   *  }
   * }
   *
   * \@Component({
   *   selector: 'app',
   *   template: '<button counting>Increment</button>',
   * })
   * class App {}
   * ```
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const HostListener = makePropDecorator('HostListener', (eventName, args) => ({ eventName, args }));
  /** @type {?} */
  const SWITCH_COMPILE_COMPONENT__PRE_R3__ = noop$1;
  /** @type {?} */
  const SWITCH_COMPILE_DIRECTIVE__PRE_R3__ = noop$1;
  /** @type {?} */
  const SWITCH_COMPILE_PIPE__PRE_R3__ = noop$1;
  /** @type {?} */
  const SWITCH_COMPILE_COMPONENT = SWITCH_COMPILE_COMPONENT__PRE_R3__;
  /** @type {?} */
  const SWITCH_COMPILE_DIRECTIVE = SWITCH_COMPILE_DIRECTIVE__PRE_R3__;
  /** @type {?} */
  const SWITCH_COMPILE_PIPE = SWITCH_COMPILE_PIPE__PRE_R3__;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  const ɵ0$2 = getClosureSafeProperty;
  /** @type {?} */
  const USE_VALUE$1$1 = getClosureSafeProperty({ provide: String, useValue: ɵ0$2 });
  /** @type {?} */
  const EMPTY_ARRAY$3 = [];
  /**
   * @param {?} type
   * @param {?=} provider
   * @return {?}
   */
  function convertInjectableProviderToFactory(type, provider) {
      if (!provider) {
          /** @type {?} */
          const reflectionCapabilities = new ReflectionCapabilities();
          /** @type {?} */
          const deps = reflectionCapabilities.parameters(type);
          // TODO - convert to flags.
          return () => new type(...injectArgs((/** @type {?} */ (deps))));
      }
      if (USE_VALUE$1$1 in provider) {
          /** @type {?} */
          const valueProvider = ((/** @type {?} */ (provider)));
          return () => valueProvider.useValue;
      }
      else if (((/** @type {?} */ (provider))).useExisting) {
          /** @type {?} */
          const existingProvider = ((/** @type {?} */ (provider)));
          return () => inject(existingProvider.useExisting);
      }
      else if (((/** @type {?} */ (provider))).useFactory) {
          /** @type {?} */
          const factoryProvider = ((/** @type {?} */ (provider)));
          return () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY$3));
      }
      else if (((/** @type {?} */ (provider))).useClass) {
          /** @type {?} */
          const classProvider = ((/** @type {?} */ (provider)));
          /** @type {?} */
          let deps = ((/** @type {?} */ (provider))).deps;
          if (!deps) {
              /** @type {?} */
              const reflectionCapabilities = new ReflectionCapabilities();
              deps = reflectionCapabilities.parameters(type);
          }
          return () => new classProvider.useClass(...injectArgs(deps));
      }
      else {
          /** @type {?} */
          let deps = ((/** @type {?} */ (provider))).deps;
          if (!deps) {
              /** @type {?} */
              const reflectionCapabilities = new ReflectionCapabilities();
              deps = reflectionCapabilities.parameters(type);
          }
          return () => new type(...injectArgs((/** @type {?} */ (deps))));
      }
  }
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const NgModule = makeDecorator('NgModule', (ngModule) => ngModule, undefined, undefined, 
  /**
   * Decorator that marks the following class as an NgModule, and supplies
   * configuration metadata for it.
   *
   * * The `declarations` and `entryComponents` options configure the compiler
   * with information about what belongs to the NgModule.
   * * The `providers` options configures the NgModule's injector to provide
   * dependencies the NgModule members.
   * * The `imports` and `exports` options bring in members from other modules, and make
   * this module's members available to others.
   */
  (type, meta) => SWITCH_COMPILE_NGMODULE(type, meta));
  /**
   * @param {?} moduleType
   * @param {?} metadata
   * @return {?}
   */
  function preR3NgModuleCompile(moduleType, metadata) {
      /** @type {?} */
      let imports = (metadata && metadata.imports) || [];
      if (metadata && metadata.exports) {
          imports = [...imports, metadata.exports];
      }
      /** @nocollapse */ moduleType.ngInjectorDef = defineInjector({
          factory: convertInjectableProviderToFactory(moduleType, { useClass: moduleType }),
          providers: metadata && metadata.providers,
          imports: imports,
      });
  }
  /** @type {?} */
  const SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;
  /** @type {?} */
  const SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__PRE_R3__;
  const ɵ0$3 = getClosureSafeProperty;
  /** @type {?} */
  const USE_VALUE$2$1 = getClosureSafeProperty({ provide: String, useValue: ɵ0$3 });

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * Injectable decorator and metadata.
   *
   * \@Annotation
   * \@publicApi
   * @type {?}
   */
  const Injectable = makeDecorator('Injectable', undefined, undefined, undefined, (type, meta) => SWITCH_COMPILE_INJECTABLE((/** @type {?} */ (type)), meta));
  /**
   * Supports \@Injectable() in JIT mode for Render2.
   * @param {?} injectableType
   * @param {?} options
   * @return {?}
   */
  function render2CompileInjectable(injectableType, options) {
      if (options && options.providedIn !== undefined && !getInjectableDef(injectableType)) {
          /** @nocollapse */ injectableType.ngInjectableDef = defineInjectable({
              providedIn: options.providedIn,
              factory: convertInjectableProviderToFactory(injectableType, options),
          });
      }
  }
  /** @type {?} */
  const SWITCH_COMPILE_INJECTABLE__PRE_R3__ = render2CompileInjectable;
  /** @type {?} */
  const SWITCH_COMPILE_INJECTABLE = SWITCH_COMPILE_INJECTABLE__PRE_R3__;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const ERROR_DEBUG_CONTEXT = 'ngDebugContext';
  /** @type {?} */
  const ERROR_ORIGINAL_ERROR = 'ngOriginalError';
  /** @type {?} */
  const ERROR_LOGGER = 'ngErrorLogger';
  /**
   * @param {?} error
   * @return {?}
   */
  function getDebugContext(error) {
      return ((/** @type {?} */ (error)))[ERROR_DEBUG_CONTEXT];
  }
  /**
   * @param {?} error
   * @return {?}
   */
  function getOriginalError(error) {
      return ((/** @type {?} */ (error)))[ERROR_ORIGINAL_ERROR];
  }
  /**
   * @param {?} error
   * @return {?}
   */
  function getErrorLogger(error) {
      return ((/** @type {?} */ (error)))[ERROR_LOGGER] || defaultErrorLogger;
  }
  /**
   * @param {?} console
   * @param {...?} values
   * @return {?}
   */
  function defaultErrorLogger(console, ...values) {
      ((/** @type {?} */ (console.error)))(...values);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Provides a hook for centralized exception handling.
   *
   * The default implementation of `ErrorHandler` prints error messages to the `console`. To
   * intercept error handling, write a custom exception handler that replaces this default as
   * appropriate for your app.
   *
   * \@usageNotes
   * ### Example
   *
   * ```
   * class MyErrorHandler implements ErrorHandler {
   *   handleError(error) {
   *     // do something with the exception
   *   }
   * }
   *
   * \@NgModule({
   *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
   * })
   * class MyModule {}
   * ```
   *
   * \@publicApi
   */
  class ErrorHandler {
      constructor() {
          /**
           * \@internal
           */
          this._console = console;
      }
      /**
       * @param {?} error
       * @return {?}
       */
      handleError(error) {
          /** @type {?} */
          const originalError = this._findOriginalError(error);
          /** @type {?} */
          const context = this._findContext(error);
          // Note: Browser consoles show the place from where console.error was called.
          // We can use this to give users additional information about the error.
          /** @type {?} */
          const errorLogger = getErrorLogger(error);
          errorLogger(this._console, `ERROR`, error);
          if (originalError) {
              errorLogger(this._console, `ORIGINAL ERROR`, originalError);
          }
          if (context) {
              errorLogger(this._console, 'ERROR CONTEXT', context);
          }
      }
      /**
       * \@internal
       * @param {?} error
       * @return {?}
       */
      _findContext(error) {
          if (error) {
              return getDebugContext(error) ? getDebugContext(error) :
                  this._findContext(getOriginalError(error));
          }
          return null;
      }
      /**
       * \@internal
       * @param {?} error
       * @return {?}
       */
      _findOriginalError(error) {
          /** @type {?} */
          let e = getOriginalError(error);
          while (e && getOriginalError(e)) {
              e = getOriginalError(e);
          }
          return e;
      }
  }
  /**
   * @param {?} message
   * @param {?} originalError
   * @return {?}
   */
  function wrappedError(message, originalError) {
      /** @type {?} */
      const msg = `${message} caused by: ${originalError instanceof Error ? originalError.message : originalError}`;
      /** @type {?} */
      const error = Error(msg);
      ((/** @type {?} */ (error)))[ERROR_ORIGINAL_ERROR] = originalError;
      return error;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} keys
   * @return {?}
   */
  function findFirstClosedCycle(keys) {
      /** @type {?} */
      const res = [];
      for (let i = 0; i < keys.length; ++i) {
          if (res.indexOf(keys[i]) > -1) {
              res.push(keys[i]);
              return res;
          }
          res.push(keys[i]);
      }
      return res;
  }
  /**
   * @param {?} keys
   * @return {?}
   */
  function constructResolvingPath(keys) {
      if (keys.length > 1) {
          /** @type {?} */
          const reversed = findFirstClosedCycle(keys.slice().reverse());
          /** @type {?} */
          const tokenStrs = reversed.map(k => stringify$1(k.token));
          return ' (' + tokenStrs.join(' -> ') + ')';
      }
      return '';
  }
  /**
   * @param {?} injector
   * @param {?} key
   * @param {?} constructResolvingMessage
   * @param {?=} originalError
   * @return {?}
   */
  function injectionError(injector, key, constructResolvingMessage, originalError) {
      /** @type {?} */
      const keys = [key];
      /** @type {?} */
      const errMsg = constructResolvingMessage(keys);
      /** @type {?} */
      const error = (/** @type {?} */ ((originalError ? wrappedError(errMsg, originalError) : Error(errMsg))));
      error.addKey = addKey;
      error.keys = keys;
      error.injectors = [injector];
      error.constructResolvingMessage = constructResolvingMessage;
      ((/** @type {?} */ (error)))[ERROR_ORIGINAL_ERROR] = originalError;
      return error;
  }
  /**
   * @this {?}
   * @param {?} injector
   * @param {?} key
   * @return {?}
   */
  function addKey(injector, key) {
      this.injectors.push(injector);
      this.keys.push(key);
      // Note: This updated message won't be reflected in the `.stack` property
      this.message = this.constructResolvingMessage(this.keys);
  }
  /**
   * Thrown when trying to retrieve a dependency by key from {\@link Injector}, but the
   * {\@link Injector} does not have a {\@link Provider} for the given key.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * class A {
   *   constructor(b:B) {}
   * }
   *
   * expect(() => Injector.resolveAndCreate([A])).toThrowError();
   * ```
   * @param {?} injector
   * @param {?} key
   * @return {?}
   */
  function noProviderError(injector, key) {
      return injectionError(injector, key, function (keys) {
          /** @type {?} */
          const first$$1 = stringify$1(keys[0].token);
          return `No provider for ${first$$1}!${constructResolvingPath(keys)}`;
      });
  }
  /**
   * Thrown when dependencies form a cycle.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * var injector = Injector.resolveAndCreate([
   *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
   *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
   * ]);
   *
   * expect(() => injector.get("one")).toThrowError();
   * ```
   *
   * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
   * @param {?} injector
   * @param {?} key
   * @return {?}
   */
  function cyclicDependencyError(injector, key) {
      return injectionError(injector, key, function (keys) {
          return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;
      });
  }
  /**
   * Thrown when a constructing type returns with an Error.
   *
   * The `InstantiationError` class contains the original error plus the dependency graph which caused
   * this object to be instantiated.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * class A {
   *   constructor() {
   *     throw new Error('message');
   *   }
   * }
   *
   * var injector = Injector.resolveAndCreate([A]);
   * try {
   *   injector.get(A);
   * } catch (e) {
   *   expect(e instanceof InstantiationError).toBe(true);
   *   expect(e.originalException.message).toEqual("message");
   *   expect(e.originalStack).toBeDefined();
   * }
   * ```
   * @param {?} injector
   * @param {?} originalException
   * @param {?} originalStack
   * @param {?} key
   * @return {?}
   */
  function instantiationError(injector, originalException, originalStack, key) {
      return injectionError(injector, key, function (keys) {
          /** @type {?} */
          const first$$1 = stringify$1(keys[0].token);
          return `${originalException.message}: Error during instantiation of ${first$$1}!${constructResolvingPath(keys)}.`;
      }, originalException);
  }
  /**
   * Thrown when an object other then {\@link Provider} (or `Type`) is passed to {\@link Injector}
   * creation.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
   * ```
   * @param {?} provider
   * @return {?}
   */
  function invalidProviderError(provider) {
      return Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);
  }
  /**
   * Thrown when the class has no annotation information.
   *
   * Lack of annotation information prevents the {\@link Injector} from determining which dependencies
   * need to be injected into the constructor.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * class A {
   *   constructor(b) {}
   * }
   *
   * expect(() => Injector.resolveAndCreate([A])).toThrowError();
   * ```
   *
   * This error is also thrown when the class not marked with {\@link Injectable} has parameter types.
   *
   * ```typescript
   * class B {}
   *
   * class A {
   *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
   * }
   *
   * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
   * ```
   *
   * @param {?} typeOrFunc
   * @param {?} params
   * @return {?}
   */
  function noAnnotationError(typeOrFunc, params) {
      /** @type {?} */
      const signature = [];
      for (let i = 0, ii = params.length; i < ii; i++) {
          /** @type {?} */
          const parameter = params[i];
          if (!parameter || parameter.length == 0) {
              signature.push('?');
          }
          else {
              signature.push(parameter.map(stringify$1).join(' '));
          }
      }
      return Error('Cannot resolve all parameters for \'' + stringify$1(typeOrFunc) + '\'(' +
          signature.join(', ') + '). ' +
          'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
          stringify$1(typeOrFunc) + '\' is decorated with Injectable.');
  }
  /**
   * Thrown when getting an object by index.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * class A {}
   *
   * var injector = Injector.resolveAndCreate([A]);
   *
   * expect(() => injector.getAt(100)).toThrowError();
   * ```
   *
   * @param {?} index
   * @return {?}
   */
  function outOfBoundsError(index) {
      return Error(`Index ${index} is out-of-bounds.`);
  }
  // TODO: add a working example after alpha38 is released
  /**
   * Thrown when a multi provider and a regular provider are bound to the same token.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * expect(() => Injector.resolveAndCreate([
   *   { provide: "Strings", useValue: "string1", multi: true},
   *   { provide: "Strings", useValue: "string2", multi: false}
   * ])).toThrowError();
   * ```
   * @param {?} provider1
   * @param {?} provider2
   * @return {?}
   */
  function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
      return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A unique object used for retrieving items from the {\@link ReflectiveInjector}.
   *
   * Keys have:
   * - a system-wide unique `id`.
   * - a `token`.
   *
   * `Key` is used internally by {\@link ReflectiveInjector} because its system-wide unique `id` allows
   * the
   * injector to store created objects in a more efficient way.
   *
   * `Key` should not be created directly. {\@link ReflectiveInjector} creates keys automatically when
   * resolving
   * providers.
   *
   * @deprecated No replacement
   * \@publicApi
   */
  class ReflectiveKey {
      /**
       * Private
       * @param {?} token
       * @param {?} id
       */
      constructor(token, id) {
          this.token = token;
          this.id = id;
          if (!token) {
              throw new Error('Token must be defined!');
          }
          this.displayName = stringify$1(this.token);
      }
      /**
       * Retrieves a `Key` for a token.
       * @param {?} token
       * @return {?}
       */
      static get(token) {
          return _globalKeyRegistry.get(resolveForwardRef$1(token));
      }
      /**
       * @return {?} the number of keys registered in the system.
       */
      static get numberOfKeys() { return _globalKeyRegistry.numberOfKeys; }
  }
  class KeyRegistry {
      constructor() {
          this._allKeys = new Map();
      }
      /**
       * @param {?} token
       * @return {?}
       */
      get(token) {
          if (token instanceof ReflectiveKey)
              return token;
          if (this._allKeys.has(token)) {
              return (/** @type {?} */ (this._allKeys.get(token)));
          }
          /** @type {?} */
          const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
          this._allKeys.set(token, newKey);
          return newKey;
      }
      /**
       * @return {?}
       */
      get numberOfKeys() { return this._allKeys.size; }
  }
  /** @type {?} */
  const _globalKeyRegistry = new KeyRegistry();

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Provides access to reflection data about symbols. Used internally by Angular
   * to power dependency injection and compilation.
   */
  class Reflector {
      /**
       * @param {?} reflectionCapabilities
       */
      constructor(reflectionCapabilities) {
          this.reflectionCapabilities = reflectionCapabilities;
      }
      /**
       * @param {?} caps
       * @return {?}
       */
      updateCapabilities(caps) { this.reflectionCapabilities = caps; }
      /**
       * @param {?} type
       * @return {?}
       */
      factory(type) { return this.reflectionCapabilities.factory(type); }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      parameters(typeOrFunc) {
          return this.reflectionCapabilities.parameters(typeOrFunc);
      }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      annotations(typeOrFunc) {
          return this.reflectionCapabilities.annotations(typeOrFunc);
      }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      propMetadata(typeOrFunc) {
          return this.reflectionCapabilities.propMetadata(typeOrFunc);
      }
      /**
       * @param {?} type
       * @param {?} lcProperty
       * @return {?}
       */
      hasLifecycleHook(type, lcProperty) {
          return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
      }
      /**
       * @param {?} name
       * @return {?}
       */
      getter(name) { return this.reflectionCapabilities.getter(name); }
      /**
       * @param {?} name
       * @return {?}
       */
      setter(name) { return this.reflectionCapabilities.setter(name); }
      /**
       * @param {?} name
       * @return {?}
       */
      method(name) { return this.reflectionCapabilities.method(name); }
      /**
       * @param {?} type
       * @return {?}
       */
      importUri(type) { return this.reflectionCapabilities.importUri(type); }
      /**
       * @param {?} type
       * @return {?}
       */
      resourceUri(type) { return this.reflectionCapabilities.resourceUri(type); }
      /**
       * @param {?} name
       * @param {?} moduleUrl
       * @param {?} members
       * @param {?} runtime
       * @return {?}
       */
      resolveIdentifier(name, moduleUrl, members, runtime) {
          return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);
      }
      /**
       * @param {?} identifier
       * @param {?} name
       * @return {?}
       */
      resolveEnum(identifier, name) {
          return this.reflectionCapabilities.resolveEnum(identifier, name);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The {\@link Reflector} used internally in Angular to access metadata
   * about symbols.
   * @type {?}
   */
  const reflector = new Reflector(new ReflectionCapabilities());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * `Dependency` is used by the framework to extend DI.
   * This is internal to Angular and should not be used directly.
   */
  class ReflectiveDependency {
      /**
       * @param {?} key
       * @param {?} optional
       * @param {?} visibility
       */
      constructor(key, optional, visibility) {
          this.key = key;
          this.optional = optional;
          this.visibility = visibility;
      }
      /**
       * @param {?} key
       * @return {?}
       */
      static fromKey(key) {
          return new ReflectiveDependency(key, false, null);
      }
  }
  /** @type {?} */
  const _EMPTY_LIST = [];
  class ResolvedReflectiveProvider_ {
      /**
       * @param {?} key
       * @param {?} resolvedFactories
       * @param {?} multiProvider
       */
      constructor(key, resolvedFactories, multiProvider) {
          this.key = key;
          this.resolvedFactories = resolvedFactories;
          this.multiProvider = multiProvider;
          this.resolvedFactory = this.resolvedFactories[0];
      }
  }
  /**
   * An internal resolved representation of a factory function created by resolving `Provider`.
   * \@publicApi
   */
  class ResolvedReflectiveFactory {
      /**
       * @param {?} factory
       * @param {?} dependencies
       */
      constructor(factory, dependencies) {
          this.factory = factory;
          this.dependencies = dependencies;
      }
  }
  /**
   * Resolve a single provider.
   * @param {?} provider
   * @return {?}
   */
  function resolveReflectiveFactory(provider) {
      /** @type {?} */
      let factoryFn;
      /** @type {?} */
      let resolvedDeps;
      if (provider.useClass) {
          /** @type {?} */
          const useClass = resolveForwardRef$1(provider.useClass);
          factoryFn = reflector.factory(useClass);
          resolvedDeps = _dependenciesFor(useClass);
      }
      else if (provider.useExisting) {
          factoryFn = (aliasInstance) => aliasInstance;
          resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
      }
      else if (provider.useFactory) {
          factoryFn = provider.useFactory;
          resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
      }
      else {
          factoryFn = () => provider.useValue;
          resolvedDeps = _EMPTY_LIST;
      }
      return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
  }
  /**
   * Converts the `Provider` into `ResolvedProvider`.
   *
   * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider
   * syntax.
   * @param {?} provider
   * @return {?}
   */
  function resolveReflectiveProvider(provider) {
      return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);
  }
  /**
   * Resolve a list of Providers.
   * @param {?} providers
   * @return {?}
   */
  function resolveReflectiveProviders(providers) {
      /** @type {?} */
      const normalized = _normalizeProviders(providers, []);
      /** @type {?} */
      const resolved = normalized.map(resolveReflectiveProvider);
      /** @type {?} */
      const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
      return Array.from(resolvedProviderMap.values());
  }
  /**
   * Merges a list of ResolvedProviders into a list where each key is contained exactly once and
   * multi providers have been merged.
   * @param {?} providers
   * @param {?} normalizedProvidersMap
   * @return {?}
   */
  function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
      for (let i = 0; i < providers.length; i++) {
          /** @type {?} */
          const provider = providers[i];
          /** @type {?} */
          const existing = normalizedProvidersMap.get(provider.key.id);
          if (existing) {
              if (provider.multiProvider !== existing.multiProvider) {
                  throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
              }
              if (provider.multiProvider) {
                  for (let j = 0; j < provider.resolvedFactories.length; j++) {
                      existing.resolvedFactories.push(provider.resolvedFactories[j]);
                  }
              }
              else {
                  normalizedProvidersMap.set(provider.key.id, provider);
              }
          }
          else {
              /** @type {?} */
              let resolvedProvider;
              if (provider.multiProvider) {
                  resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
              }
              else {
                  resolvedProvider = provider;
              }
              normalizedProvidersMap.set(provider.key.id, resolvedProvider);
          }
      }
      return normalizedProvidersMap;
  }
  /**
   * @param {?} providers
   * @param {?} res
   * @return {?}
   */
  function _normalizeProviders(providers, res) {
      providers.forEach(b => {
          if (b instanceof Type$2) {
              res.push({ provide: b, useClass: b });
          }
          else if (b && typeof b == 'object' && ((/** @type {?} */ (b))).provide !== undefined) {
              res.push((/** @type {?} */ (b)));
          }
          else if (b instanceof Array) {
              _normalizeProviders(b, res);
          }
          else {
              throw invalidProviderError(b);
          }
      });
      return res;
  }
  /**
   * @param {?} typeOrFunc
   * @param {?=} dependencies
   * @return {?}
   */
  function constructDependencies(typeOrFunc, dependencies) {
      if (!dependencies) {
          return _dependenciesFor(typeOrFunc);
      }
      else {
          /** @type {?} */
          const params = dependencies.map(t => [t]);
          return dependencies.map(t => _extractToken(typeOrFunc, t, params));
      }
  }
  /**
   * @param {?} typeOrFunc
   * @return {?}
   */
  function _dependenciesFor(typeOrFunc) {
      /** @type {?} */
      const params = reflector.parameters(typeOrFunc);
      if (!params)
          return [];
      if (params.some(p => p == null)) {
          throw noAnnotationError(typeOrFunc, params);
      }
      return params.map(p => _extractToken(typeOrFunc, p, params));
  }
  /**
   * @param {?} typeOrFunc
   * @param {?} metadata
   * @param {?} params
   * @return {?}
   */
  function _extractToken(typeOrFunc, metadata, params) {
      /** @type {?} */
      let token = null;
      /** @type {?} */
      let optional = false;
      if (!Array.isArray(metadata)) {
          if (metadata instanceof Inject) {
              return _createDependency(metadata.token, optional, null);
          }
          else {
              return _createDependency(metadata, optional, null);
          }
      }
      /** @type {?} */
      let visibility = null;
      for (let i = 0; i < metadata.length; ++i) {
          /** @type {?} */
          const paramMetadata = metadata[i];
          if (paramMetadata instanceof Type$2) {
              token = paramMetadata;
          }
          else if (paramMetadata instanceof Inject) {
              token = paramMetadata.token;
          }
          else if (paramMetadata instanceof Optional) {
              optional = true;
          }
          else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
              visibility = paramMetadata;
          }
          else if (paramMetadata instanceof InjectionToken) {
              token = paramMetadata;
          }
      }
      token = resolveForwardRef$1(token);
      if (token != null) {
          return _createDependency(token, optional, visibility);
      }
      else {
          throw noAnnotationError(typeOrFunc, params);
      }
  }
  /**
   * @param {?} token
   * @param {?} optional
   * @param {?} visibility
   * @return {?}
   */
  function _createDependency(token, optional, visibility) {
      return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Threshold for the dynamic version
  /** @type {?} */
  const UNDEFINED = new Object();
  /**
   * A ReflectiveDependency injection container used for instantiating objects and resolving
   * dependencies.
   *
   * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
   * constructor dependencies.
   *
   * In typical use, application code asks for the dependencies in the constructor and they are
   * resolved by the `Injector`.
   *
   * \@usageNotes
   * ### Example
   *
   * The following example creates an `Injector` configured to create `Engine` and `Car`.
   *
   * ```typescript
   * \@Injectable()
   * class Engine {
   * }
   *
   * \@Injectable()
   * class Car {
   *   constructor(public engine:Engine) {}
   * }
   *
   * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
   * var car = injector.get(Car);
   * expect(car instanceof Car).toBe(true);
   * expect(car.engine instanceof Engine).toBe(true);
   * ```
   *
   * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
   * resolve all of the object's dependencies automatically.
   *
   * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.
   * \@publicApi
   * @abstract
   */
  class ReflectiveInjector {
      /**
       * Turns an array of provider definitions into an array of resolved providers.
       *
       * A resolution is a process of flattening multiple nested arrays and converting individual
       * providers into an array of `ResolvedReflectiveProvider`s.
       *
       * \@usageNotes
       * ### Example
       *
       * ```typescript
       * \@Injectable()
       * class Engine {
       * }
       *  /
       * class Car {
       *   constructor(public engine:Engine) {}
       * }
       *
       * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
       *
       * expect(providers.length).toEqual(2);
       *
       * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
       * expect(providers[0].key.displayName).toBe("Car");
       * expect(providers[0].dependencies.length).toEqual(1);
       * expect(providers[0].factory).toBeDefined();
       *
       * expect(providers[1].key.displayName).toBe("Engine");
       * });
       * ```
       *
       * @param {?} providers
       * @return {?}
       */
      static resolve(providers) {
          return resolveReflectiveProviders(providers);
      }
      /**
       * Resolves an array of providers and creates an injector from those providers.
       *
       * The passed-in providers can be an array of `Type`, `Provider`,
       * or a recursive array of more providers.
       *
       * \@usageNotes
       * ### Example
       *
       * ```typescript
       * \@Injectable()
       * class Engine {
       * }
       *  /
       * class Car {
       *   constructor(public engine:Engine) {}
       * }
       *
       * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
       * expect(injector.get(Car) instanceof Car).toBe(true);
       * ```
       * @param {?} providers
       * @param {?=} parent
       * @return {?}
       */
      static resolveAndCreate(providers, parent) {
          /** @type {?} */
          const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
          return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
      }
      /**
       * Creates an injector from previously resolved providers.
       *
       * This API is the recommended way to construct injectors in performance-sensitive parts.
       *
       * \@usageNotes
       * ### Example
       *
       * ```typescript
       * \@Injectable()
       * class Engine {
       * }
       *  /
       * class Car {
       *   constructor(public engine:Engine) {}
       * }
       *
       * var providers = ReflectiveInjector.resolve([Car, Engine]);
       * var injector = ReflectiveInjector.fromResolvedProviders(providers);
       * expect(injector.get(Car) instanceof Car).toBe(true);
       * ```
       * @param {?} providers
       * @param {?=} parent
       * @return {?}
       */
      static fromResolvedProviders(providers, parent) {
          return new ReflectiveInjector_(providers, parent);
      }
  }
  class ReflectiveInjector_ {
      /**
       * Private
       * @param {?} _providers
       * @param {?=} _parent
       */
      constructor(_providers, _parent) {
          /**
           * \@internal
           */
          this._constructionCounter = 0;
          this._providers = _providers;
          this.parent = _parent || null;
          /** @type {?} */
          const len = _providers.length;
          this.keyIds = new Array(len);
          this.objs = new Array(len);
          for (let i = 0; i < len; i++) {
              this.keyIds[i] = _providers[i].key.id;
              this.objs[i] = UNDEFINED;
          }
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */
      get(token, notFoundValue = THROW_IF_NOT_FOUND) {
          return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
      }
      /**
       * @param {?} providers
       * @return {?}
       */
      resolveAndCreateChild(providers) {
          /** @type {?} */
          const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
          return this.createChildFromResolved(ResolvedReflectiveProviders);
      }
      /**
       * @param {?} providers
       * @return {?}
       */
      createChildFromResolved(providers) {
          /** @type {?} */
          const inj = new ReflectiveInjector_(providers);
          ((/** @type {?} */ (inj))).parent = this;
          return inj;
      }
      /**
       * @param {?} provider
       * @return {?}
       */
      resolveAndInstantiate(provider) {
          return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
      }
      /**
       * @param {?} provider
       * @return {?}
       */
      instantiateResolved(provider) {
          return this._instantiateProvider(provider);
      }
      /**
       * @param {?} index
       * @return {?}
       */
      getProviderAtIndex(index) {
          if (index < 0 || index >= this._providers.length) {
              throw outOfBoundsError(index);
          }
          return this._providers[index];
      }
      /**
       * \@internal
       * @param {?} provider
       * @return {?}
       */
      _new(provider) {
          if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
              throw cyclicDependencyError(this, provider.key);
          }
          return this._instantiateProvider(provider);
      }
      /**
       * @private
       * @return {?}
       */
      _getMaxNumberOfObjects() { return this.objs.length; }
      /**
       * @private
       * @param {?} provider
       * @return {?}
       */
      _instantiateProvider(provider) {
          if (provider.multiProvider) {
              /** @type {?} */
              const res = new Array(provider.resolvedFactories.length);
              for (let i = 0; i < provider.resolvedFactories.length; ++i) {
                  res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
              }
              return res;
          }
          else {
              return this._instantiate(provider, provider.resolvedFactories[0]);
          }
      }
      /**
       * @private
       * @param {?} provider
       * @param {?} ResolvedReflectiveFactory
       * @return {?}
       */
      _instantiate(provider, ResolvedReflectiveFactory$$1) {
          /** @type {?} */
          const factory = ResolvedReflectiveFactory$$1.factory;
          /** @type {?} */
          let deps;
          try {
              deps =
                  ResolvedReflectiveFactory$$1.dependencies.map(dep => this._getByReflectiveDependency(dep));
          }
          catch (e) {
              if (e.addKey) {
                  e.addKey(this, provider.key);
              }
              throw e;
          }
          /** @type {?} */
          let obj;
          try {
              obj = factory(...deps);
          }
          catch (e) {
              throw instantiationError(this, e, e.stack, provider.key);
          }
          return obj;
      }
      /**
       * @private
       * @param {?} dep
       * @return {?}
       */
      _getByReflectiveDependency(dep) {
          return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
      }
      /**
       * @private
       * @param {?} key
       * @param {?} visibility
       * @param {?} notFoundValue
       * @return {?}
       */
      _getByKey(key, visibility, notFoundValue) {
          if (key === ReflectiveInjector_.INJECTOR_KEY) {
              return this;
          }
          if (visibility instanceof Self) {
              return this._getByKeySelf(key, notFoundValue);
          }
          else {
              return this._getByKeyDefault(key, notFoundValue, visibility);
          }
      }
      /**
       * @private
       * @param {?} keyId
       * @return {?}
       */
      _getObjByKeyId(keyId) {
          for (let i = 0; i < this.keyIds.length; i++) {
              if (this.keyIds[i] === keyId) {
                  if (this.objs[i] === UNDEFINED) {
                      this.objs[i] = this._new(this._providers[i]);
                  }
                  return this.objs[i];
              }
          }
          return UNDEFINED;
      }
      /**
       * \@internal
       * @param {?} key
       * @param {?} notFoundValue
       * @return {?}
       */
      _throwOrNull(key, notFoundValue) {
          if (notFoundValue !== THROW_IF_NOT_FOUND) {
              return notFoundValue;
          }
          else {
              throw noProviderError(this, key);
          }
      }
      /**
       * \@internal
       * @param {?} key
       * @param {?} notFoundValue
       * @return {?}
       */
      _getByKeySelf(key, notFoundValue) {
          /** @type {?} */
          const obj = this._getObjByKeyId(key.id);
          return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
      }
      /**
       * \@internal
       * @param {?} key
       * @param {?} notFoundValue
       * @param {?} visibility
       * @return {?}
       */
      _getByKeyDefault(key, notFoundValue, visibility) {
          /** @type {?} */
          let inj;
          if (visibility instanceof SkipSelf) {
              inj = this.parent;
          }
          else {
              inj = this;
          }
          while (inj instanceof ReflectiveInjector_) {
              /** @type {?} */
              const inj_ = (/** @type {?} */ (inj));
              /** @type {?} */
              const obj = inj_._getObjByKeyId(key.id);
              if (obj !== UNDEFINED)
                  return obj;
              inj = inj_.parent;
          }
          if (inj !== null) {
              return inj.get(key.token, notFoundValue);
          }
          else {
              return this._throwOrNull(key, notFoundValue);
          }
      }
      /**
       * @return {?}
       */
      get displayName() {
          /** @type {?} */
          const providers = _mapProviders(this, (b) => ' "' + b.key.displayName + '" ')
              .join(', ');
          return `ReflectiveInjector(providers: [${providers}])`;
      }
      /**
       * @return {?}
       */
      toString() { return this.displayName; }
  }
  ReflectiveInjector_.INJECTOR_KEY = ReflectiveKey.get(Injector);
  /**
   * @param {?} injector
   * @param {?} fn
   * @return {?}
   */
  function _mapProviders(injector, fn) {
      /** @type {?} */
      const res = new Array(injector._providers.length);
      for (let i = 0; i < injector._providers.length; ++i) {
          res[i] = fn(injector.getProviderAtIndex(i));
      }
      return res;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * Determine if the argument is shaped like a Promise
   * @param {?} obj
   * @return {?}
   */
  function isPromise$2(obj) {
      // allow any Promise/A+ compliant thenable.
      // It's up to the caller to ensure that obj.then conforms to the spec
      return !!obj && typeof obj.then === 'function';
  }
  /**
   * Determine if the argument is an Observable
   * @param {?} obj
   * @return {?}
   */
  function isObservable$1(obj) {
      // TODO: use isObservable once we update pass rxjs 6.1
      // https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#610-2018-05-03
      return !!obj && typeof obj.subscribe === 'function';
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A function that will be executed when an application is initialized.
   *
   * \@publicApi
   * @type {?}
   */
  const APP_INITIALIZER = new InjectionToken('Application Initializer');
  /**
   * A class that reflects the state of running {\@link APP_INITIALIZER}s.
   *
   * \@publicApi
   */
  class ApplicationInitStatus {
      /**
       * @param {?} appInits
       */
      constructor(appInits) {
          this.appInits = appInits;
          this.initialized = false;
          this.done = false;
          this.donePromise = new Promise((res, rej) => {
              this.resolve = res;
              this.reject = rej;
          });
      }
      /**
       * \@internal
       * @return {?}
       */
      runInitializers() {
          if (this.initialized) {
              return;
          }
          /** @type {?} */
          const asyncInitPromises = [];
          /** @type {?} */
          const complete = () => {
              ((/** @type {?} */ (this))).done = true;
              this.resolve();
          };
          if (this.appInits) {
              for (let i = 0; i < this.appInits.length; i++) {
                  /** @type {?} */
                  const initResult = this.appInits[i]();
                  if (isPromise$2(initResult)) {
                      asyncInitPromises.push(initResult);
                  }
              }
          }
          Promise.all(asyncInitPromises).then(() => { complete(); }).catch(e => { this.reject(e); });
          if (asyncInitPromises.length === 0) {
              complete();
          }
          this.initialized = true;
      }
  }
  ApplicationInitStatus.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  ApplicationInitStatus.ctorParameters = () => [
      { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A DI Token representing a unique string id assigned to the application by Angular and used
   * primarily for prefixing application attributes and CSS styles when
   * {\@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.
   *
   * If you need to avoid randomly generated value to be used as an application id, you can provide
   * a custom value via a DI provider <!-- TODO: provider --> configuring the root {\@link Injector}
   * using this token.
   * \@publicApi
   * @type {?}
   */
  const APP_ID = new InjectionToken('AppId');
  /**
   * @return {?}
   */
  function _appIdRandomProviderFactory() {
      return `${_randomChar()}${_randomChar()}${_randomChar()}`;
  }
  /**
   * Providers that will generate a random APP_ID_TOKEN.
   * \@publicApi
   * @type {?}
   */
  const APP_ID_RANDOM_PROVIDER = {
      provide: APP_ID,
      useFactory: _appIdRandomProviderFactory,
      deps: (/** @type {?} */ ([])),
  };
  /**
   * @return {?}
   */
  function _randomChar() {
      return String.fromCharCode(97 + Math.floor(Math.random() * 25));
  }
  /**
   * A function that will be executed when a platform is initialized.
   * \@publicApi
   * @type {?}
   */
  const PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');
  /**
   * A token that indicates an opaque platform id.
   * \@publicApi
   * @type {?}
   */
  const PLATFORM_ID = new InjectionToken('Platform ID');
  /**
   * All callbacks provided via this token will be called for every component that is bootstrapped.
   * Signature of the callback:
   *
   * `(componentRef: ComponentRef) => void`.
   *
   * \@publicApi
   * @type {?}
   */
  const APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
  /**
   * A token which indicates the root directory of the application
   * \@publicApi
   * @type {?}
   */
  const PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class Console {
      /**
       * @param {?} message
       * @return {?}
       */
      log(message) {
          // tslint:disable-next-line:no-console
          console.log(message);
      }
      // Note: for reporting errors use `DOM.logError()` as it is platform specific
      /**
       * @param {?} message
       * @return {?}
       */
      warn(message) {
          // tslint:disable-next-line:no-console
          console.warn(message);
      }
  }
  Console.decorators = [
      { type: Injectable }
  ];
  /**
   * @return {?}
   */
  function _throwError() {
      throw new Error(`Runtime compiler is not loaded`);
  }
  /** @type {?} */
  const Compiler_compileModuleSync__PRE_R3__ = (/** @type {?} */ (_throwError));
  /** @type {?} */
  const Compiler_compileModuleSync = Compiler_compileModuleSync__PRE_R3__;
  /** @type {?} */
  const Compiler_compileModuleAsync__PRE_R3__ = (/** @type {?} */ (_throwError));
  /** @type {?} */
  const Compiler_compileModuleAsync = Compiler_compileModuleAsync__PRE_R3__;
  /** @type {?} */
  const Compiler_compileModuleAndAllComponentsSync__PRE_R3__ = (/** @type {?} */ (_throwError));
  /** @type {?} */
  const Compiler_compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync__PRE_R3__;
  /** @type {?} */
  const Compiler_compileModuleAndAllComponentsAsync__PRE_R3__ = (/** @type {?} */ (_throwError));
  /** @type {?} */
  const Compiler_compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync__PRE_R3__;
  /**
   * Low-level service for running the angular compiler during runtime
   * to create {\@link ComponentFactory}s, which
   * can later be used to create and render a Component instance.
   *
   * Each `\@NgModule` provides an own `Compiler` to its injector,
   * that will use the directives/pipes of the ng module for compilation
   * of components.
   *
   * \@publicApi
   */
  class Compiler {
      constructor() {
          /**
           * Compiles the given NgModule and all of its components. All templates of the components listed
           * in `entryComponents` have to be inlined.
           */
          this.compileModuleSync = Compiler_compileModuleSync;
          /**
           * Compiles the given NgModule and all of its components
           */
          this.compileModuleAsync = Compiler_compileModuleAsync;
          /**
           * Same as {\@link #compileModuleSync} but also creates ComponentFactories for all components.
           */
          this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync;
          /**
           * Same as {\@link #compileModuleAsync} but also creates ComponentFactories for all components.
           */
          this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;
      }
      /**
       * Clears all caches.
       * @return {?}
       */
      clearCache() { }
      /**
       * Clears the cache for the given component/ngModule.
       * @param {?} type
       * @return {?}
       */
      clearCacheFor(type) { }
      /**
       * Returns the id for a given NgModule, if one is defined and known to the compiler.
       * @param {?} moduleType
       * @return {?}
       */
      getModuleId(moduleType) { return undefined; }
  }
  Compiler.decorators = [
      { type: Injectable }
  ];
  /**
   * Token to provide CompilerOptions in the platform injector.
   *
   * \@publicApi
   * @type {?}
   */
  const COMPILER_OPTIONS = new InjectionToken('compilerOptions');
  /**
   * A factory for creating a Compiler
   *
   * \@publicApi
   * @abstract
   */
  class CompilerFactory {
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  let trace;
  /** @type {?} */
  let events;
  /**
   * @return {?}
   */
  function detectWTF() {
      /** @type {?} */
      const wtf = ((/** @type {?} */ (_global$1)))['wtf'];
      if (wtf) {
          trace = wtf['trace'];
          if (trace) {
              events = trace['events'];
              return true;
          }
      }
      return false;
  }
  /**
   * @param {?} signature
   * @param {?=} flags
   * @return {?}
   */
  function createScope(signature, flags = null) {
      return events.createScope(signature, flags);
  }
  /**
   * @template T
   * @param {?} scope
   * @param {?=} returnValue
   * @return {?}
   */
  function leave(scope, returnValue) {
      trace.leaveScope(scope, returnValue);
      return returnValue;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * True if WTF is enabled.
   * @type {?}
   */
  const wtfEnabled = detectWTF();
  /**
   * @param {?=} arg0
   * @param {?=} arg1
   * @return {?}
   */
  function noopScope(arg0, arg1) {
      return null;
  }
  /**
   * Create trace scope.
   *
   * Scopes must be strictly nested and are analogous to stack frames, but
   * do not have to follow the stack frames. Instead it is recommended that they follow logical
   * nesting. You may want to use
   * [Event
   * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
   * as they are defined in WTF.
   *
   * Used to mark scope entry. The return value is used to leave the scope.
   *
   *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
   *
   *     someMethod() {
   *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
   *        // DO SOME WORK HERE
   *        return wtfLeave(s, 123); // Return value 123
   *     }
   *
   * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
   * negatively impact the performance of your application. For this reason we recommend that
   * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
   * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
   * exception, will produce incorrect trace, but presence of exception signifies logic error which
   * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
   * an exception is expected during normal execution while profiling.
   *
   * \@publicApi
   * @type {?}
   */
  const wtfCreateScope = wtfEnabled ? createScope : (signature, flags) => noopScope;
  /**
   * Used to mark end of Scope.
   *
   * - `scope` to end.
   * - `returnValue` (optional) to be passed to the WTF.
   *
   * Returns the `returnValue for easy chaining.
   * \@publicApi
   * @type {?}
   */
  const wtfLeave = wtfEnabled ? leave : (s, r) => r;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * An injectable service for executing work inside or outside of the Angular zone.
   *
   * The most common use of this service is to optimize performance when starting a work consisting of
   * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
   * Angular. Such tasks can be kicked off via {\@link #runOutsideAngular} and if needed, these tasks
   * can reenter the Angular zone via {\@link #run}.
   *
   * <!-- TODO: add/fix links to:
   *   - docs explaining zones and the use of zones in Angular and change-detection
   *   - link to runOutsideAngular/run (throughout this file!)
   *   -->
   *
   * \@usageNotes
   * ### Example
   *
   * ```
   * import {Component, NgZone} from '\@angular/core';
   * import {NgIf} from '\@angular/common';
   *
   * \@Component({
   *   selector: 'ng-zone-demo',
   *   template: `
   *     <h2>Demo: NgZone</h2>
   *
   *     <p>Progress: {{progress}}%</p>
   *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
   *
   *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
   *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
   *   `,
   * })
   * export class NgZoneDemo {
   *   progress: number = 0;
   *   label: string;
   *
   *   constructor(private _ngZone: NgZone) {}
   *
   *   // Loop inside the Angular zone
   *   // so the UI DOES refresh after each setTimeout cycle
   *   processWithinAngularZone() {
   *     this.label = 'inside';
   *     this.progress = 0;
   *     this._increaseProgress(() => console.log('Inside Done!'));
   *   }
   *
   *   // Loop outside of the Angular zone
   *   // so the UI DOES NOT refresh after each setTimeout cycle
   *   processOutsideOfAngularZone() {
   *     this.label = 'outside';
   *     this.progress = 0;
   *     this._ngZone.runOutsideAngular(() => {
   *       this._increaseProgress(() => {
   *         // reenter the Angular zone and display done
   *         this._ngZone.run(() => { console.log('Outside Done!'); });
   *       });
   *     });
   *   }
   *
   *   _increaseProgress(doneCallback: () => void) {
   *     this.progress += 1;
   *     console.log(`Current progress: ${this.progress}%`);
   *
   *     if (this.progress < 100) {
   *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);
   *     } else {
   *       doneCallback();
   *     }
   *   }
   * }
   * ```
   *
   * \@publicApi
   */
  class NgZone {
      /**
       * @param {?} __0
       */
      constructor({ enableLongStackTrace = false }) {
          this.hasPendingMicrotasks = false;
          this.hasPendingMacrotasks = false;
          /**
           * Whether there are no outstanding microtasks or macrotasks.
           */
          this.isStable = true;
          /**
           * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
           */
          this.onUnstable = new EventEmitter(false);
          /**
           * Notifies when there is no more microtasks enqueued in the current VM Turn.
           * This is a hint for Angular to do change detection, which may enqueue more microtasks.
           * For this reason this event can fire multiple times per VM Turn.
           */
          this.onMicrotaskEmpty = new EventEmitter(false);
          /**
           * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
           * implies we are about to relinquish VM turn.
           * This event gets called just once.
           */
          this.onStable = new EventEmitter(false);
          /**
           * Notifies that an error has been delivered.
           */
          this.onError = new EventEmitter(false);
          if (typeof Zone == 'undefined') {
              throw new Error(`In this configuration Angular requires Zone.js`);
          }
          Zone.assertZonePatched();
          /** @type {?} */
          const self = (/** @type {?} */ ((/** @type {?} */ (this))));
          self._nesting = 0;
          self._outer = self._inner = Zone.current;
          if (((/** @type {?} */ (Zone)))['wtfZoneSpec']) {
              self._inner = self._inner.fork(((/** @type {?} */ (Zone)))['wtfZoneSpec']);
          }
          if (((/** @type {?} */ (Zone)))['TaskTrackingZoneSpec']) {
              self._inner = self._inner.fork(new ((/** @type {?} */ (((/** @type {?} */ (Zone)))['TaskTrackingZoneSpec']))));
          }
          if (enableLongStackTrace && ((/** @type {?} */ (Zone)))['longStackTraceZoneSpec']) {
              self._inner = self._inner.fork(((/** @type {?} */ (Zone)))['longStackTraceZoneSpec']);
          }
          forkInnerZoneWithAngularBehavior(self);
      }
      /**
       * @return {?}
       */
      static isInAngularZone() { return Zone.current.get('isAngularZone') === true; }
      /**
       * @return {?}
       */
      static assertInAngularZone() {
          if (!NgZone.isInAngularZone()) {
              throw new Error('Expected to be in Angular Zone, but it is not!');
          }
      }
      /**
       * @return {?}
       */
      static assertNotInAngularZone() {
          if (NgZone.isInAngularZone()) {
              throw new Error('Expected to not be in Angular Zone, but it is!');
          }
      }
      /**
       * Executes the `fn` function synchronously within the Angular zone and returns value returned by
       * the function.
       *
       * Running functions via `run` allows you to reenter Angular zone from a task that was executed
       * outside of the Angular zone (typically started via {\@link #runOutsideAngular}).
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * within the Angular zone.
       *
       * If a synchronous error happens it will be rethrown and not reported via `onError`.
       * @template T
       * @param {?} fn
       * @param {?=} applyThis
       * @param {?=} applyArgs
       * @return {?}
       */
      run(fn, applyThis, applyArgs) {
          return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this)))))._inner.run(fn, applyThis, applyArgs)));
      }
      /**
       * Executes the `fn` function synchronously within the Angular zone as a task and returns value
       * returned by the function.
       *
       * Running functions via `run` allows you to reenter Angular zone from a task that was executed
       * outside of the Angular zone (typically started via {\@link #runOutsideAngular}).
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * within the Angular zone.
       *
       * If a synchronous error happens it will be rethrown and not reported via `onError`.
       * @template T
       * @param {?} fn
       * @param {?=} applyThis
       * @param {?=} applyArgs
       * @param {?=} name
       * @return {?}
       */
      runTask(fn, applyThis, applyArgs, name) {
          /** @type {?} */
          const zone = ((/** @type {?} */ ((/** @type {?} */ (this)))))._inner;
          /** @type {?} */
          const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop$1$1, noop$1$1);
          try {
              return (/** @type {?} */ (zone.runTask(task, applyThis, applyArgs)));
          }
          finally {
              zone.cancelTask(task);
          }
      }
      /**
       * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
       * rethrown.
       * @template T
       * @param {?} fn
       * @param {?=} applyThis
       * @param {?=} applyArgs
       * @return {?}
       */
      runGuarded(fn, applyThis, applyArgs) {
          return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this)))))._inner.runGuarded(fn, applyThis, applyArgs)));
      }
      /**
       * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
       * the function.
       *
       * Running functions via {\@link #runOutsideAngular} allows you to escape Angular's zone and do
       * work that
       * doesn't trigger Angular change-detection or is subject to Angular's error handling.
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * outside of the Angular zone.
       *
       * Use {\@link #run} to reenter the Angular zone and do work that updates the application model.
       * @template T
       * @param {?} fn
       * @return {?}
       */
      runOutsideAngular(fn) {
          return (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this)))))._outer.run(fn)));
      }
  }
  /**
   * @return {?}
   */
  function noop$1$1() { }
  /** @type {?} */
  const EMPTY_PAYLOAD = {};
  /**
   * @param {?} zone
   * @return {?}
   */
  function checkStable(zone) {
      if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
          try {
              zone._nesting++;
              zone.onMicrotaskEmpty.emit(null);
          }
          finally {
              zone._nesting--;
              if (!zone.hasPendingMicrotasks) {
                  try {
                      zone.runOutsideAngular(() => zone.onStable.emit(null));
                  }
                  finally {
                      zone.isStable = true;
                  }
              }
          }
      }
  }
  /**
   * @param {?} zone
   * @return {?}
   */
  function forkInnerZoneWithAngularBehavior(zone) {
      zone._inner = zone._inner.fork({
          name: 'angular',
          properties: (/** @type {?} */ ({ 'isAngularZone': true })),
          onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
              try {
                  onEnter(zone);
                  return delegate.invokeTask(target, task, applyThis, applyArgs);
              }
              finally {
                  onLeave(zone);
              }
          },
          onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
              try {
                  onEnter(zone);
                  return delegate.invoke(target, callback, applyThis, applyArgs, source);
              }
              finally {
                  onLeave(zone);
              }
          },
          onHasTask: (delegate, current, target, hasTaskState) => {
              delegate.hasTask(target, hasTaskState);
              if (current === target) {
                  // We are only interested in hasTask events which originate from our zone
                  // (A child hasTask event is not interesting to us)
                  if (hasTaskState.change == 'microTask') {
                      zone.hasPendingMicrotasks = hasTaskState.microTask;
                      checkStable(zone);
                  }
                  else if (hasTaskState.change == 'macroTask') {
                      zone.hasPendingMacrotasks = hasTaskState.macroTask;
                  }
              }
          },
          onHandleError: (delegate, current, target, error) => {
              delegate.handleError(target, error);
              zone.runOutsideAngular(() => zone.onError.emit(error));
              return false;
          }
      });
  }
  /**
   * @param {?} zone
   * @return {?}
   */
  function onEnter(zone) {
      zone._nesting++;
      if (zone.isStable) {
          zone.isStable = false;
          zone.onUnstable.emit(null);
      }
  }
  /**
   * @param {?} zone
   * @return {?}
   */
  function onLeave(zone) {
      zone._nesting--;
      checkStable(zone);
  }
  /**
   * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls
   * to framework to perform rendering.
   */
  class NoopNgZone {
      constructor() {
          this.hasPendingMicrotasks = false;
          this.hasPendingMacrotasks = false;
          this.isStable = true;
          this.onUnstable = new EventEmitter();
          this.onMicrotaskEmpty = new EventEmitter();
          this.onStable = new EventEmitter();
          this.onError = new EventEmitter();
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      run(fn) { return fn(); }
      /**
       * @param {?} fn
       * @return {?}
       */
      runGuarded(fn) { return fn(); }
      /**
       * @param {?} fn
       * @return {?}
       */
      runOutsideAngular(fn) { return fn(); }
      /**
       * @template T
       * @param {?} fn
       * @return {?}
       */
      runTask(fn) { return fn(); }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The Testability service provides testing hooks that can be accessed from
   * the browser and by services such as Protractor. Each bootstrapped Angular
   * application on the page will have an instance of Testability.
   * \@publicApi
   */
  class Testability {
      /**
       * @param {?} _ngZone
       */
      constructor(_ngZone) {
          this._ngZone = _ngZone;
          this._pendingCount = 0;
          this._isZoneStable = true;
          /**
           * Whether any work was done since the last 'whenStable' callback. This is
           * useful to detect if this could have potentially destabilized another
           * component while it is stabilizing.
           * \@internal
           */
          this._didWork = false;
          this._callbacks = [];
          this.taskTrackingZone = null;
          this._watchAngularEvents();
          _ngZone.run(() => {
              this.taskTrackingZone =
                  typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');
          });
      }
      /**
       * @private
       * @return {?}
       */
      _watchAngularEvents() {
          this._ngZone.onUnstable.subscribe({
              next: () => {
                  this._didWork = true;
                  this._isZoneStable = false;
              }
          });
          this._ngZone.runOutsideAngular(() => {
              this._ngZone.onStable.subscribe({
                  next: () => {
                      NgZone.assertNotInAngularZone();
                      scheduleMicroTask(() => {
                          this._isZoneStable = true;
                          this._runCallbacksIfReady();
                      });
                  }
              });
          });
      }
      /**
       * Increases the number of pending request
       * @deprecated pending requests are now tracked with zones.
       * @return {?}
       */
      increasePendingRequestCount() {
          this._pendingCount += 1;
          this._didWork = true;
          return this._pendingCount;
      }
      /**
       * Decreases the number of pending request
       * @deprecated pending requests are now tracked with zones
       * @return {?}
       */
      decreasePendingRequestCount() {
          this._pendingCount -= 1;
          if (this._pendingCount < 0) {
              throw new Error('pending async requests below zero');
          }
          this._runCallbacksIfReady();
          return this._pendingCount;
      }
      /**
       * Whether an associated application is stable
       * @return {?}
       */
      isStable() {
          return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
      }
      /**
       * @private
       * @return {?}
       */
      _runCallbacksIfReady() {
          if (this.isStable()) {
              // Schedules the call backs in a new frame so that it is always async.
              scheduleMicroTask(() => {
                  while (this._callbacks.length !== 0) {
                      /** @type {?} */
                      let cb = (/** @type {?} */ (this._callbacks.pop()));
                      clearTimeout(cb.timeoutId);
                      cb.doneCb(this._didWork);
                  }
                  this._didWork = false;
              });
          }
          else {
              // Still not stable, send updates.
              /** @type {?} */
              let pending = this.getPendingTasks();
              this._callbacks = this._callbacks.filter((cb) => {
                  if (cb.updateCb && cb.updateCb(pending)) {
                      clearTimeout(cb.timeoutId);
                      return false;
                  }
                  return true;
              });
              this._didWork = true;
          }
      }
      /**
       * @private
       * @return {?}
       */
      getPendingTasks() {
          if (!this.taskTrackingZone) {
              return [];
          }
          // Copy the tasks data so that we don't leak tasks.
          return this.taskTrackingZone.macroTasks.map((t) => {
              return {
                  source: t.source,
                  // From TaskTrackingZone:
                  // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
                  creationLocation: (/** @type {?} */ (((/** @type {?} */ (t))).creationLocation)),
                  data: t.data
              };
          });
      }
      /**
       * @private
       * @param {?} cb
       * @param {?=} timeout
       * @param {?=} updateCb
       * @return {?}
       */
      addCallback(cb, timeout$$1, updateCb) {
          /** @type {?} */
          let timeoutId = -1;
          if (timeout$$1 && timeout$$1 > 0) {
              timeoutId = setTimeout(() => {
                  this._callbacks = this._callbacks.filter((cb) => cb.timeoutId !== timeoutId);
                  cb(this._didWork, this.getPendingTasks());
              }, timeout$$1);
          }
          this._callbacks.push((/** @type {?} */ ({ doneCb: cb, timeoutId: timeoutId, updateCb: updateCb })));
      }
      /**
       * Wait for the application to be stable with a timeout. If the timeout is reached before that
       * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
       *
       * @param {?} doneCb The callback to invoke when Angular is stable or the timeout expires
       *    whichever comes first.
       * @param {?=} timeout Optional. The maximum time to wait for Angular to become stable. If not
       *    specified, whenStable() will wait forever.
       * @param {?=} updateCb Optional. If specified, this callback will be invoked whenever the set of
       *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
       *    and no further updates will be issued.
       * @return {?}
       */
      whenStable(doneCb, timeout$$1, updateCb) {
          if (updateCb && !this.taskTrackingZone) {
              throw new Error('Task tracking zone is required when passing an update callback to ' +
                  'whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
          }
          // These arguments are 'Function' above to keep the public API simple.
          this.addCallback((/** @type {?} */ (doneCb)), timeout$$1, (/** @type {?} */ (updateCb)));
          this._runCallbacksIfReady();
      }
      /**
       * Get the number of pending requests
       * @deprecated pending requests are now tracked with zones
       * @return {?}
       */
      getPendingRequestCount() { return this._pendingCount; }
      /**
       * Find providers by name
       * @param {?} using The root element to search from
       * @param {?} provider The name of binding variable
       * @param {?} exactMatch Whether using exactMatch
       * @return {?}
       */
      findProviders(using$$1, provider, exactMatch) {
          // TODO(juliemr): implement.
          return [];
      }
  }
  Testability.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  Testability.ctorParameters = () => [
      { type: NgZone }
  ];
  /**
   * A global registry of {\@link Testability} instances for specific elements.
   * \@publicApi
   */
  class TestabilityRegistry {
      constructor() {
          /**
           * \@internal
           */
          this._applications = new Map();
          _testabilityGetter.addToWindow(this);
      }
      /**
       * Registers an application with a testability hook so that it can be tracked
       * @param {?} token token of application, root element
       * @param {?} testability Testability hook
       * @return {?}
       */
      registerApplication(token, testability) {
          this._applications.set(token, testability);
      }
      /**
       * Unregisters an application.
       * @param {?} token token of application, root element
       * @return {?}
       */
      unregisterApplication(token) { this._applications.delete(token); }
      /**
       * Unregisters all applications
       * @return {?}
       */
      unregisterAllApplications() { this._applications.clear(); }
      /**
       * Get a testability hook associated with the application
       * @param {?} elem root element
       * @return {?}
       */
      getTestability(elem) { return this._applications.get(elem) || null; }
      /**
       * Get all registered testabilities
       * @return {?}
       */
      getAllTestabilities() { return Array.from(this._applications.values()); }
      /**
       * Get all registered applications(root elements)
       * @return {?}
       */
      getAllRootElements() { return Array.from(this._applications.keys()); }
      /**
       * Find testability of a node in the Tree
       * @param {?} elem node
       * @param {?=} findInAncestors whether finding testability in ancestors if testability was not found in
       * current node
       * @return {?}
       */
      findTestabilityInTree(elem, findInAncestors = true) {
          return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
      }
  }
  TestabilityRegistry.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  TestabilityRegistry.ctorParameters = () => [];
  class _NoopGetTestability {
      /**
       * @param {?} registry
       * @return {?}
       */
      addToWindow(registry) { }
      /**
       * @param {?} registry
       * @param {?} elem
       * @param {?} findInAncestors
       * @return {?}
       */
      findTestabilityInTree(registry, elem, findInAncestors) {
          return null;
      }
  }
  /**
   * Set the {\@link GetTestability} implementation used by the Angular testing framework.
   * \@publicApi
   * @param {?} getter
   * @return {?}
   */
  function setTestabilityGetter(getter) {
      _testabilityGetter = getter;
  }
  /** @type {?} */
  let _testabilityGetter = new _NoopGetTestability();

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  let _platform;
  /** @type {?} */
  let compileNgModuleFactory = compileNgModuleFactory__PRE_R3__;
  /**
   * @template M
   * @param {?} injector
   * @param {?} options
   * @param {?} moduleType
   * @return {?}
   */
  function compileNgModuleFactory__PRE_R3__(injector, options, moduleType) {
      /** @type {?} */
      const compilerFactory = injector.get(CompilerFactory);
      /** @type {?} */
      const compiler = compilerFactory.createCompiler([options]);
      return compiler.compileModuleAsync(moduleType);
  }
  /** @type {?} */
  const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
  /**
   * A token for third-party components that can register themselves with NgProbe.
   *
   * \@publicApi
   */
  class NgProbeToken {
      /**
       * @param {?} name
       * @param {?} token
       */
      constructor(name, token) {
          this.name = name;
          this.token = token;
      }
  }
  /**
   * Creates a platform.
   * Platforms have to be eagerly created via this function.
   *
   * \@publicApi
   * @param {?} injector
   * @return {?}
   */
  function createPlatform(injector) {
      if (_platform && !_platform.destroyed &&
          !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
          throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
      }
      _platform = injector.get(PlatformRef);
      /** @type {?} */
      const inits = injector.get(PLATFORM_INITIALIZER, null);
      if (inits)
          inits.forEach((init) => init());
      return _platform;
  }
  /**
   * Creates a factory for a platform
   *
   * \@publicApi
   * @param {?} parentPlatformFactory
   * @param {?} name
   * @param {?=} providers
   * @return {?}
   */
  function createPlatformFactory(parentPlatformFactory, name, providers = []) {
      /** @type {?} */
      const desc = `Platform: ${name}`;
      /** @type {?} */
      const marker = new InjectionToken(desc);
      return (extraProviders = []) => {
          /** @type {?} */
          let platform = getPlatform();
          if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
              if (parentPlatformFactory) {
                  parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
              }
              else {
                  /** @type {?} */
                  const injectedProviders = providers.concat(extraProviders).concat({ provide: marker, useValue: true });
                  createPlatform(Injector.create({ providers: injectedProviders, name: desc }));
              }
          }
          return assertPlatform(marker);
      };
  }
  /**
   * Checks that there currently is a platform which contains the given token as a provider.
   *
   * \@publicApi
   * @param {?} requiredToken
   * @return {?}
   */
  function assertPlatform(requiredToken) {
      /** @type {?} */
      const platform = getPlatform();
      if (!platform) {
          throw new Error('No platform exists!');
      }
      if (!platform.injector.get(requiredToken, null)) {
          throw new Error('A platform with a different configuration has been created. Please destroy it first.');
      }
      return platform;
  }
  /**
   * Returns the current platform.
   *
   * \@publicApi
   * @return {?}
   */
  function getPlatform() {
      return _platform && !_platform.destroyed ? _platform : null;
  }
  /**
   * The Angular platform is the entry point for Angular on a web page. Each page
   * has exactly one platform, and services (such as reflection) which are common
   * to every Angular application running on the page are bound in its scope.
   *
   * A page's platform is initialized implicitly when a platform is created via a platform factory
   * (e.g. {\@link platformBrowser}), or explicitly by calling the {\@link createPlatform} function.
   *
   * \@publicApi
   */
  class PlatformRef {
      /**
       * \@internal
       * @param {?} _injector
       */
      constructor(_injector) {
          this._injector = _injector;
          this._modules = [];
          this._destroyListeners = [];
          this._destroyed = false;
      }
      /**
       * Creates an instance of an `\@NgModule` for the given platform
       * for offline compilation.
       *
       * \@usageNotes
       * ### Simple Example
       *
       * ```typescript
       * my_module.ts:
       *
       * \@NgModule({
       *   imports: [BrowserModule]
       * })
       * class MyModule {}
       *
       * main.ts:
       * import {MyModuleNgFactory} from './my_module.ngfactory';
       * import {platformBrowser} from '\@angular/platform-browser';
       *
       * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
       * ```
       * @template M
       * @param {?} moduleFactory
       * @param {?=} options
       * @return {?}
       */
      bootstrapModuleFactory(moduleFactory, options) {
          // Note: We need to create the NgZone _before_ we instantiate the module,
          // as instantiating the module creates some providers eagerly.
          // So we create a mini parent injector that just contains the new NgZone and
          // pass that as parent to the NgModuleFactory.
          /** @type {?} */
          const ngZoneOption = options ? options.ngZone : undefined;
          /** @type {?} */
          const ngZone = getNgZone(ngZoneOption);
          /** @type {?} */
          const providers = [{ provide: NgZone, useValue: ngZone }];
          // Attention: Don't use ApplicationRef.run here,
          // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
          return ngZone.run(() => {
              /** @type {?} */
              const ngZoneInjector = Injector.create({ providers: providers, parent: this.injector, name: moduleFactory.moduleType.name });
              /** @type {?} */
              const moduleRef = (/** @type {?} */ (moduleFactory.create(ngZoneInjector)));
              /** @type {?} */
              const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
              if (!exceptionHandler) {
                  throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
              }
              moduleRef.onDestroy(() => remove(this._modules, moduleRef));
              (/** @type {?} */ (ngZone)).runOutsideAngular(() => (/** @type {?} */ (ngZone)).onError.subscribe({ next: (error) => { exceptionHandler.handleError(error); } }));
              return _callAndReportToErrorHandler(exceptionHandler, (/** @type {?} */ (ngZone)), () => {
                  /** @type {?} */
                  const initStatus = moduleRef.injector.get(ApplicationInitStatus);
                  initStatus.runInitializers();
                  return initStatus.donePromise.then(() => {
                      this._moduleDoBootstrap(moduleRef);
                      return moduleRef;
                  });
              });
          });
      }
      /**
       * Creates an instance of an `\@NgModule` for a given platform using the given runtime compiler.
       *
       * \@usageNotes
       * ### Simple Example
       *
       * ```typescript
       * \@NgModule({
       *   imports: [BrowserModule]
       * })
       * class MyModule {}
       *
       * let moduleRef = platformBrowser().bootstrapModule(MyModule);
       * ```
       *
       * @template M
       * @param {?} moduleType
       * @param {?=} compilerOptions
       * @return {?}
       */
      bootstrapModule(moduleType, compilerOptions = []) {
          /** @type {?} */
          const options = optionsReducer({}, compilerOptions);
          return compileNgModuleFactory(this.injector, options, moduleType)
              .then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
      }
      /**
       * @private
       * @param {?} moduleRef
       * @return {?}
       */
      _moduleDoBootstrap(moduleRef) {
          /** @type {?} */
          const appRef = (/** @type {?} */ (moduleRef.injector.get(ApplicationRef)));
          if (moduleRef._bootstrapComponents.length > 0) {
              moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));
          }
          else if (moduleRef.instance.ngDoBootstrap) {
              moduleRef.instance.ngDoBootstrap(appRef);
          }
          else {
              throw new Error(`The module ${stringify$1(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. ` +
                  `Please define one of these.`);
          }
          this._modules.push(moduleRef);
      }
      /**
       * Register a listener to be called when the platform is disposed.
       * @param {?} callback
       * @return {?}
       */
      onDestroy(callback) { this._destroyListeners.push(callback); }
      /**
       * Retrieve the platform {\@link Injector}, which is the parent injector for
       * every Angular application on the page and provides singleton providers.
       * @return {?}
       */
      get injector() { return this._injector; }
      /**
       * Destroy the Angular platform and all Angular applications on the page.
       * @return {?}
       */
      destroy() {
          if (this._destroyed) {
              throw new Error('The platform has already been destroyed!');
          }
          this._modules.slice().forEach(module => module.destroy());
          this._destroyListeners.forEach(listener => listener());
          this._destroyed = true;
      }
      /**
       * @return {?}
       */
      get destroyed() { return this._destroyed; }
  }
  PlatformRef.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  PlatformRef.ctorParameters = () => [
      { type: Injector }
  ];
  /**
   * @param {?=} ngZoneOption
   * @return {?}
   */
  function getNgZone(ngZoneOption) {
      /** @type {?} */
      let ngZone;
      if (ngZoneOption === 'noop') {
          ngZone = new NoopNgZone();
      }
      else {
          ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) ||
              new NgZone({ enableLongStackTrace: isDevMode() });
      }
      return ngZone;
  }
  /**
   * @param {?} errorHandler
   * @param {?} ngZone
   * @param {?} callback
   * @return {?}
   */
  function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
      try {
          /** @type {?} */
          const result = callback();
          if (isPromise$2(result)) {
              return result.catch((e) => {
                  ngZone.runOutsideAngular(() => errorHandler.handleError(e));
                  // rethrow as the exception handler might not do it
                  throw e;
              });
          }
          return result;
      }
      catch (e) {
          ngZone.runOutsideAngular(() => errorHandler.handleError(e));
          // rethrow as the exception handler might not do it
          throw e;
      }
  }
  /**
   * @template T
   * @param {?} dst
   * @param {?} objs
   * @return {?}
   */
  function optionsReducer(dst, objs) {
      if (Array.isArray(objs)) {
          dst = objs.reduce(optionsReducer, dst);
      }
      else {
          dst = Object.assign({}, dst, ((/** @type {?} */ (objs))));
      }
      return dst;
  }
  /**
   * A reference to an Angular application running on a page.
   *
   * \@usageNotes
   *
   * {\@a is-stable-examples}
   * ### isStable examples and caveats
   *
   * Note two important points about `isStable`, demonstrated in the examples below:
   * - the application will never be stable if you start any kind
   * of recurrent asynchronous task when the application starts
   * (for example for a polling process, started with a `setInterval`, a `setTimeout`
   * or using RxJS operators like `interval`);
   * - the `isStable` Observable runs outside of the Angular zone.
   *
   * Let's imagine that you start a recurrent task
   * (here incrementing a counter, using RxJS `interval`),
   * and at the same time subscribe to `isStable`.
   *
   * ```
   * constructor(appRef: ApplicationRef) {
   *   appRef.isStable.pipe(
   *      filter(stable => stable)
   *   ).subscribe(() => console.log('App is stable now');
   *   interval(1000).subscribe(counter => console.log(counter));
   * }
   * ```
   * In this example, `isStable` will never emit `true`,
   * and the trace "App is stable now" will never get logged.
   *
   * If you want to execute something when the app is stable,
   * you have to wait for the application to be stable
   * before starting your polling process.
   *
   * ```
   * constructor(appRef: ApplicationRef) {
   *   appRef.isStable.pipe(
   *     first(stable => stable),
   *     tap(stable => console.log('App is stable now')),
   *     switchMap(() => interval(1000))
   *   ).subscribe(counter => console.log(counter));
   * }
   * ```
   * In this example, the trace "App is stable now" will be logged
   * and then the counter starts incrementing every second.
   *
   * Note also that this Observable runs outside of the Angular zone,
   * which means that the code in the subscription
   * to this Observable will not trigger the change detection.
   *
   * Let's imagine that instead of logging the counter value,
   * you update a field of your component
   * and display it in its template.
   *
   * ```
   * constructor(appRef: ApplicationRef) {
   *   appRef.isStable.pipe(
   *     first(stable => stable),
   *     switchMap(() => interval(1000))
   *   ).subscribe(counter => this.value = counter);
   * }
   * ```
   * As the `isStable` Observable runs outside the zone,
   * the `value` field will be updated properly,
   * but the template will not be refreshed!
   *
   * You'll have to manually trigger the change detection to update the template.
   *
   * ```
   * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {
   *   appRef.isStable.pipe(
   *     first(stable => stable),
   *     switchMap(() => interval(1000))
   *   ).subscribe(counter => {
   *     this.value = counter;
   *     cd.detectChanges();
   *   });
   * }
   * ```
   *
   * Or make the subscription callback run inside the zone.
   *
   * ```
   * constructor(appRef: ApplicationRef, zone: NgZone) {
   *   appRef.isStable.pipe(
   *     first(stable => stable),
   *     switchMap(() => interval(1000))
   *   ).subscribe(counter => zone.run(() => this.value = counter));
   * }
   * ```
   *
   * \@publicApi
   */
  class ApplicationRef {
      /**
       * \@internal
       * @param {?} _zone
       * @param {?} _console
       * @param {?} _injector
       * @param {?} _exceptionHandler
       * @param {?} _componentFactoryResolver
       * @param {?} _initStatus
       */
      constructor(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
          this._zone = _zone;
          this._console = _console;
          this._injector = _injector;
          this._exceptionHandler = _exceptionHandler;
          this._componentFactoryResolver = _componentFactoryResolver;
          this._initStatus = _initStatus;
          this._bootstrapListeners = [];
          this._views = [];
          this._runningTick = false;
          this._enforceNoNewChanges = false;
          this._stable = true;
          /**
           * Get a list of component types registered to this application.
           * This list is populated even before the component is created.
           */
          this.componentTypes = [];
          /**
           * Get a list of components registered to this application.
           */
          this.components = [];
          this._enforceNoNewChanges = isDevMode();
          this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick(); }); } });
          /** @type {?} */
          const isCurrentlyStable = new Observable((observer) => {
              this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks &&
                  !this._zone.hasPendingMicrotasks;
              this._zone.runOutsideAngular(() => {
                  observer.next(this._stable);
                  observer.complete();
              });
          });
          /** @type {?} */
          const isStable = new Observable((observer) => {
              // Create the subscription to onStable outside the Angular Zone so that
              // the callback is run outside the Angular Zone.
              /** @type {?} */
              let stableSub;
              this._zone.runOutsideAngular(() => {
                  stableSub = this._zone.onStable.subscribe(() => {
                      NgZone.assertNotInAngularZone();
                      // Check whether there are no pending macro/micro tasks in the next tick
                      // to allow for NgZone to update the state.
                      scheduleMicroTask(() => {
                          if (!this._stable && !this._zone.hasPendingMacrotasks &&
                              !this._zone.hasPendingMicrotasks) {
                              this._stable = true;
                              observer.next(true);
                          }
                      });
                  });
              });
              /** @type {?} */
              const unstableSub = this._zone.onUnstable.subscribe(() => {
                  NgZone.assertInAngularZone();
                  if (this._stable) {
                      this._stable = false;
                      this._zone.runOutsideAngular(() => { observer.next(false); });
                  }
              });
              return () => {
                  stableSub.unsubscribe();
                  unstableSub.unsubscribe();
              };
          });
          ((/** @type {?} */ (this))).isStable =
              merge(isCurrentlyStable, isStable.pipe(share()));
      }
      /**
       * Bootstrap a new component at the root level of the application.
       *
       * \@usageNotes
       * ### Bootstrap process
       *
       * When bootstrapping a new root component into an application, Angular mounts the
       * specified application component onto DOM elements identified by the componentType's
       * selector and kicks off automatic change detection to finish initializing the component.
       *
       * Optionally, a component can be mounted onto a DOM element that does not match the
       * componentType's selector.
       *
       * ### Example
       * {\@example core/ts/platform/platform.ts region='longform'}
       * @template C
       * @param {?} componentOrFactory
       * @param {?=} rootSelectorOrNode
       * @return {?}
       */
      bootstrap(componentOrFactory, rootSelectorOrNode) {
          if (!this._initStatus.done) {
              throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
          }
          /** @type {?} */
          let componentFactory;
          if (componentOrFactory instanceof ComponentFactory) {
              componentFactory = componentOrFactory;
          }
          else {
              componentFactory =
                  (/** @type {?} */ (this._componentFactoryResolver.resolveComponentFactory(componentOrFactory)));
          }
          this.componentTypes.push(componentFactory.componentType);
          // Create a factory associated with the current module if it's not bound to some other
          /** @type {?} */
          const ngModule = componentFactory instanceof ComponentFactoryBoundToModule ?
              null :
              this._injector.get(NgModuleRef);
          /** @type {?} */
          const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
          /** @type {?} */
          const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
          compRef.onDestroy(() => { this._unloadComponent(compRef); });
          /** @type {?} */
          const testability = compRef.injector.get(Testability, null);
          if (testability) {
              compRef.injector.get(TestabilityRegistry)
                  .registerApplication(compRef.location.nativeElement, testability);
          }
          this._loadComponent(compRef);
          if (isDevMode()) {
              this._console.log(`Angular is running in the development mode. Call enableProdMode() to enable the production mode.`);
          }
          return compRef;
      }
      /**
       * Invoke this method to explicitly process change detection and its side-effects.
       *
       * In development mode, `tick()` also performs a second change detection cycle to ensure that no
       * further changes are detected. If additional changes are picked up during this second cycle,
       * bindings in the app have side-effects that cannot be resolved in a single change detection
       * pass.
       * In this case, Angular throws an error, since an Angular application can only have one change
       * detection pass during which all change detection must complete.
       * @return {?}
       */
      tick() {
          if (this._runningTick) {
              throw new Error('ApplicationRef.tick is called recursively');
          }
          /** @type {?} */
          const scope = ApplicationRef._tickScope();
          try {
              this._runningTick = true;
              this._views.forEach((view) => view.detectChanges());
              if (this._enforceNoNewChanges) {
                  this._views.forEach((view) => view.checkNoChanges());
              }
          }
          catch (e) {
              // Attention: Don't rethrow as it could cancel subscriptions to Observables!
              this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));
          }
          finally {
              this._runningTick = false;
              wtfLeave(scope);
          }
      }
      /**
       * Attaches a view so that it will be dirty checked.
       * The view will be automatically detached when it is destroyed.
       * This will throw if the view is already attached to a ViewContainer.
       * @param {?} viewRef
       * @return {?}
       */
      attachView(viewRef) {
          /** @type {?} */
          const view = ((/** @type {?} */ (viewRef)));
          this._views.push(view);
          view.attachToAppRef(this);
      }
      /**
       * Detaches a view from dirty checking again.
       * @param {?} viewRef
       * @return {?}
       */
      detachView(viewRef) {
          /** @type {?} */
          const view = ((/** @type {?} */ (viewRef)));
          remove(this._views, view);
          view.detachFromAppRef();
      }
      /**
       * @private
       * @param {?} componentRef
       * @return {?}
       */
      _loadComponent(componentRef) {
          this.attachView(componentRef.hostView);
          this.tick();
          this.components.push(componentRef);
          // Get the listeners lazily to prevent DI cycles.
          /** @type {?} */
          const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);
          listeners.forEach((listener) => listener(componentRef));
      }
      /**
       * @private
       * @param {?} componentRef
       * @return {?}
       */
      _unloadComponent(componentRef) {
          this.detachView(componentRef.hostView);
          remove(this.components, componentRef);
      }
      /**
       * \@internal
       * @return {?}
       */
      ngOnDestroy() {
          // TODO(alxhub): Dispose of the NgZone.
          this._views.slice().forEach((view) => view.destroy());
      }
      /**
       * Returns the number of attached views.
       * @return {?}
       */
      get viewCount() { return this._views.length; }
  }
  /**
   * \@internal
   */
  ApplicationRef._tickScope = wtfCreateScope('ApplicationRef#tick()');
  ApplicationRef.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  ApplicationRef.ctorParameters = () => [
      { type: NgZone },
      { type: Console },
      { type: Injector },
      { type: ErrorHandler },
      { type: ComponentFactoryResolver },
      { type: ApplicationInitStatus }
  ];
  /**
   * @template T
   * @param {?} list
   * @param {?} el
   * @return {?}
   */
  function remove(list, el) {
      /** @type {?} */
      const index = list.indexOf(el);
      if (index > -1) {
          list.splice(index, 1);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * An unmodifiable list of items that Angular keeps up to date when the state
   * of the application changes.
   *
   * The type of object that {\@link ViewChildren}, {\@link ContentChildren}, and {\@link QueryList}
   * provide.
   *
   * Implements an iterable interface, therefore it can be used in both ES6
   * javascript `for (var i of items)` loops as well as in Angular templates with
   * `*ngFor="let i of myList"`.
   *
   * Changes can be observed by subscribing to the changes `Observable`.
   *
   * NOTE: In the future this class will implement an `Observable` interface.
   *
   * \@usageNotes
   * ### Example
   * ```typescript
   * \@Component({...})
   * class Container {
   * \@ViewChildren(Item) items:QueryList<Item>;
   * }
   * ```
   *
   * \@publicApi
   * @template T
   */
  class QueryList$1 {
      constructor() {
          this.dirty = true;
          this._results = [];
          this.changes = new EventEmitter();
          this.length = 0;
      }
      /**
       * See
       * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
       * @template U
       * @param {?} fn
       * @return {?}
       */
      map(fn) { return this._results.map(fn); }
      /**
       * See
       * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
       * @param {?} fn
       * @return {?}
       */
      filter(fn) {
          return this._results.filter(fn);
      }
      /**
       * See
       * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
       * @param {?} fn
       * @return {?}
       */
      find(fn) {
          return this._results.find(fn);
      }
      /**
       * See
       * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
       * @template U
       * @param {?} fn
       * @param {?} init
       * @return {?}
       */
      reduce(fn, init) {
          return this._results.reduce(fn, init);
      }
      /**
       * See
       * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
       * @param {?} fn
       * @return {?}
       */
      forEach(fn) { this._results.forEach(fn); }
      /**
       * See
       * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
       * @param {?} fn
       * @return {?}
       */
      some(fn) {
          return this._results.some(fn);
      }
      /**
       * @return {?}
       */
      toArray() { return this._results.slice(); }
      /**
       * @return {?}
       */
      [getSymbolIterator$1()]() { return ((/** @type {?} */ (this._results)))[getSymbolIterator$1()](); }
      /**
       * @return {?}
       */
      toString() { return this._results.toString(); }
      /**
       * @param {?} res
       * @return {?}
       */
      reset(res) {
          this._results = flatten$2(res);
          ((/** @type {?} */ (this))).dirty = false;
          ((/** @type {?} */ (this))).length = this._results.length;
          ((/** @type {?} */ (this))).last = this._results[this.length - 1];
          ((/** @type {?} */ (this))).first = this._results[0];
      }
      /**
       * @return {?}
       */
      notifyOnChanges() { ((/** @type {?} */ (this.changes))).emit(this); }
      /**
       * internal
       * @return {?}
       */
      setDirty() { ((/** @type {?} */ (this))).dirty = true; }
      /**
       * internal
       * @return {?}
       */
      destroy() {
          ((/** @type {?} */ (this.changes))).complete();
          ((/** @type {?} */ (this.changes))).unsubscribe();
      }
  }
  /**
   * @template T
   * @param {?} list
   * @return {?}
   */
  function flatten$2(list) {
      return list.reduce((flat, item) => {
          /** @type {?} */
          const flatItem = Array.isArray(item) ? flatten$2(item) : item;
          return ((/** @type {?} */ (flat))).concat(flatItem);
      }, []);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Represents a container where one or more views can be attached to a component.
   *
   * Can contain *host views* (created by instantiating a
   * component with the `createComponent()` method), and *embedded views*
   * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).
   *
   * A view container instance can contain other view containers,
   * creating a [view hierarchy](guide/glossary#view-tree).
   *
   * @see `ComponentRef`
   * @see `EmbeddedViewRef`
   *
   * \@publicApi
   * @abstract
   */
  class ViewContainerRef {
  }
  /**
   * \@internal
   */
  ViewContainerRef.__NG_ELEMENT_ID__ = () => SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef);
  /** @type {?} */
  const SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__ = noop$1;
  /** @type {?} */
  const SWITCH_VIEW_CONTAINER_REF_FACTORY = SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Base class for Angular Views, provides change detection functionality.
   * A change-detection tree collects all views that are to be checked for changes.
   * Use the methods to add and remove views from the tree, initiate change-detection,
   * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.
   *
   * \@usageNotes
   *
   * The following examples demonstrate how to modify default change-detection behavior
   * to perform explicit detection when needed.
   *
   * ### Use `markForCheck()` with `CheckOnce` strategy
   *
   * The following example sets the `OnPush` change-detection strategy for a component
   * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check
   * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).
   *
   * <code-example path="core/ts/change_detect/change-detection.ts"
   * region="mark-for-check"></code-example>
   *
   * ### Detach change detector to limit how often check occurs
   *
   * The following example defines a component with a large list of read-only data
   * that is expected to change constantly, many times per second.
   * To improve performance, we want to check and update the list
   * less often than the changes actually occur. To do that, we detach
   * the component's change detector and perform an explicit local check every five seconds.
   *
   * <code-example path="core/ts/change_detect/change-detection.ts" region="detach"></code-example>
   *
   *
   * ### Reattaching a detached component
   *
   * The following example creates a component displaying live data.
   * The component detaches its change detector from the main change detector tree
   * when the `live` property is set to false, and reattaches it when the property
   * becomes true.
   *
   * <code-example path="core/ts/change_detect/change-detection.ts" region="reattach"></code-example>
   *
   * \@publicApi
   * @abstract
   */
  class ChangeDetectorRef {
  }
  /**
   * \@internal
   */
  ChangeDetectorRef.__NG_ELEMENT_ID__ = () => SWITCH_CHANGE_DETECTOR_REF_FACTORY();
  /** @type {?} */
  const SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__ = (...args) => { };
  /** @type {?} */
  const SWITCH_CHANGE_DETECTOR_REF_FACTORY = SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class EventListener {
      /**
       * @param {?} name
       * @param {?} callback
       */
      constructor(name, callback) {
          this.name = name;
          this.callback = callback;
      }
  }
  // WARNING: interface has both a type and a value, skipping emit
  class DebugNode__PRE_R3__ {
      /**
       * @param {?} nativeNode
       * @param {?} parent
       * @param {?} _debugContext
       */
      constructor(nativeNode, parent, _debugContext) {
          this.listeners = [];
          this.parent = null;
          this._debugContext = _debugContext;
          this.nativeNode = nativeNode;
          if (parent && parent instanceof DebugElement__PRE_R3__) {
              parent.addChild(this);
          }
      }
      /**
       * @return {?}
       */
      get injector() { return this._debugContext.injector; }
      /**
       * @return {?}
       */
      get componentInstance() { return this._debugContext.component; }
      /**
       * @return {?}
       */
      get context() { return this._debugContext.context; }
      /**
       * @return {?}
       */
      get references() { return this._debugContext.references; }
      /**
       * @return {?}
       */
      get providerTokens() { return this._debugContext.providerTokens; }
  }
  // WARNING: interface has both a type and a value, skipping emit
  class DebugElement__PRE_R3__ extends DebugNode__PRE_R3__ {
      /**
       * @param {?} nativeNode
       * @param {?} parent
       * @param {?} _debugContext
       */
      constructor(nativeNode, parent, _debugContext) {
          super(nativeNode, parent, _debugContext);
          this.properties = {};
          this.attributes = {};
          this.classes = {};
          this.styles = {};
          this.childNodes = [];
          this.nativeElement = nativeNode;
      }
      /**
       * @param {?} child
       * @return {?}
       */
      addChild(child) {
          if (child) {
              this.childNodes.push(child);
              ((/** @type {?} */ (child))).parent = this;
          }
      }
      /**
       * @param {?} child
       * @return {?}
       */
      removeChild(child) {
          /** @type {?} */
          const childIndex = this.childNodes.indexOf(child);
          if (childIndex !== -1) {
              ((/** @type {?} */ (child))).parent = null;
              this.childNodes.splice(childIndex, 1);
          }
      }
      /**
       * @param {?} child
       * @param {?} newChildren
       * @return {?}
       */
      insertChildrenAfter(child, newChildren) {
          /** @type {?} */
          const siblingIndex = this.childNodes.indexOf(child);
          if (siblingIndex !== -1) {
              this.childNodes.splice(siblingIndex + 1, 0, ...newChildren);
              newChildren.forEach(c => {
                  if (c.parent) {
                      ((/** @type {?} */ (c.parent))).removeChild(c);
                  }
                  ((/** @type {?} */ (child))).parent = this;
              });
          }
      }
      /**
       * @param {?} refChild
       * @param {?} newChild
       * @return {?}
       */
      insertBefore(refChild, newChild) {
          /** @type {?} */
          const refIndex = this.childNodes.indexOf(refChild);
          if (refIndex === -1) {
              this.addChild(newChild);
          }
          else {
              if (newChild.parent) {
                  ((/** @type {?} */ (newChild.parent))).removeChild(newChild);
              }
              ((/** @type {?} */ (newChild))).parent = this;
              this.childNodes.splice(refIndex, 0, newChild);
          }
      }
      /**
       * @param {?} predicate
       * @return {?}
       */
      query(predicate) {
          /** @type {?} */
          const results = this.queryAll(predicate);
          return results[0] || null;
      }
      /**
       * @param {?} predicate
       * @return {?}
       */
      queryAll(predicate) {
          /** @type {?} */
          const matches = [];
          _queryElementChildren(this, predicate, matches);
          return matches;
      }
      /**
       * @param {?} predicate
       * @return {?}
       */
      queryAllNodes(predicate) {
          /** @type {?} */
          const matches = [];
          _queryNodeChildren(this, predicate, matches);
          return matches;
      }
      /**
       * @return {?}
       */
      get children() {
          return (/** @type {?} */ (this
              .childNodes //
              .filter((node) => node instanceof DebugElement__PRE_R3__)));
      }
      /**
       * @param {?} eventName
       * @param {?} eventObj
       * @return {?}
       */
      triggerEventHandler(eventName, eventObj) {
          this.listeners.forEach((listener) => {
              if (listener.name == eventName) {
                  listener.callback(eventObj);
              }
          });
      }
  }
  /**
   * @param {?} element
   * @param {?} predicate
   * @param {?} matches
   * @return {?}
   */
  function _queryElementChildren(element, predicate, matches) {
      element.childNodes.forEach(node => {
          if (node instanceof DebugElement__PRE_R3__) {
              if (predicate(node)) {
                  matches.push(node);
              }
              _queryElementChildren(node, predicate, matches);
          }
      });
  }
  /**
   * @param {?} parentNode
   * @param {?} predicate
   * @param {?} matches
   * @return {?}
   */
  function _queryNodeChildren(parentNode, predicate, matches) {
      if (parentNode instanceof DebugElement__PRE_R3__) {
          parentNode.childNodes.forEach(node => {
              if (predicate(node)) {
                  matches.push(node);
              }
              if (node instanceof DebugElement__PRE_R3__) {
                  _queryNodeChildren(node, predicate, matches);
              }
          });
      }
  }
  // Need to keep the nodes in a global Map so that multiple angular apps are supported.
  /** @type {?} */
  const _nativeNodeToDebugNode = new Map();
  /**
   * @param {?} nativeNode
   * @return {?}
   */
  function getDebugNode__PRE_R3__(nativeNode) {
      return _nativeNodeToDebugNode.get(nativeNode) || null;
  }
  /**
   * \@publicApi
   * @type {?}
   */
  const getDebugNode = getDebugNode__PRE_R3__;
  /**
   * @param {?} node
   * @return {?}
   */
  function indexDebugNode(node) {
      _nativeNodeToDebugNode.set(node.nativeNode, node);
  }
  /**
   * @param {?} node
   * @return {?}
   */
  function removeDebugNodeFromIndex(node) {
      _nativeNodeToDebugNode.delete(node.nativeNode);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class DefaultIterableDifferFactory {
      constructor() { }
      /**
       * @param {?} obj
       * @return {?}
       */
      supports(obj) { return isListLikeIterable(obj); }
      /**
       * @template V
       * @param {?=} trackByFn
       * @return {?}
       */
      create(trackByFn) {
          return new DefaultIterableDiffer(trackByFn);
      }
  }
  /** @type {?} */
  const trackByIdentity = (index, item) => item;
  /**
   * @deprecated v4.0.0 - Should not be part of public API.
   * \@publicApi
   * @template V
   */
  class DefaultIterableDiffer {
      /**
       * @param {?=} trackByFn
       */
      constructor(trackByFn) {
          this.length = 0;
          // Keeps track of the used records at any point in time (during & across `_check()` calls)
          this._linkedRecords = null;
          // Keeps track of the removed records at any point in time during `_check()` calls.
          this._unlinkedRecords = null;
          this._previousItHead = null;
          this._itHead = null;
          this._itTail = null;
          this._additionsHead = null;
          this._additionsTail = null;
          this._movesHead = null;
          this._movesTail = null;
          this._removalsHead = null;
          this._removalsTail = null;
          // Keeps track of records where custom track by is the same, but item identity has changed
          this._identityChangesHead = null;
          this._identityChangesTail = null;
          this._trackByFn = trackByFn || trackByIdentity;
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._itHead; record !== null; record = record._next) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachOperation(fn) {
          /** @type {?} */
          let nextIt = this._itHead;
          /** @type {?} */
          let nextRemove = this._removalsHead;
          /** @type {?} */
          let addRemoveOffset = 0;
          /** @type {?} */
          let moveOffsets = null;
          while (nextIt || nextRemove) {
              // Figure out which is the next record to process
              // Order: remove, add, move
              /** @type {?} */
              const record = !nextRemove ||
                  nextIt &&
                      (/** @type {?} */ (nextIt.currentIndex)) <
                          getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
                  (/** @type {?} */ (nextIt)) :
                  nextRemove;
              /** @type {?} */
              const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
              /** @type {?} */
              const currentIndex = record.currentIndex;
              // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
              if (record === nextRemove) {
                  addRemoveOffset--;
                  nextRemove = nextRemove._nextRemoved;
              }
              else {
                  nextIt = (/** @type {?} */ (nextIt))._next;
                  if (record.previousIndex == null) {
                      addRemoveOffset++;
                  }
                  else {
                      // INVARIANT:  currentIndex < previousIndex
                      if (!moveOffsets)
                          moveOffsets = [];
                      /** @type {?} */
                      const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
                      /** @type {?} */
                      const localCurrentIndex = (/** @type {?} */ (currentIndex)) - addRemoveOffset;
                      if (localMovePreviousIndex != localCurrentIndex) {
                          for (let i = 0; i < localMovePreviousIndex; i++) {
                              /** @type {?} */
                              const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
                              /** @type {?} */
                              const index = offset + i;
                              if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                                  moveOffsets[i] = offset + 1;
                              }
                          }
                          /** @type {?} */
                          const previousIndex = record.previousIndex;
                          moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
                      }
                  }
              }
              if (adjPreviousIndex !== currentIndex) {
                  fn(record, adjPreviousIndex, currentIndex);
              }
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachPreviousItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachAddedItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachMovedItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._movesHead; record !== null; record = record._nextMoved) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachRemovedItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachIdentityChange(fn) {
          /** @type {?} */
          let record;
          for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
              fn(record);
          }
      }
      /**
       * @param {?} collection
       * @return {?}
       */
      diff(collection) {
          if (collection == null)
              collection = [];
          if (!isListLikeIterable(collection)) {
              throw new Error(`Error trying to diff '${stringify$1(collection)}'. Only arrays and iterables are allowed`);
          }
          if (this.check(collection)) {
              return this;
          }
          else {
              return null;
          }
      }
      /**
       * @return {?}
       */
      onDestroy() { }
      /**
       * @param {?} collection
       * @return {?}
       */
      check(collection) {
          this._reset();
          /** @type {?} */
          let record = this._itHead;
          /** @type {?} */
          let mayBeDirty = false;
          /** @type {?} */
          let index;
          /** @type {?} */
          let item;
          /** @type {?} */
          let itemTrackBy;
          if (Array.isArray(collection)) {
              ((/** @type {?} */ (this))).length = collection.length;
              for (let index = 0; index < this.length; index++) {
                  item = collection[index];
                  itemTrackBy = this._trackByFn(index, item);
                  if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
                      record = this._mismatch(record, item, itemTrackBy, index);
                      mayBeDirty = true;
                  }
                  else {
                      if (mayBeDirty) {
                          // TODO(misko): can we limit this to duplicates only?
                          record = this._verifyReinsertion(record, item, itemTrackBy, index);
                      }
                      if (!looseIdentical(record.item, item))
                          this._addIdentityChange(record, item);
                  }
                  record = record._next;
              }
          }
          else {
              index = 0;
              iterateListLike(collection, (item) => {
                  itemTrackBy = this._trackByFn(index, item);
                  if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
                      record = this._mismatch(record, item, itemTrackBy, index);
                      mayBeDirty = true;
                  }
                  else {
                      if (mayBeDirty) {
                          // TODO(misko): can we limit this to duplicates only?
                          record = this._verifyReinsertion(record, item, itemTrackBy, index);
                      }
                      if (!looseIdentical(record.item, item))
                          this._addIdentityChange(record, item);
                  }
                  record = record._next;
                  index++;
              });
              ((/** @type {?} */ (this))).length = index;
          }
          this._truncate(record);
          ((/** @type {?} */ (this))).collection = collection;
          return this.isDirty;
      }
      /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
         * changes.
         */
      /**
       * @return {?}
       */
      get isDirty() {
          return this._additionsHead !== null || this._movesHead !== null ||
              this._removalsHead !== null || this._identityChangesHead !== null;
      }
      /**
       * Reset the state of the change objects to show no changes. This means set previousKey to
       * currentKey, and clear all of the queues (additions, moves, removals).
       * Set the previousIndexes of moved and added items to their currentIndexes
       * Reset the list of additions, moves and removals
       *
       * \@internal
       * @return {?}
       */
      _reset() {
          if (this.isDirty) {
              /** @type {?} */
              let record;
              /** @type {?} */
              let nextRecord;
              for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
                  record._nextPrevious = record._next;
              }
              for (record = this._additionsHead; record !== null; record = record._nextAdded) {
                  record.previousIndex = record.currentIndex;
              }
              this._additionsHead = this._additionsTail = null;
              for (record = this._movesHead; record !== null; record = nextRecord) {
                  record.previousIndex = record.currentIndex;
                  nextRecord = record._nextMoved;
              }
              this._movesHead = this._movesTail = null;
              this._removalsHead = this._removalsTail = null;
              this._identityChangesHead = this._identityChangesTail = null;
              // TODO(vicb): when assert gets supported
              // assert(!this.isDirty);
          }
      }
      /**
       * This is the core function which handles differences between collections.
       *
       * - `record` is the record which we saw at this position last time. If null then it is a new
       *   item.
       * - `item` is the current item in the collection
       * - `index` is the position of the item in the collection
       *
       * \@internal
       * @param {?} record
       * @param {?} item
       * @param {?} itemTrackBy
       * @param {?} index
       * @return {?}
       */
      _mismatch(record, item, itemTrackBy, index) {
          // The previous record after which we will append the current one.
          /** @type {?} */
          let previousRecord;
          if (record === null) {
              previousRecord = this._itTail;
          }
          else {
              previousRecord = record._prev;
              // Remove the record from the collection since we know it does not match the item.
              this._remove(record);
          }
          // Attempt to see if we have seen the item before.
          record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
          if (record !== null) {
              // We have seen this before, we need to move it forward in the collection.
              // But first we need to check if identity changed, so we can update in view if necessary
              if (!looseIdentical(record.item, item))
                  this._addIdentityChange(record, item);
              this._moveAfter(record, previousRecord, index);
          }
          else {
              // Never seen it, check evicted list.
              record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
              if (record !== null) {
                  // It is an item which we have evicted earlier: reinsert it back into the list.
                  // But first we need to check if identity changed, so we can update in view if necessary
                  if (!looseIdentical(record.item, item))
                      this._addIdentityChange(record, item);
                  this._reinsertAfter(record, previousRecord, index);
              }
              else {
                  // It is a new item: add it.
                  record =
                      this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
              }
          }
          return record;
      }
      /**
       * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
       *
       * Use case: `[a, a]` => `[b, a, a]`
       *
       * If we did not have this check then the insertion of `b` would:
       *   1) evict first `a`
       *   2) insert `b` at `0` index.
       *   3) leave `a` at index `1` as is. <-- this is wrong!
       *   3) reinsert `a` at index 2. <-- this is wrong!
       *
       * The correct behavior is:
       *   1) evict first `a`
       *   2) insert `b` at `0` index.
       *   3) reinsert `a` at index 1.
       *   3) move `a` at from `1` to `2`.
       *
       *
       * Double check that we have not evicted a duplicate item. We need to check if the item type may
       * have already been removed:
       * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
       * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
       * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
       * at the end.
       *
       * \@internal
       * @param {?} record
       * @param {?} item
       * @param {?} itemTrackBy
       * @param {?} index
       * @return {?}
       */
      _verifyReinsertion(record, item, itemTrackBy, index) {
          /** @type {?} */
          let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);
          if (reinsertRecord !== null) {
              record = this._reinsertAfter(reinsertRecord, (/** @type {?} */ (record._prev)), index);
          }
          else if (record.currentIndex != index) {
              record.currentIndex = index;
              this._addToMoves(record, index);
          }
          return record;
      }
      /**
       * Get rid of any excess {\@link IterableChangeRecord_}s from the previous collection
       *
       * - `record` The first excess {\@link IterableChangeRecord_}.
       *
       * \@internal
       * @param {?} record
       * @return {?}
       */
      _truncate(record) {
          // Anything after that needs to be removed;
          while (record !== null) {
              /** @type {?} */
              const nextRecord = record._next;
              this._addToRemovals(this._unlink(record));
              record = nextRecord;
          }
          if (this._unlinkedRecords !== null) {
              this._unlinkedRecords.clear();
          }
          if (this._additionsTail !== null) {
              this._additionsTail._nextAdded = null;
          }
          if (this._movesTail !== null) {
              this._movesTail._nextMoved = null;
          }
          if (this._itTail !== null) {
              this._itTail._next = null;
          }
          if (this._removalsTail !== null) {
              this._removalsTail._nextRemoved = null;
          }
          if (this._identityChangesTail !== null) {
              this._identityChangesTail._nextIdentityChange = null;
          }
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} prevRecord
       * @param {?} index
       * @return {?}
       */
      _reinsertAfter(record, prevRecord, index) {
          if (this._unlinkedRecords !== null) {
              this._unlinkedRecords.remove(record);
          }
          /** @type {?} */
          const prev = record._prevRemoved;
          /** @type {?} */
          const next = record._nextRemoved;
          if (prev === null) {
              this._removalsHead = next;
          }
          else {
              prev._nextRemoved = next;
          }
          if (next === null) {
              this._removalsTail = prev;
          }
          else {
              next._prevRemoved = prev;
          }
          this._insertAfter(record, prevRecord, index);
          this._addToMoves(record, index);
          return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} prevRecord
       * @param {?} index
       * @return {?}
       */
      _moveAfter(record, prevRecord, index) {
          this._unlink(record);
          this._insertAfter(record, prevRecord, index);
          this._addToMoves(record, index);
          return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} prevRecord
       * @param {?} index
       * @return {?}
       */
      _addAfter(record, prevRecord, index) {
          this._insertAfter(record, prevRecord, index);
          if (this._additionsTail === null) {
              // TODO(vicb):
              // assert(this._additionsHead === null);
              this._additionsTail = this._additionsHead = record;
          }
          else {
              // TODO(vicb):
              // assert(_additionsTail._nextAdded === null);
              // assert(record._nextAdded === null);
              this._additionsTail = this._additionsTail._nextAdded = record;
          }
          return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} prevRecord
       * @param {?} index
       * @return {?}
       */
      _insertAfter(record, prevRecord, index) {
          // TODO(vicb):
          // assert(record != prevRecord);
          // assert(record._next === null);
          // assert(record._prev === null);
          // TODO(vicb):
          // assert(record != prevRecord);
          // assert(record._next === null);
          // assert(record._prev === null);
          /** @type {?} */
          const next = prevRecord === null ? this._itHead : prevRecord._next;
          // TODO(vicb):
          // assert(next != record);
          // assert(prevRecord != record);
          record._next = next;
          record._prev = prevRecord;
          if (next === null) {
              this._itTail = record;
          }
          else {
              next._prev = record;
          }
          if (prevRecord === null) {
              this._itHead = record;
          }
          else {
              prevRecord._next = record;
          }
          if (this._linkedRecords === null) {
              this._linkedRecords = new _DuplicateMap();
          }
          this._linkedRecords.put(record);
          record.currentIndex = index;
          return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @return {?}
       */
      _remove(record) {
          return this._addToRemovals(this._unlink(record));
      }
      /**
       * \@internal
       * @param {?} record
       * @return {?}
       */
      _unlink(record) {
          if (this._linkedRecords !== null) {
              this._linkedRecords.remove(record);
          }
          /** @type {?} */
          const prev = record._prev;
          /** @type {?} */
          const next = record._next;
          // TODO(vicb):
          // assert((record._prev = null) === null);
          // assert((record._next = null) === null);
          if (prev === null) {
              this._itHead = next;
          }
          else {
              prev._next = next;
          }
          if (next === null) {
              this._itTail = prev;
          }
          else {
              next._prev = prev;
          }
          return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} toIndex
       * @return {?}
       */
      _addToMoves(record, toIndex) {
          // TODO(vicb):
          // assert(record._nextMoved === null);
          if (record.previousIndex === toIndex) {
              return record;
          }
          if (this._movesTail === null) {
              // TODO(vicb):
              // assert(_movesHead === null);
              this._movesTail = this._movesHead = record;
          }
          else {
              // TODO(vicb):
              // assert(_movesTail._nextMoved === null);
              this._movesTail = this._movesTail._nextMoved = record;
          }
          return record;
      }
      /**
       * @private
       * @param {?} record
       * @return {?}
       */
      _addToRemovals(record) {
          if (this._unlinkedRecords === null) {
              this._unlinkedRecords = new _DuplicateMap();
          }
          this._unlinkedRecords.put(record);
          record.currentIndex = null;
          record._nextRemoved = null;
          if (this._removalsTail === null) {
              // TODO(vicb):
              // assert(_removalsHead === null);
              this._removalsTail = this._removalsHead = record;
              record._prevRemoved = null;
          }
          else {
              // TODO(vicb):
              // assert(_removalsTail._nextRemoved === null);
              // assert(record._nextRemoved === null);
              record._prevRemoved = this._removalsTail;
              this._removalsTail = this._removalsTail._nextRemoved = record;
          }
          return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} item
       * @return {?}
       */
      _addIdentityChange(record, item) {
          record.item = item;
          if (this._identityChangesTail === null) {
              this._identityChangesTail = this._identityChangesHead = record;
          }
          else {
              this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
          }
          return record;
      }
  }
  /**
   * @template V
   */
  class IterableChangeRecord_ {
      /**
       * @param {?} item
       * @param {?} trackById
       */
      constructor(item, trackById) {
          this.item = item;
          this.trackById = trackById;
          this.currentIndex = null;
          this.previousIndex = null;
          /**
           * \@internal
           */
          this._nextPrevious = null;
          /**
           * \@internal
           */
          this._prev = null;
          /**
           * \@internal
           */
          this._next = null;
          /**
           * \@internal
           */
          this._prevDup = null;
          /**
           * \@internal
           */
          this._nextDup = null;
          /**
           * \@internal
           */
          this._prevRemoved = null;
          /**
           * \@internal
           */
          this._nextRemoved = null;
          /**
           * \@internal
           */
          this._nextAdded = null;
          /**
           * \@internal
           */
          this._nextMoved = null;
          /**
           * \@internal
           */
          this._nextIdentityChange = null;
      }
  }
  // A linked list of CollectionChangeRecords with the same IterableChangeRecord_.item
  /**
   * @template V
   */
  class _DuplicateItemRecordList {
      constructor() {
          /**
           * \@internal
           */
          this._head = null;
          /**
           * \@internal
           */
          this._tail = null;
      }
      /**
       * Append the record to the list of duplicates.
       *
       * Note: by design all records in the list of duplicates hold the same value in record.item.
       * @param {?} record
       * @return {?}
       */
      add(record) {
          if (this._head === null) {
              this._head = this._tail = record;
              record._nextDup = null;
              record._prevDup = null;
          }
          else {
              // TODO(vicb):
              // assert(record.item ==  _head.item ||
              //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
              (/** @type {?} */ (this._tail))._nextDup = record;
              record._prevDup = this._tail;
              record._nextDup = null;
              this._tail = record;
          }
      }
      // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
      // IterableChangeRecord_.currentIndex >= atOrAfterIndex
      /**
       * @param {?} trackById
       * @param {?} atOrAfterIndex
       * @return {?}
       */
      get(trackById, atOrAfterIndex) {
          /** @type {?} */
          let record;
          for (record = this._head; record !== null; record = record._nextDup) {
              if ((atOrAfterIndex === null || atOrAfterIndex <= (/** @type {?} */ (record.currentIndex))) &&
                  looseIdentical(record.trackById, trackById)) {
                  return record;
              }
          }
          return null;
      }
      /**
       * Remove one {\@link IterableChangeRecord_} from the list of duplicates.
       *
       * Returns whether the list of duplicates is empty.
       * @param {?} record
       * @return {?}
       */
      remove(record) {
          // TODO(vicb):
          // assert(() {
          //  // verify that the record being removed is in the list.
          //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {
          //    if (identical(cursor, record)) return true;
          //  }
          //  return false;
          //});
          // TODO(vicb):
          // assert(() {
          //  // verify that the record being removed is in the list.
          //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {
          //    if (identical(cursor, record)) return true;
          //  }
          //  return false;
          //});
          /** @type {?} */
          const prev = record._prevDup;
          /** @type {?} */
          const next = record._nextDup;
          if (prev === null) {
              this._head = next;
          }
          else {
              prev._nextDup = next;
          }
          if (next === null) {
              this._tail = prev;
          }
          else {
              next._prevDup = prev;
          }
          return this._head === null;
      }
  }
  /**
   * @template V
   */
  class _DuplicateMap {
      constructor() {
          this.map = new Map();
      }
      /**
       * @param {?} record
       * @return {?}
       */
      put(record) {
          /** @type {?} */
          const key = record.trackById;
          /** @type {?} */
          let duplicates = this.map.get(key);
          if (!duplicates) {
              duplicates = new _DuplicateItemRecordList();
              this.map.set(key, duplicates);
          }
          duplicates.add(record);
      }
      /**
       * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
       * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
       *
       * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
       * have any more `a`s needs to return the second `a`.
       * @param {?} trackById
       * @param {?} atOrAfterIndex
       * @return {?}
       */
      get(trackById, atOrAfterIndex) {
          /** @type {?} */
          const key = trackById;
          /** @type {?} */
          const recordList = this.map.get(key);
          return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
      }
      /**
       * Removes a {\@link IterableChangeRecord_} from the list of duplicates.
       *
       * The list of duplicates also is removed from the map if it gets empty.
       * @param {?} record
       * @return {?}
       */
      remove(record) {
          /** @type {?} */
          const key = record.trackById;
          /** @type {?} */
          const recordList = (/** @type {?} */ (this.map.get(key)));
          // Remove the list of duplicates when it gets empty
          if (recordList.remove(record)) {
              this.map.delete(key);
          }
          return record;
      }
      /**
       * @return {?}
       */
      get isEmpty() { return this.map.size === 0; }
      /**
       * @return {?}
       */
      clear() { this.map.clear(); }
  }
  /**
   * @param {?} item
   * @param {?} addRemoveOffset
   * @param {?} moveOffsets
   * @return {?}
   */
  function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
      /** @type {?} */
      const previousIndex = item.previousIndex;
      if (previousIndex === null)
          return previousIndex;
      /** @type {?} */
      let moveOffset = 0;
      if (moveOffsets && previousIndex < moveOffsets.length) {
          moveOffset = moveOffsets[previousIndex];
      }
      return previousIndex + addRemoveOffset + moveOffset;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @template K, V
   */
  class DefaultKeyValueDifferFactory {
      constructor() { }
      /**
       * @param {?} obj
       * @return {?}
       */
      supports(obj) { return obj instanceof Map || isJsObject(obj); }
      /**
       * @template K, V
       * @return {?}
       */
      create() { return new DefaultKeyValueDiffer(); }
  }
  /**
   * @template K, V
   */
  class DefaultKeyValueDiffer {
      constructor() {
          this._records = new Map();
          this._mapHead = null;
          // _appendAfter is used in the check loop
          this._appendAfter = null;
          this._previousMapHead = null;
          this._changesHead = null;
          this._changesTail = null;
          this._additionsHead = null;
          this._additionsTail = null;
          this._removalsHead = null;
          this._removalsTail = null;
      }
      /**
       * @return {?}
       */
      get isDirty() {
          return this._additionsHead !== null || this._changesHead !== null ||
              this._removalsHead !== null;
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._mapHead; record !== null; record = record._next) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachPreviousItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachChangedItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._changesHead; record !== null; record = record._nextChanged) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachAddedItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._additionsHead; record !== null; record = record._nextAdded) {
              fn(record);
          }
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      forEachRemovedItem(fn) {
          /** @type {?} */
          let record;
          for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
              fn(record);
          }
      }
      /**
       * @param {?=} map
       * @return {?}
       */
      diff(map$$1) {
          if (!map$$1) {
              map$$1 = new Map();
          }
          else if (!(map$$1 instanceof Map || isJsObject(map$$1))) {
              throw new Error(`Error trying to diff '${stringify$1(map$$1)}'. Only maps and objects are allowed`);
          }
          return this.check(map$$1) ? this : null;
      }
      /**
       * @return {?}
       */
      onDestroy() { }
      /**
       * Check the current state of the map vs the previous.
       * The algorithm is optimised for when the keys do no change.
       * @param {?} map
       * @return {?}
       */
      check(map$$1) {
          this._reset();
          /** @type {?} */
          let insertBefore = this._mapHead;
          this._appendAfter = null;
          this._forEach(map$$1, (value, key) => {
              if (insertBefore && insertBefore.key === key) {
                  this._maybeAddToChanges(insertBefore, value);
                  this._appendAfter = insertBefore;
                  insertBefore = insertBefore._next;
              }
              else {
                  /** @type {?} */
                  const record = this._getOrCreateRecordForKey(key, value);
                  insertBefore = this._insertBeforeOrAppend(insertBefore, record);
              }
          });
          // Items remaining at the end of the list have been deleted
          if (insertBefore) {
              if (insertBefore._prev) {
                  insertBefore._prev._next = null;
              }
              this._removalsHead = insertBefore;
              for (let record = insertBefore; record !== null; record = record._nextRemoved) {
                  if (record === this._mapHead) {
                      this._mapHead = null;
                  }
                  this._records.delete(record.key);
                  record._nextRemoved = record._next;
                  record.previousValue = record.currentValue;
                  record.currentValue = null;
                  record._prev = null;
                  record._next = null;
              }
          }
          // Make sure tails have no next records from previous runs
          if (this._changesTail)
              this._changesTail._nextChanged = null;
          if (this._additionsTail)
              this._additionsTail._nextAdded = null;
          return this.isDirty;
      }
      /**
       * Inserts a record before `before` or append at the end of the list when `before` is null.
       *
       * Notes:
       * - This method appends at `this._appendAfter`,
       * - This method updates `this._appendAfter`,
       * - The return value is the new value for the insertion pointer.
       * @private
       * @param {?} before
       * @param {?} record
       * @return {?}
       */
      _insertBeforeOrAppend(before, record) {
          if (before) {
              /** @type {?} */
              const prev = before._prev;
              record._next = before;
              record._prev = prev;
              before._prev = record;
              if (prev) {
                  prev._next = record;
              }
              if (before === this._mapHead) {
                  this._mapHead = record;
              }
              this._appendAfter = before;
              return before;
          }
          if (this._appendAfter) {
              this._appendAfter._next = record;
              record._prev = this._appendAfter;
          }
          else {
              this._mapHead = record;
          }
          this._appendAfter = record;
          return null;
      }
      /**
       * @private
       * @param {?} key
       * @param {?} value
       * @return {?}
       */
      _getOrCreateRecordForKey(key, value) {
          if (this._records.has(key)) {
              /** @type {?} */
              const record = (/** @type {?} */ (this._records.get(key)));
              this._maybeAddToChanges(record, value);
              /** @type {?} */
              const prev = record._prev;
              /** @type {?} */
              const next = record._next;
              if (prev) {
                  prev._next = next;
              }
              if (next) {
                  next._prev = prev;
              }
              record._next = null;
              record._prev = null;
              return record;
          }
          /** @type {?} */
          const record = new KeyValueChangeRecord_(key);
          this._records.set(key, record);
          record.currentValue = value;
          this._addToAdditions(record);
          return record;
      }
      /**
       * \@internal
       * @return {?}
       */
      _reset() {
          if (this.isDirty) {
              /** @type {?} */
              let record;
              // let `_previousMapHead` contain the state of the map before the changes
              this._previousMapHead = this._mapHead;
              for (record = this._previousMapHead; record !== null; record = record._next) {
                  record._nextPrevious = record._next;
              }
              // Update `record.previousValue` with the value of the item before the changes
              // We need to update all changed items (that's those which have been added and changed)
              for (record = this._changesHead; record !== null; record = record._nextChanged) {
                  record.previousValue = record.currentValue;
              }
              for (record = this._additionsHead; record != null; record = record._nextAdded) {
                  record.previousValue = record.currentValue;
              }
              this._changesHead = this._changesTail = null;
              this._additionsHead = this._additionsTail = null;
              this._removalsHead = null;
          }
      }
      // Add the record or a given key to the list of changes only when the value has actually changed
      /**
       * @private
       * @param {?} record
       * @param {?} newValue
       * @return {?}
       */
      _maybeAddToChanges(record, newValue) {
          if (!looseIdentical(newValue, record.currentValue)) {
              record.previousValue = record.currentValue;
              record.currentValue = newValue;
              this._addToChanges(record);
          }
      }
      /**
       * @private
       * @param {?} record
       * @return {?}
       */
      _addToAdditions(record) {
          if (this._additionsHead === null) {
              this._additionsHead = this._additionsTail = record;
          }
          else {
              (/** @type {?} */ (this._additionsTail))._nextAdded = record;
              this._additionsTail = record;
          }
      }
      /**
       * @private
       * @param {?} record
       * @return {?}
       */
      _addToChanges(record) {
          if (this._changesHead === null) {
              this._changesHead = this._changesTail = record;
          }
          else {
              (/** @type {?} */ (this._changesTail))._nextChanged = record;
              this._changesTail = record;
          }
      }
      /**
       * \@internal
       * @private
       * @template K, V
       * @param {?} obj
       * @param {?} fn
       * @return {?}
       */
      _forEach(obj, fn) {
          if (obj instanceof Map) {
              obj.forEach(fn);
          }
          else {
              Object.keys(obj).forEach(k => fn(obj[k], k));
          }
      }
  }
  /**
   * @template K, V
   */
  class KeyValueChangeRecord_ {
      /**
       * @param {?} key
       */
      constructor(key) {
          this.key = key;
          this.previousValue = null;
          this.currentValue = null;
          /**
           * \@internal
           */
          this._nextPrevious = null;
          /**
           * \@internal
           */
          this._next = null;
          /**
           * \@internal
           */
          this._prev = null;
          /**
           * \@internal
           */
          this._nextAdded = null;
          /**
           * \@internal
           */
          this._nextRemoved = null;
          /**
           * \@internal
           */
          this._nextChanged = null;
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
   *
   * \@publicApi
   */
  class IterableDiffers {
      /**
       * @param {?} factories
       */
      constructor(factories) { this.factories = factories; }
      /**
       * @param {?} factories
       * @param {?=} parent
       * @return {?}
       */
      static create(factories, parent) {
          if (parent != null) {
              /** @type {?} */
              const copied = parent.factories.slice();
              factories = factories.concat(copied);
          }
          return new IterableDiffers(factories);
      }
      /**
       * Takes an array of {\@link IterableDifferFactory} and returns a provider used to extend the
       * inherited {\@link IterableDiffers} instance with the provided factories and return a new
       * {\@link IterableDiffers} instance.
       *
       * \@usageNotes
       * ### Example
       *
       * The following example shows how to extend an existing list of factories,
       * which will only be applied to the injector for this component and its children.
       * This step is all that's required to make a new {\@link IterableDiffer} available.
       *
       * ```
       * \@Component({
       *   viewProviders: [
       *     IterableDiffers.extend([new ImmutableListDiffer()])
       *   ]
       * })
       * ```
       * @param {?} factories
       * @return {?}
       */
      static extend(factories) {
          return {
              provide: IterableDiffers,
              useFactory: (parent) => {
                  if (!parent) {
                      // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
                      // to
                      // bootstrap(), which would override default pipes instead of extending them.
                      throw new Error('Cannot extend IterableDiffers without a parent injector');
                  }
                  return IterableDiffers.create(factories, parent);
              },
              // Dependency technically isn't optional, but we can provide a better error message this way.
              deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
          };
      }
      /**
       * @param {?} iterable
       * @return {?}
       */
      find(iterable) {
          /** @type {?} */
          const factory = this.factories.find(f => f.supports(iterable));
          if (factory != null) {
              return factory;
          }
          else {
              throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);
          }
      }
  }
  /** @nocollapse */
  /** @nocollapse */ IterableDiffers.ngInjectableDef = defineInjectable({
      providedIn: 'root',
      factory: () => new IterableDiffers([new DefaultIterableDifferFactory()])
  });
  /**
   * @param {?} type
   * @return {?}
   */
  function getTypeNameForDebugging(type) {
      return type['name'] || typeof type;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
   *
   * \@publicApi
   */
  class KeyValueDiffers {
      /**
       * @param {?} factories
       */
      constructor(factories) { this.factories = factories; }
      /**
       * @template S
       * @param {?} factories
       * @param {?=} parent
       * @return {?}
       */
      static create(factories, parent) {
          if (parent) {
              /** @type {?} */
              const copied = parent.factories.slice();
              factories = factories.concat(copied);
          }
          return new KeyValueDiffers(factories);
      }
      /**
       * Takes an array of {\@link KeyValueDifferFactory} and returns a provider used to extend the
       * inherited {\@link KeyValueDiffers} instance with the provided factories and return a new
       * {\@link KeyValueDiffers} instance.
       *
       * \@usageNotes
       * ### Example
       *
       * The following example shows how to extend an existing list of factories,
       * which will only be applied to the injector for this component and its children.
       * This step is all that's required to make a new {\@link KeyValueDiffer} available.
       *
       * ```
       * \@Component({
       *   viewProviders: [
       *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
       *   ]
       * })
       * ```
       * @template S
       * @param {?} factories
       * @return {?}
       */
      static extend(factories) {
          return {
              provide: KeyValueDiffers,
              useFactory: (parent) => {
                  if (!parent) {
                      // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
                      // to bootstrap(), which would override default pipes instead of extending them.
                      throw new Error('Cannot extend KeyValueDiffers without a parent injector');
                  }
                  return KeyValueDiffers.create(factories, parent);
              },
              // Dependency technically isn't optional, but we can provide a better error message this way.
              deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
          };
      }
      /**
       * @param {?} kv
       * @return {?}
       */
      find(kv) {
          /** @type {?} */
          const factory = this.factories.find(f => f.supports(kv));
          if (factory) {
              return factory;
          }
          throw new Error(`Cannot find a differ supporting object '${kv}'`);
      }
  }
  /** @nocollapse */
  /** @nocollapse */ KeyValueDiffers.ngInjectableDef = defineInjectable({
      providedIn: 'root',
      factory: () => new KeyValueDiffers([new DefaultKeyValueDifferFactory()])
  });

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Structural diffing for `Object`s and `Map`s.
   * @type {?}
   */
  const keyValDiff = [new DefaultKeyValueDifferFactory()];
  /**
   * Structural diffing for `Iterable` types such as `Array`s.
   * @type {?}
   */
  const iterableDiff = [new DefaultIterableDifferFactory()];
  /** @type {?} */
  const defaultIterableDiffers = new IterableDiffers(iterableDiff);
  /** @type {?} */
  const defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const _CORE_PLATFORM_PROVIDERS = [
      // Set a default platform name for platforms that don't set it explicitly.
      { provide: PLATFORM_ID, useValue: 'unknown' },
      { provide: PlatformRef, deps: [Injector] },
      { provide: TestabilityRegistry, deps: [] },
      { provide: Console, deps: [] },
  ];
  /**
   * This platform has to be included in any other platform
   *
   * \@publicApi
   * @type {?}
   */
  const platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Provide this token to set the locale of your application.
   * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,
   * DecimalPipe and PercentPipe) and by ICU expressions.
   *
   * See the [i18n guide](guide/i18n#setting-up-locale) for more information.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * import { LOCALE_ID } from '\@angular/core';
   * import { platformBrowserDynamic } from '\@angular/platform-browser-dynamic';
   * import { AppModule } from './app/app.module';
   *
   * platformBrowserDynamic().bootstrapModule(AppModule, {
   *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]
   * });
   * ```
   *
   * \@publicApi
   * @type {?}
   */
  const LOCALE_ID = new InjectionToken('LocaleId');
  /**
   * Use this token at bootstrap to provide the content of your translation file (`xtb`,
   * `xlf` or `xlf2`) when you want to translate your application in another language.
   *
   * See the [i18n guide](guide/i18n#merge) for more information.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * import { TRANSLATIONS } from '\@angular/core';
   * import { platformBrowserDynamic } from '\@angular/platform-browser-dynamic';
   * import { AppModule } from './app/app.module';
   *
   * // content of your translation file
   * const translations = '....';
   *
   * platformBrowserDynamic().bootstrapModule(AppModule, {
   *   providers: [{provide: TRANSLATIONS, useValue: translations }]
   * });
   * ```
   *
   * \@publicApi
   * @type {?}
   */
  const TRANSLATIONS = new InjectionToken('Translations');
  /**
   * Provide this token at bootstrap to set the format of your {\@link TRANSLATIONS}: `xtb`,
   * `xlf` or `xlf2`.
   *
   * See the [i18n guide](guide/i18n#merge) for more information.
   *
   * \@usageNotes
   * ### Example
   *
   * ```typescript
   * import { TRANSLATIONS_FORMAT } from '\@angular/core';
   * import { platformBrowserDynamic } from '\@angular/platform-browser-dynamic';
   * import { AppModule } from './app/app.module';
   *
   * platformBrowserDynamic().bootstrapModule(AppModule, {
   *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]
   * });
   * ```
   *
   * \@publicApi
   * @type {?}
   */
  const TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');
  /** @enum {number} */
  const MissingTranslationStrategy$1 = {
      Error: 0,
      Warning: 1,
      Ignore: 2,
  };
  MissingTranslationStrategy$1[MissingTranslationStrategy$1.Error] = 'Error';
  MissingTranslationStrategy$1[MissingTranslationStrategy$1.Warning] = 'Warning';
  MissingTranslationStrategy$1[MissingTranslationStrategy$1.Ignore] = 'Ignore';

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @return {?}
   */
  function _iterableDiffersFactory() {
      return defaultIterableDiffers;
  }
  /**
   * @return {?}
   */
  function _keyValueDiffersFactory() {
      return defaultKeyValueDiffers;
  }
  /**
   * @param {?=} locale
   * @return {?}
   */
  function _localeFactory(locale) {
      return locale || 'en-US';
  }
  /**
   * A built-in [dependency injection token](guide/glossary#di-token)
   * that is used to configure the root injector for bootstrapping.
   * @type {?}
   */
  const APPLICATION_MODULE_PROVIDERS = [
      {
          provide: ApplicationRef,
          useClass: ApplicationRef,
          deps: [NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]
      },
      {
          provide: ApplicationInitStatus,
          useClass: ApplicationInitStatus,
          deps: [[new Optional(), APP_INITIALIZER]]
      },
      { provide: Compiler, useClass: Compiler, deps: [] },
      APP_ID_RANDOM_PROVIDER,
      { provide: IterableDiffers, useFactory: _iterableDiffersFactory, deps: [] },
      { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory, deps: [] },
      {
          provide: LOCALE_ID,
          useFactory: _localeFactory,
          deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]
      },
  ];
  /**
   * Configures the root injector for an app with
   * providers of `\@angular/core` dependencies that `ApplicationRef` needs
   * to bootstrap components.
   *
   * Re-exported by `BrowserModule`, which is included automatically in the root
   * `AppModule` when you create a new app with the CLI `new` command.
   *
   * \@publicApi
   */
  class ApplicationModule {
      // Inject ApplicationRef to make it eager...
      /**
       * @param {?} appRef
       */
      constructor(appRef) { }
  }
  ApplicationModule.decorators = [
      { type: NgModule, args: [{ providers: APPLICATION_MODULE_PROVIDERS },] }
  ];
  /** @nocollapse */
  ApplicationModule.ctorParameters = () => [
      { type: ApplicationRef }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Called before each cycle of a view's check to detect whether this is in the
  // initState for which we need to call ngOnInit, ngAfterContentInit or ngAfterViewInit
  // lifecycle methods. Returns true if this check cycle should call lifecycle
  // methods.
  /**
   * @param {?} view
   * @param {?} priorInitState
   * @param {?} newInitState
   * @return {?}
   */
  function shiftInitState(view, priorInitState, newInitState) {
      // Only update the InitState if we are currently in the prior state.
      // For example, only move into CallingInit if we are in BeforeInit. Only
      // move into CallingContentInit if we are in CallingInit. Normally this will
      // always be true because of how checkCycle is called in checkAndUpdateView.
      // However, if checkAndUpdateView is called recursively or if an exception is
      // thrown while checkAndUpdateView is running, checkAndUpdateView starts over
      // from the beginning. This ensures the state is monotonically increasing,
      // terminating in the AfterInit state, which ensures the Init methods are called
      // at least once and only once.
      /** @type {?} */
      const state = view.state;
      /** @type {?} */
      const initState = state & 1792 /* InitState_Mask */;
      if (initState === priorInitState) {
          view.state = (state & ~1792 /* InitState_Mask */) | newInitState;
          view.initIndex = -1;
          return true;
      }
      return initState === newInitState;
  }
  // Returns true if the lifecycle init method should be called for the node with
  // the given init index.
  /**
   * @param {?} view
   * @param {?} initState
   * @param {?} index
   * @return {?}
   */
  function shouldCallLifecycleInitHook(view, initState, index) {
      if ((view.state & 1792 /* InitState_Mask */) === initState && view.initIndex <= index) {
          view.initIndex = index + 1;
          return true;
      }
      return false;
  }
  /**
   * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
   * @param {?} view
   * @param {?} index
   * @return {?}
   */
  function asTextData(view, index) {
      return (/** @type {?} */ (view.nodes[index]));
  }
  /**
   * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
   * @param {?} view
   * @param {?} index
   * @return {?}
   */
  function asElementData(view, index) {
      return (/** @type {?} */ (view.nodes[index]));
  }
  /**
   * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
   * @param {?} view
   * @param {?} index
   * @return {?}
   */
  function asProviderData(view, index) {
      return (/** @type {?} */ (view.nodes[index]));
  }
  /**
   * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
   * @param {?} view
   * @param {?} index
   * @return {?}
   */
  function asPureExpressionData(view, index) {
      return (/** @type {?} */ (view.nodes[index]));
  }
  /**
   * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
   * @param {?} view
   * @param {?} index
   * @return {?}
   */
  function asQueryList(view, index) {
      return (/** @type {?} */ (view.nodes[index]));
  }
  // WARNING: interface has both a type and a value, skipping emit
  /**
   * This object is used to prevent cycles in the source files and to have a place where
   * debug mode can hook it. It is lazily filled when `isDevMode` is known.
   * @type {?}
   */
  const Services = {
      setCurrentNode: (/** @type {?} */ (undefined)),
      createRootView: (/** @type {?} */ (undefined)),
      createEmbeddedView: (/** @type {?} */ (undefined)),
      createComponentView: (/** @type {?} */ (undefined)),
      createNgModuleRef: (/** @type {?} */ (undefined)),
      overrideProvider: (/** @type {?} */ (undefined)),
      overrideComponentView: (/** @type {?} */ (undefined)),
      clearOverrides: (/** @type {?} */ (undefined)),
      checkAndUpdateView: (/** @type {?} */ (undefined)),
      checkNoChangesView: (/** @type {?} */ (undefined)),
      destroyView: (/** @type {?} */ (undefined)),
      resolveDep: (/** @type {?} */ (undefined)),
      createDebugContext: (/** @type {?} */ (undefined)),
      handleEvent: (/** @type {?} */ (undefined)),
      updateDirectives: (/** @type {?} */ (undefined)),
      updateRenderer: (/** @type {?} */ (undefined)),
      dirtyParentQueries: (/** @type {?} */ (undefined)),
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} context
   * @param {?} oldValue
   * @param {?} currValue
   * @param {?} isFirstCheck
   * @return {?}
   */
  function expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {
      /** @type {?} */
      let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '${oldValue}'. Current value: '${currValue}'.`;
      if (isFirstCheck) {
          msg +=
              ` It seems like the view has been created after its parent and its children have been dirty checked.` +
                  ` Has it been created in a change detection hook ?`;
      }
      return viewDebugError(msg, context);
  }
  /**
   * @param {?} err
   * @param {?} context
   * @return {?}
   */
  function viewWrappedDebugError(err, context) {
      if (!(err instanceof Error)) {
          // errors that are not Error instances don't have a stack,
          // so it is ok to wrap them into a new Error object...
          err = new Error(err.toString());
      }
      _addDebugContext(err, context);
      return err;
  }
  /**
   * @param {?} msg
   * @param {?} context
   * @return {?}
   */
  function viewDebugError(msg, context) {
      /** @type {?} */
      const err = new Error(msg);
      _addDebugContext(err, context);
      return err;
  }
  /**
   * @param {?} err
   * @param {?} context
   * @return {?}
   */
  function _addDebugContext(err, context) {
      ((/** @type {?} */ (err)))[ERROR_DEBUG_CONTEXT] = context;
      ((/** @type {?} */ (err)))[ERROR_LOGGER] = context.logError.bind(context);
  }
  /**
   * @param {?} err
   * @return {?}
   */
  function isViewDebugError(err) {
      return !!getDebugContext(err);
  }
  /**
   * @param {?} action
   * @return {?}
   */
  function viewDestroyedError(action) {
      return new Error(`ViewDestroyedError: Attempt to use a destroyed view: ${action}`);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const NOOP = () => { };
  /** @type {?} */
  const _tokenKeyCache = new Map();
  /**
   * @param {?} token
   * @return {?}
   */
  function tokenKey(token) {
      /** @type {?} */
      let key = _tokenKeyCache.get(token);
      if (!key) {
          key = stringify$1(token) + '_' + _tokenKeyCache.size;
          _tokenKeyCache.set(token, key);
      }
      return key;
  }
  /**
   * @param {?} view
   * @param {?} nodeIdx
   * @param {?} bindingIdx
   * @param {?} value
   * @return {?}
   */
  function unwrapValue$1(view, nodeIdx, bindingIdx, value) {
      if (WrappedValue.isWrapped(value)) {
          value = WrappedValue.unwrap(value);
          /** @type {?} */
          const globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx;
          /** @type {?} */
          const oldValue = WrappedValue.unwrap(view.oldValues[globalBindingIdx]);
          view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);
      }
      return value;
  }
  /** @type {?} */
  const UNDEFINED_RENDERER_TYPE_ID = '$$undefined';
  /** @type {?} */
  const EMPTY_RENDERER_TYPE_ID = '$$empty';
  // Attention: this function is called as top level function.
  // Putting any logic in here will destroy closure tree shaking!
  /**
   * @param {?} values
   * @return {?}
   */
  function createRendererType2(values) {
      return {
          id: UNDEFINED_RENDERER_TYPE_ID,
          styles: values.styles,
          encapsulation: values.encapsulation,
          data: values.data
      };
  }
  /** @type {?} */
  let _renderCompCount$1 = 0;
  /**
   * @param {?=} type
   * @return {?}
   */
  function resolveRendererType2(type) {
      if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {
          // first time we see this RendererType2. Initialize it...
          /** @type {?} */
          const isFilled = ((type.encapsulation != null && type.encapsulation !== ViewEncapsulation$1.None) ||
              type.styles.length || Object.keys(type.data).length);
          if (isFilled) {
              type.id = `c${_renderCompCount$1++}`;
          }
          else {
              type.id = EMPTY_RENDERER_TYPE_ID;
          }
      }
      if (type && type.id === EMPTY_RENDERER_TYPE_ID) {
          type = null;
      }
      return type || null;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} bindingIdx
   * @param {?} value
   * @return {?}
   */
  function checkBinding(view, def, bindingIdx, value) {
      /** @type {?} */
      const oldValues = view.oldValues;
      if ((view.state & 2 /* FirstCheck */) ||
          !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) {
          return true;
      }
      return false;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} bindingIdx
   * @param {?} value
   * @return {?}
   */
  function checkAndUpdateBinding(view, def, bindingIdx, value) {
      if (checkBinding(view, def, bindingIdx, value)) {
          view.oldValues[def.bindingIndex + bindingIdx] = value;
          return true;
      }
      return false;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} bindingIdx
   * @param {?} value
   * @return {?}
   */
  function checkBindingNoChanges(view, def, bindingIdx, value) {
      /** @type {?} */
      const oldValue = view.oldValues[def.bindingIndex + bindingIdx];
      if ((view.state & 1 /* BeforeFirstCheck */) || !devModeEqual(oldValue, value)) {
          /** @type {?} */
          const bindingName = def.bindings[bindingIdx].name;
          throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, def.nodeIndex), `${bindingName}: ${oldValue}`, `${bindingName}: ${value}`, (view.state & 1 /* BeforeFirstCheck */) !== 0);
      }
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function markParentViewsForCheck(view) {
      /** @type {?} */
      let currView = view;
      while (currView) {
          if (currView.def.flags & 2 /* OnPush */) {
              currView.state |= 8 /* ChecksEnabled */;
          }
          currView = currView.viewContainerParent || currView.parent;
      }
  }
  /**
   * @param {?} view
   * @param {?} endView
   * @return {?}
   */
  function markParentViewsForCheckProjectedViews(view, endView) {
      /** @type {?} */
      let currView = view;
      while (currView && currView !== endView) {
          currView.state |= 64 /* CheckProjectedViews */;
          currView = currView.viewContainerParent || currView.parent;
      }
  }
  /**
   * @param {?} view
   * @param {?} nodeIndex
   * @param {?} eventName
   * @param {?} event
   * @return {?}
   */
  function dispatchEvent(view, nodeIndex, eventName, event) {
      try {
          /** @type {?} */
          const nodeDef = view.def.nodes[nodeIndex];
          /** @type {?} */
          const startView = nodeDef.flags & 33554432 /* ComponentView */ ?
              asElementData(view, nodeIndex).componentView :
              view;
          markParentViewsForCheck(startView);
          return Services.handleEvent(view, nodeIndex, eventName, event);
      }
      catch (e) {
          // Attention: Don't rethrow, as it would cancel Observable subscriptions!
          view.root.errorHandler.handleError(e);
      }
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function declaredViewContainer(view) {
      if (view.parent) {
          /** @type {?} */
          const parentView = view.parent;
          return asElementData(parentView, (/** @type {?} */ (view.parentNodeDef)).nodeIndex);
      }
      return null;
  }
  /**
   * for component views, this is the host element.
   * for embedded views, this is the index of the parent node
   * that contains the view container.
   * @param {?} view
   * @return {?}
   */
  function viewParentEl(view) {
      /** @type {?} */
      const parentView = view.parent;
      if (parentView) {
          return (/** @type {?} */ (view.parentNodeDef)).parent;
      }
      else {
          return null;
      }
  }
  /**
   * @param {?} view
   * @param {?} def
   * @return {?}
   */
  function renderNode(view, def) {
      switch (def.flags & 201347067 /* Types */) {
          case 1 /* TypeElement */:
              return asElementData(view, def.nodeIndex).renderElement;
          case 2 /* TypeText */:
              return asTextData(view, def.nodeIndex).renderText;
      }
  }
  /**
   * @param {?} target
   * @param {?} name
   * @return {?}
   */
  function elementEventFullName$1(target, name) {
      return target ? `${target}:${name}` : name;
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function isComponentView(view) {
      return !!view.parent && !!((/** @type {?} */ (view.parentNodeDef)).flags & 32768 /* Component */);
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function isEmbeddedView(view) {
      return !!view.parent && !((/** @type {?} */ (view.parentNodeDef)).flags & 32768 /* Component */);
  }
  /**
   * @param {?} queryId
   * @return {?}
   */
  function filterQueryId(queryId) {
      return 1 << (queryId % 32);
  }
  /**
   * @param {?} matchedQueriesDsl
   * @return {?}
   */
  function splitMatchedQueriesDsl(matchedQueriesDsl) {
      /** @type {?} */
      const matchedQueries = {};
      /** @type {?} */
      let matchedQueryIds = 0;
      /** @type {?} */
      const references = {};
      if (matchedQueriesDsl) {
          matchedQueriesDsl.forEach(([queryId, valueType]) => {
              if (typeof queryId === 'number') {
                  matchedQueries[queryId] = valueType;
                  matchedQueryIds |= filterQueryId(queryId);
              }
              else {
                  references[queryId] = valueType;
              }
          });
      }
      return { matchedQueries, references, matchedQueryIds };
  }
  /**
   * @param {?} deps
   * @param {?=} sourceName
   * @return {?}
   */
  function splitDepsDsl(deps, sourceName) {
      return deps.map(value => {
          /** @type {?} */
          let token;
          /** @type {?} */
          let flags;
          if (Array.isArray(value)) {
              [flags, token] = value;
          }
          else {
              flags = 0 /* None */;
              token = value;
          }
          if (token && (typeof token === 'function' || typeof token === 'object') && sourceName) {
              Object.defineProperty(token, SOURCE, { value: sourceName, configurable: true });
          }
          return { flags, token, tokenKey: tokenKey(token) };
      });
  }
  /**
   * @param {?} view
   * @param {?} renderHost
   * @param {?} def
   * @return {?}
   */
  function getParentRenderElement(view, renderHost, def) {
      /** @type {?} */
      let renderParent = def.renderParent;
      if (renderParent) {
          if ((renderParent.flags & 1 /* TypeElement */) === 0 ||
              (renderParent.flags & 33554432 /* ComponentView */) === 0 ||
              ((/** @type {?} */ (renderParent.element)).componentRendererType &&
                  (/** @type {?} */ ((/** @type {?} */ (renderParent.element)).componentRendererType)).encapsulation ===
                      ViewEncapsulation$1.Native)) {
              // only children of non components, or children of components with native encapsulation should
              // be attached.
              return asElementData(view, (/** @type {?} */ (def.renderParent)).nodeIndex).renderElement;
          }
      }
      else {
          return renderHost;
      }
  }
  /** @type {?} */
  const DEFINITION_CACHE = new WeakMap();
  /**
   * @template D
   * @param {?} factory
   * @return {?}
   */
  function resolveDefinition(factory) {
      /** @type {?} */
      let value = (/** @type {?} */ ((/** @type {?} */ (DEFINITION_CACHE.get(factory)))));
      if (!value) {
          value = factory(() => NOOP);
          value.factory = factory;
          DEFINITION_CACHE.set(factory, value);
      }
      return value;
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function rootRenderNodes(view) {
      /** @type {?} */
      const renderNodes = [];
      visitRootRenderNodes(view, 0 /* Collect */, undefined, undefined, renderNodes);
      return renderNodes;
  }
  /**
   * @param {?} view
   * @param {?} action
   * @param {?} parentNode
   * @param {?} nextSibling
   * @param {?=} target
   * @return {?}
   */
  function visitRootRenderNodes(view, action, parentNode, nextSibling, target) {
      // We need to re-compute the parent node in case the nodes have been moved around manually
      if (action === 3 /* RemoveChild */) {
          parentNode = view.renderer.parentNode(renderNode(view, (/** @type {?} */ (view.def.lastRenderRootNode))));
      }
      visitSiblingRenderNodes(view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);
  }
  /**
   * @param {?} view
   * @param {?} action
   * @param {?} startIndex
   * @param {?} endIndex
   * @param {?} parentNode
   * @param {?} nextSibling
   * @param {?=} target
   * @return {?}
   */
  function visitSiblingRenderNodes(view, action, startIndex, endIndex, parentNode, nextSibling, target) {
      for (let i = startIndex; i <= endIndex; i++) {
          /** @type {?} */
          const nodeDef = view.def.nodes[i];
          if (nodeDef.flags & (1 /* TypeElement */ | 2 /* TypeText */ | 8 /* TypeNgContent */)) {
              visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target);
          }
          // jump to next sibling
          i += nodeDef.childCount;
      }
  }
  /**
   * @param {?} view
   * @param {?} ngContentIndex
   * @param {?} action
   * @param {?} parentNode
   * @param {?} nextSibling
   * @param {?=} target
   * @return {?}
   */
  function visitProjectedRenderNodes(view, ngContentIndex, action, parentNode, nextSibling, target) {
      /** @type {?} */
      let compView = view;
      while (compView && !isComponentView(compView)) {
          compView = compView.parent;
      }
      /** @type {?} */
      const hostView = (/** @type {?} */ (compView)).parent;
      /** @type {?} */
      const hostElDef = viewParentEl((/** @type {?} */ (compView)));
      /** @type {?} */
      const startIndex = (/** @type {?} */ (hostElDef)).nodeIndex + 1;
      /** @type {?} */
      const endIndex = (/** @type {?} */ (hostElDef)).nodeIndex + (/** @type {?} */ (hostElDef)).childCount;
      for (let i = startIndex; i <= endIndex; i++) {
          /** @type {?} */
          const nodeDef = (/** @type {?} */ (hostView)).def.nodes[i];
          if (nodeDef.ngContentIndex === ngContentIndex) {
              visitRenderNode((/** @type {?} */ (hostView)), nodeDef, action, parentNode, nextSibling, target);
          }
          // jump to next sibling
          i += nodeDef.childCount;
      }
      if (!(/** @type {?} */ (hostView)).parent) {
          // a root view
          /** @type {?} */
          const projectedNodes = view.root.projectableNodes[ngContentIndex];
          if (projectedNodes) {
              for (let i = 0; i < projectedNodes.length; i++) {
                  execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);
              }
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} action
   * @param {?} parentNode
   * @param {?} nextSibling
   * @param {?=} target
   * @return {?}
   */
  function visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target) {
      if (nodeDef.flags & 8 /* TypeNgContent */) {
          visitProjectedRenderNodes(view, (/** @type {?} */ (nodeDef.ngContent)).index, action, parentNode, nextSibling, target);
      }
      else {
          /** @type {?} */
          const rn = renderNode(view, nodeDef);
          if (action === 3 /* RemoveChild */ && (nodeDef.flags & 33554432 /* ComponentView */) &&
              (nodeDef.bindingFlags & 48 /* CatSyntheticProperty */)) {
              // Note: we might need to do both actions.
              if (nodeDef.bindingFlags & (16 /* SyntheticProperty */)) {
                  execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
              }
              if (nodeDef.bindingFlags & (32 /* SyntheticHostProperty */)) {
                  /** @type {?} */
                  const compView = asElementData(view, nodeDef.nodeIndex).componentView;
                  execRenderNodeAction(compView, rn, action, parentNode, nextSibling, target);
              }
          }
          else {
              execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
          }
          if (nodeDef.flags & 16777216 /* EmbeddedViews */) {
              /** @type {?} */
              const embeddedViews = (/** @type {?} */ (asElementData(view, nodeDef.nodeIndex).viewContainer))._embeddedViews;
              for (let k = 0; k < embeddedViews.length; k++) {
                  visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);
              }
          }
          if (nodeDef.flags & 1 /* TypeElement */ && !(/** @type {?} */ (nodeDef.element)).name) {
              visitSiblingRenderNodes(view, action, nodeDef.nodeIndex + 1, nodeDef.nodeIndex + nodeDef.childCount, parentNode, nextSibling, target);
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} renderNode
   * @param {?} action
   * @param {?} parentNode
   * @param {?} nextSibling
   * @param {?=} target
   * @return {?}
   */
  function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {
      /** @type {?} */
      const renderer = view.renderer;
      switch (action) {
          case 1 /* AppendChild */:
              renderer.appendChild(parentNode, renderNode);
              break;
          case 2 /* InsertBefore */:
              renderer.insertBefore(parentNode, renderNode, nextSibling);
              break;
          case 3 /* RemoveChild */:
              renderer.removeChild(parentNode, renderNode);
              break;
          case 0 /* Collect */:
              (/** @type {?} */ (target)).push(renderNode);
              break;
      }
  }
  /** @type {?} */
  const NS_PREFIX_RE = /^:([^:]+):(.+)$/;
  /**
   * @param {?} name
   * @return {?}
   */
  function splitNamespace(name) {
      if (name[0] === ':') {
          /** @type {?} */
          const match = (/** @type {?} */ (name.match(NS_PREFIX_RE)));
          return [match[1], match[2]];
      }
      return ['', name];
  }
  /**
   * @param {?} bindings
   * @return {?}
   */
  function calcBindingFlags(bindings) {
      /** @type {?} */
      let flags = 0;
      for (let i = 0; i < bindings.length; i++) {
          flags |= bindings[i].flags;
      }
      return flags;
  }
  /**
   * @param {?} valueCount
   * @param {?} constAndInterp
   * @return {?}
   */
  function interpolate$1(valueCount, constAndInterp) {
      /** @type {?} */
      let result = '';
      for (let i = 0; i < valueCount * 2; i = i + 2) {
          result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);
      }
      return result + constAndInterp[valueCount * 2];
  }
  /**
   * @param {?} valueCount
   * @param {?} c0
   * @param {?} a1
   * @param {?} c1
   * @param {?=} a2
   * @param {?=} c2
   * @param {?=} a3
   * @param {?=} c3
   * @param {?=} a4
   * @param {?=} c4
   * @param {?=} a5
   * @param {?=} c5
   * @param {?=} a6
   * @param {?=} c6
   * @param {?=} a7
   * @param {?=} c7
   * @param {?=} a8
   * @param {?=} c8
   * @param {?=} a9
   * @param {?=} c9
   * @return {?}
   */
  function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
      switch (valueCount) {
          case 1:
              return c0 + _toStringWithNull(a1) + c1;
          case 2:
              return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
          case 3:
              return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                  c3;
          case 4:
              return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                  c3 + _toStringWithNull(a4) + c4;
          case 5:
              return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                  c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
          case 6:
              return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                  c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
          case 7:
              return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                  c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                  c6 + _toStringWithNull(a7) + c7;
          case 8:
              return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                  c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                  c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
          case 9:
              return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
                  c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
                  c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
          default:
              throw new Error(`Does not support more than 9 expressions`);
      }
  }
  /**
   * @param {?} v
   * @return {?}
   */
  function _toStringWithNull(v) {
      return v != null ? v.toString() : '';
  }
  /** @type {?} */
  const EMPTY_ARRAY$4 = [];
  /** @type {?} */
  const EMPTY_MAP = {};

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} flags
   * @param {?} matchedQueriesDsl
   * @param {?} ngContentIndex
   * @param {?} childCount
   * @param {?=} handleEvent
   * @param {?=} templateFactory
   * @return {?}
   */
  function anchorDef(flags, matchedQueriesDsl, ngContentIndex, childCount, handleEvent, templateFactory) {
      flags |= 1 /* TypeElement */;
      const { matchedQueries, references, matchedQueryIds } = splitMatchedQueriesDsl(matchedQueriesDsl);
      /** @type {?} */
      const template = templateFactory ? resolveDefinition(templateFactory) : null;
      return {
          // will bet set by the view definition
          nodeIndex: -1,
          parent: null,
          renderParent: null,
          bindingIndex: -1,
          outputIndex: -1,
          // regular values
          flags,
          checkIndex: -1,
          childFlags: 0,
          directChildFlags: 0,
          childMatchedQueries: 0, matchedQueries, matchedQueryIds, references, ngContentIndex, childCount,
          bindings: [],
          bindingFlags: 0,
          outputs: [],
          element: {
              ns: null,
              name: null,
              attrs: null, template,
              componentProvider: null,
              componentView: null,
              componentRendererType: null,
              publicProviders: null,
              allProviders: null,
              handleEvent: handleEvent || NOOP
          },
          provider: null,
          text: null,
          query: null,
          ngContent: null
      };
  }
  /**
   * @param {?} checkIndex
   * @param {?} flags
   * @param {?} matchedQueriesDsl
   * @param {?} ngContentIndex
   * @param {?} childCount
   * @param {?} namespaceAndName
   * @param {?=} fixedAttrs
   * @param {?=} bindings
   * @param {?=} outputs
   * @param {?=} handleEvent
   * @param {?=} componentView
   * @param {?=} componentRendererType
   * @return {?}
   */
  function elementDef(checkIndex, flags, matchedQueriesDsl, ngContentIndex, childCount, namespaceAndName, fixedAttrs = [], bindings, outputs, handleEvent, componentView, componentRendererType) {
      if (!handleEvent) {
          handleEvent = NOOP;
      }
      const { matchedQueries, references, matchedQueryIds } = splitMatchedQueriesDsl(matchedQueriesDsl);
      /** @type {?} */
      let ns = (/** @type {?} */ (null));
      /** @type {?} */
      let name = (/** @type {?} */ (null));
      if (namespaceAndName) {
          [ns, name] = splitNamespace(namespaceAndName);
      }
      bindings = bindings || [];
      /** @type {?} */
      const bindingDefs = new Array(bindings.length);
      for (let i = 0; i < bindings.length; i++) {
          const [bindingFlags, namespaceAndName, suffixOrSecurityContext] = bindings[i];
          const [ns, name] = splitNamespace(namespaceAndName);
          /** @type {?} */
          let securityContext = (/** @type {?} */ (undefined));
          /** @type {?} */
          let suffix = (/** @type {?} */ (undefined));
          switch (bindingFlags & 15 /* Types */) {
              case 4 /* TypeElementStyle */:
                  suffix = (/** @type {?} */ (suffixOrSecurityContext));
                  break;
              case 1 /* TypeElementAttribute */:
              case 8 /* TypeProperty */:
                  securityContext = (/** @type {?} */ (suffixOrSecurityContext));
                  break;
          }
          bindingDefs[i] =
              { flags: bindingFlags, ns, name, nonMinifiedName: name, securityContext, suffix };
      }
      outputs = outputs || [];
      /** @type {?} */
      const outputDefs = new Array(outputs.length);
      for (let i = 0; i < outputs.length; i++) {
          const [target, eventName] = outputs[i];
          outputDefs[i] = {
              type: 0 /* ElementOutput */,
              target: (/** @type {?} */ (target)), eventName,
              propName: null
          };
      }
      fixedAttrs = fixedAttrs || [];
      /** @type {?} */
      const attrs = (/** @type {?} */ (fixedAttrs.map(([namespaceAndName, value]) => {
          const [ns, name] = splitNamespace(namespaceAndName);
          return [ns, name, value];
      })));
      componentRendererType = resolveRendererType2(componentRendererType);
      if (componentView) {
          flags |= 33554432 /* ComponentView */;
      }
      flags |= 1 /* TypeElement */;
      return {
          // will bet set by the view definition
          nodeIndex: -1,
          parent: null,
          renderParent: null,
          bindingIndex: -1,
          outputIndex: -1,
          // regular values
          checkIndex,
          flags,
          childFlags: 0,
          directChildFlags: 0,
          childMatchedQueries: 0, matchedQueries, matchedQueryIds, references, ngContentIndex, childCount,
          bindings: bindingDefs,
          bindingFlags: calcBindingFlags(bindingDefs),
          outputs: outputDefs,
          element: {
              ns,
              name,
              attrs,
              template: null,
              // will bet set by the view definition
              componentProvider: null,
              componentView: componentView || null,
              componentRendererType: componentRendererType,
              publicProviders: null,
              allProviders: null,
              handleEvent: handleEvent || NOOP,
          },
          provider: null,
          text: null,
          query: null,
          ngContent: null
      };
  }
  /**
   * @param {?} view
   * @param {?} renderHost
   * @param {?} def
   * @return {?}
   */
  function createElement(view, renderHost, def) {
      /** @type {?} */
      const elDef = (/** @type {?} */ (def.element));
      /** @type {?} */
      const rootSelectorOrNode = view.root.selectorOrNode;
      /** @type {?} */
      const renderer = view.renderer;
      /** @type {?} */
      let el;
      if (view.parent || !rootSelectorOrNode) {
          if (elDef.name) {
              el = renderer.createElement(elDef.name, elDef.ns);
          }
          else {
              el = renderer.createComment('');
          }
          /** @type {?} */
          const parentEl = getParentRenderElement(view, renderHost, def);
          if (parentEl) {
              renderer.appendChild(parentEl, el);
          }
      }
      else {
          // when using native Shadow DOM, do not clear the root element contents to allow slot projection
          /** @type {?} */
          const preserveContent = (!!elDef.componentRendererType &&
              elDef.componentRendererType.encapsulation === ViewEncapsulation$1.ShadowDom);
          el = renderer.selectRootElement(rootSelectorOrNode, preserveContent);
      }
      if (elDef.attrs) {
          for (let i = 0; i < elDef.attrs.length; i++) {
              const [ns, name, value] = elDef.attrs[i];
              renderer.setAttribute(el, name, value, ns);
          }
      }
      return el;
  }
  /**
   * @param {?} view
   * @param {?} compView
   * @param {?} def
   * @param {?} el
   * @return {?}
   */
  function listenToElementOutputs(view, compView, def, el) {
      for (let i = 0; i < def.outputs.length; i++) {
          /** @type {?} */
          const output = def.outputs[i];
          /** @type {?} */
          const handleEventClosure = renderEventHandlerClosure(view, def.nodeIndex, elementEventFullName$1(output.target, output.eventName));
          /** @type {?} */
          let listenTarget = output.target;
          /** @type {?} */
          let listenerView = view;
          if (output.target === 'component') {
              listenTarget = null;
              listenerView = compView;
          }
          /** @type {?} */
          const disposable = (/** @type {?} */ (listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure)));
          (/** @type {?} */ (view.disposables))[def.outputIndex + i] = disposable;
      }
  }
  /**
   * @param {?} view
   * @param {?} index
   * @param {?} eventName
   * @return {?}
   */
  function renderEventHandlerClosure(view, index, eventName) {
      return (event) => dispatchEvent(view, index, eventName, event);
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} v0
   * @param {?} v1
   * @param {?} v2
   * @param {?} v3
   * @param {?} v4
   * @param {?} v5
   * @param {?} v6
   * @param {?} v7
   * @param {?} v8
   * @param {?} v9
   * @return {?}
   */
  function checkAndUpdateElementInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const bindLen = def.bindings.length;
      /** @type {?} */
      let changed = false;
      if (bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0))
          changed = true;
      if (bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1))
          changed = true;
      if (bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2))
          changed = true;
      if (bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3))
          changed = true;
      if (bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4))
          changed = true;
      if (bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5))
          changed = true;
      if (bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6))
          changed = true;
      if (bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7))
          changed = true;
      if (bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8))
          changed = true;
      if (bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9))
          changed = true;
      return changed;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} values
   * @return {?}
   */
  function checkAndUpdateElementDynamic(view, def, values) {
      /** @type {?} */
      let changed = false;
      for (let i = 0; i < values.length; i++) {
          if (checkAndUpdateElementValue(view, def, i, values[i]))
              changed = true;
      }
      return changed;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} bindingIdx
   * @param {?} value
   * @return {?}
   */
  function checkAndUpdateElementValue(view, def, bindingIdx, value) {
      if (!checkAndUpdateBinding(view, def, bindingIdx, value)) {
          return false;
      }
      /** @type {?} */
      const binding = def.bindings[bindingIdx];
      /** @type {?} */
      const elData = asElementData(view, def.nodeIndex);
      /** @type {?} */
      const renderNode$$1 = elData.renderElement;
      /** @type {?} */
      const name = (/** @type {?} */ (binding.name));
      switch (binding.flags & 15 /* Types */) {
          case 1 /* TypeElementAttribute */:
              setElementAttribute(view, binding, renderNode$$1, binding.ns, name, value);
              break;
          case 2 /* TypeElementClass */:
              setElementClass(view, renderNode$$1, name, value);
              break;
          case 4 /* TypeElementStyle */:
              setElementStyle(view, binding, renderNode$$1, name, value);
              break;
          case 8 /* TypeProperty */:
              /** @type {?} */
              const bindView = (def.flags & 33554432 /* ComponentView */ &&
                  binding.flags & 32 /* SyntheticHostProperty */) ?
                  elData.componentView :
                  view;
              setElementProperty(bindView, binding, renderNode$$1, name, value);
              break;
      }
      return true;
  }
  /**
   * @param {?} view
   * @param {?} binding
   * @param {?} renderNode
   * @param {?} ns
   * @param {?} name
   * @param {?} value
   * @return {?}
   */
  function setElementAttribute(view, binding, renderNode$$1, ns, name, value) {
      /** @type {?} */
      const securityContext = binding.securityContext;
      /** @type {?} */
      let renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
      renderValue = renderValue != null ? renderValue.toString() : null;
      /** @type {?} */
      const renderer = view.renderer;
      if (value != null) {
          renderer.setAttribute(renderNode$$1, name, renderValue, ns);
      }
      else {
          renderer.removeAttribute(renderNode$$1, name, ns);
      }
  }
  /**
   * @param {?} view
   * @param {?} renderNode
   * @param {?} name
   * @param {?} value
   * @return {?}
   */
  function setElementClass(view, renderNode$$1, name, value) {
      /** @type {?} */
      const renderer = view.renderer;
      if (value) {
          renderer.addClass(renderNode$$1, name);
      }
      else {
          renderer.removeClass(renderNode$$1, name);
      }
  }
  /**
   * @param {?} view
   * @param {?} binding
   * @param {?} renderNode
   * @param {?} name
   * @param {?} value
   * @return {?}
   */
  function setElementStyle(view, binding, renderNode$$1, name, value) {
      /** @type {?} */
      let renderValue = view.root.sanitizer.sanitize(SecurityContext$1.STYLE, (/** @type {?} */ (value)));
      if (renderValue != null) {
          renderValue = renderValue.toString();
          /** @type {?} */
          const unit = binding.suffix;
          if (unit != null) {
              renderValue = renderValue + unit;
          }
      }
      else {
          renderValue = null;
      }
      /** @type {?} */
      const renderer = view.renderer;
      if (renderValue != null) {
          renderer.setStyle(renderNode$$1, name, renderValue);
      }
      else {
          renderer.removeStyle(renderNode$$1, name);
      }
  }
  /**
   * @param {?} view
   * @param {?} binding
   * @param {?} renderNode
   * @param {?} name
   * @param {?} value
   * @return {?}
   */
  function setElementProperty(view, binding, renderNode$$1, name, value) {
      /** @type {?} */
      const securityContext = binding.securityContext;
      /** @type {?} */
      let renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
      view.renderer.setProperty(renderNode$$1, name, renderValue);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const UNDEFINED_VALUE = new Object();
  /** @type {?} */
  const InjectorRefTokenKey = tokenKey(Injector);
  /** @type {?} */
  const INJECTORRefTokenKey = tokenKey(INJECTOR$1);
  /** @type {?} */
  const NgModuleRefTokenKey = tokenKey(NgModuleRef);
  /**
   * @param {?} flags
   * @param {?} token
   * @param {?} value
   * @param {?} deps
   * @return {?}
   */
  function moduleProvideDef(flags, token, value, deps) {
      // Need to resolve forwardRefs as e.g. for `useValue` we
      // lowered the expression and then stopped evaluating it,
      // i.e. also didn't unwrap it.
      value = resolveForwardRef$1(value);
      /** @type {?} */
      const depDefs = splitDepsDsl(deps, stringify$1(token));
      return {
          // will bet set by the module definition
          index: -1,
          deps: depDefs, flags, token, value
      };
  }
  /**
   * @param {?} providers
   * @return {?}
   */
  function moduleDef(providers) {
      /** @type {?} */
      const providersByKey = {};
      /** @type {?} */
      const modules = [];
      /** @type {?} */
      let isRoot = false;
      for (let i = 0; i < providers.length; i++) {
          /** @type {?} */
          const provider = providers[i];
          if (provider.token === APP_ROOT && provider.value === true) {
              isRoot = true;
          }
          if (provider.flags & 1073741824 /* TypeNgModule */) {
              modules.push(provider.token);
          }
          provider.index = i;
          providersByKey[tokenKey(provider.token)] = provider;
      }
      return {
          // Will be filled later...
          factory: null,
          providersByKey,
          providers,
          modules,
          isRoot,
      };
  }
  /**
   * @param {?} data
   * @return {?}
   */
  function initNgModule(data) {
      /** @type {?} */
      const def = data._def;
      /** @type {?} */
      const providers = data._providers = new Array(def.providers.length);
      for (let i = 0; i < def.providers.length; i++) {
          /** @type {?} */
          const provDef = def.providers[i];
          if (!(provDef.flags & 4096 /* LazyProvider */)) {
              // Make sure the provider has not been already initialized outside this loop.
              if (providers[i] === undefined) {
                  providers[i] = _createProviderInstance(data, provDef);
              }
          }
      }
  }
  /**
   * @param {?} data
   * @param {?} depDef
   * @param {?=} notFoundValue
   * @return {?}
   */
  function resolveNgModuleDep(data, depDef, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
      /** @type {?} */
      const former = setCurrentInjector(data);
      try {
          if (depDef.flags & 8 /* Value */) {
              return depDef.token;
          }
          if (depDef.flags & 2 /* Optional */) {
              notFoundValue = null;
          }
          if (depDef.flags & 1 /* SkipSelf */) {
              return data._parent.get(depDef.token, notFoundValue);
          }
          /** @type {?} */
          const tokenKey$$1 = depDef.tokenKey;
          switch (tokenKey$$1) {
              case InjectorRefTokenKey:
              case INJECTORRefTokenKey:
              case NgModuleRefTokenKey:
                  return data;
          }
          /** @type {?} */
          const providerDef = data._def.providersByKey[tokenKey$$1];
          /** @type {?} */
          let injectableDef;
          if (providerDef) {
              /** @type {?} */
              let providerInstance = data._providers[providerDef.index];
              if (providerInstance === undefined) {
                  providerInstance = data._providers[providerDef.index] =
                      _createProviderInstance(data, providerDef);
              }
              return providerInstance === UNDEFINED_VALUE ? undefined : providerInstance;
          }
          else if ((injectableDef = getInjectableDef(depDef.token)) && targetsModule(data, injectableDef)) {
              /** @type {?} */
              const index = data._providers.length;
              data._def.providersByKey[depDef.tokenKey] = {
                  flags: 1024 /* TypeFactoryProvider */ | 4096 /* LazyProvider */,
                  value: injectableDef.factory,
                  deps: [], index,
                  token: depDef.token,
              };
              data._providers[index] = UNDEFINED_VALUE;
              return (data._providers[index] =
                  _createProviderInstance(data, data._def.providersByKey[depDef.tokenKey]));
          }
          else if (depDef.flags & 4 /* Self */) {
              return notFoundValue;
          }
          return data._parent.get(depDef.token, notFoundValue);
      }
      finally {
          setCurrentInjector(former);
      }
  }
  /**
   * @param {?} ngModule
   * @param {?} scope
   * @return {?}
   */
  function moduleTransitivelyPresent(ngModule, scope) {
      return ngModule._def.modules.indexOf(scope) > -1;
  }
  /**
   * @param {?} ngModule
   * @param {?} def
   * @return {?}
   */
  function targetsModule(ngModule, def) {
      return def.providedIn != null && (moduleTransitivelyPresent(ngModule, def.providedIn) ||
          def.providedIn === 'root' && ngModule._def.isRoot);
  }
  /**
   * @param {?} ngModule
   * @param {?} providerDef
   * @return {?}
   */
  function _createProviderInstance(ngModule, providerDef) {
      /** @type {?} */
      let injectable;
      switch (providerDef.flags & 201347067 /* Types */) {
          case 512 /* TypeClassProvider */:
              injectable = _createClass(ngModule, providerDef.value, providerDef.deps);
              break;
          case 1024 /* TypeFactoryProvider */:
              injectable = _callFactory(ngModule, providerDef.value, providerDef.deps);
              break;
          case 2048 /* TypeUseExistingProvider */:
              injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);
              break;
          case 256 /* TypeValueProvider */:
              injectable = providerDef.value;
              break;
      }
      // The read of `ngOnDestroy` here is slightly expensive as it's megamorphic, so it should be
      // avoided if possible. The sequence of checks here determines whether ngOnDestroy needs to be
      // checked. It might not if the `injectable` isn't an object or if NodeFlags.OnDestroy is already
      // set (ngOnDestroy was detected statically).
      if (injectable !== UNDEFINED_VALUE && injectable != null && typeof injectable === 'object' &&
          !(providerDef.flags & 131072 /* OnDestroy */) && typeof injectable.ngOnDestroy === 'function') {
          providerDef.flags |= 131072 /* OnDestroy */;
      }
      return injectable === undefined ? UNDEFINED_VALUE : injectable;
  }
  /**
   * @param {?} ngModule
   * @param {?} ctor
   * @param {?} deps
   * @return {?}
   */
  function _createClass(ngModule, ctor, deps) {
      /** @type {?} */
      const len = deps.length;
      switch (len) {
          case 0:
              return new ctor();
          case 1:
              return new ctor(resolveNgModuleDep(ngModule, deps[0]));
          case 2:
              return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));
          case 3:
              return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));
          default:
              /** @type {?} */
              const depValues = new Array(len);
              for (let i = 0; i < len; i++) {
                  depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
              }
              return new ctor(...depValues);
      }
  }
  /**
   * @param {?} ngModule
   * @param {?} factory
   * @param {?} deps
   * @return {?}
   */
  function _callFactory(ngModule, factory, deps) {
      /** @type {?} */
      const len = deps.length;
      switch (len) {
          case 0:
              return factory();
          case 1:
              return factory(resolveNgModuleDep(ngModule, deps[0]));
          case 2:
              return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));
          case 3:
              return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));
          default:
              /** @type {?} */
              const depValues = Array(len);
              for (let i = 0; i < len; i++) {
                  depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
              }
              return factory(...depValues);
      }
  }
  /**
   * @param {?} ngModule
   * @param {?} lifecycles
   * @return {?}
   */
  function callNgModuleLifecycle(ngModule, lifecycles) {
      /** @type {?} */
      const def = ngModule._def;
      /** @type {?} */
      const destroyed = new Set();
      for (let i = 0; i < def.providers.length; i++) {
          /** @type {?} */
          const provDef = def.providers[i];
          if (provDef.flags & 131072 /* OnDestroy */) {
              /** @type {?} */
              const instance = ngModule._providers[i];
              if (instance && instance !== UNDEFINED_VALUE) {
                  /** @type {?} */
                  const onDestroy = instance.ngOnDestroy;
                  if (typeof onDestroy === 'function' && !destroyed.has(instance)) {
                      onDestroy.apply(instance);
                      destroyed.add(instance);
                  }
              }
          }
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} parentView
   * @param {?} elementData
   * @param {?} viewIndex
   * @param {?} view
   * @return {?}
   */
  function attachEmbeddedView(parentView, elementData, viewIndex, view) {
      /** @type {?} */
      let embeddedViews = (/** @type {?} */ (elementData.viewContainer))._embeddedViews;
      if (viewIndex === null || viewIndex === undefined) {
          viewIndex = embeddedViews.length;
      }
      view.viewContainerParent = parentView;
      addToArray(embeddedViews, (/** @type {?} */ (viewIndex)), view);
      attachProjectedView(elementData, view);
      Services.dirtyParentQueries(view);
      /** @type {?} */
      const prevView = (/** @type {?} */ (viewIndex)) > 0 ? embeddedViews[(/** @type {?} */ (viewIndex)) - 1] : null;
      renderAttachEmbeddedView(elementData, prevView, view);
  }
  /**
   * @param {?} vcElementData
   * @param {?} view
   * @return {?}
   */
  function attachProjectedView(vcElementData, view) {
      /** @type {?} */
      const dvcElementData = declaredViewContainer(view);
      if (!dvcElementData || dvcElementData === vcElementData ||
          view.state & 16 /* IsProjectedView */) {
          return;
      }
      // Note: For performance reasons, we
      // - add a view to template._projectedViews only 1x throughout its lifetime,
      //   and remove it not until the view is destroyed.
      //   (hard, as when a parent view is attached/detached we would need to attach/detach all
      //    nested projected views as well, even across component boundaries).
      // - don't track the insertion order of views in the projected views array
      //   (hard, as when the views of the same template are inserted different view containers)
      view.state |= 16 /* IsProjectedView */;
      /** @type {?} */
      let projectedViews = dvcElementData.template._projectedViews;
      if (!projectedViews) {
          projectedViews = dvcElementData.template._projectedViews = [];
      }
      projectedViews.push(view);
      // Note: we are changing the NodeDef here as we cannot calculate
      // the fact whether a template is used for projection during compilation.
      markNodeAsProjectedTemplate((/** @type {?} */ (view.parent)).def, (/** @type {?} */ (view.parentNodeDef)));
  }
  /**
   * @param {?} viewDef
   * @param {?} nodeDef
   * @return {?}
   */
  function markNodeAsProjectedTemplate(viewDef, nodeDef) {
      if (nodeDef.flags & 4 /* ProjectedTemplate */) {
          return;
      }
      viewDef.nodeFlags |= 4 /* ProjectedTemplate */;
      nodeDef.flags |= 4 /* ProjectedTemplate */;
      /** @type {?} */
      let parentNodeDef = nodeDef.parent;
      while (parentNodeDef) {
          parentNodeDef.childFlags |= 4 /* ProjectedTemplate */;
          parentNodeDef = parentNodeDef.parent;
      }
  }
  /**
   * @param {?} elementData
   * @param {?=} viewIndex
   * @return {?}
   */
  function detachEmbeddedView(elementData, viewIndex) {
      /** @type {?} */
      const embeddedViews = (/** @type {?} */ (elementData.viewContainer))._embeddedViews;
      if (viewIndex == null || viewIndex >= embeddedViews.length) {
          viewIndex = embeddedViews.length - 1;
      }
      if (viewIndex < 0) {
          return null;
      }
      /** @type {?} */
      const view = embeddedViews[viewIndex];
      view.viewContainerParent = null;
      removeFromArray(embeddedViews, viewIndex);
      // See attachProjectedView for why we don't update projectedViews here.
      Services.dirtyParentQueries(view);
      renderDetachView(view);
      return view;
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function detachProjectedView(view) {
      if (!(view.state & 16 /* IsProjectedView */)) {
          return;
      }
      /** @type {?} */
      const dvcElementData = declaredViewContainer(view);
      if (dvcElementData) {
          /** @type {?} */
          const projectedViews = dvcElementData.template._projectedViews;
          if (projectedViews) {
              removeFromArray(projectedViews, projectedViews.indexOf(view));
              Services.dirtyParentQueries(view);
          }
      }
  }
  /**
   * @param {?} elementData
   * @param {?} oldViewIndex
   * @param {?} newViewIndex
   * @return {?}
   */
  function moveEmbeddedView(elementData, oldViewIndex, newViewIndex) {
      /** @type {?} */
      const embeddedViews = (/** @type {?} */ (elementData.viewContainer))._embeddedViews;
      /** @type {?} */
      const view = embeddedViews[oldViewIndex];
      removeFromArray(embeddedViews, oldViewIndex);
      if (newViewIndex == null) {
          newViewIndex = embeddedViews.length;
      }
      addToArray(embeddedViews, newViewIndex, view);
      // Note: Don't need to change projectedViews as the order in there
      // as always invalid...
      Services.dirtyParentQueries(view);
      renderDetachView(view);
      /** @type {?} */
      const prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;
      renderAttachEmbeddedView(elementData, prevView, view);
      return view;
  }
  /**
   * @param {?} elementData
   * @param {?} prevView
   * @param {?} view
   * @return {?}
   */
  function renderAttachEmbeddedView(elementData, prevView, view) {
      /** @type {?} */
      const prevRenderNode = prevView ? renderNode(prevView, (/** @type {?} */ (prevView.def.lastRenderRootNode))) :
          elementData.renderElement;
      /** @type {?} */
      const parentNode = view.renderer.parentNode(prevRenderNode);
      /** @type {?} */
      const nextSibling = view.renderer.nextSibling(prevRenderNode);
      // Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!
      // However, browsers automatically do `appendChild` when there is no `nextSibling`.
      visitRootRenderNodes(view, 2 /* InsertBefore */, parentNode, nextSibling, undefined);
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function renderDetachView(view) {
      visitRootRenderNodes(view, 3 /* RemoveChild */, null, null, undefined);
  }
  /**
   * @param {?} arr
   * @param {?} index
   * @param {?} value
   * @return {?}
   */
  function addToArray(arr, index, value) {
      // perf: array.push is faster than array.splice!
      if (index >= arr.length) {
          arr.push(value);
      }
      else {
          arr.splice(index, 0, value);
      }
  }
  /**
   * @param {?} arr
   * @param {?} index
   * @return {?}
   */
  function removeFromArray(arr, index) {
      // perf: array.pop is faster than array.splice!
      if (index >= arr.length - 1) {
          arr.pop();
      }
      else {
          arr.splice(index, 1);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const EMPTY_CONTEXT = new Object();
  // Attention: this function is called as top level function.
  // Putting any logic in here will destroy closure tree shaking!
  /**
   * @param {?} selector
   * @param {?} componentType
   * @param {?} viewDefFactory
   * @param {?} inputs
   * @param {?} outputs
   * @param {?} ngContentSelectors
   * @return {?}
   */
  function createComponentFactory(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors) {
      return new ComponentFactory_(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);
  }
  /**
   * @param {?} componentFactory
   * @return {?}
   */
  function getComponentViewDefinitionFactory(componentFactory) {
      return ((/** @type {?} */ (componentFactory))).viewDefFactory;
  }
  class ComponentFactory_ extends ComponentFactory {
      /**
       * @param {?} selector
       * @param {?} componentType
       * @param {?} viewDefFactory
       * @param {?} _inputs
       * @param {?} _outputs
       * @param {?} ngContentSelectors
       */
      constructor(selector, componentType, viewDefFactory, _inputs, _outputs, ngContentSelectors) {
          // Attention: this ctor is called as top level function.
          // Putting any logic in here will destroy closure tree shaking!
          super();
          this.selector = selector;
          this.componentType = componentType;
          this._inputs = _inputs;
          this._outputs = _outputs;
          this.ngContentSelectors = ngContentSelectors;
          this.viewDefFactory = viewDefFactory;
      }
      /**
       * @return {?}
       */
      get inputs() {
          /** @type {?} */
          const inputsArr = [];
          /** @type {?} */
          const inputs = (/** @type {?} */ (this._inputs));
          for (let propName in inputs) {
              /** @type {?} */
              const templateName = inputs[propName];
              inputsArr.push({ propName, templateName });
          }
          return inputsArr;
      }
      /**
       * @return {?}
       */
      get outputs() {
          /** @type {?} */
          const outputsArr = [];
          for (let propName in this._outputs) {
              /** @type {?} */
              const templateName = this._outputs[propName];
              outputsArr.push({ propName, templateName });
          }
          return outputsArr;
      }
      /**
       * Creates a new component.
       * @param {?} injector
       * @param {?=} projectableNodes
       * @param {?=} rootSelectorOrNode
       * @param {?=} ngModule
       * @return {?}
       */
      create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
          if (!ngModule) {
              throw new Error('ngModule should be provided');
          }
          /** @type {?} */
          const viewDef = resolveDefinition(this.viewDefFactory);
          /** @type {?} */
          const componentNodeIndex = (/** @type {?} */ ((/** @type {?} */ (viewDef.nodes[0].element)).componentProvider)).nodeIndex;
          /** @type {?} */
          const view = Services.createRootView(injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);
          /** @type {?} */
          const component = asProviderData(view, componentNodeIndex).instance;
          if (rootSelectorOrNode) {
              view.renderer.setAttribute(asElementData(view, 0).renderElement, 'ng-version', VERSION$2.full);
          }
          return new ComponentRef_(view, new ViewRef_(view), component);
      }
  }
  class ComponentRef_ extends ComponentRef {
      /**
       * @param {?} _view
       * @param {?} _viewRef
       * @param {?} _component
       */
      constructor(_view, _viewRef, _component) {
          super();
          this._view = _view;
          this._viewRef = _viewRef;
          this._component = _component;
          this._elDef = this._view.def.nodes[0];
          this.hostView = _viewRef;
          this.changeDetectorRef = _viewRef;
          this.instance = _component;
      }
      /**
       * @return {?}
       */
      get location() {
          return new ElementRef(asElementData(this._view, this._elDef.nodeIndex).renderElement);
      }
      /**
       * @return {?}
       */
      get injector() { return new Injector_(this._view, this._elDef); }
      /**
       * @return {?}
       */
      get componentType() { return (/** @type {?} */ (this._component.constructor)); }
      /**
       * @return {?}
       */
      destroy() { this._viewRef.destroy(); }
      /**
       * @param {?} callback
       * @return {?}
       */
      onDestroy(callback) { this._viewRef.onDestroy(callback); }
  }
  /**
   * @param {?} view
   * @param {?} elDef
   * @param {?} elData
   * @return {?}
   */
  function createViewContainerData(view, elDef, elData) {
      return new ViewContainerRef_(view, elDef, elData);
  }
  class ViewContainerRef_ {
      /**
       * @param {?} _view
       * @param {?} _elDef
       * @param {?} _data
       */
      constructor(_view, _elDef, _data) {
          this._view = _view;
          this._elDef = _elDef;
          this._data = _data;
          /**
           * \@internal
           */
          this._embeddedViews = [];
      }
      /**
       * @return {?}
       */
      get element() { return new ElementRef(this._data.renderElement); }
      /**
       * @return {?}
       */
      get injector() { return new Injector_(this._view, this._elDef); }
      /**
       * @deprecated No replacement
       * @return {?}
       */
      get parentInjector() {
          /** @type {?} */
          let view = this._view;
          /** @type {?} */
          let elDef = this._elDef.parent;
          while (!elDef && view) {
              elDef = viewParentEl(view);
              view = (/** @type {?} */ (view.parent));
          }
          return view ? new Injector_(view, elDef) : new Injector_(this._view, null);
      }
      /**
       * @return {?}
       */
      clear() {
          /** @type {?} */
          const len = this._embeddedViews.length;
          for (let i = len - 1; i >= 0; i--) {
              /** @type {?} */
              const view = (/** @type {?} */ (detachEmbeddedView(this._data, i)));
              Services.destroyView(view);
          }
      }
      /**
       * @param {?} index
       * @return {?}
       */
      get(index) {
          /** @type {?} */
          const view = this._embeddedViews[index];
          if (view) {
              /** @type {?} */
              const ref = new ViewRef_(view);
              ref.attachToViewContainerRef(this);
              return ref;
          }
          return null;
      }
      /**
       * @return {?}
       */
      get length() { return this._embeddedViews.length; }
      /**
       * @template C
       * @param {?} templateRef
       * @param {?=} context
       * @param {?=} index
       * @return {?}
       */
      createEmbeddedView(templateRef, context, index) {
          /** @type {?} */
          const viewRef = templateRef.createEmbeddedView(context || (/** @type {?} */ ({})));
          this.insert(viewRef, index);
          return viewRef;
      }
      /**
       * @template C
       * @param {?} componentFactory
       * @param {?=} index
       * @param {?=} injector
       * @param {?=} projectableNodes
       * @param {?=} ngModuleRef
       * @return {?}
       */
      createComponent(componentFactory, index, injector, projectableNodes, ngModuleRef) {
          /** @type {?} */
          const contextInjector = injector || this.parentInjector;
          if (!ngModuleRef && !(componentFactory instanceof ComponentFactoryBoundToModule)) {
              ngModuleRef = contextInjector.get(NgModuleRef);
          }
          /** @type {?} */
          const componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);
          this.insert(componentRef.hostView, index);
          return componentRef;
      }
      /**
       * @param {?} viewRef
       * @param {?=} index
       * @return {?}
       */
      insert(viewRef, index) {
          if (viewRef.destroyed) {
              throw new Error('Cannot insert a destroyed View in a ViewContainer!');
          }
          /** @type {?} */
          const viewRef_ = (/** @type {?} */ (viewRef));
          /** @type {?} */
          const viewData = viewRef_._view;
          attachEmbeddedView(this._view, this._data, index, viewData);
          viewRef_.attachToViewContainerRef(this);
          return viewRef;
      }
      /**
       * @param {?} viewRef
       * @param {?} currentIndex
       * @return {?}
       */
      move(viewRef, currentIndex) {
          if (viewRef.destroyed) {
              throw new Error('Cannot move a destroyed View in a ViewContainer!');
          }
          /** @type {?} */
          const previousIndex = this._embeddedViews.indexOf(viewRef._view);
          moveEmbeddedView(this._data, previousIndex, currentIndex);
          return viewRef;
      }
      /**
       * @param {?} viewRef
       * @return {?}
       */
      indexOf(viewRef) {
          return this._embeddedViews.indexOf(((/** @type {?} */ (viewRef)))._view);
      }
      /**
       * @param {?=} index
       * @return {?}
       */
      remove(index) {
          /** @type {?} */
          const viewData = detachEmbeddedView(this._data, index);
          if (viewData) {
              Services.destroyView(viewData);
          }
      }
      /**
       * @param {?=} index
       * @return {?}
       */
      detach(index) {
          /** @type {?} */
          const view = detachEmbeddedView(this._data, index);
          return view ? new ViewRef_(view) : null;
      }
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function createChangeDetectorRef(view) {
      return new ViewRef_(view);
  }
  class ViewRef_ {
      /**
       * @param {?} _view
       */
      constructor(_view) {
          this._view = _view;
          this._viewContainerRef = null;
          this._appRef = null;
      }
      /**
       * @return {?}
       */
      get rootNodes() { return rootRenderNodes(this._view); }
      /**
       * @return {?}
       */
      get context() { return this._view.context; }
      /**
       * @return {?}
       */
      get destroyed() { return (this._view.state & 128 /* Destroyed */) !== 0; }
      /**
       * @return {?}
       */
      markForCheck() { markParentViewsForCheck(this._view); }
      /**
       * @return {?}
       */
      detach() { this._view.state &= ~4 /* Attached */; }
      /**
       * @return {?}
       */
      detectChanges() {
          /** @type {?} */
          const fs = this._view.root.rendererFactory;
          if (fs.begin) {
              fs.begin();
          }
          try {
              Services.checkAndUpdateView(this._view);
          }
          finally {
              if (fs.end) {
                  fs.end();
              }
          }
      }
      /**
       * @return {?}
       */
      checkNoChanges() { Services.checkNoChangesView(this._view); }
      /**
       * @return {?}
       */
      reattach() { this._view.state |= 4 /* Attached */; }
      /**
       * @param {?} callback
       * @return {?}
       */
      onDestroy(callback) {
          if (!this._view.disposables) {
              this._view.disposables = [];
          }
          this._view.disposables.push((/** @type {?} */ (callback)));
      }
      /**
       * @return {?}
       */
      destroy() {
          if (this._appRef) {
              this._appRef.detachView(this);
          }
          else if (this._viewContainerRef) {
              this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));
          }
          Services.destroyView(this._view);
      }
      /**
       * @return {?}
       */
      detachFromAppRef() {
          this._appRef = null;
          renderDetachView(this._view);
          Services.dirtyParentQueries(this._view);
      }
      /**
       * @param {?} appRef
       * @return {?}
       */
      attachToAppRef(appRef) {
          if (this._viewContainerRef) {
              throw new Error('This view is already attached to a ViewContainer!');
          }
          this._appRef = appRef;
      }
      /**
       * @param {?} vcRef
       * @return {?}
       */
      attachToViewContainerRef(vcRef) {
          if (this._appRef) {
              throw new Error('This view is already attached directly to the ApplicationRef!');
          }
          this._viewContainerRef = vcRef;
      }
  }
  /**
   * @param {?} view
   * @param {?} def
   * @return {?}
   */
  function createTemplateData(view, def) {
      return new TemplateRef_(view, def);
  }
  class TemplateRef_ extends TemplateRef {
      /**
       * @param {?} _parentView
       * @param {?} _def
       */
      constructor(_parentView, _def) {
          super();
          this._parentView = _parentView;
          this._def = _def;
      }
      /**
       * @param {?} context
       * @return {?}
       */
      createEmbeddedView(context) {
          return new ViewRef_(Services.createEmbeddedView(this._parentView, this._def, (/** @type {?} */ ((/** @type {?} */ (this._def.element)).template)), context));
      }
      /**
       * @return {?}
       */
      get elementRef() {
          return new ElementRef(asElementData(this._parentView, this._def.nodeIndex).renderElement);
      }
  }
  /**
   * @param {?} view
   * @param {?} elDef
   * @return {?}
   */
  function createInjector$1(view, elDef) {
      return new Injector_(view, elDef);
  }
  class Injector_ {
      /**
       * @param {?} view
       * @param {?} elDef
       */
      constructor(view, elDef) {
          this.view = view;
          this.elDef = elDef;
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */
      get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
          /** @type {?} */
          const allowPrivateServices = this.elDef ? (this.elDef.flags & 33554432 /* ComponentView */) !== 0 : false;
          return Services.resolveDep(this.view, this.elDef, allowPrivateServices, { flags: 0 /* None */, token, tokenKey: tokenKey(token) }, notFoundValue);
      }
  }
  /**
   * @param {?} view
   * @param {?} index
   * @return {?}
   */
  function nodeValue(view, index) {
      /** @type {?} */
      const def = view.def.nodes[index];
      if (def.flags & 1 /* TypeElement */) {
          /** @type {?} */
          const elData = asElementData(view, def.nodeIndex);
          return (/** @type {?} */ (def.element)).template ? elData.template : elData.renderElement;
      }
      else if (def.flags & 2 /* TypeText */) {
          return asTextData(view, def.nodeIndex).renderText;
      }
      else if (def.flags & (20224 /* CatProvider */ | 16 /* TypePipe */)) {
          return asProviderData(view, def.nodeIndex).instance;
      }
      throw new Error(`Illegal state: read nodeValue for node index ${index}`);
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function createRendererV1(view) {
      return new RendererAdapter(view.renderer);
  }
  class RendererAdapter {
      /**
       * @param {?} delegate
       */
      constructor(delegate) {
          this.delegate = delegate;
      }
      /**
       * @param {?} selectorOrNode
       * @return {?}
       */
      selectRootElement(selectorOrNode) {
          return this.delegate.selectRootElement(selectorOrNode);
      }
      /**
       * @param {?} parent
       * @param {?} namespaceAndName
       * @return {?}
       */
      createElement(parent, namespaceAndName) {
          const [ns, name] = splitNamespace(namespaceAndName);
          /** @type {?} */
          const el = this.delegate.createElement(name, ns);
          if (parent) {
              this.delegate.appendChild(parent, el);
          }
          return el;
      }
      /**
       * @param {?} hostElement
       * @return {?}
       */
      createViewRoot(hostElement) { return hostElement; }
      /**
       * @param {?} parentElement
       * @return {?}
       */
      createTemplateAnchor(parentElement) {
          /** @type {?} */
          const comment = this.delegate.createComment('');
          if (parentElement) {
              this.delegate.appendChild(parentElement, comment);
          }
          return comment;
      }
      /**
       * @param {?} parentElement
       * @param {?} value
       * @return {?}
       */
      createText(parentElement, value) {
          /** @type {?} */
          const node = this.delegate.createText(value);
          if (parentElement) {
              this.delegate.appendChild(parentElement, node);
          }
          return node;
      }
      /**
       * @param {?} parentElement
       * @param {?} nodes
       * @return {?}
       */
      projectNodes(parentElement, nodes) {
          for (let i = 0; i < nodes.length; i++) {
              this.delegate.appendChild(parentElement, nodes[i]);
          }
      }
      /**
       * @param {?} node
       * @param {?} viewRootNodes
       * @return {?}
       */
      attachViewAfter(node, viewRootNodes) {
          /** @type {?} */
          const parentElement = this.delegate.parentNode(node);
          /** @type {?} */
          const nextSibling = this.delegate.nextSibling(node);
          for (let i = 0; i < viewRootNodes.length; i++) {
              this.delegate.insertBefore(parentElement, viewRootNodes[i], nextSibling);
          }
      }
      /**
       * @param {?} viewRootNodes
       * @return {?}
       */
      detachView(viewRootNodes) {
          for (let i = 0; i < viewRootNodes.length; i++) {
              /** @type {?} */
              const node = viewRootNodes[i];
              /** @type {?} */
              const parentElement = this.delegate.parentNode(node);
              this.delegate.removeChild(parentElement, node);
          }
      }
      /**
       * @param {?} hostElement
       * @param {?} viewAllNodes
       * @return {?}
       */
      destroyView(hostElement, viewAllNodes) {
          for (let i = 0; i < viewAllNodes.length; i++) {
              (/** @type {?} */ (this.delegate.destroyNode))(viewAllNodes[i]);
          }
      }
      /**
       * @param {?} renderElement
       * @param {?} name
       * @param {?} callback
       * @return {?}
       */
      listen(renderElement, name, callback) {
          return this.delegate.listen(renderElement, name, (/** @type {?} */ (callback)));
      }
      /**
       * @param {?} target
       * @param {?} name
       * @param {?} callback
       * @return {?}
       */
      listenGlobal(target, name, callback) {
          return this.delegate.listen(target, name, (/** @type {?} */ (callback)));
      }
      /**
       * @param {?} renderElement
       * @param {?} propertyName
       * @param {?} propertyValue
       * @return {?}
       */
      setElementProperty(renderElement, propertyName, propertyValue) {
          this.delegate.setProperty(renderElement, propertyName, propertyValue);
      }
      /**
       * @param {?} renderElement
       * @param {?} namespaceAndName
       * @param {?=} attributeValue
       * @return {?}
       */
      setElementAttribute(renderElement, namespaceAndName, attributeValue) {
          const [ns, name] = splitNamespace(namespaceAndName);
          if (attributeValue != null) {
              this.delegate.setAttribute(renderElement, name, attributeValue, ns);
          }
          else {
              this.delegate.removeAttribute(renderElement, name, ns);
          }
      }
      /**
       * @param {?} renderElement
       * @param {?} propertyName
       * @param {?} propertyValue
       * @return {?}
       */
      setBindingDebugInfo(renderElement, propertyName, propertyValue) { }
      /**
       * @param {?} renderElement
       * @param {?} className
       * @param {?} isAdd
       * @return {?}
       */
      setElementClass(renderElement, className, isAdd) {
          if (isAdd) {
              this.delegate.addClass(renderElement, className);
          }
          else {
              this.delegate.removeClass(renderElement, className);
          }
      }
      /**
       * @param {?} renderElement
       * @param {?} styleName
       * @param {?=} styleValue
       * @return {?}
       */
      setElementStyle(renderElement, styleName, styleValue) {
          if (styleValue != null) {
              this.delegate.setStyle(renderElement, styleName, styleValue);
          }
          else {
              this.delegate.removeStyle(renderElement, styleName);
          }
      }
      /**
       * @param {?} renderElement
       * @param {?} methodName
       * @param {?} args
       * @return {?}
       */
      invokeElementMethod(renderElement, methodName, args) {
          ((/** @type {?} */ (renderElement)))[methodName].apply(renderElement, args);
      }
      /**
       * @param {?} renderNode
       * @param {?} text
       * @return {?}
       */
      setText(renderNode$$1, text) { this.delegate.setValue(renderNode$$1, text); }
      /**
       * @return {?}
       */
      animate() { throw new Error('Renderer.animate is no longer supported!'); }
  }
  /**
   * @param {?} moduleType
   * @param {?} parent
   * @param {?} bootstrapComponents
   * @param {?} def
   * @return {?}
   */
  function createNgModuleRef(moduleType, parent, bootstrapComponents, def) {
      return new NgModuleRef_(moduleType, parent, bootstrapComponents, def);
  }
  class NgModuleRef_ {
      /**
       * @param {?} _moduleType
       * @param {?} _parent
       * @param {?} _bootstrapComponents
       * @param {?} _def
       */
      constructor(_moduleType, _parent, _bootstrapComponents, _def) {
          this._moduleType = _moduleType;
          this._parent = _parent;
          this._bootstrapComponents = _bootstrapComponents;
          this._def = _def;
          this._destroyListeners = [];
          this._destroyed = false;
          this.injector = this;
          initNgModule(this);
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @param {?=} injectFlags
       * @return {?}
       */
      get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
          /** @type {?} */
          let flags = 0 /* None */;
          if (injectFlags & InjectFlags.SkipSelf) {
              flags |= 1 /* SkipSelf */;
          }
          else if (injectFlags & InjectFlags.Self) {
              flags |= 4 /* Self */;
          }
          return resolveNgModuleDep(this, { token: token, tokenKey: tokenKey(token), flags: flags }, notFoundValue);
      }
      /**
       * @return {?}
       */
      get instance() { return this.get(this._moduleType); }
      /**
       * @return {?}
       */
      get componentFactoryResolver() { return this.get(ComponentFactoryResolver); }
      /**
       * @return {?}
       */
      destroy() {
          if (this._destroyed) {
              throw new Error(`The ng module ${stringify$1(this.instance.constructor)} has already been destroyed.`);
          }
          this._destroyed = true;
          callNgModuleLifecycle(this, 131072 /* OnDestroy */);
          this._destroyListeners.forEach((listener) => listener());
      }
      /**
       * @param {?} callback
       * @return {?}
       */
      onDestroy(callback) { this._destroyListeners.push(callback); }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const RendererV1TokenKey = tokenKey(Renderer);
  /** @type {?} */
  const Renderer2TokenKey = tokenKey(Renderer2);
  /** @type {?} */
  const ElementRefTokenKey = tokenKey(ElementRef);
  /** @type {?} */
  const ViewContainerRefTokenKey = tokenKey(ViewContainerRef);
  /** @type {?} */
  const TemplateRefTokenKey = tokenKey(TemplateRef);
  /** @type {?} */
  const ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);
  /** @type {?} */
  const InjectorRefTokenKey$1 = tokenKey(Injector);
  /** @type {?} */
  const INJECTORRefTokenKey$1 = tokenKey(INJECTOR$1);
  /**
   * @param {?} checkIndex
   * @param {?} flags
   * @param {?} matchedQueries
   * @param {?} childCount
   * @param {?} ctor
   * @param {?} deps
   * @param {?=} props
   * @param {?=} outputs
   * @return {?}
   */
  function directiveDef(checkIndex, flags, matchedQueries, childCount, ctor, deps, props, outputs) {
      /** @type {?} */
      const bindings = [];
      if (props) {
          for (let prop in props) {
              const [bindingIndex, nonMinifiedName] = props[prop];
              bindings[bindingIndex] = {
                  flags: 8 /* TypeProperty */,
                  name: prop, nonMinifiedName,
                  ns: null,
                  securityContext: null,
                  suffix: null
              };
          }
      }
      /** @type {?} */
      const outputDefs = [];
      if (outputs) {
          for (let propName in outputs) {
              outputDefs.push({ type: 1 /* DirectiveOutput */, propName, target: null, eventName: outputs[propName] });
          }
      }
      flags |= 16384 /* TypeDirective */;
      return _def(checkIndex, flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);
  }
  /**
   * @param {?} flags
   * @param {?} ctor
   * @param {?} deps
   * @return {?}
   */
  function pipeDef(flags, ctor, deps) {
      flags |= 16 /* TypePipe */;
      return _def(-1, flags, null, 0, ctor, ctor, deps);
  }
  /**
   * @param {?} flags
   * @param {?} matchedQueries
   * @param {?} token
   * @param {?} value
   * @param {?} deps
   * @return {?}
   */
  function providerDef$1(flags, matchedQueries, token, value, deps) {
      return _def(-1, flags, matchedQueries, 0, token, value, deps);
  }
  /**
   * @param {?} checkIndex
   * @param {?} flags
   * @param {?} matchedQueriesDsl
   * @param {?} childCount
   * @param {?} token
   * @param {?} value
   * @param {?} deps
   * @param {?=} bindings
   * @param {?=} outputs
   * @return {?}
   */
  function _def(checkIndex, flags, matchedQueriesDsl, childCount, token, value, deps, bindings, outputs) {
      const { matchedQueries, references, matchedQueryIds } = splitMatchedQueriesDsl(matchedQueriesDsl);
      if (!outputs) {
          outputs = [];
      }
      if (!bindings) {
          bindings = [];
      }
      // Need to resolve forwardRefs as e.g. for `useValue` we
      // lowered the expression and then stopped evaluating it,
      // i.e. also didn't unwrap it.
      value = resolveForwardRef$1(value);
      /** @type {?} */
      const depDefs = splitDepsDsl(deps, stringify$1(token));
      return {
          // will bet set by the view definition
          nodeIndex: -1,
          parent: null,
          renderParent: null,
          bindingIndex: -1,
          outputIndex: -1,
          // regular values
          checkIndex,
          flags,
          childFlags: 0,
          directChildFlags: 0,
          childMatchedQueries: 0, matchedQueries, matchedQueryIds, references,
          ngContentIndex: -1, childCount, bindings,
          bindingFlags: calcBindingFlags(bindings), outputs,
          element: null,
          provider: { token, value, deps: depDefs },
          text: null,
          query: null,
          ngContent: null
      };
  }
  /**
   * @param {?} view
   * @param {?} def
   * @return {?}
   */
  function createProviderInstance(view, def) {
      return _createProviderInstance$1(view, def);
  }
  /**
   * @param {?} view
   * @param {?} def
   * @return {?}
   */
  function createPipeInstance(view, def) {
      // deps are looked up from component.
      /** @type {?} */
      let compView = view;
      while (compView.parent && !isComponentView(compView)) {
          compView = compView.parent;
      }
      // pipes can see the private services of the component
      /** @type {?} */
      const allowPrivateServices = true;
      // pipes are always eager and classes!
      return createClass((/** @type {?} */ (compView.parent)), (/** @type {?} */ (viewParentEl(compView))), allowPrivateServices, (/** @type {?} */ (def.provider)).value, (/** @type {?} */ (def.provider)).deps);
  }
  /**
   * @param {?} view
   * @param {?} def
   * @return {?}
   */
  function createDirectiveInstance(view, def) {
      // components can see other private services, other directives can't.
      /** @type {?} */
      const allowPrivateServices = (def.flags & 32768 /* Component */) > 0;
      // directives are always eager and classes!
      /** @type {?} */
      const instance = createClass(view, (/** @type {?} */ (def.parent)), allowPrivateServices, (/** @type {?} */ (def.provider)).value, (/** @type {?} */ (def.provider)).deps);
      if (def.outputs.length) {
          for (let i = 0; i < def.outputs.length; i++) {
              /** @type {?} */
              const output = def.outputs[i];
              /** @type {?} */
              const outputObservable = instance[(/** @type {?} */ (output.propName))];
              if (isObservable$1(outputObservable)) {
                  /** @type {?} */
                  const subscription = outputObservable.subscribe(eventHandlerClosure(view, (/** @type {?} */ (def.parent)).nodeIndex, output.eventName));
                  (/** @type {?} */ (view.disposables))[def.outputIndex + i] = subscription.unsubscribe.bind(subscription);
              }
              else {
                  throw new Error(`@Output ${output.propName} not initialized in '${instance.constructor.name}'.`);
              }
          }
      }
      return instance;
  }
  /**
   * @param {?} view
   * @param {?} index
   * @param {?} eventName
   * @return {?}
   */
  function eventHandlerClosure(view, index, eventName) {
      return (event) => dispatchEvent(view, index, eventName, event);
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} v0
   * @param {?} v1
   * @param {?} v2
   * @param {?} v3
   * @param {?} v4
   * @param {?} v5
   * @param {?} v6
   * @param {?} v7
   * @param {?} v8
   * @param {?} v9
   * @return {?}
   */
  function checkAndUpdateDirectiveInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const providerData = asProviderData(view, def.nodeIndex);
      /** @type {?} */
      const directive = providerData.instance;
      /** @type {?} */
      let changed = false;
      /** @type {?} */
      let changes = (/** @type {?} */ (undefined));
      /** @type {?} */
      const bindLen = def.bindings.length;
      if (bindLen > 0 && checkBinding(view, def, 0, v0)) {
          changed = true;
          changes = updateProp(view, providerData, def, 0, v0, changes);
      }
      if (bindLen > 1 && checkBinding(view, def, 1, v1)) {
          changed = true;
          changes = updateProp(view, providerData, def, 1, v1, changes);
      }
      if (bindLen > 2 && checkBinding(view, def, 2, v2)) {
          changed = true;
          changes = updateProp(view, providerData, def, 2, v2, changes);
      }
      if (bindLen > 3 && checkBinding(view, def, 3, v3)) {
          changed = true;
          changes = updateProp(view, providerData, def, 3, v3, changes);
      }
      if (bindLen > 4 && checkBinding(view, def, 4, v4)) {
          changed = true;
          changes = updateProp(view, providerData, def, 4, v4, changes);
      }
      if (bindLen > 5 && checkBinding(view, def, 5, v5)) {
          changed = true;
          changes = updateProp(view, providerData, def, 5, v5, changes);
      }
      if (bindLen > 6 && checkBinding(view, def, 6, v6)) {
          changed = true;
          changes = updateProp(view, providerData, def, 6, v6, changes);
      }
      if (bindLen > 7 && checkBinding(view, def, 7, v7)) {
          changed = true;
          changes = updateProp(view, providerData, def, 7, v7, changes);
      }
      if (bindLen > 8 && checkBinding(view, def, 8, v8)) {
          changed = true;
          changes = updateProp(view, providerData, def, 8, v8, changes);
      }
      if (bindLen > 9 && checkBinding(view, def, 9, v9)) {
          changed = true;
          changes = updateProp(view, providerData, def, 9, v9, changes);
      }
      if (changes) {
          directive.ngOnChanges(changes);
      }
      if ((def.flags & 65536 /* OnInit */) &&
          shouldCallLifecycleInitHook(view, 256 /* InitState_CallingOnInit */, def.nodeIndex)) {
          directive.ngOnInit();
      }
      if (def.flags & 262144 /* DoCheck */) {
          directive.ngDoCheck();
      }
      return changed;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} values
   * @return {?}
   */
  function checkAndUpdateDirectiveDynamic(view, def, values) {
      /** @type {?} */
      const providerData = asProviderData(view, def.nodeIndex);
      /** @type {?} */
      const directive = providerData.instance;
      /** @type {?} */
      let changed = false;
      /** @type {?} */
      let changes = (/** @type {?} */ (undefined));
      for (let i = 0; i < values.length; i++) {
          if (checkBinding(view, def, i, values[i])) {
              changed = true;
              changes = updateProp(view, providerData, def, i, values[i], changes);
          }
      }
      if (changes) {
          directive.ngOnChanges(changes);
      }
      if ((def.flags & 65536 /* OnInit */) &&
          shouldCallLifecycleInitHook(view, 256 /* InitState_CallingOnInit */, def.nodeIndex)) {
          directive.ngOnInit();
      }
      if (def.flags & 262144 /* DoCheck */) {
          directive.ngDoCheck();
      }
      return changed;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @return {?}
   */
  function _createProviderInstance$1(view, def) {
      // private services can see other private services
      /** @type {?} */
      const allowPrivateServices = (def.flags & 8192 /* PrivateProvider */) > 0;
      /** @type {?} */
      const providerDef = def.provider;
      switch (def.flags & 201347067 /* Types */) {
          case 512 /* TypeClassProvider */:
              return createClass(view, (/** @type {?} */ (def.parent)), allowPrivateServices, (/** @type {?} */ (providerDef)).value, (/** @type {?} */ (providerDef)).deps);
          case 1024 /* TypeFactoryProvider */:
              return callFactory(view, (/** @type {?} */ (def.parent)), allowPrivateServices, (/** @type {?} */ (providerDef)).value, (/** @type {?} */ (providerDef)).deps);
          case 2048 /* TypeUseExistingProvider */:
              return resolveDep(view, (/** @type {?} */ (def.parent)), allowPrivateServices, (/** @type {?} */ (providerDef)).deps[0]);
          case 256 /* TypeValueProvider */:
              return (/** @type {?} */ (providerDef)).value;
      }
  }
  /**
   * @param {?} view
   * @param {?} elDef
   * @param {?} allowPrivateServices
   * @param {?} ctor
   * @param {?} deps
   * @return {?}
   */
  function createClass(view, elDef, allowPrivateServices, ctor, deps) {
      /** @type {?} */
      const len = deps.length;
      switch (len) {
          case 0:
              return new ctor();
          case 1:
              return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));
          case 2:
              return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));
          case 3:
              return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));
          default:
              /** @type {?} */
              const depValues = new Array(len);
              for (let i = 0; i < len; i++) {
                  depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
              }
              return new ctor(...depValues);
      }
  }
  /**
   * @param {?} view
   * @param {?} elDef
   * @param {?} allowPrivateServices
   * @param {?} factory
   * @param {?} deps
   * @return {?}
   */
  function callFactory(view, elDef, allowPrivateServices, factory, deps) {
      /** @type {?} */
      const len = deps.length;
      switch (len) {
          case 0:
              return factory();
          case 1:
              return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));
          case 2:
              return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));
          case 3:
              return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));
          default:
              /** @type {?} */
              const depValues = Array(len);
              for (let i = 0; i < len; i++) {
                  depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
              }
              return factory(...depValues);
      }
  }
  // This default value is when checking the hierarchy for a token.
  //
  // It means both:
  // - the token is not provided by the current injector,
  // - only the element injectors should be checked (ie do not check module injectors
  //
  //          mod1
  //         /
  //       el1   mod2
  //         \  /
  //         el2
  //
  // When requesting el2.injector.get(token), we should check in the following order and return the
  // first found value:
  // - el2.injector.get(token, default)
  // - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module
  // - mod2.injector.get(token, default)
  /** @type {?} */
  const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR$1 = {};
  /**
   * @param {?} view
   * @param {?} elDef
   * @param {?} allowPrivateServices
   * @param {?} depDef
   * @param {?=} notFoundValue
   * @return {?}
   */
  function resolveDep(view, elDef, allowPrivateServices, depDef, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
      if (depDef.flags & 8 /* Value */) {
          return depDef.token;
      }
      /** @type {?} */
      const startView = view;
      if (depDef.flags & 2 /* Optional */) {
          notFoundValue = null;
      }
      /** @type {?} */
      const tokenKey$$1 = depDef.tokenKey;
      if (tokenKey$$1 === ChangeDetectorRefTokenKey) {
          // directives on the same element as a component should be able to control the change detector
          // of that component as well.
          allowPrivateServices = !!(elDef && (/** @type {?} */ (elDef.element)).componentView);
      }
      if (elDef && (depDef.flags & 1 /* SkipSelf */)) {
          allowPrivateServices = false;
          elDef = (/** @type {?} */ (elDef.parent));
      }
      /** @type {?} */
      let searchView = view;
      while (searchView) {
          if (elDef) {
              switch (tokenKey$$1) {
                  case RendererV1TokenKey: {
                      /** @type {?} */
                      const compView = findCompView(searchView, elDef, allowPrivateServices);
                      return createRendererV1(compView);
                  }
                  case Renderer2TokenKey: {
                      /** @type {?} */
                      const compView = findCompView(searchView, elDef, allowPrivateServices);
                      return compView.renderer;
                  }
                  case ElementRefTokenKey:
                      return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);
                  case ViewContainerRefTokenKey:
                      return asElementData(searchView, elDef.nodeIndex).viewContainer;
                  case TemplateRefTokenKey: {
                      if ((/** @type {?} */ (elDef.element)).template) {
                          return asElementData(searchView, elDef.nodeIndex).template;
                      }
                      break;
                  }
                  case ChangeDetectorRefTokenKey: {
                      /** @type {?} */
                      let cdView = findCompView(searchView, elDef, allowPrivateServices);
                      return createChangeDetectorRef(cdView);
                  }
                  case InjectorRefTokenKey$1:
                  case INJECTORRefTokenKey$1:
                      return createInjector$1(searchView, elDef);
                  default:
                      /** @type {?} */
                      const providerDef = (/** @type {?} */ ((allowPrivateServices ? (/** @type {?} */ (elDef.element)).allProviders :
                          (/** @type {?} */ (elDef.element)).publicProviders)))[tokenKey$$1];
                      if (providerDef) {
                          /** @type {?} */
                          let providerData = asProviderData(searchView, providerDef.nodeIndex);
                          if (!providerData) {
                              providerData = { instance: _createProviderInstance$1(searchView, providerDef) };
                              searchView.nodes[providerDef.nodeIndex] = (/** @type {?} */ (providerData));
                          }
                          return providerData.instance;
                      }
              }
          }
          allowPrivateServices = isComponentView(searchView);
          elDef = (/** @type {?} */ (viewParentEl(searchView)));
          searchView = (/** @type {?} */ (searchView.parent));
          if (depDef.flags & 4 /* Self */) {
              searchView = null;
          }
      }
      /** @type {?} */
      const value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR$1);
      if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR$1 ||
          notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR$1) {
          // Return the value from the root element injector when
          // - it provides it
          //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
          // - the module injector should not be checked
          //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
          return value;
      }
      return startView.root.ngModule.injector.get(depDef.token, notFoundValue);
  }
  /**
   * @param {?} view
   * @param {?} elDef
   * @param {?} allowPrivateServices
   * @return {?}
   */
  function findCompView(view, elDef, allowPrivateServices) {
      /** @type {?} */
      let compView;
      if (allowPrivateServices) {
          compView = asElementData(view, elDef.nodeIndex).componentView;
      }
      else {
          compView = view;
          while (compView.parent && !isComponentView(compView)) {
              compView = compView.parent;
          }
      }
      return compView;
  }
  /**
   * @param {?} view
   * @param {?} providerData
   * @param {?} def
   * @param {?} bindingIdx
   * @param {?} value
   * @param {?} changes
   * @return {?}
   */
  function updateProp(view, providerData, def, bindingIdx, value, changes) {
      if (def.flags & 32768 /* Component */) {
          /** @type {?} */
          const compView = asElementData(view, (/** @type {?} */ (def.parent)).nodeIndex).componentView;
          if (compView.def.flags & 2 /* OnPush */) {
              compView.state |= 8 /* ChecksEnabled */;
          }
      }
      /** @type {?} */
      const binding = def.bindings[bindingIdx];
      /** @type {?} */
      const propName = (/** @type {?} */ (binding.name));
      // Note: This is still safe with Closure Compiler as
      // the user passed in the property name as an object has to `providerDef`,
      // so Closure Compiler will have renamed the property correctly already.
      providerData.instance[propName] = value;
      if (def.flags & 524288 /* OnChanges */) {
          changes = changes || {};
          /** @type {?} */
          const oldValue = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);
          /** @type {?} */
          const binding = def.bindings[bindingIdx];
          changes[(/** @type {?} */ (binding.nonMinifiedName))] =
              new SimpleChange(oldValue, value, (view.state & 2 /* FirstCheck */) !== 0);
      }
      view.oldValues[def.bindingIndex + bindingIdx] = value;
      return changes;
  }
  // This function calls the ngAfterContentCheck, ngAfterContentInit,
  // ngAfterViewCheck, and ngAfterViewInit lifecycle hooks (depending on the node
  // flags in lifecycle). Unlike ngDoCheck, ngOnChanges and ngOnInit, which are
  // called during a pre-order traversal of the view tree (that is calling the
  // parent hooks before the child hooks) these events are sent in using a
  // post-order traversal of the tree (children before parents). This changes the
  // meaning of initIndex in the view state. For ngOnInit, initIndex tracks the
  // expected nodeIndex which a ngOnInit should be called. When sending
  // ngAfterContentInit and ngAfterViewInit it is the expected count of
  // ngAfterContentInit or ngAfterViewInit methods that have been called. This
  // ensure that despite being called recursively or after picking up after an
  // exception, the ngAfterContentInit or ngAfterViewInit will be called on the
  // correct nodes. Consider for example, the following (where E is an element
  // and D is a directive)
  //  Tree:       pre-order index  post-order index
  //    E1        0                6
  //      E2      1                1
  //       D3     2                0
  //      E4      3                5
  //       E5     4                4
  //        E6    5                2
  //        E7    6                3
  // As can be seen, the post-order index has an unclear relationship to the
  // pre-order index (postOrderIndex === preOrderIndex - parentCount +
  // childCount). Since number of calls to ngAfterContentInit and ngAfterViewInit
  // are stable (will be the same for the same view regardless of exceptions or
  // recursion) we just need to count them which will roughly correspond to the
  // post-order index (it skips elements and directives that do not have
  // lifecycle hooks).
  //
  // For example, if an exception is raised in the E6.onAfterViewInit() the
  // initIndex is left at 3 (by shouldCallLifecycleInitHook() which set it to
  // initIndex + 1). When checkAndUpdateView() is called again D3, E2 and E6 will
  // not have their ngAfterViewInit() called but, starting with E7, the rest of
  // the view will begin getting ngAfterViewInit() called until a check and
  // pass is complete.
  //
  // This algorthim also handles recursion. Consider if E4's ngAfterViewInit()
  // indirectly calls E1's ChangeDetectorRef.detectChanges(). The expected
  // initIndex is set to 6, the recusive checkAndUpdateView() starts walk again.
  // D3, E2, E6, E7, E5 and E4 are skipped, ngAfterViewInit() is called on E1.
  // When the recursion returns the initIndex will be 7 so E1 is skipped as it
  // has already been called in the recursively called checkAnUpdateView().
  /**
   * @param {?} view
   * @param {?} lifecycles
   * @return {?}
   */
  function callLifecycleHooksChildrenFirst(view, lifecycles) {
      if (!(view.def.nodeFlags & lifecycles)) {
          return;
      }
      /** @type {?} */
      const nodes = view.def.nodes;
      /** @type {?} */
      let initIndex = 0;
      for (let i = 0; i < nodes.length; i++) {
          /** @type {?} */
          const nodeDef = nodes[i];
          /** @type {?} */
          let parent = nodeDef.parent;
          if (!parent && nodeDef.flags & lifecycles) {
              // matching root node (e.g. a pipe)
              callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);
          }
          if ((nodeDef.childFlags & lifecycles) === 0) {
              // no child matches one of the lifecycles
              i += nodeDef.childCount;
          }
          while (parent && (parent.flags & 1 /* TypeElement */) &&
              i === parent.nodeIndex + parent.childCount) {
              // last child of an element
              if (parent.directChildFlags & lifecycles) {
                  initIndex = callElementProvidersLifecycles(view, parent, lifecycles, initIndex);
              }
              parent = parent.parent;
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} elDef
   * @param {?} lifecycles
   * @param {?} initIndex
   * @return {?}
   */
  function callElementProvidersLifecycles(view, elDef, lifecycles, initIndex) {
      for (let i = elDef.nodeIndex + 1; i <= elDef.nodeIndex + elDef.childCount; i++) {
          /** @type {?} */
          const nodeDef = view.def.nodes[i];
          if (nodeDef.flags & lifecycles) {
              callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);
          }
          // only visit direct children
          i += nodeDef.childCount;
      }
      return initIndex;
  }
  /**
   * @param {?} view
   * @param {?} index
   * @param {?} lifecycles
   * @param {?} initIndex
   * @return {?}
   */
  function callProviderLifecycles(view, index, lifecycles, initIndex) {
      /** @type {?} */
      const providerData = asProviderData(view, index);
      if (!providerData) {
          return;
      }
      /** @type {?} */
      const provider = providerData.instance;
      if (!provider) {
          return;
      }
      Services.setCurrentNode(view, index);
      if (lifecycles & 1048576 /* AfterContentInit */ &&
          shouldCallLifecycleInitHook(view, 512 /* InitState_CallingAfterContentInit */, initIndex)) {
          provider.ngAfterContentInit();
      }
      if (lifecycles & 2097152 /* AfterContentChecked */) {
          provider.ngAfterContentChecked();
      }
      if (lifecycles & 4194304 /* AfterViewInit */ &&
          shouldCallLifecycleInitHook(view, 768 /* InitState_CallingAfterViewInit */, initIndex)) {
          provider.ngAfterViewInit();
      }
      if (lifecycles & 8388608 /* AfterViewChecked */) {
          provider.ngAfterViewChecked();
      }
      if (lifecycles & 131072 /* OnDestroy */) {
          provider.ngOnDestroy();
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} flags
   * @param {?} id
   * @param {?} bindings
   * @return {?}
   */
  function queryDef(flags, id, bindings) {
      /** @type {?} */
      let bindingDefs = [];
      for (let propName in bindings) {
          /** @type {?} */
          const bindingType = bindings[propName];
          bindingDefs.push({ propName, bindingType });
      }
      return {
          // will bet set by the view definition
          nodeIndex: -1,
          parent: null,
          renderParent: null,
          bindingIndex: -1,
          outputIndex: -1,
          // regular values
          // TODO(vicb): check
          checkIndex: -1, flags,
          childFlags: 0,
          directChildFlags: 0,
          childMatchedQueries: 0,
          ngContentIndex: -1,
          matchedQueries: {},
          matchedQueryIds: 0,
          references: {},
          childCount: 0,
          bindings: [],
          bindingFlags: 0,
          outputs: [],
          element: null,
          provider: null,
          text: null,
          query: { id, filterId: filterQueryId(id), bindings: bindingDefs },
          ngContent: null
      };
  }
  /**
   * @return {?}
   */
  function createQuery$1() {
      return new QueryList$1();
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function dirtyParentQueries(view) {
      /** @type {?} */
      const queryIds = view.def.nodeMatchedQueries;
      while (view.parent && isEmbeddedView(view)) {
          /** @type {?} */
          let tplDef = (/** @type {?} */ (view.parentNodeDef));
          view = view.parent;
          // content queries
          /** @type {?} */
          const end = tplDef.nodeIndex + tplDef.childCount;
          for (let i = 0; i <= end; i++) {
              /** @type {?} */
              const nodeDef = view.def.nodes[i];
              if ((nodeDef.flags & 67108864 /* TypeContentQuery */) &&
                  (nodeDef.flags & 536870912 /* DynamicQuery */) &&
                  ((/** @type {?} */ (nodeDef.query)).filterId & queryIds) === (/** @type {?} */ (nodeDef.query)).filterId) {
                  asQueryList(view, i).setDirty();
              }
              if ((nodeDef.flags & 1 /* TypeElement */ && i + nodeDef.childCount < tplDef.nodeIndex) ||
                  !(nodeDef.childFlags & 67108864 /* TypeContentQuery */) ||
                  !(nodeDef.childFlags & 536870912 /* DynamicQuery */)) {
                  // skip elements that don't contain the template element or no query.
                  i += nodeDef.childCount;
              }
          }
      }
      // view queries
      if (view.def.nodeFlags & 134217728 /* TypeViewQuery */) {
          for (let i = 0; i < view.def.nodes.length; i++) {
              /** @type {?} */
              const nodeDef = view.def.nodes[i];
              if ((nodeDef.flags & 134217728 /* TypeViewQuery */) && (nodeDef.flags & 536870912 /* DynamicQuery */)) {
                  asQueryList(view, i).setDirty();
              }
              // only visit the root nodes
              i += nodeDef.childCount;
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @return {?}
   */
  function checkAndUpdateQuery(view, nodeDef) {
      /** @type {?} */
      const queryList = asQueryList(view, nodeDef.nodeIndex);
      if (!queryList.dirty) {
          return;
      }
      /** @type {?} */
      let directiveInstance;
      /** @type {?} */
      let newValues = (/** @type {?} */ (undefined));
      if (nodeDef.flags & 67108864 /* TypeContentQuery */) {
          /** @type {?} */
          const elementDef = (/** @type {?} */ ((/** @type {?} */ (nodeDef.parent)).parent));
          newValues = calcQueryValues(view, elementDef.nodeIndex, elementDef.nodeIndex + elementDef.childCount, (/** @type {?} */ (nodeDef.query)), []);
          directiveInstance = asProviderData(view, (/** @type {?} */ (nodeDef.parent)).nodeIndex).instance;
      }
      else if (nodeDef.flags & 134217728 /* TypeViewQuery */) {
          newValues = calcQueryValues(view, 0, view.def.nodes.length - 1, (/** @type {?} */ (nodeDef.query)), []);
          directiveInstance = view.component;
      }
      queryList.reset(newValues);
      /** @type {?} */
      const bindings = (/** @type {?} */ (nodeDef.query)).bindings;
      /** @type {?} */
      let notify = false;
      for (let i = 0; i < bindings.length; i++) {
          /** @type {?} */
          const binding = bindings[i];
          /** @type {?} */
          let boundValue;
          switch (binding.bindingType) {
              case 0 /* First */:
                  boundValue = queryList.first;
                  break;
              case 1 /* All */:
                  boundValue = queryList;
                  notify = true;
                  break;
          }
          directiveInstance[binding.propName] = boundValue;
      }
      if (notify) {
          queryList.notifyOnChanges();
      }
  }
  /**
   * @param {?} view
   * @param {?} startIndex
   * @param {?} endIndex
   * @param {?} queryDef
   * @param {?} values
   * @return {?}
   */
  function calcQueryValues(view, startIndex, endIndex, queryDef, values) {
      for (let i = startIndex; i <= endIndex; i++) {
          /** @type {?} */
          const nodeDef = view.def.nodes[i];
          /** @type {?} */
          const valueType = nodeDef.matchedQueries[queryDef.id];
          if (valueType != null) {
              values.push(getQueryValue(view, nodeDef, valueType));
          }
          if (nodeDef.flags & 1 /* TypeElement */ && (/** @type {?} */ (nodeDef.element)).template &&
              ((/** @type {?} */ ((/** @type {?} */ (nodeDef.element)).template)).nodeMatchedQueries & queryDef.filterId) ===
                  queryDef.filterId) {
              /** @type {?} */
              const elementData = asElementData(view, i);
              // check embedded views that were attached at the place of their template,
              // but process child nodes first if some match the query (see issue #16568)
              if ((nodeDef.childMatchedQueries & queryDef.filterId) === queryDef.filterId) {
                  calcQueryValues(view, i + 1, i + nodeDef.childCount, queryDef, values);
                  i += nodeDef.childCount;
              }
              if (nodeDef.flags & 16777216 /* EmbeddedViews */) {
                  /** @type {?} */
                  const embeddedViews = (/** @type {?} */ (elementData.viewContainer))._embeddedViews;
                  for (let k = 0; k < embeddedViews.length; k++) {
                      /** @type {?} */
                      const embeddedView = embeddedViews[k];
                      /** @type {?} */
                      const dvc = declaredViewContainer(embeddedView);
                      if (dvc && dvc === elementData) {
                          calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);
                      }
                  }
              }
              /** @type {?} */
              const projectedViews = elementData.template._projectedViews;
              if (projectedViews) {
                  for (let k = 0; k < projectedViews.length; k++) {
                      /** @type {?} */
                      const projectedView = projectedViews[k];
                      calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);
                  }
              }
          }
          if ((nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId) {
              // if no child matches the query, skip the children.
              i += nodeDef.childCount;
          }
      }
      return values;
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} queryValueType
   * @return {?}
   */
  function getQueryValue(view, nodeDef, queryValueType) {
      if (queryValueType != null) {
          // a match
          switch (queryValueType) {
              case 1 /* RenderElement */:
                  return asElementData(view, nodeDef.nodeIndex).renderElement;
              case 0 /* ElementRef */:
                  return new ElementRef(asElementData(view, nodeDef.nodeIndex).renderElement);
              case 2 /* TemplateRef */:
                  return asElementData(view, nodeDef.nodeIndex).template;
              case 3 /* ViewContainerRef */:
                  return asElementData(view, nodeDef.nodeIndex).viewContainer;
              case 4 /* Provider */:
                  return asProviderData(view, nodeDef.nodeIndex).instance;
          }
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} ngContentIndex
   * @param {?} index
   * @return {?}
   */
  function ngContentDef(ngContentIndex, index) {
      return {
          // will bet set by the view definition
          nodeIndex: -1,
          parent: null,
          renderParent: null,
          bindingIndex: -1,
          outputIndex: -1,
          // regular values
          checkIndex: -1,
          flags: 8 /* TypeNgContent */,
          childFlags: 0,
          directChildFlags: 0,
          childMatchedQueries: 0,
          matchedQueries: {},
          matchedQueryIds: 0,
          references: {}, ngContentIndex,
          childCount: 0,
          bindings: [],
          bindingFlags: 0,
          outputs: [],
          element: null,
          provider: null,
          text: null,
          query: null,
          ngContent: { index }
      };
  }
  /**
   * @param {?} view
   * @param {?} renderHost
   * @param {?} def
   * @return {?}
   */
  function appendNgContent(view, renderHost, def) {
      /** @type {?} */
      const parentEl = getParentRenderElement(view, renderHost, def);
      if (!parentEl) {
          // Nothing to do if there is no parent element.
          return;
      }
      /** @type {?} */
      const ngContentIndex = (/** @type {?} */ (def.ngContent)).index;
      visitProjectedRenderNodes(view, ngContentIndex, 1 /* AppendChild */, parentEl, null, undefined);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} checkIndex
   * @param {?} argCount
   * @return {?}
   */
  function purePipeDef(checkIndex, argCount) {
      // argCount + 1 to include the pipe as first arg
      return _pureExpressionDef(128 /* TypePurePipe */, checkIndex, new Array(argCount + 1));
  }
  /**
   * @param {?} checkIndex
   * @param {?} argCount
   * @return {?}
   */
  function pureArrayDef(checkIndex, argCount) {
      return _pureExpressionDef(32 /* TypePureArray */, checkIndex, new Array(argCount));
  }
  /**
   * @param {?} checkIndex
   * @param {?} propToIndex
   * @return {?}
   */
  function pureObjectDef(checkIndex, propToIndex) {
      /** @type {?} */
      const keys = Object.keys(propToIndex);
      /** @type {?} */
      const nbKeys = keys.length;
      /** @type {?} */
      const propertyNames = new Array(nbKeys);
      for (let i = 0; i < nbKeys; i++) {
          /** @type {?} */
          const key = keys[i];
          /** @type {?} */
          const index = propToIndex[key];
          propertyNames[index] = key;
      }
      return _pureExpressionDef(64 /* TypePureObject */, checkIndex, propertyNames);
  }
  /**
   * @param {?} flags
   * @param {?} checkIndex
   * @param {?} propertyNames
   * @return {?}
   */
  function _pureExpressionDef(flags, checkIndex, propertyNames) {
      /** @type {?} */
      const bindings = new Array(propertyNames.length);
      for (let i = 0; i < propertyNames.length; i++) {
          /** @type {?} */
          const prop = propertyNames[i];
          bindings[i] = {
              flags: 8 /* TypeProperty */,
              name: prop,
              ns: null,
              nonMinifiedName: prop,
              securityContext: null,
              suffix: null
          };
      }
      return {
          // will bet set by the view definition
          nodeIndex: -1,
          parent: null,
          renderParent: null,
          bindingIndex: -1,
          outputIndex: -1,
          // regular values
          checkIndex,
          flags,
          childFlags: 0,
          directChildFlags: 0,
          childMatchedQueries: 0,
          matchedQueries: {},
          matchedQueryIds: 0,
          references: {},
          ngContentIndex: -1,
          childCount: 0, bindings,
          bindingFlags: calcBindingFlags(bindings),
          outputs: [],
          element: null,
          provider: null,
          text: null,
          query: null,
          ngContent: null
      };
  }
  /**
   * @param {?} view
   * @param {?} def
   * @return {?}
   */
  function createPureExpression(view, def) {
      return { value: undefined };
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} v0
   * @param {?} v1
   * @param {?} v2
   * @param {?} v3
   * @param {?} v4
   * @param {?} v5
   * @param {?} v6
   * @param {?} v7
   * @param {?} v8
   * @param {?} v9
   * @return {?}
   */
  function checkAndUpdatePureExpressionInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const bindings = def.bindings;
      /** @type {?} */
      let changed = false;
      /** @type {?} */
      const bindLen = bindings.length;
      if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))
          changed = true;
      if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))
          changed = true;
      if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))
          changed = true;
      if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))
          changed = true;
      if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))
          changed = true;
      if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))
          changed = true;
      if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))
          changed = true;
      if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))
          changed = true;
      if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))
          changed = true;
      if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))
          changed = true;
      if (changed) {
          /** @type {?} */
          const data = asPureExpressionData(view, def.nodeIndex);
          /** @type {?} */
          let value;
          switch (def.flags & 201347067 /* Types */) {
              case 32 /* TypePureArray */:
                  value = new Array(bindings.length);
                  if (bindLen > 0)
                      value[0] = v0;
                  if (bindLen > 1)
                      value[1] = v1;
                  if (bindLen > 2)
                      value[2] = v2;
                  if (bindLen > 3)
                      value[3] = v3;
                  if (bindLen > 4)
                      value[4] = v4;
                  if (bindLen > 5)
                      value[5] = v5;
                  if (bindLen > 6)
                      value[6] = v6;
                  if (bindLen > 7)
                      value[7] = v7;
                  if (bindLen > 8)
                      value[8] = v8;
                  if (bindLen > 9)
                      value[9] = v9;
                  break;
              case 64 /* TypePureObject */:
                  value = {};
                  if (bindLen > 0)
                      value[(/** @type {?} */ (bindings[0].name))] = v0;
                  if (bindLen > 1)
                      value[(/** @type {?} */ (bindings[1].name))] = v1;
                  if (bindLen > 2)
                      value[(/** @type {?} */ (bindings[2].name))] = v2;
                  if (bindLen > 3)
                      value[(/** @type {?} */ (bindings[3].name))] = v3;
                  if (bindLen > 4)
                      value[(/** @type {?} */ (bindings[4].name))] = v4;
                  if (bindLen > 5)
                      value[(/** @type {?} */ (bindings[5].name))] = v5;
                  if (bindLen > 6)
                      value[(/** @type {?} */ (bindings[6].name))] = v6;
                  if (bindLen > 7)
                      value[(/** @type {?} */ (bindings[7].name))] = v7;
                  if (bindLen > 8)
                      value[(/** @type {?} */ (bindings[8].name))] = v8;
                  if (bindLen > 9)
                      value[(/** @type {?} */ (bindings[9].name))] = v9;
                  break;
              case 128 /* TypePurePipe */:
                  /** @type {?} */
                  const pipe$$1 = v0;
                  switch (bindLen) {
                      case 1:
                          value = pipe$$1.transform(v0);
                          break;
                      case 2:
                          value = pipe$$1.transform(v1);
                          break;
                      case 3:
                          value = pipe$$1.transform(v1, v2);
                          break;
                      case 4:
                          value = pipe$$1.transform(v1, v2, v3);
                          break;
                      case 5:
                          value = pipe$$1.transform(v1, v2, v3, v4);
                          break;
                      case 6:
                          value = pipe$$1.transform(v1, v2, v3, v4, v5);
                          break;
                      case 7:
                          value = pipe$$1.transform(v1, v2, v3, v4, v5, v6);
                          break;
                      case 8:
                          value = pipe$$1.transform(v1, v2, v3, v4, v5, v6, v7);
                          break;
                      case 9:
                          value = pipe$$1.transform(v1, v2, v3, v4, v5, v6, v7, v8);
                          break;
                      case 10:
                          value = pipe$$1.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);
                          break;
                  }
                  break;
          }
          data.value = value;
      }
      return changed;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} values
   * @return {?}
   */
  function checkAndUpdatePureExpressionDynamic(view, def, values) {
      /** @type {?} */
      const bindings = def.bindings;
      /** @type {?} */
      let changed = false;
      for (let i = 0; i < values.length; i++) {
          // Note: We need to loop over all values, so that
          // the old values are updates as well!
          if (checkAndUpdateBinding(view, def, i, values[i])) {
              changed = true;
          }
      }
      if (changed) {
          /** @type {?} */
          const data = asPureExpressionData(view, def.nodeIndex);
          /** @type {?} */
          let value;
          switch (def.flags & 201347067 /* Types */) {
              case 32 /* TypePureArray */:
                  value = values;
                  break;
              case 64 /* TypePureObject */:
                  value = {};
                  for (let i = 0; i < values.length; i++) {
                      value[(/** @type {?} */ (bindings[i].name))] = values[i];
                  }
                  break;
              case 128 /* TypePurePipe */:
                  /** @type {?} */
                  const pipe$$1 = values[0];
                  /** @type {?} */
                  const params = values.slice(1);
                  value = ((/** @type {?} */ (pipe$$1.transform)))(...params);
                  break;
          }
          data.value = value;
      }
      return changed;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} checkIndex
   * @param {?} ngContentIndex
   * @param {?} staticText
   * @return {?}
   */
  function textDef(checkIndex, ngContentIndex, staticText) {
      /** @type {?} */
      const bindings = new Array(staticText.length - 1);
      for (let i = 1; i < staticText.length; i++) {
          bindings[i - 1] = {
              flags: 8 /* TypeProperty */,
              name: null,
              ns: null,
              nonMinifiedName: null,
              securityContext: null,
              suffix: staticText[i],
          };
      }
      return {
          // will bet set by the view definition
          nodeIndex: -1,
          parent: null,
          renderParent: null,
          bindingIndex: -1,
          outputIndex: -1,
          // regular values
          checkIndex,
          flags: 2 /* TypeText */,
          childFlags: 0,
          directChildFlags: 0,
          childMatchedQueries: 0,
          matchedQueries: {},
          matchedQueryIds: 0,
          references: {}, ngContentIndex,
          childCount: 0, bindings,
          bindingFlags: 8 /* TypeProperty */,
          outputs: [],
          element: null,
          provider: null,
          text: { prefix: staticText[0] },
          query: null,
          ngContent: null,
      };
  }
  /**
   * @param {?} view
   * @param {?} renderHost
   * @param {?} def
   * @return {?}
   */
  function createText(view, renderHost, def) {
      /** @type {?} */
      let renderNode$$1;
      /** @type {?} */
      const renderer = view.renderer;
      renderNode$$1 = renderer.createText((/** @type {?} */ (def.text)).prefix);
      /** @type {?} */
      const parentEl = getParentRenderElement(view, renderHost, def);
      if (parentEl) {
          renderer.appendChild(parentEl, renderNode$$1);
      }
      return { renderText: renderNode$$1 };
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} v0
   * @param {?} v1
   * @param {?} v2
   * @param {?} v3
   * @param {?} v4
   * @param {?} v5
   * @param {?} v6
   * @param {?} v7
   * @param {?} v8
   * @param {?} v9
   * @return {?}
   */
  function checkAndUpdateTextInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      let changed = false;
      /** @type {?} */
      const bindings = def.bindings;
      /** @type {?} */
      const bindLen = bindings.length;
      if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0))
          changed = true;
      if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1))
          changed = true;
      if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2))
          changed = true;
      if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3))
          changed = true;
      if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4))
          changed = true;
      if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5))
          changed = true;
      if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6))
          changed = true;
      if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7))
          changed = true;
      if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8))
          changed = true;
      if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9))
          changed = true;
      if (changed) {
          /** @type {?} */
          let value = (/** @type {?} */ (def.text)).prefix;
          if (bindLen > 0)
              value += _addInterpolationPart(v0, bindings[0]);
          if (bindLen > 1)
              value += _addInterpolationPart(v1, bindings[1]);
          if (bindLen > 2)
              value += _addInterpolationPart(v2, bindings[2]);
          if (bindLen > 3)
              value += _addInterpolationPart(v3, bindings[3]);
          if (bindLen > 4)
              value += _addInterpolationPart(v4, bindings[4]);
          if (bindLen > 5)
              value += _addInterpolationPart(v5, bindings[5]);
          if (bindLen > 6)
              value += _addInterpolationPart(v6, bindings[6]);
          if (bindLen > 7)
              value += _addInterpolationPart(v7, bindings[7]);
          if (bindLen > 8)
              value += _addInterpolationPart(v8, bindings[8]);
          if (bindLen > 9)
              value += _addInterpolationPart(v9, bindings[9]);
          /** @type {?} */
          const renderNode$$1 = asTextData(view, def.nodeIndex).renderText;
          view.renderer.setValue(renderNode$$1, value);
      }
      return changed;
  }
  /**
   * @param {?} view
   * @param {?} def
   * @param {?} values
   * @return {?}
   */
  function checkAndUpdateTextDynamic(view, def, values) {
      /** @type {?} */
      const bindings = def.bindings;
      /** @type {?} */
      let changed = false;
      for (let i = 0; i < values.length; i++) {
          // Note: We need to loop over all values, so that
          // the old values are updates as well!
          if (checkAndUpdateBinding(view, def, i, values[i])) {
              changed = true;
          }
      }
      if (changed) {
          /** @type {?} */
          let value = '';
          for (let i = 0; i < values.length; i++) {
              value = value + _addInterpolationPart(values[i], bindings[i]);
          }
          value = (/** @type {?} */ (def.text)).prefix + value;
          /** @type {?} */
          const renderNode$$1 = asTextData(view, def.nodeIndex).renderText;
          view.renderer.setValue(renderNode$$1, value);
      }
      return changed;
  }
  /**
   * @param {?} value
   * @param {?} binding
   * @return {?}
   */
  function _addInterpolationPart(value, binding) {
      /** @type {?} */
      const valueStr = value != null ? value.toString() : '';
      return valueStr + binding.suffix;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} flags
   * @param {?} nodes
   * @param {?=} updateDirectives
   * @param {?=} updateRenderer
   * @return {?}
   */
  function viewDef(flags, nodes, updateDirectives, updateRenderer) {
      // clone nodes and set auto calculated values
      /** @type {?} */
      let viewBindingCount = 0;
      /** @type {?} */
      let viewDisposableCount = 0;
      /** @type {?} */
      let viewNodeFlags = 0;
      /** @type {?} */
      let viewRootNodeFlags = 0;
      /** @type {?} */
      let viewMatchedQueries = 0;
      /** @type {?} */
      let currentParent = null;
      /** @type {?} */
      let currentRenderParent = null;
      /** @type {?} */
      let currentElementHasPublicProviders = false;
      /** @type {?} */
      let currentElementHasPrivateProviders = false;
      /** @type {?} */
      let lastRenderRootNode = null;
      for (let i = 0; i < nodes.length; i++) {
          /** @type {?} */
          const node = nodes[i];
          node.nodeIndex = i;
          node.parent = currentParent;
          node.bindingIndex = viewBindingCount;
          node.outputIndex = viewDisposableCount;
          node.renderParent = currentRenderParent;
          viewNodeFlags |= node.flags;
          viewMatchedQueries |= node.matchedQueryIds;
          if (node.element) {
              /** @type {?} */
              const elDef = node.element;
              elDef.publicProviders =
                  currentParent ? (/** @type {?} */ (currentParent.element)).publicProviders : Object.create(null);
              elDef.allProviders = elDef.publicProviders;
              // Note: We assume that all providers of an element are before any child element!
              currentElementHasPublicProviders = false;
              currentElementHasPrivateProviders = false;
              if (node.element.template) {
                  viewMatchedQueries |= node.element.template.nodeMatchedQueries;
              }
          }
          validateNode(currentParent, node, nodes.length);
          viewBindingCount += node.bindings.length;
          viewDisposableCount += node.outputs.length;
          if (!currentRenderParent && (node.flags & 3 /* CatRenderNode */)) {
              lastRenderRootNode = node;
          }
          if (node.flags & 20224 /* CatProvider */) {
              if (!currentElementHasPublicProviders) {
                  currentElementHasPublicProviders = true;
                  // Use prototypical inheritance to not get O(n^2) complexity...
                  (/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).publicProviders =
                      Object.create((/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).publicProviders);
                  (/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).allProviders = (/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).publicProviders;
              }
              /** @type {?} */
              const isPrivateService = (node.flags & 8192 /* PrivateProvider */) !== 0;
              /** @type {?} */
              const isComponent = (node.flags & 32768 /* Component */) !== 0;
              if (!isPrivateService || isComponent) {
                  (/** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).publicProviders))[tokenKey((/** @type {?} */ (node.provider)).token)] = node;
              }
              else {
                  if (!currentElementHasPrivateProviders) {
                      currentElementHasPrivateProviders = true;
                      // Use prototypical inheritance to not get O(n^2) complexity...
                      (/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).allProviders =
                          Object.create((/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).publicProviders);
                  }
                  (/** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).allProviders))[tokenKey((/** @type {?} */ (node.provider)).token)] = node;
              }
              if (isComponent) {
                  (/** @type {?} */ ((/** @type {?} */ (currentParent)).element)).componentProvider = node;
              }
          }
          if (currentParent) {
              currentParent.childFlags |= node.flags;
              currentParent.directChildFlags |= node.flags;
              currentParent.childMatchedQueries |= node.matchedQueryIds;
              if (node.element && node.element.template) {
                  currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries;
              }
          }
          else {
              viewRootNodeFlags |= node.flags;
          }
          if (node.childCount > 0) {
              currentParent = node;
              if (!isNgContainer$1(node)) {
                  currentRenderParent = node;
              }
          }
          else {
              // When the current node has no children, check if it is the last children of its parent.
              // When it is, propagate the flags up.
              // The loop is required because an element could be the last transitive children of several
              // elements. We loop to either the root or the highest opened element (= with remaining
              // children)
              while (currentParent && i === currentParent.nodeIndex + currentParent.childCount) {
                  /** @type {?} */
                  const newParent = currentParent.parent;
                  if (newParent) {
                      newParent.childFlags |= currentParent.childFlags;
                      newParent.childMatchedQueries |= currentParent.childMatchedQueries;
                  }
                  currentParent = newParent;
                  // We also need to update the render parent & account for ng-container
                  if (currentParent && isNgContainer$1(currentParent)) {
                      currentRenderParent = currentParent.renderParent;
                  }
                  else {
                      currentRenderParent = currentParent;
                  }
              }
          }
      }
      /** @type {?} */
      const handleEvent = (view, nodeIndex, eventName, event) => (/** @type {?} */ ((/** @type {?} */ (nodes[nodeIndex].element)).handleEvent))(view, eventName, event);
      return {
          // Will be filled later...
          factory: null,
          nodeFlags: viewNodeFlags,
          rootNodeFlags: viewRootNodeFlags,
          nodeMatchedQueries: viewMatchedQueries, flags,
          nodes: nodes,
          updateDirectives: updateDirectives || NOOP,
          updateRenderer: updateRenderer || NOOP, handleEvent,
          bindingCount: viewBindingCount,
          outputCount: viewDisposableCount, lastRenderRootNode
      };
  }
  /**
   * @param {?} node
   * @return {?}
   */
  function isNgContainer$1(node) {
      return (node.flags & 1 /* TypeElement */) !== 0 && (/** @type {?} */ (node.element)).name === null;
  }
  /**
   * @param {?} parent
   * @param {?} node
   * @param {?} nodeCount
   * @return {?}
   */
  function validateNode(parent, node, nodeCount) {
      /** @type {?} */
      const template = node.element && node.element.template;
      if (template) {
          if (!template.lastRenderRootNode) {
              throw new Error(`Illegal State: Embedded templates without nodes are not allowed!`);
          }
          if (template.lastRenderRootNode &&
              template.lastRenderRootNode.flags & 16777216 /* EmbeddedViews */) {
              throw new Error(`Illegal State: Last root node of a template can't have embedded views, at index ${node.nodeIndex}!`);
          }
      }
      if (node.flags & 20224 /* CatProvider */) {
          /** @type {?} */
          const parentFlags = parent ? parent.flags : 0;
          if ((parentFlags & 1 /* TypeElement */) === 0) {
              throw new Error(`Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index ${node.nodeIndex}!`);
          }
      }
      if (node.query) {
          if (node.flags & 67108864 /* TypeContentQuery */ &&
              (!parent || (parent.flags & 16384 /* TypeDirective */) === 0)) {
              throw new Error(`Illegal State: Content Query nodes need to be children of directives, at index ${node.nodeIndex}!`);
          }
          if (node.flags & 134217728 /* TypeViewQuery */ && parent) {
              throw new Error(`Illegal State: View Query nodes have to be top level nodes, at index ${node.nodeIndex}!`);
          }
      }
      if (node.childCount) {
          /** @type {?} */
          const parentEnd = parent ? parent.nodeIndex + parent.childCount : nodeCount - 1;
          if (node.nodeIndex <= parentEnd && node.nodeIndex + node.childCount > parentEnd) {
              throw new Error(`Illegal State: childCount of node leads outside of parent, at index ${node.nodeIndex}!`);
          }
      }
  }
  /**
   * @param {?} parent
   * @param {?} anchorDef
   * @param {?} viewDef
   * @param {?=} context
   * @return {?}
   */
  function createEmbeddedView(parent, anchorDef$$1, viewDef, context) {
      // embedded views are seen as siblings to the anchor, so we need
      // to get the parent of the anchor and use it as parentIndex.
      /** @type {?} */
      const view = createView(parent.root, parent.renderer, parent, anchorDef$$1, viewDef);
      initView(view, parent.component, context);
      createViewNodes(view);
      return view;
  }
  /**
   * @param {?} root
   * @param {?} def
   * @param {?=} context
   * @return {?}
   */
  function createRootView(root, def, context) {
      /** @type {?} */
      const view = createView(root, root.renderer, null, null, def);
      initView(view, context, context);
      createViewNodes(view);
      return view;
  }
  /**
   * @param {?} parentView
   * @param {?} nodeDef
   * @param {?} viewDef
   * @param {?} hostElement
   * @return {?}
   */
  function createComponentView(parentView, nodeDef, viewDef, hostElement) {
      /** @type {?} */
      const rendererType = (/** @type {?} */ (nodeDef.element)).componentRendererType;
      /** @type {?} */
      let compRenderer;
      if (!rendererType) {
          compRenderer = parentView.root.renderer;
      }
      else {
          compRenderer = parentView.root.rendererFactory.createRenderer(hostElement, rendererType);
      }
      return createView(parentView.root, compRenderer, parentView, (/** @type {?} */ (nodeDef.element)).componentProvider, viewDef);
  }
  /**
   * @param {?} root
   * @param {?} renderer
   * @param {?} parent
   * @param {?} parentNodeDef
   * @param {?} def
   * @return {?}
   */
  function createView(root, renderer, parent, parentNodeDef, def) {
      /** @type {?} */
      const nodes = new Array(def.nodes.length);
      /** @type {?} */
      const disposables = def.outputCount ? new Array(def.outputCount) : null;
      /** @type {?} */
      const view = {
          def,
          parent,
          viewContainerParent: null, parentNodeDef,
          context: null,
          component: null, nodes,
          state: 13 /* CatInit */, root, renderer,
          oldValues: new Array(def.bindingCount), disposables,
          initIndex: -1
      };
      return view;
  }
  /**
   * @param {?} view
   * @param {?} component
   * @param {?} context
   * @return {?}
   */
  function initView(view, component, context) {
      view.component = component;
      view.context = context;
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function createViewNodes(view) {
      /** @type {?} */
      let renderHost;
      if (isComponentView(view)) {
          /** @type {?} */
          const hostDef = view.parentNodeDef;
          renderHost = asElementData((/** @type {?} */ (view.parent)), (/** @type {?} */ ((/** @type {?} */ (hostDef)).parent)).nodeIndex).renderElement;
      }
      /** @type {?} */
      const def = view.def;
      /** @type {?} */
      const nodes = view.nodes;
      for (let i = 0; i < def.nodes.length; i++) {
          /** @type {?} */
          const nodeDef = def.nodes[i];
          Services.setCurrentNode(view, i);
          /** @type {?} */
          let nodeData;
          switch (nodeDef.flags & 201347067 /* Types */) {
              case 1 /* TypeElement */:
                  /** @type {?} */
                  const el = (/** @type {?} */ (createElement(view, renderHost, nodeDef)));
                  /** @type {?} */
                  let componentView = (/** @type {?} */ (undefined));
                  if (nodeDef.flags & 33554432 /* ComponentView */) {
                      /** @type {?} */
                      const compViewDef = resolveDefinition((/** @type {?} */ ((/** @type {?} */ (nodeDef.element)).componentView)));
                      componentView = Services.createComponentView(view, nodeDef, compViewDef, el);
                  }
                  listenToElementOutputs(view, componentView, nodeDef, el);
                  nodeData = (/** @type {?} */ ({
                      renderElement: el,
                      componentView,
                      viewContainer: null,
                      template: (/** @type {?} */ (nodeDef.element)).template ? createTemplateData(view, nodeDef) : undefined
                  }));
                  if (nodeDef.flags & 16777216 /* EmbeddedViews */) {
                      nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData);
                  }
                  break;
              case 2 /* TypeText */:
                  nodeData = (/** @type {?} */ (createText(view, renderHost, nodeDef)));
                  break;
              case 512 /* TypeClassProvider */:
              case 1024 /* TypeFactoryProvider */:
              case 2048 /* TypeUseExistingProvider */:
              case 256 /* TypeValueProvider */: {
                  nodeData = nodes[i];
                  if (!nodeData && !(nodeDef.flags & 4096 /* LazyProvider */)) {
                      /** @type {?} */
                      const instance = createProviderInstance(view, nodeDef);
                      nodeData = (/** @type {?} */ ({ instance }));
                  }
                  break;
              }
              case 16 /* TypePipe */: {
                  /** @type {?} */
                  const instance = createPipeInstance(view, nodeDef);
                  nodeData = (/** @type {?} */ ({ instance }));
                  break;
              }
              case 16384 /* TypeDirective */: {
                  nodeData = nodes[i];
                  if (!nodeData) {
                      /** @type {?} */
                      const instance = createDirectiveInstance(view, nodeDef);
                      nodeData = (/** @type {?} */ ({ instance }));
                  }
                  if (nodeDef.flags & 32768 /* Component */) {
                      /** @type {?} */
                      const compView = asElementData(view, (/** @type {?} */ (nodeDef.parent)).nodeIndex).componentView;
                      initView(compView, nodeData.instance, nodeData.instance);
                  }
                  break;
              }
              case 32 /* TypePureArray */:
              case 64 /* TypePureObject */:
              case 128 /* TypePurePipe */:
                  nodeData = (/** @type {?} */ (createPureExpression(view, nodeDef)));
                  break;
              case 67108864 /* TypeContentQuery */:
              case 134217728 /* TypeViewQuery */:
                  nodeData = (/** @type {?} */ (createQuery$1()));
                  break;
              case 8 /* TypeNgContent */:
                  appendNgContent(view, renderHost, nodeDef);
                  // no runtime data needed for NgContent...
                  nodeData = undefined;
                  break;
          }
          nodes[i] = nodeData;
      }
      // Create the ViewData.nodes of component views after we created everything else,
      // so that e.g. ng-content works
      execComponentViewsAction(view, ViewAction.CreateViewNodes);
      // fill static content and view queries
      execQueriesAction(view, 67108864 /* TypeContentQuery */ | 134217728 /* TypeViewQuery */, 268435456 /* StaticQuery */, 0 /* CheckAndUpdate */);
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function checkNoChangesView(view) {
      markProjectedViewsForCheck(view);
      Services.updateDirectives(view, 1 /* CheckNoChanges */);
      execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);
      Services.updateRenderer(view, 1 /* CheckNoChanges */);
      execComponentViewsAction(view, ViewAction.CheckNoChanges);
      // Note: We don't check queries for changes as we didn't do this in v2.x.
      // TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.
      view.state &= ~(64 /* CheckProjectedViews */ | 32 /* CheckProjectedView */);
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function checkAndUpdateView(view) {
      if (view.state & 1 /* BeforeFirstCheck */) {
          view.state &= ~1 /* BeforeFirstCheck */;
          view.state |= 2 /* FirstCheck */;
      }
      else {
          view.state &= ~2 /* FirstCheck */;
      }
      shiftInitState(view, 0 /* InitState_BeforeInit */, 256 /* InitState_CallingOnInit */);
      markProjectedViewsForCheck(view);
      Services.updateDirectives(view, 0 /* CheckAndUpdate */);
      execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);
      execQueriesAction(view, 67108864 /* TypeContentQuery */, 536870912 /* DynamicQuery */, 0 /* CheckAndUpdate */);
      /** @type {?} */
      let callInit = shiftInitState(view, 256 /* InitState_CallingOnInit */, 512 /* InitState_CallingAfterContentInit */);
      callLifecycleHooksChildrenFirst(view, 2097152 /* AfterContentChecked */ | (callInit ? 1048576 /* AfterContentInit */ : 0));
      Services.updateRenderer(view, 0 /* CheckAndUpdate */);
      execComponentViewsAction(view, ViewAction.CheckAndUpdate);
      execQueriesAction(view, 134217728 /* TypeViewQuery */, 536870912 /* DynamicQuery */, 0 /* CheckAndUpdate */);
      callInit = shiftInitState(view, 512 /* InitState_CallingAfterContentInit */, 768 /* InitState_CallingAfterViewInit */);
      callLifecycleHooksChildrenFirst(view, 8388608 /* AfterViewChecked */ | (callInit ? 4194304 /* AfterViewInit */ : 0));
      if (view.def.flags & 2 /* OnPush */) {
          view.state &= ~8 /* ChecksEnabled */;
      }
      view.state &= ~(64 /* CheckProjectedViews */ | 32 /* CheckProjectedView */);
      shiftInitState(view, 768 /* InitState_CallingAfterViewInit */, 1024 /* InitState_AfterInit */);
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} argStyle
   * @param {?=} v0
   * @param {?=} v1
   * @param {?=} v2
   * @param {?=} v3
   * @param {?=} v4
   * @param {?=} v5
   * @param {?=} v6
   * @param {?=} v7
   * @param {?=} v8
   * @param {?=} v9
   * @return {?}
   */
  function checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      if (argStyle === 0 /* Inline */) {
          return checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
      }
      else {
          return checkAndUpdateNodeDynamic(view, nodeDef, v0);
      }
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function markProjectedViewsForCheck(view) {
      /** @type {?} */
      const def = view.def;
      if (!(def.nodeFlags & 4 /* ProjectedTemplate */)) {
          return;
      }
      for (let i = 0; i < def.nodes.length; i++) {
          /** @type {?} */
          const nodeDef = def.nodes[i];
          if (nodeDef.flags & 4 /* ProjectedTemplate */) {
              /** @type {?} */
              const projectedViews = asElementData(view, i).template._projectedViews;
              if (projectedViews) {
                  for (let i = 0; i < projectedViews.length; i++) {
                      /** @type {?} */
                      const projectedView = projectedViews[i];
                      projectedView.state |= 32 /* CheckProjectedView */;
                      markParentViewsForCheckProjectedViews(projectedView, view);
                  }
              }
          }
          else if ((nodeDef.childFlags & 4 /* ProjectedTemplate */) === 0) {
              // a parent with leafs
              // no child is a component,
              // then skip the children
              i += nodeDef.childCount;
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?=} v0
   * @param {?=} v1
   * @param {?=} v2
   * @param {?=} v3
   * @param {?=} v4
   * @param {?=} v5
   * @param {?=} v6
   * @param {?=} v7
   * @param {?=} v8
   * @param {?=} v9
   * @return {?}
   */
  function checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      switch (nodeDef.flags & 201347067 /* Types */) {
          case 1 /* TypeElement */:
              return checkAndUpdateElementInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
          case 2 /* TypeText */:
              return checkAndUpdateTextInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
          case 16384 /* TypeDirective */:
              return checkAndUpdateDirectiveInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
          case 32 /* TypePureArray */:
          case 64 /* TypePureObject */:
          case 128 /* TypePurePipe */:
              return checkAndUpdatePureExpressionInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
          default:
              throw 'unreachable';
      }
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} values
   * @return {?}
   */
  function checkAndUpdateNodeDynamic(view, nodeDef, values) {
      switch (nodeDef.flags & 201347067 /* Types */) {
          case 1 /* TypeElement */:
              return checkAndUpdateElementDynamic(view, nodeDef, values);
          case 2 /* TypeText */:
              return checkAndUpdateTextDynamic(view, nodeDef, values);
          case 16384 /* TypeDirective */:
              return checkAndUpdateDirectiveDynamic(view, nodeDef, values);
          case 32 /* TypePureArray */:
          case 64 /* TypePureObject */:
          case 128 /* TypePurePipe */:
              return checkAndUpdatePureExpressionDynamic(view, nodeDef, values);
          default:
              throw 'unreachable';
      }
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} argStyle
   * @param {?=} v0
   * @param {?=} v1
   * @param {?=} v2
   * @param {?=} v3
   * @param {?=} v4
   * @param {?=} v5
   * @param {?=} v6
   * @param {?=} v7
   * @param {?=} v8
   * @param {?=} v9
   * @return {?}
   */
  function checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      if (argStyle === 0 /* Inline */) {
          checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
      }
      else {
          checkNoChangesNodeDynamic(view, nodeDef, v0);
      }
      // Returning false is ok here as we would have thrown in case of a change.
      return false;
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} v0
   * @param {?} v1
   * @param {?} v2
   * @param {?} v3
   * @param {?} v4
   * @param {?} v5
   * @param {?} v6
   * @param {?} v7
   * @param {?} v8
   * @param {?} v9
   * @return {?}
   */
  function checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const bindLen = nodeDef.bindings.length;
      if (bindLen > 0)
          checkBindingNoChanges(view, nodeDef, 0, v0);
      if (bindLen > 1)
          checkBindingNoChanges(view, nodeDef, 1, v1);
      if (bindLen > 2)
          checkBindingNoChanges(view, nodeDef, 2, v2);
      if (bindLen > 3)
          checkBindingNoChanges(view, nodeDef, 3, v3);
      if (bindLen > 4)
          checkBindingNoChanges(view, nodeDef, 4, v4);
      if (bindLen > 5)
          checkBindingNoChanges(view, nodeDef, 5, v5);
      if (bindLen > 6)
          checkBindingNoChanges(view, nodeDef, 6, v6);
      if (bindLen > 7)
          checkBindingNoChanges(view, nodeDef, 7, v7);
      if (bindLen > 8)
          checkBindingNoChanges(view, nodeDef, 8, v8);
      if (bindLen > 9)
          checkBindingNoChanges(view, nodeDef, 9, v9);
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} values
   * @return {?}
   */
  function checkNoChangesNodeDynamic(view, nodeDef, values) {
      for (let i = 0; i < values.length; i++) {
          checkBindingNoChanges(view, nodeDef, i, values[i]);
      }
  }
  /**
   * Workaround https://github.com/angular/tsickle/issues/497
   * @suppress {misplacedTypeAnnotation}
   * @param {?} view
   * @param {?} nodeDef
   * @return {?}
   */
  function checkNoChangesQuery(view, nodeDef) {
      /** @type {?} */
      const queryList = asQueryList(view, nodeDef.nodeIndex);
      if (queryList.dirty) {
          throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, nodeDef.nodeIndex), `Query ${(/** @type {?} */ (nodeDef.query)).id} not dirty`, `Query ${(/** @type {?} */ (nodeDef.query)).id} dirty`, (view.state & 1 /* BeforeFirstCheck */) !== 0);
      }
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function destroyView(view) {
      if (view.state & 128 /* Destroyed */) {
          return;
      }
      execEmbeddedViewsAction(view, ViewAction.Destroy);
      execComponentViewsAction(view, ViewAction.Destroy);
      callLifecycleHooksChildrenFirst(view, 131072 /* OnDestroy */);
      if (view.disposables) {
          for (let i = 0; i < view.disposables.length; i++) {
              view.disposables[i]();
          }
      }
      detachProjectedView(view);
      if (view.renderer.destroyNode) {
          destroyViewNodes(view);
      }
      if (isComponentView(view)) {
          view.renderer.destroy();
      }
      view.state |= 128 /* Destroyed */;
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function destroyViewNodes(view) {
      /** @type {?} */
      const len = view.def.nodes.length;
      for (let i = 0; i < len; i++) {
          /** @type {?} */
          const def = view.def.nodes[i];
          if (def.flags & 1 /* TypeElement */) {
              (/** @type {?} */ (view.renderer.destroyNode))(asElementData(view, i).renderElement);
          }
          else if (def.flags & 2 /* TypeText */) {
              (/** @type {?} */ (view.renderer.destroyNode))(asTextData(view, i).renderText);
          }
          else if (def.flags & 67108864 /* TypeContentQuery */ || def.flags & 134217728 /* TypeViewQuery */) {
              asQueryList(view, i).destroy();
          }
      }
  }
  /** @enum {number} */
  const ViewAction = {
      CreateViewNodes: 0,
      CheckNoChanges: 1,
      CheckNoChangesProjectedViews: 2,
      CheckAndUpdate: 3,
      CheckAndUpdateProjectedViews: 4,
      Destroy: 5,
  };
  ViewAction[ViewAction.CreateViewNodes] = 'CreateViewNodes';
  ViewAction[ViewAction.CheckNoChanges] = 'CheckNoChanges';
  ViewAction[ViewAction.CheckNoChangesProjectedViews] = 'CheckNoChangesProjectedViews';
  ViewAction[ViewAction.CheckAndUpdate] = 'CheckAndUpdate';
  ViewAction[ViewAction.CheckAndUpdateProjectedViews] = 'CheckAndUpdateProjectedViews';
  ViewAction[ViewAction.Destroy] = 'Destroy';
  /**
   * @param {?} view
   * @param {?} action
   * @return {?}
   */
  function execComponentViewsAction(view, action) {
      /** @type {?} */
      const def = view.def;
      if (!(def.nodeFlags & 33554432 /* ComponentView */)) {
          return;
      }
      for (let i = 0; i < def.nodes.length; i++) {
          /** @type {?} */
          const nodeDef = def.nodes[i];
          if (nodeDef.flags & 33554432 /* ComponentView */) {
              // a leaf
              callViewAction(asElementData(view, i).componentView, action);
          }
          else if ((nodeDef.childFlags & 33554432 /* ComponentView */) === 0) {
              // a parent with leafs
              // no child is a component,
              // then skip the children
              i += nodeDef.childCount;
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} action
   * @return {?}
   */
  function execEmbeddedViewsAction(view, action) {
      /** @type {?} */
      const def = view.def;
      if (!(def.nodeFlags & 16777216 /* EmbeddedViews */)) {
          return;
      }
      for (let i = 0; i < def.nodes.length; i++) {
          /** @type {?} */
          const nodeDef = def.nodes[i];
          if (nodeDef.flags & 16777216 /* EmbeddedViews */) {
              // a leaf
              /** @type {?} */
              const embeddedViews = (/** @type {?} */ (asElementData(view, i).viewContainer))._embeddedViews;
              for (let k = 0; k < embeddedViews.length; k++) {
                  callViewAction(embeddedViews[k], action);
              }
          }
          else if ((nodeDef.childFlags & 16777216 /* EmbeddedViews */) === 0) {
              // a parent with leafs
              // no child is a component,
              // then skip the children
              i += nodeDef.childCount;
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} action
   * @return {?}
   */
  function callViewAction(view, action) {
      /** @type {?} */
      const viewState = view.state;
      switch (action) {
          case ViewAction.CheckNoChanges:
              if ((viewState & 128 /* Destroyed */) === 0) {
                  if ((viewState & 12 /* CatDetectChanges */) === 12 /* CatDetectChanges */) {
                      checkNoChangesView(view);
                  }
                  else if (viewState & 64 /* CheckProjectedViews */) {
                      execProjectedViewsAction(view, ViewAction.CheckNoChangesProjectedViews);
                  }
              }
              break;
          case ViewAction.CheckNoChangesProjectedViews:
              if ((viewState & 128 /* Destroyed */) === 0) {
                  if (viewState & 32 /* CheckProjectedView */) {
                      checkNoChangesView(view);
                  }
                  else if (viewState & 64 /* CheckProjectedViews */) {
                      execProjectedViewsAction(view, action);
                  }
              }
              break;
          case ViewAction.CheckAndUpdate:
              if ((viewState & 128 /* Destroyed */) === 0) {
                  if ((viewState & 12 /* CatDetectChanges */) === 12 /* CatDetectChanges */) {
                      checkAndUpdateView(view);
                  }
                  else if (viewState & 64 /* CheckProjectedViews */) {
                      execProjectedViewsAction(view, ViewAction.CheckAndUpdateProjectedViews);
                  }
              }
              break;
          case ViewAction.CheckAndUpdateProjectedViews:
              if ((viewState & 128 /* Destroyed */) === 0) {
                  if (viewState & 32 /* CheckProjectedView */) {
                      checkAndUpdateView(view);
                  }
                  else if (viewState & 64 /* CheckProjectedViews */) {
                      execProjectedViewsAction(view, action);
                  }
              }
              break;
          case ViewAction.Destroy:
              // Note: destroyView recurses over all views,
              // so we don't need to special case projected views here.
              destroyView(view);
              break;
          case ViewAction.CreateViewNodes:
              createViewNodes(view);
              break;
      }
  }
  /**
   * @param {?} view
   * @param {?} action
   * @return {?}
   */
  function execProjectedViewsAction(view, action) {
      execEmbeddedViewsAction(view, action);
      execComponentViewsAction(view, action);
  }
  /**
   * @param {?} view
   * @param {?} queryFlags
   * @param {?} staticDynamicQueryFlag
   * @param {?} checkType
   * @return {?}
   */
  function execQueriesAction(view, queryFlags, staticDynamicQueryFlag, checkType) {
      if (!(view.def.nodeFlags & queryFlags) || !(view.def.nodeFlags & staticDynamicQueryFlag)) {
          return;
      }
      /** @type {?} */
      const nodeCount = view.def.nodes.length;
      for (let i = 0; i < nodeCount; i++) {
          /** @type {?} */
          const nodeDef = view.def.nodes[i];
          if ((nodeDef.flags & queryFlags) && (nodeDef.flags & staticDynamicQueryFlag)) {
              Services.setCurrentNode(view, nodeDef.nodeIndex);
              switch (checkType) {
                  case 0 /* CheckAndUpdate */:
                      checkAndUpdateQuery(view, nodeDef);
                      break;
                  case 1 /* CheckNoChanges */:
                      checkNoChangesQuery(view, nodeDef);
                      break;
              }
          }
          if (!(nodeDef.childFlags & queryFlags) || !(nodeDef.childFlags & staticDynamicQueryFlag)) {
              // no child has a matching query
              // then skip the children
              i += nodeDef.childCount;
          }
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  let initialized = false;
  /**
   * @return {?}
   */
  function initServicesIfNeeded() {
      if (initialized) {
          return;
      }
      initialized = true;
      /** @type {?} */
      const services = isDevMode() ? createDebugServices() : createProdServices();
      Services.setCurrentNode = services.setCurrentNode;
      Services.createRootView = services.createRootView;
      Services.createEmbeddedView = services.createEmbeddedView;
      Services.createComponentView = services.createComponentView;
      Services.createNgModuleRef = services.createNgModuleRef;
      Services.overrideProvider = services.overrideProvider;
      Services.overrideComponentView = services.overrideComponentView;
      Services.clearOverrides = services.clearOverrides;
      Services.checkAndUpdateView = services.checkAndUpdateView;
      Services.checkNoChangesView = services.checkNoChangesView;
      Services.destroyView = services.destroyView;
      Services.resolveDep = resolveDep;
      Services.createDebugContext = services.createDebugContext;
      Services.handleEvent = services.handleEvent;
      Services.updateDirectives = services.updateDirectives;
      Services.updateRenderer = services.updateRenderer;
      Services.dirtyParentQueries = dirtyParentQueries;
  }
  /**
   * @return {?}
   */
  function createProdServices() {
      return {
          setCurrentNode: () => { },
          createRootView: createProdRootView,
          createEmbeddedView: createEmbeddedView,
          createComponentView: createComponentView,
          createNgModuleRef: createNgModuleRef,
          overrideProvider: NOOP,
          overrideComponentView: NOOP,
          clearOverrides: NOOP,
          checkAndUpdateView: checkAndUpdateView,
          checkNoChangesView: checkNoChangesView,
          destroyView: destroyView,
          createDebugContext: (view, nodeIndex) => new DebugContext_(view, nodeIndex),
          handleEvent: (view, nodeIndex, eventName, event) => view.def.handleEvent(view, nodeIndex, eventName, event),
          updateDirectives: (view, checkType) => view.def.updateDirectives(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :
              prodCheckNoChangesNode, view),
          updateRenderer: (view, checkType) => view.def.updateRenderer(checkType === 0 /* CheckAndUpdate */ ? prodCheckAndUpdateNode :
              prodCheckNoChangesNode, view),
      };
  }
  /**
   * @return {?}
   */
  function createDebugServices() {
      return {
          setCurrentNode: debugSetCurrentNode,
          createRootView: debugCreateRootView,
          createEmbeddedView: debugCreateEmbeddedView,
          createComponentView: debugCreateComponentView,
          createNgModuleRef: debugCreateNgModuleRef,
          overrideProvider: debugOverrideProvider,
          overrideComponentView: debugOverrideComponentView,
          clearOverrides: debugClearOverrides,
          checkAndUpdateView: debugCheckAndUpdateView,
          checkNoChangesView: debugCheckNoChangesView,
          destroyView: debugDestroyView,
          createDebugContext: (view, nodeIndex) => new DebugContext_(view, nodeIndex),
          handleEvent: debugHandleEvent,
          updateDirectives: debugUpdateDirectives,
          updateRenderer: debugUpdateRenderer,
      };
  }
  /**
   * @param {?} elInjector
   * @param {?} projectableNodes
   * @param {?} rootSelectorOrNode
   * @param {?} def
   * @param {?} ngModule
   * @param {?=} context
   * @return {?}
   */
  function createProdRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
      /** @type {?} */
      const rendererFactory = ngModule.injector.get(RendererFactory2);
      return createRootView(createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode), def, context);
  }
  /**
   * @param {?} elInjector
   * @param {?} projectableNodes
   * @param {?} rootSelectorOrNode
   * @param {?} def
   * @param {?} ngModule
   * @param {?=} context
   * @return {?}
   */
  function debugCreateRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
      /** @type {?} */
      const rendererFactory = ngModule.injector.get(RendererFactory2);
      /** @type {?} */
      const root = createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode);
      /** @type {?} */
      const defWithOverride = applyProviderOverridesToView(def);
      return callWithDebugContext(DebugAction.create, createRootView, null, [root, defWithOverride, context]);
  }
  /**
   * @param {?} elInjector
   * @param {?} ngModule
   * @param {?} rendererFactory
   * @param {?} projectableNodes
   * @param {?} rootSelectorOrNode
   * @return {?}
   */
  function createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode) {
      /** @type {?} */
      const sanitizer = ngModule.injector.get(Sanitizer);
      /** @type {?} */
      const errorHandler = ngModule.injector.get(ErrorHandler);
      /** @type {?} */
      const renderer = rendererFactory.createRenderer(null, null);
      return {
          ngModule,
          injector: elInjector, projectableNodes,
          selectorOrNode: rootSelectorOrNode, sanitizer, rendererFactory, renderer, errorHandler
      };
  }
  /**
   * @param {?} parentView
   * @param {?} anchorDef
   * @param {?} viewDef
   * @param {?=} context
   * @return {?}
   */
  function debugCreateEmbeddedView(parentView, anchorDef, viewDef$$1, context) {
      /** @type {?} */
      const defWithOverride = applyProviderOverridesToView(viewDef$$1);
      return callWithDebugContext(DebugAction.create, createEmbeddedView, null, [parentView, anchorDef, defWithOverride, context]);
  }
  /**
   * @param {?} parentView
   * @param {?} nodeDef
   * @param {?} viewDef
   * @param {?} hostElement
   * @return {?}
   */
  function debugCreateComponentView(parentView, nodeDef, viewDef$$1, hostElement) {
      /** @type {?} */
      const overrideComponentView = viewDefOverrides.get((/** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ (nodeDef.element)).componentProvider)).provider)).token);
      if (overrideComponentView) {
          viewDef$$1 = overrideComponentView;
      }
      else {
          viewDef$$1 = applyProviderOverridesToView(viewDef$$1);
      }
      return callWithDebugContext(DebugAction.create, createComponentView, null, [parentView, nodeDef, viewDef$$1, hostElement]);
  }
  /**
   * @param {?} moduleType
   * @param {?} parentInjector
   * @param {?} bootstrapComponents
   * @param {?} def
   * @return {?}
   */
  function debugCreateNgModuleRef(moduleType, parentInjector, bootstrapComponents, def) {
      /** @type {?} */
      const defWithOverride = applyProviderOverridesToNgModule(def);
      return createNgModuleRef(moduleType, parentInjector, bootstrapComponents, defWithOverride);
  }
  /** @type {?} */
  const providerOverrides = new Map();
  /** @type {?} */
  const providerOverridesWithScope = new Map();
  /** @type {?} */
  const viewDefOverrides = new Map();
  /**
   * @param {?} override
   * @return {?}
   */
  function debugOverrideProvider(override) {
      providerOverrides.set(override.token, override);
      /** @type {?} */
      let injectableDef;
      if (typeof override.token === 'function' && (injectableDef = getInjectableDef(override.token)) &&
          typeof injectableDef.providedIn === 'function') {
          providerOverridesWithScope.set((/** @type {?} */ (override.token)), override);
      }
  }
  /**
   * @param {?} comp
   * @param {?} compFactory
   * @return {?}
   */
  function debugOverrideComponentView(comp, compFactory) {
      /** @type {?} */
      const hostViewDef = resolveDefinition(getComponentViewDefinitionFactory(compFactory));
      /** @type {?} */
      const compViewDef = resolveDefinition((/** @type {?} */ ((/** @type {?} */ (hostViewDef.nodes[0].element)).componentView)));
      viewDefOverrides.set(comp, compViewDef);
  }
  /**
   * @return {?}
   */
  function debugClearOverrides() {
      providerOverrides.clear();
      providerOverridesWithScope.clear();
      viewDefOverrides.clear();
  }
  // Notes about the algorithm:
  // 1) Locate the providers of an element and check if one of them was overwritten
  // 2) Change the providers of that element
  //
  // We only create new datastructures if we need to, to keep perf impact
  // reasonable.
  /**
   * @param {?} def
   * @return {?}
   */
  function applyProviderOverridesToView(def) {
      if (providerOverrides.size === 0) {
          return def;
      }
      /** @type {?} */
      const elementIndicesWithOverwrittenProviders = findElementIndicesWithOverwrittenProviders(def);
      if (elementIndicesWithOverwrittenProviders.length === 0) {
          return def;
      }
      // clone the whole view definition,
      // as it maintains references between the nodes that are hard to update.
      def = (/** @type {?} */ (def.factory))(() => NOOP);
      for (let i = 0; i < elementIndicesWithOverwrittenProviders.length; i++) {
          applyProviderOverridesToElement(def, elementIndicesWithOverwrittenProviders[i]);
      }
      return def;
      /**
       * @param {?} def
       * @return {?}
       */
      function findElementIndicesWithOverwrittenProviders(def) {
          /** @type {?} */
          const elIndicesWithOverwrittenProviders = [];
          /** @type {?} */
          let lastElementDef = null;
          for (let i = 0; i < def.nodes.length; i++) {
              /** @type {?} */
              const nodeDef = def.nodes[i];
              if (nodeDef.flags & 1 /* TypeElement */) {
                  lastElementDef = nodeDef;
              }
              if (lastElementDef && nodeDef.flags & 3840 /* CatProviderNoDirective */ &&
                  providerOverrides.has((/** @type {?} */ (nodeDef.provider)).token)) {
                  elIndicesWithOverwrittenProviders.push((/** @type {?} */ (lastElementDef)).nodeIndex);
                  lastElementDef = null;
              }
          }
          return elIndicesWithOverwrittenProviders;
      }
      /**
       * @param {?} viewDef
       * @param {?} elIndex
       * @return {?}
       */
      function applyProviderOverridesToElement(viewDef$$1, elIndex) {
          for (let i = elIndex + 1; i < viewDef$$1.nodes.length; i++) {
              /** @type {?} */
              const nodeDef = viewDef$$1.nodes[i];
              if (nodeDef.flags & 1 /* TypeElement */) {
                  // stop at the next element
                  return;
              }
              if (nodeDef.flags & 3840 /* CatProviderNoDirective */) {
                  /** @type {?} */
                  const provider = (/** @type {?} */ (nodeDef.provider));
                  /** @type {?} */
                  const override = providerOverrides.get(provider.token);
                  if (override) {
                      nodeDef.flags = (nodeDef.flags & ~3840 /* CatProviderNoDirective */) | override.flags;
                      provider.deps = splitDepsDsl(override.deps);
                      provider.value = override.value;
                  }
              }
          }
      }
  }
  // Notes about the algorithm:
  // We only create new datastructures if we need to, to keep perf impact
  // reasonable.
  /**
   * @param {?} def
   * @return {?}
   */
  function applyProviderOverridesToNgModule(def) {
      const { hasOverrides, hasDeprecatedOverrides } = calcHasOverrides(def);
      if (!hasOverrides) {
          return def;
      }
      // clone the whole view definition,
      // as it maintains references between the nodes that are hard to update.
      def = (/** @type {?} */ (def.factory))(() => NOOP);
      applyProviderOverrides(def);
      return def;
      /**
       * @param {?} def
       * @return {?}
       */
      function calcHasOverrides(def) {
          /** @type {?} */
          let hasOverrides = false;
          /** @type {?} */
          let hasDeprecatedOverrides = false;
          if (providerOverrides.size === 0) {
              return { hasOverrides, hasDeprecatedOverrides };
          }
          def.providers.forEach(node => {
              /** @type {?} */
              const override = providerOverrides.get(node.token);
              if ((node.flags & 3840 /* CatProviderNoDirective */) && override) {
                  hasOverrides = true;
                  hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;
              }
          });
          def.modules.forEach(module => {
              providerOverridesWithScope.forEach((override, token) => {
                  if ((/** @type {?} */ (getInjectableDef(token))).providedIn === module) {
                      hasOverrides = true;
                      hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;
                  }
              });
          });
          return { hasOverrides, hasDeprecatedOverrides };
      }
      /**
       * @param {?} def
       * @return {?}
       */
      function applyProviderOverrides(def) {
          for (let i = 0; i < def.providers.length; i++) {
              /** @type {?} */
              const provider = def.providers[i];
              if (hasDeprecatedOverrides) {
                  // We had a bug where me made
                  // all providers lazy. Keep this logic behind a flag
                  // for migrating existing users.
                  provider.flags |= 4096 /* LazyProvider */;
              }
              /** @type {?} */
              const override = providerOverrides.get(provider.token);
              if (override) {
                  provider.flags = (provider.flags & ~3840 /* CatProviderNoDirective */) | override.flags;
                  provider.deps = splitDepsDsl(override.deps);
                  provider.value = override.value;
              }
          }
          if (providerOverridesWithScope.size > 0) {
              /** @type {?} */
              let moduleSet = new Set(def.modules);
              providerOverridesWithScope.forEach((override, token) => {
                  if (moduleSet.has((/** @type {?} */ (getInjectableDef(token))).providedIn)) {
                      /** @type {?} */
                      let provider = {
                          token: token,
                          flags: override.flags | (hasDeprecatedOverrides ? 4096 /* LazyProvider */ : 0 /* None */),
                          deps: splitDepsDsl(override.deps),
                          value: override.value,
                          index: def.providers.length,
                      };
                      def.providers.push(provider);
                      def.providersByKey[tokenKey(token)] = provider;
                  }
              });
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} checkIndex
   * @param {?} argStyle
   * @param {?=} v0
   * @param {?=} v1
   * @param {?=} v2
   * @param {?=} v3
   * @param {?=} v4
   * @param {?=} v5
   * @param {?=} v6
   * @param {?=} v7
   * @param {?=} v8
   * @param {?=} v9
   * @return {?}
   */
  function prodCheckAndUpdateNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const nodeDef = view.def.nodes[checkIndex];
      checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
      return (nodeDef.flags & 224 /* CatPureExpression */) ?
          asPureExpressionData(view, checkIndex).value :
          undefined;
  }
  /**
   * @param {?} view
   * @param {?} checkIndex
   * @param {?} argStyle
   * @param {?=} v0
   * @param {?=} v1
   * @param {?=} v2
   * @param {?=} v3
   * @param {?=} v4
   * @param {?=} v5
   * @param {?=} v6
   * @param {?=} v7
   * @param {?=} v8
   * @param {?=} v9
   * @return {?}
   */
  function prodCheckNoChangesNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const nodeDef = view.def.nodes[checkIndex];
      checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
      return (nodeDef.flags & 224 /* CatPureExpression */) ?
          asPureExpressionData(view, checkIndex).value :
          undefined;
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function debugCheckAndUpdateView(view) {
      return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [view]);
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function debugCheckNoChangesView(view) {
      return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [view]);
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function debugDestroyView(view) {
      return callWithDebugContext(DebugAction.destroy, destroyView, null, [view]);
  }
  /** @enum {number} */
  const DebugAction = {
      create: 0,
      detectChanges: 1,
      checkNoChanges: 2,
      destroy: 3,
      handleEvent: 4,
  };
  DebugAction[DebugAction.create] = 'create';
  DebugAction[DebugAction.detectChanges] = 'detectChanges';
  DebugAction[DebugAction.checkNoChanges] = 'checkNoChanges';
  DebugAction[DebugAction.destroy] = 'destroy';
  DebugAction[DebugAction.handleEvent] = 'handleEvent';
  /** @type {?} */
  let _currentAction;
  /** @type {?} */
  let _currentView;
  /** @type {?} */
  let _currentNodeIndex;
  /**
   * @param {?} view
   * @param {?} nodeIndex
   * @return {?}
   */
  function debugSetCurrentNode(view, nodeIndex) {
      _currentView = view;
      _currentNodeIndex = nodeIndex;
  }
  /**
   * @param {?} view
   * @param {?} nodeIndex
   * @param {?} eventName
   * @param {?} event
   * @return {?}
   */
  function debugHandleEvent(view, nodeIndex, eventName, event) {
      debugSetCurrentNode(view, nodeIndex);
      return callWithDebugContext(DebugAction.handleEvent, view.def.handleEvent, null, [view, nodeIndex, eventName, event]);
  }
  /**
   * @param {?} view
   * @param {?} checkType
   * @return {?}
   */
  function debugUpdateDirectives(view, checkType) {
      if (view.state & 128 /* Destroyed */) {
          throw viewDestroyedError(DebugAction[_currentAction]);
      }
      debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0));
      return view.def.updateDirectives(debugCheckDirectivesFn, view);
      /**
       * @param {?} view
       * @param {?} nodeIndex
       * @param {?} argStyle
       * @param {...?} values
       * @return {?}
       */
      function debugCheckDirectivesFn(view, nodeIndex, argStyle, ...values) {
          /** @type {?} */
          const nodeDef = view.def.nodes[nodeIndex];
          if (checkType === 0 /* CheckAndUpdate */) {
              debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
          }
          else {
              debugCheckNoChangesNode(view, nodeDef, argStyle, values);
          }
          if (nodeDef.flags & 16384 /* TypeDirective */) {
              debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex));
          }
          return (nodeDef.flags & 224 /* CatPureExpression */) ?
              asPureExpressionData(view, nodeDef.nodeIndex).value :
              undefined;
      }
  }
  /**
   * @param {?} view
   * @param {?} checkType
   * @return {?}
   */
  function debugUpdateRenderer(view, checkType) {
      if (view.state & 128 /* Destroyed */) {
          throw viewDestroyedError(DebugAction[_currentAction]);
      }
      debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0));
      return view.def.updateRenderer(debugCheckRenderNodeFn, view);
      /**
       * @param {?} view
       * @param {?} nodeIndex
       * @param {?} argStyle
       * @param {...?} values
       * @return {?}
       */
      function debugCheckRenderNodeFn(view, nodeIndex, argStyle, ...values) {
          /** @type {?} */
          const nodeDef = view.def.nodes[nodeIndex];
          if (checkType === 0 /* CheckAndUpdate */) {
              debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
          }
          else {
              debugCheckNoChangesNode(view, nodeDef, argStyle, values);
          }
          if (nodeDef.flags & 3 /* CatRenderNode */) {
              debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex));
          }
          return (nodeDef.flags & 224 /* CatPureExpression */) ?
              asPureExpressionData(view, nodeDef.nodeIndex).value :
              undefined;
      }
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} argStyle
   * @param {?} givenValues
   * @return {?}
   */
  function debugCheckAndUpdateNode(view, nodeDef, argStyle, givenValues) {
      /** @type {?} */
      const changed = ((/** @type {?} */ (checkAndUpdateNode)))(view, nodeDef, argStyle, ...givenValues);
      if (changed) {
          /** @type {?} */
          const values = argStyle === 1 /* Dynamic */ ? givenValues[0] : givenValues;
          if (nodeDef.flags & 16384 /* TypeDirective */) {
              /** @type {?} */
              const bindingValues = {};
              for (let i = 0; i < nodeDef.bindings.length; i++) {
                  /** @type {?} */
                  const binding = nodeDef.bindings[i];
                  /** @type {?} */
                  const value = values[i];
                  if (binding.flags & 8 /* TypeProperty */) {
                      bindingValues[normalizeDebugBindingName((/** @type {?} */ (binding.nonMinifiedName)))] =
                          normalizeDebugBindingValue(value);
                  }
              }
              /** @type {?} */
              const elDef = (/** @type {?} */ (nodeDef.parent));
              /** @type {?} */
              const el = asElementData(view, elDef.nodeIndex).renderElement;
              if (!(/** @type {?} */ (elDef.element)).name) {
                  // a comment.
                  view.renderer.setValue(el, `bindings=${JSON.stringify(bindingValues, null, 2)}`);
              }
              else {
                  // a regular element.
                  for (let attr in bindingValues) {
                      /** @type {?} */
                      const value = bindingValues[attr];
                      if (value != null) {
                          view.renderer.setAttribute(el, attr, value);
                      }
                      else {
                          view.renderer.removeAttribute(el, attr);
                      }
                  }
              }
          }
      }
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} argStyle
   * @param {?} values
   * @return {?}
   */
  function debugCheckNoChangesNode(view, nodeDef, argStyle, values) {
      ((/** @type {?} */ (checkNoChangesNode)))(view, nodeDef, argStyle, ...values);
  }
  /**
   * @param {?} view
   * @param {?} nodeIndex
   * @return {?}
   */
  function nextDirectiveWithBinding(view, nodeIndex) {
      for (let i = nodeIndex; i < view.def.nodes.length; i++) {
          /** @type {?} */
          const nodeDef = view.def.nodes[i];
          if (nodeDef.flags & 16384 /* TypeDirective */ && nodeDef.bindings && nodeDef.bindings.length) {
              return i;
          }
      }
      return null;
  }
  /**
   * @param {?} view
   * @param {?} nodeIndex
   * @return {?}
   */
  function nextRenderNodeWithBinding(view, nodeIndex) {
      for (let i = nodeIndex; i < view.def.nodes.length; i++) {
          /** @type {?} */
          const nodeDef = view.def.nodes[i];
          if ((nodeDef.flags & 3 /* CatRenderNode */) && nodeDef.bindings && nodeDef.bindings.length) {
              return i;
          }
      }
      return null;
  }
  class DebugContext_ {
      /**
       * @param {?} view
       * @param {?} nodeIndex
       */
      constructor(view, nodeIndex) {
          this.view = view;
          this.nodeIndex = nodeIndex;
          if (nodeIndex == null) {
              this.nodeIndex = nodeIndex = 0;
          }
          this.nodeDef = view.def.nodes[nodeIndex];
          /** @type {?} */
          let elDef = this.nodeDef;
          /** @type {?} */
          let elView = view;
          while (elDef && (elDef.flags & 1 /* TypeElement */) === 0) {
              elDef = (/** @type {?} */ (elDef.parent));
          }
          if (!elDef) {
              while (!elDef && elView) {
                  elDef = (/** @type {?} */ (viewParentEl(elView)));
                  elView = (/** @type {?} */ (elView.parent));
              }
          }
          this.elDef = elDef;
          this.elView = elView;
      }
      /**
       * @private
       * @return {?}
       */
      get elOrCompView() {
          // Has to be done lazily as we use the DebugContext also during creation of elements...
          return asElementData(this.elView, this.elDef.nodeIndex).componentView || this.view;
      }
      /**
       * @return {?}
       */
      get injector() { return createInjector$1(this.elView, this.elDef); }
      /**
       * @return {?}
       */
      get component() { return this.elOrCompView.component; }
      /**
       * @return {?}
       */
      get context() { return this.elOrCompView.context; }
      /**
       * @return {?}
       */
      get providerTokens() {
          /** @type {?} */
          const tokens = [];
          if (this.elDef) {
              for (let i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {
                  /** @type {?} */
                  const childDef = this.elView.def.nodes[i];
                  if (childDef.flags & 20224 /* CatProvider */) {
                      tokens.push((/** @type {?} */ (childDef.provider)).token);
                  }
                  i += childDef.childCount;
              }
          }
          return tokens;
      }
      /**
       * @return {?}
       */
      get references() {
          /** @type {?} */
          const references = {};
          if (this.elDef) {
              collectReferences(this.elView, this.elDef, references);
              for (let i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {
                  /** @type {?} */
                  const childDef = this.elView.def.nodes[i];
                  if (childDef.flags & 20224 /* CatProvider */) {
                      collectReferences(this.elView, childDef, references);
                  }
                  i += childDef.childCount;
              }
          }
          return references;
      }
      /**
       * @return {?}
       */
      get componentRenderElement() {
          /** @type {?} */
          const elData = findHostElement(this.elOrCompView);
          return elData ? elData.renderElement : undefined;
      }
      /**
       * @return {?}
       */
      get renderNode() {
          return this.nodeDef.flags & 2 /* TypeText */ ? renderNode(this.view, this.nodeDef) :
              renderNode(this.elView, this.elDef);
      }
      /**
       * @param {?} console
       * @param {...?} values
       * @return {?}
       */
      logError(console, ...values) {
          /** @type {?} */
          let logViewDef;
          /** @type {?} */
          let logNodeIndex;
          if (this.nodeDef.flags & 2 /* TypeText */) {
              logViewDef = this.view.def;
              logNodeIndex = this.nodeDef.nodeIndex;
          }
          else {
              logViewDef = this.elView.def;
              logNodeIndex = this.elDef.nodeIndex;
          }
          // Note: we only generate a log function for text and element nodes
          // to make the generated code as small as possible.
          /** @type {?} */
          const renderNodeIndex = getRenderNodeIndex(logViewDef, logNodeIndex);
          /** @type {?} */
          let currRenderNodeIndex = -1;
          /** @type {?} */
          let nodeLogger = () => {
              currRenderNodeIndex++;
              if (currRenderNodeIndex === renderNodeIndex) {
                  return console.error.bind(console, ...values);
              }
              else {
                  return NOOP;
              }
          };
          (/** @type {?} */ (logViewDef.factory))(nodeLogger);
          if (currRenderNodeIndex < renderNodeIndex) {
              console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');
              ((/** @type {?} */ (console.error)))(...values);
          }
      }
  }
  /**
   * @param {?} viewDef
   * @param {?} nodeIndex
   * @return {?}
   */
  function getRenderNodeIndex(viewDef$$1, nodeIndex) {
      /** @type {?} */
      let renderNodeIndex = -1;
      for (let i = 0; i <= nodeIndex; i++) {
          /** @type {?} */
          const nodeDef = viewDef$$1.nodes[i];
          if (nodeDef.flags & 3 /* CatRenderNode */) {
              renderNodeIndex++;
          }
      }
      return renderNodeIndex;
  }
  /**
   * @param {?} view
   * @return {?}
   */
  function findHostElement(view) {
      while (view && !isComponentView(view)) {
          view = (/** @type {?} */ (view.parent));
      }
      if (view.parent) {
          return asElementData(view.parent, (/** @type {?} */ (viewParentEl(view))).nodeIndex);
      }
      return null;
  }
  /**
   * @param {?} view
   * @param {?} nodeDef
   * @param {?} references
   * @return {?}
   */
  function collectReferences(view, nodeDef, references) {
      for (let refName in nodeDef.references) {
          references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);
      }
  }
  /**
   * @param {?} action
   * @param {?} fn
   * @param {?} self
   * @param {?} args
   * @return {?}
   */
  function callWithDebugContext(action, fn, self, args) {
      /** @type {?} */
      const oldAction = _currentAction;
      /** @type {?} */
      const oldView = _currentView;
      /** @type {?} */
      const oldNodeIndex = _currentNodeIndex;
      try {
          _currentAction = action;
          /** @type {?} */
          const result = fn.apply(self, args);
          _currentView = oldView;
          _currentNodeIndex = oldNodeIndex;
          _currentAction = oldAction;
          return result;
      }
      catch (e) {
          if (isViewDebugError(e) || !_currentView) {
              throw e;
          }
          throw viewWrappedDebugError(e, (/** @type {?} */ (getCurrentDebugContext())));
      }
  }
  /**
   * @return {?}
   */
  function getCurrentDebugContext() {
      return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;
  }
  class DebugRendererFactory2 {
      /**
       * @param {?} delegate
       */
      constructor(delegate) {
          this.delegate = delegate;
      }
      /**
       * @param {?} element
       * @param {?} renderData
       * @return {?}
       */
      createRenderer(element, renderData) {
          return new DebugRenderer2(this.delegate.createRenderer(element, renderData));
      }
      /**
       * @return {?}
       */
      begin() {
          if (this.delegate.begin) {
              this.delegate.begin();
          }
      }
      /**
       * @return {?}
       */
      end() {
          if (this.delegate.end) {
              this.delegate.end();
          }
      }
      /**
       * @return {?}
       */
      whenRenderingDone() {
          if (this.delegate.whenRenderingDone) {
              return this.delegate.whenRenderingDone();
          }
          return Promise.resolve(null);
      }
  }
  class DebugRenderer2 {
      /**
       * @param {?} delegate
       */
      constructor(delegate) {
          this.delegate = delegate;
          /**
           * Factory function used to create a `DebugContext` when a node is created.
           *
           * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.
           *
           * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine
           * or a Render context.
           */
          this.debugContextFactory = getCurrentDebugContext;
          this.data = this.delegate.data;
      }
      /**
       * @private
       * @param {?} nativeElement
       * @return {?}
       */
      createDebugContext(nativeElement) { return this.debugContextFactory(nativeElement); }
      /**
       * @param {?} node
       * @return {?}
       */
      destroyNode(node) {
          removeDebugNodeFromIndex((/** @type {?} */ (getDebugNode(node))));
          if (this.delegate.destroyNode) {
              this.delegate.destroyNode(node);
          }
      }
      /**
       * @return {?}
       */
      destroy() { this.delegate.destroy(); }
      /**
       * @param {?} name
       * @param {?=} namespace
       * @return {?}
       */
      createElement(name, namespace) {
          /** @type {?} */
          const el = this.delegate.createElement(name, namespace);
          /** @type {?} */
          const debugCtx = this.createDebugContext(el);
          if (debugCtx) {
              /** @type {?} */
              const debugEl = new DebugElement__PRE_R3__(el, null, debugCtx);
              ((/** @type {?} */ (debugEl))).name = name;
              indexDebugNode(debugEl);
          }
          return el;
      }
      /**
       * @param {?} value
       * @return {?}
       */
      createComment(value) {
          /** @type {?} */
          const comment = this.delegate.createComment(value);
          /** @type {?} */
          const debugCtx = this.createDebugContext(comment);
          if (debugCtx) {
              indexDebugNode(new DebugNode__PRE_R3__(comment, null, debugCtx));
          }
          return comment;
      }
      /**
       * @param {?} value
       * @return {?}
       */
      createText(value) {
          /** @type {?} */
          const text = this.delegate.createText(value);
          /** @type {?} */
          const debugCtx = this.createDebugContext(text);
          if (debugCtx) {
              indexDebugNode(new DebugNode__PRE_R3__(text, null, debugCtx));
          }
          return text;
      }
      /**
       * @param {?} parent
       * @param {?} newChild
       * @return {?}
       */
      appendChild(parent, newChild) {
          /** @type {?} */
          const debugEl = getDebugNode(parent);
          /** @type {?} */
          const debugChildEl = getDebugNode(newChild);
          if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {
              debugEl.addChild(debugChildEl);
          }
          this.delegate.appendChild(parent, newChild);
      }
      /**
       * @param {?} parent
       * @param {?} newChild
       * @param {?} refChild
       * @return {?}
       */
      insertBefore(parent, newChild, refChild) {
          /** @type {?} */
          const debugEl = getDebugNode(parent);
          /** @type {?} */
          const debugChildEl = getDebugNode(newChild);
          /** @type {?} */
          const debugRefEl = (/** @type {?} */ (getDebugNode(refChild)));
          if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {
              debugEl.insertBefore(debugRefEl, debugChildEl);
          }
          this.delegate.insertBefore(parent, newChild, refChild);
      }
      /**
       * @param {?} parent
       * @param {?} oldChild
       * @return {?}
       */
      removeChild(parent, oldChild) {
          /** @type {?} */
          const debugEl = getDebugNode(parent);
          /** @type {?} */
          const debugChildEl = getDebugNode(oldChild);
          if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {
              debugEl.removeChild(debugChildEl);
          }
          this.delegate.removeChild(parent, oldChild);
      }
      /**
       * @param {?} selectorOrNode
       * @param {?=} preserveContent
       * @return {?}
       */
      selectRootElement(selectorOrNode, preserveContent) {
          /** @type {?} */
          const el = this.delegate.selectRootElement(selectorOrNode, preserveContent);
          /** @type {?} */
          const debugCtx = getCurrentDebugContext();
          if (debugCtx) {
              indexDebugNode(new DebugElement__PRE_R3__(el, null, debugCtx));
          }
          return el;
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?} value
       * @param {?=} namespace
       * @return {?}
       */
      setAttribute(el, name, value, namespace) {
          /** @type {?} */
          const debugEl = getDebugNode(el);
          if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
              /** @type {?} */
              const fullName = namespace ? namespace + ':' + name : name;
              debugEl.attributes[fullName] = value;
          }
          this.delegate.setAttribute(el, name, value, namespace);
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?=} namespace
       * @return {?}
       */
      removeAttribute(el, name, namespace) {
          /** @type {?} */
          const debugEl = getDebugNode(el);
          if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
              /** @type {?} */
              const fullName = namespace ? namespace + ':' + name : name;
              debugEl.attributes[fullName] = null;
          }
          this.delegate.removeAttribute(el, name, namespace);
      }
      /**
       * @param {?} el
       * @param {?} name
       * @return {?}
       */
      addClass(el, name) {
          /** @type {?} */
          const debugEl = getDebugNode(el);
          if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
              debugEl.classes[name] = true;
          }
          this.delegate.addClass(el, name);
      }
      /**
       * @param {?} el
       * @param {?} name
       * @return {?}
       */
      removeClass(el, name) {
          /** @type {?} */
          const debugEl = getDebugNode(el);
          if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
              debugEl.classes[name] = false;
          }
          this.delegate.removeClass(el, name);
      }
      /**
       * @param {?} el
       * @param {?} style
       * @param {?} value
       * @param {?} flags
       * @return {?}
       */
      setStyle(el, style, value, flags) {
          /** @type {?} */
          const debugEl = getDebugNode(el);
          if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
              debugEl.styles[style] = value;
          }
          this.delegate.setStyle(el, style, value, flags);
      }
      /**
       * @param {?} el
       * @param {?} style
       * @param {?} flags
       * @return {?}
       */
      removeStyle(el, style, flags) {
          /** @type {?} */
          const debugEl = getDebugNode(el);
          if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
              debugEl.styles[style] = null;
          }
          this.delegate.removeStyle(el, style, flags);
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?} value
       * @return {?}
       */
      setProperty(el, name, value) {
          /** @type {?} */
          const debugEl = getDebugNode(el);
          if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
              debugEl.properties[name] = value;
          }
          this.delegate.setProperty(el, name, value);
      }
      /**
       * @param {?} target
       * @param {?} eventName
       * @param {?} callback
       * @return {?}
       */
      listen(target, eventName, callback) {
          if (typeof target !== 'string') {
              /** @type {?} */
              const debugEl = getDebugNode(target);
              if (debugEl) {
                  debugEl.listeners.push(new EventListener(eventName, callback));
              }
          }
          return this.delegate.listen(target, eventName, callback);
      }
      /**
       * @param {?} node
       * @return {?}
       */
      parentNode(node) { return this.delegate.parentNode(node); }
      /**
       * @param {?} node
       * @return {?}
       */
      nextSibling(node) { return this.delegate.nextSibling(node); }
      /**
       * @param {?} node
       * @param {?} value
       * @return {?}
       */
      setValue(node, value) { return this.delegate.setValue(node, value); }
  }
  // Attention: this function is called as top level function.
  // Putting any logic in here will destroy closure tree shaking!
  /**
   * @param {?} ngModuleType
   * @param {?} bootstrapComponents
   * @param {?} defFactory
   * @return {?}
   */
  function createNgModuleFactory(ngModuleType, bootstrapComponents, defFactory) {
      return new NgModuleFactory_(ngModuleType, bootstrapComponents, defFactory);
  }
  /**
   * @param {?} def
   * @return {?}
   */
  function cloneNgModuleDefinition(def) {
      /** @type {?} */
      const providers = Array.from(def.providers);
      /** @type {?} */
      const modules = Array.from(def.modules);
      /** @type {?} */
      const providersByKey = {};
      for (const key in def.providersByKey) {
          providersByKey[key] = def.providersByKey[key];
      }
      return {
          factory: def.factory,
          isRoot: def.isRoot, providers, modules, providersByKey,
      };
  }
  class NgModuleFactory_ extends NgModuleFactory {
      /**
       * @param {?} moduleType
       * @param {?} _bootstrapComponents
       * @param {?} _ngModuleDefFactory
       */
      constructor(moduleType, _bootstrapComponents, _ngModuleDefFactory) {
          // Attention: this ctor is called as top level function.
          // Putting any logic in here will destroy closure tree shaking!
          super();
          this.moduleType = moduleType;
          this._bootstrapComponents = _bootstrapComponents;
          this._ngModuleDefFactory = _ngModuleDefFactory;
      }
      /**
       * @param {?} parentInjector
       * @return {?}
       */
      create(parentInjector) {
          initServicesIfNeeded();
          // Clone the NgModuleDefinition so that any tree shakeable provider definition
          // added to this instance of the NgModuleRef doesn't affect the cached copy.
          // See https://github.com/angular/angular/issues/25018.
          /** @type {?} */
          const def = cloneNgModuleDefinition(resolveDefinition(this._ngModuleDefFactory));
          return Services.createNgModuleRef(this.moduleType, parentInjector || Injector.NULL, this._bootstrapComponents, def);
      }
  }

  /**
   * @license Angular v7.2.8
   * (c) 2010-2019 Google LLC. https://angular.io/
   * License: MIT
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * This class should not be used directly by an application developer. Instead, use
   * {\@link Location}.
   *
   * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
   * agnostic.
   * This means that we can have different implementation of `PlatformLocation` for the different
   * platforms that angular supports. For example, `\@angular/platform-browser` provides an
   * implementation specific to the browser environment, while `\@angular/platform-webworker` provides
   * one suitable for use with web workers.
   *
   * The `PlatformLocation` class is used directly by all implementations of {\@link LocationStrategy}
   * when they need to interact with the DOM apis like pushState, popState, etc...
   *
   * {\@link LocationStrategy} in turn is used by the {\@link Location} service which is used directly
   * by the {\@link Router} in order to navigate between routes. Since all interactions between {\@link
   * Router} /
   * {\@link Location} / {\@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
   * class they are all platform independent.
   *
   * \@publicApi
   * @abstract
   */
  class PlatformLocation {
  }
  /**
   * \@description
   * Indicates when a location is initialized.
   *
   * \@publicApi
   * @type {?}
   */
  const LOCATION_INITIALIZED = new InjectionToken('Location Initialized');
  /**
   * A predefined [DI token](guide/glossary#di-token) for the base href
   * to be used with the `PathLocationStrategy`.
   * The base href is the URL prefix that should be preserved when generating
   * and recognizing URLs.
   *
   * \@usageNotes
   *
   * The following example shows how to use this token to configure the root app injector
   * with a base href value, so that the DI framework can supply the dependency anywhere in the app.
   *
   * ```typescript
   * import {Component, NgModule} from '\@angular/core';
   * import {APP_BASE_HREF} from '\@angular/common';
   *
   * \@NgModule({
   *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]
   * })
   * class AppModule {}
   * ```
   *
   * \@publicApi
   * @type {?}
   */
  const APP_BASE_HREF = new InjectionToken('appBaseHref');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // THIS CODE IS GENERATED - DO NOT MODIFY
  // See angular/tools/gulp-tasks/cldr/extract.js
  /** @type {?} */
  const u = undefined;
  /**
   * @param {?} n
   * @return {?}
   */
  function plural(n) {
      /** @type {?} */
      let i = Math.floor(Math.abs(n));
      /** @type {?} */
      let v = n.toString().replace(/^[^.]*\.?/, '').length;
      if (i === 1 && v === 0)
          return 1;
      return 5;
  }
  var localeEn = [
      'en', [['a', 'p'], ['AM', 'PM'], u], [['AM', 'PM'], u, u],
      [
          ['S', 'M', 'T', 'W', 'T', 'F', 'S'], ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
          ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
          ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']
      ],
      u,
      [
          ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
          ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
          [
              'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
              'October', 'November', 'December'
          ]
      ],
      u, [['B', 'A'], ['BC', 'AD'], ['Before Christ', 'Anno Domini']], 0, [6, 0],
      ['M/d/yy', 'MMM d, y', 'MMMM d, y', 'EEEE, MMMM d, y'],
      ['h:mm a', 'h:mm:ss a', 'h:mm:ss a z', 'h:mm:ss a zzzz'], ['{1}, {0}', u, '{1} \'at\' {0}', u],
      ['.', ',', ';', '%', '+', '-', 'E', '×', '‰', '∞', 'NaN', ':'],
      ['#,##0.###', '#,##0%', '¤#,##0.00', '#E0'], '$', 'US Dollar', {}, plural
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * \@publicApi
   * @type {?}
   */
  const LOCALE_DATA = {};

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  // THIS CODE IS GENERATED - DO NOT MODIFY
  // See angular/tools/gulp-tasks/cldr/extract.js
  /**
   * \@internal
   * @type {?}
   */
  const CURRENCIES_EN = {
      'ADP': [undefined, undefined, 0],
      'AFN': [undefined, undefined, 0],
      'ALL': [undefined, undefined, 0],
      'AMD': [undefined, undefined, 0],
      'AOA': [undefined, 'Kz'],
      'ARS': [undefined, '$'],
      'AUD': ['A$', '$'],
      'BAM': [undefined, 'KM'],
      'BBD': [undefined, '$'],
      'BDT': [undefined, '৳'],
      'BHD': [undefined, undefined, 3],
      'BIF': [undefined, undefined, 0],
      'BMD': [undefined, '$'],
      'BND': [undefined, '$'],
      'BOB': [undefined, 'Bs'],
      'BRL': ['R$'],
      'BSD': [undefined, '$'],
      'BWP': [undefined, 'P'],
      'BYN': [undefined, 'р.', 2],
      'BYR': [undefined, undefined, 0],
      'BZD': [undefined, '$'],
      'CAD': ['CA$', '$', 2],
      'CHF': [undefined, undefined, 2],
      'CLF': [undefined, undefined, 4],
      'CLP': [undefined, '$', 0],
      'CNY': ['CN¥', '¥'],
      'COP': [undefined, '$', 0],
      'CRC': [undefined, '₡', 2],
      'CUC': [undefined, '$'],
      'CUP': [undefined, '$'],
      'CZK': [undefined, 'Kč', 2],
      'DJF': [undefined, undefined, 0],
      'DKK': [undefined, 'kr', 2],
      'DOP': [undefined, '$'],
      'EGP': [undefined, 'E£'],
      'ESP': [undefined, '₧', 0],
      'EUR': ['€'],
      'FJD': [undefined, '$'],
      'FKP': [undefined, '£'],
      'GBP': ['£'],
      'GEL': [undefined, '₾'],
      'GIP': [undefined, '£'],
      'GNF': [undefined, 'FG', 0],
      'GTQ': [undefined, 'Q'],
      'GYD': [undefined, '$', 0],
      'HKD': ['HK$', '$'],
      'HNL': [undefined, 'L'],
      'HRK': [undefined, 'kn'],
      'HUF': [undefined, 'Ft', 2],
      'IDR': [undefined, 'Rp', 0],
      'ILS': ['₪'],
      'INR': ['₹'],
      'IQD': [undefined, undefined, 0],
      'IRR': [undefined, undefined, 0],
      'ISK': [undefined, 'kr', 0],
      'ITL': [undefined, undefined, 0],
      'JMD': [undefined, '$'],
      'JOD': [undefined, undefined, 3],
      'JPY': ['¥', undefined, 0],
      'KHR': [undefined, '៛'],
      'KMF': [undefined, 'CF', 0],
      'KPW': [undefined, '₩', 0],
      'KRW': ['₩', undefined, 0],
      'KWD': [undefined, undefined, 3],
      'KYD': [undefined, '$'],
      'KZT': [undefined, '₸'],
      'LAK': [undefined, '₭', 0],
      'LBP': [undefined, 'L£', 0],
      'LKR': [undefined, 'Rs'],
      'LRD': [undefined, '$'],
      'LTL': [undefined, 'Lt'],
      'LUF': [undefined, undefined, 0],
      'LVL': [undefined, 'Ls'],
      'LYD': [undefined, undefined, 3],
      'MGA': [undefined, 'Ar', 0],
      'MGF': [undefined, undefined, 0],
      'MMK': [undefined, 'K', 0],
      'MNT': [undefined, '₮', 0],
      'MRO': [undefined, undefined, 0],
      'MUR': [undefined, 'Rs', 0],
      'MXN': ['MX$', '$'],
      'MYR': [undefined, 'RM'],
      'NAD': [undefined, '$'],
      'NGN': [undefined, '₦'],
      'NIO': [undefined, 'C$'],
      'NOK': [undefined, 'kr', 2],
      'NPR': [undefined, 'Rs'],
      'NZD': ['NZ$', '$'],
      'OMR': [undefined, undefined, 3],
      'PHP': [undefined, '₱'],
      'PKR': [undefined, 'Rs', 0],
      'PLN': [undefined, 'zł'],
      'PYG': [undefined, '₲', 0],
      'RON': [undefined, 'lei'],
      'RSD': [undefined, undefined, 0],
      'RUB': [undefined, '₽'],
      'RUR': [undefined, 'р.'],
      'RWF': [undefined, 'RF', 0],
      'SBD': [undefined, '$'],
      'SEK': [undefined, 'kr', 2],
      'SGD': [undefined, '$'],
      'SHP': [undefined, '£'],
      'SLL': [undefined, undefined, 0],
      'SOS': [undefined, undefined, 0],
      'SRD': [undefined, '$'],
      'SSP': [undefined, '£'],
      'STD': [undefined, undefined, 0],
      'STN': [undefined, 'Db'],
      'SYP': [undefined, '£', 0],
      'THB': [undefined, '฿'],
      'TMM': [undefined, undefined, 0],
      'TND': [undefined, undefined, 3],
      'TOP': [undefined, 'T$'],
      'TRL': [undefined, undefined, 0],
      'TRY': [undefined, '₺'],
      'TTD': [undefined, '$'],
      'TWD': ['NT$', '$', 2],
      'TZS': [undefined, undefined, 0],
      'UAH': [undefined, '₴'],
      'UGX': [undefined, undefined, 0],
      'USD': ['$'],
      'UYI': [undefined, undefined, 0],
      'UYU': [undefined, '$'],
      'UZS': [undefined, undefined, 0],
      'VEF': [undefined, 'Bs'],
      'VND': ['₫', undefined, 0],
      'VUV': [undefined, undefined, 0],
      'XAF': ['FCFA', undefined, 0],
      'XCD': ['EC$', '$'],
      'XOF': ['CFA', undefined, 0],
      'XPF': ['CFPF', undefined, 0],
      'YER': [undefined, undefined, 0],
      'ZAR': [undefined, 'R'],
      'ZMK': [undefined, undefined, 0],
      'ZMW': [undefined, 'ZK'],
      'ZWD': [undefined, undefined, 0]
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @enum {number} */
  const NumberFormatStyle = {
      Decimal: 0,
      Percent: 1,
      Currency: 2,
      Scientific: 3,
  };
  NumberFormatStyle[NumberFormatStyle.Decimal] = 'Decimal';
  NumberFormatStyle[NumberFormatStyle.Percent] = 'Percent';
  NumberFormatStyle[NumberFormatStyle.Currency] = 'Currency';
  NumberFormatStyle[NumberFormatStyle.Scientific] = 'Scientific';
  /** @enum {number} */
  const Plural$1 = {
      Zero: 0,
      One: 1,
      Two: 2,
      Few: 3,
      Many: 4,
      Other: 5,
  };
  Plural$1[Plural$1.Zero] = 'Zero';
  Plural$1[Plural$1.One] = 'One';
  Plural$1[Plural$1.Two] = 'Two';
  Plural$1[Plural$1.Few] = 'Few';
  Plural$1[Plural$1.Many] = 'Many';
  Plural$1[Plural$1.Other] = 'Other';
  /** @enum {number} */
  const FormStyle = {
      Format: 0,
      Standalone: 1,
  };
  FormStyle[FormStyle.Format] = 'Format';
  FormStyle[FormStyle.Standalone] = 'Standalone';
  /** @enum {number} */
  const TranslationWidth = {
      Narrow: 0,
      Abbreviated: 1,
      Wide: 2,
      Short: 3,
  };
  TranslationWidth[TranslationWidth.Narrow] = 'Narrow';
  TranslationWidth[TranslationWidth.Abbreviated] = 'Abbreviated';
  TranslationWidth[TranslationWidth.Wide] = 'Wide';
  TranslationWidth[TranslationWidth.Short] = 'Short';
  /** @enum {number} */
  const FormatWidth = {
      Short: 0,
      Medium: 1,
      Long: 2,
      Full: 3,
  };
  FormatWidth[FormatWidth.Short] = 'Short';
  FormatWidth[FormatWidth.Medium] = 'Medium';
  FormatWidth[FormatWidth.Long] = 'Long';
  FormatWidth[FormatWidth.Full] = 'Full';
  /** @enum {number} */
  const NumberSymbol = {
      Decimal: 0,
      Group: 1,
      List: 2,
      PercentSign: 3,
      PlusSign: 4,
      MinusSign: 5,
      Exponential: 6,
      SuperscriptingExponent: 7,
      PerMille: 8,
      Infinity: 9,
      NaN: 10,
      TimeSeparator: 11,
      CurrencyDecimal: 12,
      CurrencyGroup: 13,
  };
  NumberSymbol[NumberSymbol.Decimal] = 'Decimal';
  NumberSymbol[NumberSymbol.Group] = 'Group';
  NumberSymbol[NumberSymbol.List] = 'List';
  NumberSymbol[NumberSymbol.PercentSign] = 'PercentSign';
  NumberSymbol[NumberSymbol.PlusSign] = 'PlusSign';
  NumberSymbol[NumberSymbol.MinusSign] = 'MinusSign';
  NumberSymbol[NumberSymbol.Exponential] = 'Exponential';
  NumberSymbol[NumberSymbol.SuperscriptingExponent] = 'SuperscriptingExponent';
  NumberSymbol[NumberSymbol.PerMille] = 'PerMille';
  NumberSymbol[NumberSymbol.Infinity] = 'Infinity';
  NumberSymbol[NumberSymbol.NaN] = 'NaN';
  NumberSymbol[NumberSymbol.TimeSeparator] = 'TimeSeparator';
  NumberSymbol[NumberSymbol.CurrencyDecimal] = 'CurrencyDecimal';
  NumberSymbol[NumberSymbol.CurrencyGroup] = 'CurrencyGroup';
  /**
   * The locale id for the chosen locale (e.g `en-GB`).
   *
   * \@publicApi
   * @param {?} locale
   * @return {?}
   */
  function getLocaleId(locale) {
      return findLocaleData(locale)[0 /* LocaleId */];
  }
  /**
   * Periods of the day (e.g. `[AM, PM]` for en-US).
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} formStyle
   * @param {?} width
   * @return {?}
   */
  function getLocaleDayPeriods(locale, formStyle, width) {
      /** @type {?} */
      const data = findLocaleData(locale);
      /** @type {?} */
      const amPmData = (/** @type {?} */ ([data[1 /* DayPeriodsFormat */], data[2 /* DayPeriodsStandalone */]]));
      /** @type {?} */
      const amPm = getLastDefinedValue(amPmData, formStyle);
      return getLastDefinedValue(amPm, width);
  }
  /**
   * Days of the week for the Gregorian calendar (e.g. `[Sunday, Monday, ... Saturday]` for en-US).
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} formStyle
   * @param {?} width
   * @return {?}
   */
  function getLocaleDayNames(locale, formStyle, width) {
      /** @type {?} */
      const data = findLocaleData(locale);
      /** @type {?} */
      const daysData = (/** @type {?} */ ([data[3 /* DaysFormat */], data[4 /* DaysStandalone */]]));
      /** @type {?} */
      const days = getLastDefinedValue(daysData, formStyle);
      return getLastDefinedValue(days, width);
  }
  /**
   * Months of the year for the Gregorian calendar (e.g. `[January, February, ...]` for en-US).
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} formStyle
   * @param {?} width
   * @return {?}
   */
  function getLocaleMonthNames(locale, formStyle, width) {
      /** @type {?} */
      const data = findLocaleData(locale);
      /** @type {?} */
      const monthsData = (/** @type {?} */ ([data[5 /* MonthsFormat */], data[6 /* MonthsStandalone */]]));
      /** @type {?} */
      const months = getLastDefinedValue(monthsData, formStyle);
      return getLastDefinedValue(months, width);
  }
  /**
   * Eras for the Gregorian calendar (e.g. AD/BC).
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} width
   * @return {?}
   */
  function getLocaleEraNames(locale, width) {
      /** @type {?} */
      const data = findLocaleData(locale);
      /** @type {?} */
      const erasData = (/** @type {?} */ (data[7 /* Eras */]));
      return getLastDefinedValue(erasData, width);
  }
  /**
   * Date format that depends on the locale.
   *
   * There are four basic date formats:
   * - `full` should contain long-weekday (EEEE), year (y), long-month (MMMM), day (d).
   *
   *  For example, English uses `EEEE, MMMM d, y`, corresponding to a date like
   *  "Tuesday, September 14, 1999".
   *
   * - `long` should contain year, long-month, day.
   *
   *  For example, `MMMM d, y`, corresponding to a date like "September 14, 1999".
   *
   * - `medium` should contain year, abbreviated-month (MMM), day.
   *
   *  For example, `MMM d, y`, corresponding to a date like "Sep 14, 1999".
   *  For languages that do not use abbreviated months, use the numeric month (MM/M). For example,
   *  `y/MM/dd`, corresponding to a date like "1999/09/14".
   *
   * - `short` should contain year, numeric-month (MM/M), and day.
   *
   *  For example, `M/d/yy`, corresponding to a date like "9/14/99".
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} width
   * @return {?}
   */
  function getLocaleDateFormat(locale, width) {
      /** @type {?} */
      const data = findLocaleData(locale);
      return getLastDefinedValue(data[10 /* DateFormat */], width);
  }
  /**
   * Time format that depends on the locale.
   *
   * The standard formats include four basic time formats:
   * - `full` should contain hour (h/H), minute (mm), second (ss), and zone (zzzz).
   * - `long` should contain hour, minute, second, and zone (z)
   * - `medium` should contain hour, minute, second.
   * - `short` should contain hour, minute.
   *
   * Note: The patterns depend on whether the main country using your language uses 12-hour time or
   * not:
   * - For 12-hour time, use a pattern like `hh:mm a` using h to mean a 12-hour clock cycle running
   * 1 through 12 (midnight plus 1 minute is 12:01), or using K to mean a 12-hour clock cycle
   * running 0 through 11 (midnight plus 1 minute is 0:01).
   * - For 24-hour time, use a pattern like `HH:mm` using H to mean a 24-hour clock cycle running 0
   * through 23 (midnight plus 1 minute is 0:01), or using k to mean a 24-hour clock cycle running
   * 1 through 24 (midnight plus 1 minute is 24:01).
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} width
   * @return {?}
   */
  function getLocaleTimeFormat(locale, width) {
      /** @type {?} */
      const data = findLocaleData(locale);
      return getLastDefinedValue(data[11 /* TimeFormat */], width);
  }
  /**
   * Date-time format that depends on the locale.
   *
   * The date-time pattern shows how to combine separate patterns for date (represented by {1})
   * and time (represented by {0}) into a single pattern. It usually doesn't need to be changed.
   * What you want to pay attention to are:
   * - possibly removing a space for languages that don't use it, such as many East Asian languages
   * - possibly adding a comma, other punctuation, or a combining word
   *
   * For example:
   * - English uses `{1} 'at' {0}` or `{1}, {0}` (depending on date style), while Japanese uses
   *  `{1}{0}`.
   * - An English formatted date-time using the combining pattern `{1}, {0}` could be
   *  `Dec 10, 2010, 3:59:49 PM`. Notice the comma and space between the date portion and the time
   *  portion.
   *
   * There are four formats (`full`, `long`, `medium`, `short`); the determination of which to use
   * is normally based on the date style. For example, if the date has a full month and weekday
   * name, the full combining pattern will be used to combine that with a time. If the date has
   * numeric month, the short version of the combining pattern will be used to combine that with a
   * time. English uses `{1} 'at' {0}` for full and long styles, and `{1}, {0}` for medium and short
   * styles.
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} width
   * @return {?}
   */
  function getLocaleDateTimeFormat(locale, width) {
      /** @type {?} */
      const data = findLocaleData(locale);
      /** @type {?} */
      const dateTimeFormatData = (/** @type {?} */ (data[12 /* DateTimeFormat */]));
      return getLastDefinedValue(dateTimeFormatData, width);
  }
  /**
   * Number symbol that can be used to replace placeholders in number formats.
   * See {\@link NumberSymbol} for more information.
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} symbol
   * @return {?}
   */
  function getLocaleNumberSymbol(locale, symbol) {
      /** @type {?} */
      const data = findLocaleData(locale);
      /** @type {?} */
      const res = data[13 /* NumberSymbols */][symbol];
      if (typeof res === 'undefined') {
          if (symbol === NumberSymbol.CurrencyDecimal) {
              return data[13 /* NumberSymbols */][NumberSymbol.Decimal];
          }
          else if (symbol === NumberSymbol.CurrencyGroup) {
              return data[13 /* NumberSymbols */][NumberSymbol.Group];
          }
      }
      return res;
  }
  /**
   * Number format that depends on the locale.
   *
   * Numbers are formatted using patterns, like `#,###.00`. For example, the pattern `#,###.00`
   * when used to format the number 12345.678 could result in "12'345,67". That would happen if the
   * grouping separator for your language is an apostrophe, and the decimal separator is a comma.
   *
   * <b>Important:</b> The characters `.` `,` `0` `#` (and others below) are special placeholders;
   * they stand for the decimal separator, and so on, and are NOT real characters.
   * You must NOT "translate" the placeholders; for example, don't change `.` to `,` even though in
   * your language the decimal point is written with a comma. The symbols should be replaced by the
   * local equivalents, using the Number Symbols for your language.
   *
   * Here are the special characters used in number patterns:
   *
   * | Symbol | Meaning |
   * |--------|---------|
   * | . | Replaced automatically by the character used for the decimal point. |
   * | , | Replaced by the "grouping" (thousands) separator. |
   * | 0 | Replaced by a digit (or zero if there aren't enough digits). |
   * | # | Replaced by a digit (or nothing if there aren't enough). |
   * | ¤ | This will be replaced by a currency symbol, such as $ or USD. |
   * | % | This marks a percent format. The % symbol may change position, but must be retained. |
   * | E | This marks a scientific format. The E symbol may change position, but must be retained. |
   * | ' | Special characters used as literal characters are quoted with ASCII single quotes. |
   *
   * You can find more information
   * [on the CLDR website](http://cldr.unicode.org/translation/number-patterns)
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} type
   * @return {?}
   */
  function getLocaleNumberFormat(locale, type) {
      /** @type {?} */
      const data = findLocaleData(locale);
      return data[14 /* NumberFormats */][type];
  }
  /**
   * Returns the currency values for the locale
   * @param {?} locale
   * @return {?}
   */
  function getLocaleCurrencies(locale) {
      /** @type {?} */
      const data = findLocaleData(locale);
      return data[17 /* Currencies */];
  }
  /**
   * The locale plural function used by ICU expressions to determine the plural case to use.
   * See {\@link NgPlural} for more information.
   *
   * \@publicApi
   * @param {?} locale
   * @return {?}
   */
  function getLocalePluralCase(locale) {
      /** @type {?} */
      const data = findLocaleData(locale);
      return data[18 /* PluralCase */];
  }
  /**
   * @param {?} data
   * @return {?}
   */
  function checkFullData(data) {
      if (!data[19 /* ExtraData */]) {
          throw new Error(`Missing extra locale data for the locale "${data[0 /* LocaleId */]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`);
      }
  }
  /**
   * Rules used to determine which day period to use (See `dayPeriods` below).
   * The rules can either be an array or a single value. If it's an array, consider it as "from"
   * and "to". If it's a single value then it means that the period is only valid at this exact
   * value.
   * There is always the same number of rules as the number of day periods, which means that the
   * first rule is applied to the first day period and so on.
   * You should fallback to AM/PM when there are no rules available.
   *
   * Note: this is only available if you load the full locale data.
   * See the ["I18n guide"](guide/i18n#i18n-pipes) to know how to import additional locale
   * data.
   *
   * \@publicApi
   * @param {?} locale
   * @return {?}
   */
  function getLocaleExtraDayPeriodRules(locale) {
      /** @type {?} */
      const data = findLocaleData(locale);
      checkFullData(data);
      /** @type {?} */
      const rules = data[19 /* ExtraData */][2 /* ExtraDayPeriodsRules */] || [];
      return rules.map((rule) => {
          if (typeof rule === 'string') {
              return extractTime(rule);
          }
          return [extractTime(rule[0]), extractTime(rule[1])];
      });
  }
  /**
   * Day Periods indicate roughly how the day is broken up in different languages (e.g. morning,
   * noon, afternoon, midnight, ...).
   * You should use the function {\@link getLocaleExtraDayPeriodRules} to determine which period to
   * use.
   * You should fallback to AM/PM when there are no day periods available.
   *
   * Note: this is only available if you load the full locale data.
   * See the ["I18n guide"](guide/i18n#i18n-pipes) to know how to import additional locale
   * data.
   *
   * \@publicApi
   * @param {?} locale
   * @param {?} formStyle
   * @param {?} width
   * @return {?}
   */
  function getLocaleExtraDayPeriods(locale, formStyle, width) {
      /** @type {?} */
      const data = findLocaleData(locale);
      checkFullData(data);
      /** @type {?} */
      const dayPeriodsData = (/** @type {?} */ ([
          data[19 /* ExtraData */][0 /* ExtraDayPeriodFormats */],
          data[19 /* ExtraData */][1 /* ExtraDayPeriodStandalone */]
      ]));
      /** @type {?} */
      const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];
      return getLastDefinedValue(dayPeriods, width) || [];
  }
  /**
   * Returns the first value that is defined in an array, going backwards.
   *
   * To avoid repeating the same data (e.g. when "format" and "standalone" are the same) we only
   * add the first one to the locale data arrays, the other ones are only defined when different.
   * We use this function to retrieve the first defined value.
   *
   * \@publicApi
   * @template T
   * @param {?} data
   * @param {?} index
   * @return {?}
   */
  function getLastDefinedValue(data, index) {
      for (let i = index; i > -1; i--) {
          if (typeof data[i] !== 'undefined') {
              return data[i];
          }
      }
      throw new Error('Locale data API: locale data undefined');
  }
  /**
   * Extract the hours and minutes from a string like "15:45"
   * @param {?} time
   * @return {?}
   */
  function extractTime(time) {
      const [h, m] = time.split(':');
      return { hours: +h, minutes: +m };
  }
  /**
   * Finds the locale data for a locale id
   *
   * \@publicApi
   * @param {?} locale
   * @return {?}
   */
  function findLocaleData(locale) {
      /** @type {?} */
      const normalizedLocale = locale.toLowerCase().replace(/_/g, '-');
      /** @type {?} */
      let match = LOCALE_DATA[normalizedLocale];
      if (match) {
          return match;
      }
      // let's try to find a parent locale
      /** @type {?} */
      const parentLocale = normalizedLocale.split('-')[0];
      match = LOCALE_DATA[parentLocale];
      if (match) {
          return match;
      }
      if (parentLocale === 'en') {
          return localeEn;
      }
      throw new Error(`Missing locale data for the locale "${locale}".`);
  }
  /**
   * Returns the currency symbol for a given currency code, or the code if no symbol available
   * (e.g.: format narrow = $, format wide = US$, code = USD)
   * If no locale is provided, it uses the locale "en" by default
   *
   * \@publicApi
   * @param {?} code
   * @param {?} format
   * @param {?=} locale
   * @return {?}
   */
  function getCurrencySymbol(code, format, locale = 'en') {
      /** @type {?} */
      const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];
      /** @type {?} */
      const symbolNarrow = currency[1 /* SymbolNarrow */];
      if (format === 'narrow' && typeof symbolNarrow === 'string') {
          return symbolNarrow;
      }
      return currency[0 /* Symbol */] || code;
  }
  // Most currencies have cents, that's why the default is 2
  /** @type {?} */
  const DEFAULT_NB_OF_CURRENCY_DIGITS = 2;
  /**
   * Returns the number of decimal digits for the given currency.
   * Its value depends upon the presence of cents in that particular currency.
   *
   * \@publicApi
   * @param {?} code
   * @return {?}
   */
  function getNumberOfCurrencyDigits(code) {
      /** @type {?} */
      let digits;
      /** @type {?} */
      const currency = CURRENCIES_EN[code];
      if (currency) {
          digits = currency[2 /* NbOfDigits */];
      }
      return typeof digits === 'number' ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
  //    1        2       3         4          5          6          7          8  9     10      11
  /** @type {?} */
  const NAMED_FORMATS = {};
  /** @type {?} */
  const DATE_FORMATS_SPLIT = /((?:[^GyMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
  /** @enum {number} */
  const ZoneWidth = {
      Short: 0,
      ShortGMT: 1,
      Long: 2,
      Extended: 3,
  };
  ZoneWidth[ZoneWidth.Short] = 'Short';
  ZoneWidth[ZoneWidth.ShortGMT] = 'ShortGMT';
  ZoneWidth[ZoneWidth.Long] = 'Long';
  ZoneWidth[ZoneWidth.Extended] = 'Extended';
  /** @enum {number} */
  const DateType = {
      FullYear: 0,
      Month: 1,
      Date: 2,
      Hours: 3,
      Minutes: 4,
      Seconds: 5,
      FractionalSeconds: 6,
      Day: 7,
  };
  DateType[DateType.FullYear] = 'FullYear';
  DateType[DateType.Month] = 'Month';
  DateType[DateType.Date] = 'Date';
  DateType[DateType.Hours] = 'Hours';
  DateType[DateType.Minutes] = 'Minutes';
  DateType[DateType.Seconds] = 'Seconds';
  DateType[DateType.FractionalSeconds] = 'FractionalSeconds';
  DateType[DateType.Day] = 'Day';
  /** @enum {number} */
  const TranslationType = {
      DayPeriods: 0,
      Days: 1,
      Months: 2,
      Eras: 3,
  };
  TranslationType[TranslationType.DayPeriods] = 'DayPeriods';
  TranslationType[TranslationType.Days] = 'Days';
  TranslationType[TranslationType.Months] = 'Months';
  TranslationType[TranslationType.Eras] = 'Eras';
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Formats a date according to locale rules.
   *
   * Where:
   * - `value` is a Date, a number (milliseconds since UTC epoch) or an ISO string
   *   (https://www.w3.org/TR/NOTE-datetime).
   * - `format` indicates which date/time components to include. See {\@link DatePipe} for more
   *   details.
   * - `locale` is a `string` defining the locale to use.
   * - `timezone` to be used for formatting. It understands UTC/GMT and the continental US time zone
   *   abbreviations, but for general use, use a time zone offset (e.g. `'+0430'`).
   *   If not specified, host system settings are used.
   *
   * See {\@link DatePipe} for more details.
   *
   * \@publicApi
   * @param {?} value
   * @param {?} format
   * @param {?} locale
   * @param {?=} timezone
   * @return {?}
   */
  function formatDate(value, format, locale, timezone) {
      /** @type {?} */
      let date = toDate(value);
      /** @type {?} */
      const namedFormat = getNamedFormat(locale, format);
      format = namedFormat || format;
      /** @type {?} */
      let parts = [];
      /** @type {?} */
      let match;
      while (format) {
          match = DATE_FORMATS_SPLIT.exec(format);
          if (match) {
              parts = parts.concat(match.slice(1));
              /** @type {?} */
              const part = parts.pop();
              if (!part) {
                  break;
              }
              format = part;
          }
          else {
              parts.push(format);
              break;
          }
      }
      /** @type {?} */
      let dateTimezoneOffset = date.getTimezoneOffset();
      if (timezone) {
          dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
          date = convertTimezoneToLocal(date, timezone, true);
      }
      /** @type {?} */
      let text$$1 = '';
      parts.forEach(value => {
          /** @type {?} */
          const dateFormatter = getDateFormatter(value);
          text$$1 += dateFormatter ?
              dateFormatter(date, locale, dateTimezoneOffset) :
              value === '\'\'' ? '\'' : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
      });
      return text$$1;
  }
  /**
   * @param {?} locale
   * @param {?} format
   * @return {?}
   */
  function getNamedFormat(locale, format) {
      /** @type {?} */
      const localeId = getLocaleId(locale);
      NAMED_FORMATS[localeId] = NAMED_FORMATS[localeId] || {};
      if (NAMED_FORMATS[localeId][format]) {
          return NAMED_FORMATS[localeId][format];
      }
      /** @type {?} */
      let formatValue = '';
      switch (format) {
          case 'shortDate':
              formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
              break;
          case 'mediumDate':
              formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
              break;
          case 'longDate':
              formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
              break;
          case 'fullDate':
              formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
              break;
          case 'shortTime':
              formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
              break;
          case 'mediumTime':
              formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
              break;
          case 'longTime':
              formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
              break;
          case 'fullTime':
              formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
              break;
          case 'short':
              /** @type {?} */
              const shortTime = getNamedFormat(locale, 'shortTime');
              /** @type {?} */
              const shortDate = getNamedFormat(locale, 'shortDate');
              formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
              break;
          case 'medium':
              /** @type {?} */
              const mediumTime = getNamedFormat(locale, 'mediumTime');
              /** @type {?} */
              const mediumDate = getNamedFormat(locale, 'mediumDate');
              formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
              break;
          case 'long':
              /** @type {?} */
              const longTime = getNamedFormat(locale, 'longTime');
              /** @type {?} */
              const longDate = getNamedFormat(locale, 'longDate');
              formatValue =
                  formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
              break;
          case 'full':
              /** @type {?} */
              const fullTime = getNamedFormat(locale, 'fullTime');
              /** @type {?} */
              const fullDate = getNamedFormat(locale, 'fullDate');
              formatValue =
                  formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);
              break;
      }
      if (formatValue) {
          NAMED_FORMATS[localeId][format] = formatValue;
      }
      return formatValue;
  }
  /**
   * @param {?} str
   * @param {?} opt_values
   * @return {?}
   */
  function formatDateTime(str, opt_values) {
      if (opt_values) {
          str = str.replace(/\{([^}]+)}/g, function (match, key) {
              return (opt_values != null && key in opt_values) ? opt_values[key] : match;
          });
      }
      return str;
  }
  /**
   * @param {?} num
   * @param {?} digits
   * @param {?=} minusSign
   * @param {?=} trim
   * @param {?=} negWrap
   * @return {?}
   */
  function padNumber(num, digits, minusSign = '-', trim, negWrap) {
      /** @type {?} */
      let neg = '';
      if (num < 0 || (negWrap && num <= 0)) {
          if (negWrap) {
              num = -num + 1;
          }
          else {
              num = -num;
              neg = minusSign;
          }
      }
      /** @type {?} */
      let strNum = String(num);
      while (strNum.length < digits) {
          strNum = '0' + strNum;
      }
      if (trim) {
          strNum = strNum.substr(strNum.length - digits);
      }
      return neg + strNum;
  }
  /**
   * @param {?} milliseconds
   * @param {?} digits
   * @return {?}
   */
  function formatFractionalSeconds(milliseconds, digits) {
      /** @type {?} */
      const strMs = padNumber(milliseconds, 3);
      return strMs.substr(0, digits);
  }
  /**
   * Returns a date formatter that transforms a date into its locale digit representation
   * @param {?} name
   * @param {?} size
   * @param {?=} offset
   * @param {?=} trim
   * @param {?=} negWrap
   * @return {?}
   */
  function dateGetter(name, size, offset = 0, trim = false, negWrap = false) {
      return function (date, locale) {
          /** @type {?} */
          let part = getDatePart(name, date);
          if (offset > 0 || part > -offset) {
              part += offset;
          }
          if (name === DateType.Hours) {
              if (part === 0 && offset === -12) {
                  part = 12;
              }
          }
          else if (name === DateType.FractionalSeconds) {
              return formatFractionalSeconds(part, size);
          }
          /** @type {?} */
          const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
          return padNumber(part, size, localeMinus, trim, negWrap);
      };
  }
  /**
   * @param {?} part
   * @param {?} date
   * @return {?}
   */
  function getDatePart(part, date) {
      switch (part) {
          case DateType.FullYear:
              return date.getFullYear();
          case DateType.Month:
              return date.getMonth();
          case DateType.Date:
              return date.getDate();
          case DateType.Hours:
              return date.getHours();
          case DateType.Minutes:
              return date.getMinutes();
          case DateType.Seconds:
              return date.getSeconds();
          case DateType.FractionalSeconds:
              return date.getMilliseconds();
          case DateType.Day:
              return date.getDay();
          default:
              throw new Error(`Unknown DateType value "${part}".`);
      }
  }
  /**
   * Returns a date formatter that transforms a date into its locale string representation
   * @param {?} name
   * @param {?} width
   * @param {?=} form
   * @param {?=} extended
   * @return {?}
   */
  function dateStrGetter(name, width, form = FormStyle.Format, extended = false) {
      return function (date, locale) {
          return getDateTranslation(date, locale, name, width, form, extended);
      };
  }
  /**
   * Returns the locale translation of a date for a given form, type and width
   * @param {?} date
   * @param {?} locale
   * @param {?} name
   * @param {?} width
   * @param {?} form
   * @param {?} extended
   * @return {?}
   */
  function getDateTranslation(date, locale, name, width, form, extended) {
      switch (name) {
          case TranslationType.Months:
              return getLocaleMonthNames(locale, form, width)[date.getMonth()];
          case TranslationType.Days:
              return getLocaleDayNames(locale, form, width)[date.getDay()];
          case TranslationType.DayPeriods:
              /** @type {?} */
              const currentHours = date.getHours();
              /** @type {?} */
              const currentMinutes = date.getMinutes();
              if (extended) {
                  /** @type {?} */
                  const rules = getLocaleExtraDayPeriodRules(locale);
                  /** @type {?} */
                  const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);
                  /** @type {?} */
                  let result;
                  rules.forEach((rule, index) => {
                      if (Array.isArray(rule)) {
                          // morning, afternoon, evening, night
                          const { hours: hoursFrom, minutes: minutesFrom } = rule[0];
                          const { hours: hoursTo, minutes: minutesTo } = rule[1];
                          if (currentHours >= hoursFrom && currentMinutes >= minutesFrom &&
                              (currentHours < hoursTo ||
                                  (currentHours === hoursTo && currentMinutes < minutesTo))) {
                              result = dayPeriods[index];
                          }
                      }
                      else { // noon or midnight
                          // noon or midnight
                          const { hours, minutes } = rule;
                          if (hours === currentHours && minutes === currentMinutes) {
                              result = dayPeriods[index];
                          }
                      }
                  });
                  if (result) {
                      return result;
                  }
              }
              // if no rules for the day periods, we use am/pm by default
              return getLocaleDayPeriods(locale, form, (/** @type {?} */ (width)))[currentHours < 12 ? 0 : 1];
          case TranslationType.Eras:
              return getLocaleEraNames(locale, (/** @type {?} */ (width)))[date.getFullYear() <= 0 ? 0 : 1];
          default:
              // This default case is not needed by TypeScript compiler, as the switch is exhaustive.
              // However Closure Compiler does not understand that and reports an error in typed mode.
              // The `throw new Error` below works around the problem, and the unexpected: never variable
              // makes sure tsc still checks this code is unreachable.
              /** @type {?} */
              const unexpected = name;
              throw new Error(`unexpected translation type ${unexpected}`);
      }
  }
  /**
   * Returns a date formatter that transforms a date and an offset into a timezone with ISO8601 or
   * GMT format depending on the width (eg: short = +0430, short:GMT = GMT+4, long = GMT+04:30,
   * extended = +04:30)
   * @param {?} width
   * @return {?}
   */
  function timeZoneGetter(width) {
      return function (date, locale, offset) {
          /** @type {?} */
          const zone = -1 * offset;
          /** @type {?} */
          const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
          /** @type {?} */
          const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
          switch (width) {
              case ZoneWidth.Short:
                  return ((zone >= 0) ? '+' : '') + padNumber(hours, 2, minusSign) +
                      padNumber(Math.abs(zone % 60), 2, minusSign);
              case ZoneWidth.ShortGMT:
                  return 'GMT' + ((zone >= 0) ? '+' : '') + padNumber(hours, 1, minusSign);
              case ZoneWidth.Long:
                  return 'GMT' + ((zone >= 0) ? '+' : '') + padNumber(hours, 2, minusSign) + ':' +
                      padNumber(Math.abs(zone % 60), 2, minusSign);
              case ZoneWidth.Extended:
                  if (offset === 0) {
                      return 'Z';
                  }
                  else {
                      return ((zone >= 0) ? '+' : '') + padNumber(hours, 2, minusSign) + ':' +
                          padNumber(Math.abs(zone % 60), 2, minusSign);
                  }
              default:
                  throw new Error(`Unknown zone width "${width}"`);
          }
      };
  }
  /** @type {?} */
  const JANUARY = 0;
  /** @type {?} */
  const THURSDAY = 4;
  /**
   * @param {?} year
   * @return {?}
   */
  function getFirstThursdayOfYear(year) {
      /** @type {?} */
      const firstDayOfYear = (new Date(year, JANUARY, 1)).getDay();
      return new Date(year, 0, 1 + ((firstDayOfYear <= THURSDAY) ? THURSDAY : THURSDAY + 7) - firstDayOfYear);
  }
  /**
   * @param {?} datetime
   * @return {?}
   */
  function getThursdayThisWeek(datetime) {
      return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (THURSDAY - datetime.getDay()));
  }
  /**
   * @param {?} size
   * @param {?=} monthBased
   * @return {?}
   */
  function weekGetter(size, monthBased = false) {
      return function (date, locale) {
          /** @type {?} */
          let result;
          if (monthBased) {
              /** @type {?} */
              const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;
              /** @type {?} */
              const today = date.getDate();
              result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);
          }
          else {
              /** @type {?} */
              const firstThurs = getFirstThursdayOfYear(date.getFullYear());
              /** @type {?} */
              const thisThurs = getThursdayThisWeek(date);
              /** @type {?} */
              const diff = thisThurs.getTime() - firstThurs.getTime();
              result = 1 + Math.round(diff / 6.048e8); // 6.048e8 ms per week
          }
          return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
      };
  }
  /** @type {?} */
  const DATE_FORMATS = {};
  // Based on CLDR formats:
  // See complete list: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
  // See also explanations: http://cldr.unicode.org/translation/date-time
  // TODO(ocombe): support all missing cldr formats: Y, U, Q, D, F, e, c, j, J, C, A, v, V, X, x
  /**
   * @param {?} format
   * @return {?}
   */
  function getDateFormatter(format) {
      if (DATE_FORMATS[format]) {
          return DATE_FORMATS[format];
      }
      /** @type {?} */
      let formatter;
      switch (format) {
          // Era name (AD/BC)
          case 'G':
          case 'GG':
          case 'GGG':
              formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
              break;
          case 'GGGG':
              formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
              break;
          case 'GGGGG':
              formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
              break;
          // 1 digit representation of the year, e.g. (AD 1 => 1, AD 199 => 199)
          case 'y':
              formatter = dateGetter(DateType.FullYear, 1, 0, false, true);
              break;
          // 2 digit representation of the year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
          case 'yy':
              formatter = dateGetter(DateType.FullYear, 2, 0, true, true);
              break;
          // 3 digit representation of the year, padded (000-999). (e.g. AD 2001 => 01, AD 2010 => 10)
          case 'yyy':
              formatter = dateGetter(DateType.FullYear, 3, 0, false, true);
              break;
          // 4 digit representation of the year (e.g. AD 1 => 0001, AD 2010 => 2010)
          case 'yyyy':
              formatter = dateGetter(DateType.FullYear, 4, 0, false, true);
              break;
          // Month of the year (1-12), numeric
          case 'M':
          case 'L':
              formatter = dateGetter(DateType.Month, 1, 1);
              break;
          case 'MM':
          case 'LL':
              formatter = dateGetter(DateType.Month, 2, 1);
              break;
          // Month of the year (January, ...), string, format
          case 'MMM':
              formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
              break;
          case 'MMMM':
              formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
              break;
          case 'MMMMM':
              formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
              break;
          // Month of the year (January, ...), string, standalone
          case 'LLL':
              formatter =
                  dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
              break;
          case 'LLLL':
              formatter =
                  dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
              break;
          case 'LLLLL':
              formatter =
                  dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
              break;
          // Week of the year (1, ... 52)
          case 'w':
              formatter = weekGetter(1);
              break;
          case 'ww':
              formatter = weekGetter(2);
              break;
          // Week of the month (1, ...)
          case 'W':
              formatter = weekGetter(1, true);
              break;
          // Day of the month (1-31)
          case 'd':
              formatter = dateGetter(DateType.Date, 1);
              break;
          case 'dd':
              formatter = dateGetter(DateType.Date, 2);
              break;
          // Day of the Week
          case 'E':
          case 'EE':
          case 'EEE':
              formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
              break;
          case 'EEEE':
              formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
              break;
          case 'EEEEE':
              formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
              break;
          case 'EEEEEE':
              formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
              break;
          // Generic period of the day (am-pm)
          case 'a':
          case 'aa':
          case 'aaa':
              formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
              break;
          case 'aaaa':
              formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
              break;
          case 'aaaaa':
              formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
              break;
          // Extended period of the day (midnight, at night, ...), standalone
          case 'b':
          case 'bb':
          case 'bbb':
              formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, true);
              break;
          case 'bbbb':
              formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, true);
              break;
          case 'bbbbb':
              formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, true);
              break;
          // Extended period of the day (midnight, night, ...), standalone
          case 'B':
          case 'BB':
          case 'BBB':
              formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, true);
              break;
          case 'BBBB':
              formatter =
                  dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, true);
              break;
          case 'BBBBB':
              formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, true);
              break;
          // Hour in AM/PM, (1-12)
          case 'h':
              formatter = dateGetter(DateType.Hours, 1, -12);
              break;
          case 'hh':
              formatter = dateGetter(DateType.Hours, 2, -12);
              break;
          // Hour of the day (0-23)
          case 'H':
              formatter = dateGetter(DateType.Hours, 1);
              break;
          // Hour in day, padded (00-23)
          case 'HH':
              formatter = dateGetter(DateType.Hours, 2);
              break;
          // Minute of the hour (0-59)
          case 'm':
              formatter = dateGetter(DateType.Minutes, 1);
              break;
          case 'mm':
              formatter = dateGetter(DateType.Minutes, 2);
              break;
          // Second of the minute (0-59)
          case 's':
              formatter = dateGetter(DateType.Seconds, 1);
              break;
          case 'ss':
              formatter = dateGetter(DateType.Seconds, 2);
              break;
          // Fractional second
          case 'S':
              formatter = dateGetter(DateType.FractionalSeconds, 1);
              break;
          case 'SS':
              formatter = dateGetter(DateType.FractionalSeconds, 2);
              break;
          case 'SSS':
              formatter = dateGetter(DateType.FractionalSeconds, 3);
              break;
          // Timezone ISO8601 short format (-0430)
          case 'Z':
          case 'ZZ':
          case 'ZZZ':
              formatter = timeZoneGetter(ZoneWidth.Short);
              break;
          // Timezone ISO8601 extended format (-04:30)
          case 'ZZZZZ':
              formatter = timeZoneGetter(ZoneWidth.Extended);
              break;
          // Timezone GMT short format (GMT+4)
          case 'O':
          case 'OO':
          case 'OOO':
          // Should be location, but fallback to format O instead because we don't have the data yet
          case 'z':
          case 'zz':
          case 'zzz':
              formatter = timeZoneGetter(ZoneWidth.ShortGMT);
              break;
          // Timezone GMT long format (GMT+0430)
          case 'OOOO':
          case 'ZZZZ':
          // Should be location, but fallback to format O instead because we don't have the data yet
          case 'zzzz':
              formatter = timeZoneGetter(ZoneWidth.Long);
              break;
          default:
              return null;
      }
      DATE_FORMATS[format] = formatter;
      return formatter;
  }
  /**
   * @param {?} timezone
   * @param {?} fallback
   * @return {?}
   */
  function timezoneToOffset(timezone, fallback) {
      // Support: IE 9-11 only, Edge 13-15+
      // IE/Edge do not "understand" colon (`:`) in timezone
      timezone = timezone.replace(/:/g, '');
      /** @type {?} */
      const requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
      return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
  }
  /**
   * @param {?} date
   * @param {?} minutes
   * @return {?}
   */
  function addDateMinutes(date, minutes) {
      date = new Date(date.getTime());
      date.setMinutes(date.getMinutes() + minutes);
      return date;
  }
  /**
   * @param {?} date
   * @param {?} timezone
   * @param {?} reverse
   * @return {?}
   */
  function convertTimezoneToLocal(date, timezone, reverse) {
      /** @type {?} */
      const reverseValue = reverse ? -1 : 1;
      /** @type {?} */
      const dateTimezoneOffset = date.getTimezoneOffset();
      /** @type {?} */
      const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
      return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));
  }
  /**
   * Converts a value to date.
   *
   * Supported input formats:
   * - `Date`
   * - number: timestamp
   * - string: numeric (e.g. "1234"), ISO and date strings in a format supported by
   *   [Date.parse()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
   *   Note: ISO strings without time return a date without timeoffset.
   *
   * Throws if unable to convert to a date.
   * @param {?} value
   * @return {?}
   */
  function toDate(value) {
      if (isDate$1(value)) {
          return value;
      }
      if (typeof value === 'number' && !isNaN(value)) {
          return new Date(value);
      }
      if (typeof value === 'string') {
          value = value.trim();
          /** @type {?} */
          const parsedNb = parseFloat(value);
          // any string that only contains numbers, like "1234" but not like "1234hello"
          if (!isNaN((/** @type {?} */ (value)) - parsedNb)) {
              return new Date(parsedNb);
          }
          if (/^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
              /* For ISO Strings without time the day, month and year must be extracted from the ISO String
                    before Date creation to avoid time offset and errors in the new Date.
                    If we only replace '-' with ',' in the ISO String ("2015,01,01"), and try to create a new
                    date, some browsers (e.g. IE 9) will throw an invalid Date error.
                    If we leave the '-' ("2015-01-01") and try to create a new Date("2015-01-01") the timeoffset
                    is applied.
                    Note: ISO months are 0 for January, 1 for February, ... */
              const [y, m, d] = value.split('-').map((val) => +val);
              return new Date(y, m - 1, d);
          }
          /** @type {?} */
          let match;
          if (match = value.match(ISO8601_DATE_REGEX)) {
              return isoStringToDate(match);
          }
      }
      /** @type {?} */
      const date = new Date((/** @type {?} */ (value)));
      if (!isDate$1(date)) {
          throw new Error(`Unable to convert "${value}" into a date`);
      }
      return date;
  }
  /**
   * Converts a date in ISO8601 to a Date.
   * Used instead of `Date.parse` because of browser discrepancies.
   * @param {?} match
   * @return {?}
   */
  function isoStringToDate(match) {
      /** @type {?} */
      const date = new Date(0);
      /** @type {?} */
      let tzHour = 0;
      /** @type {?} */
      let tzMin = 0;
      // match[8] means that the string contains "Z" (UTC) or a timezone like "+01:00" or "+0100"
      /** @type {?} */
      const dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
      /** @type {?} */
      const timeSetter = match[8] ? date.setUTCHours : date.setHours;
      // if there is a timezone defined like "+01:00" or "+0100"
      if (match[9]) {
          tzHour = Number(match[9] + match[10]);
          tzMin = Number(match[9] + match[11]);
      }
      dateSetter.call(date, Number(match[1]), Number(match[2]) - 1, Number(match[3]));
      /** @type {?} */
      const h = Number(match[4] || 0) - tzHour;
      /** @type {?} */
      const m = Number(match[5] || 0) - tzMin;
      /** @type {?} */
      const s = Number(match[6] || 0);
      /** @type {?} */
      const ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      return date;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function isDate$1(value) {
      return value instanceof Date && !isNaN(value.valueOf());
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
  /** @type {?} */
  const MAX_DIGITS = 22;
  /** @type {?} */
  const DECIMAL_SEP = '.';
  /** @type {?} */
  const ZERO_CHAR = '0';
  /** @type {?} */
  const PATTERN_SEP = ';';
  /** @type {?} */
  const GROUP_SEP = ',';
  /** @type {?} */
  const DIGIT_CHAR = '#';
  /** @type {?} */
  const CURRENCY_CHAR = '¤';
  /** @type {?} */
  const PERCENT_CHAR = '%';
  /**
   * Transforms a number to a locale string based on a style and a format
   * @param {?} value
   * @param {?} pattern
   * @param {?} locale
   * @param {?} groupSymbol
   * @param {?} decimalSymbol
   * @param {?=} digitsInfo
   * @param {?=} isPercent
   * @return {?}
   */
  function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {
      /** @type {?} */
      let formattedText = '';
      /** @type {?} */
      let isZero = false;
      if (!isFinite(value)) {
          formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
      }
      else {
          /** @type {?} */
          let parsedNumber = parseNumber(value);
          if (isPercent) {
              parsedNumber = toPercent(parsedNumber);
          }
          /** @type {?} */
          let minInt = pattern.minInt;
          /** @type {?} */
          let minFraction = pattern.minFrac;
          /** @type {?} */
          let maxFraction = pattern.maxFrac;
          if (digitsInfo) {
              /** @type {?} */
              const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
              if (parts === null) {
                  throw new Error(`${digitsInfo} is not a valid digit info`);
              }
              /** @type {?} */
              const minIntPart = parts[1];
              /** @type {?} */
              const minFractionPart = parts[3];
              /** @type {?} */
              const maxFractionPart = parts[5];
              if (minIntPart != null) {
                  minInt = parseIntAutoRadix$1(minIntPart);
              }
              if (minFractionPart != null) {
                  minFraction = parseIntAutoRadix$1(minFractionPart);
              }
              if (maxFractionPart != null) {
                  maxFraction = parseIntAutoRadix$1(maxFractionPart);
              }
              else if (minFractionPart != null && minFraction > maxFraction) {
                  maxFraction = minFraction;
              }
          }
          roundNumber(parsedNumber, minFraction, maxFraction);
          /** @type {?} */
          let digits = parsedNumber.digits;
          /** @type {?} */
          let integerLen = parsedNumber.integerLen;
          /** @type {?} */
          const exponent = parsedNumber.exponent;
          /** @type {?} */
          let decimals = [];
          isZero = digits.every(d => !d);
          // pad zeros for small numbers
          for (; integerLen < minInt; integerLen++) {
              digits.unshift(0);
          }
          // pad zeros for small numbers
          for (; integerLen < 0; integerLen++) {
              digits.unshift(0);
          }
          // extract decimals digits
          if (integerLen > 0) {
              decimals = digits.splice(integerLen, digits.length);
          }
          else {
              decimals = digits;
              digits = [0];
          }
          // format the integer digits with grouping separators
          /** @type {?} */
          const groups = [];
          if (digits.length >= pattern.lgSize) {
              groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
          }
          while (digits.length > pattern.gSize) {
              groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
          }
          if (digits.length) {
              groups.unshift(digits.join(''));
          }
          formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));
          // append the decimal digits
          if (decimals.length) {
              formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join('');
          }
          if (exponent) {
              formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + '+' + exponent;
          }
      }
      if (value < 0 && !isZero) {
          formattedText = pattern.negPre + formattedText + pattern.negSuf;
      }
      else {
          formattedText = pattern.posPre + formattedText + pattern.posSuf;
      }
      return formattedText;
  }
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Formats a number as currency using locale rules.
   *
   * Use `currency` to format a number as currency.
   *
   * Where:
   * - `value` is a number.
   * - `locale` is a `string` defining the locale to use.
   * - `currency` is the string that represents the currency, it can be its symbol or its name.
   * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such
   *    as `USD` for the US dollar and `EUR` for the euro.
   * - `digitInfo` See {\@link DecimalPipe} for more details.
   *
   * \@publicApi
   * @param {?} value
   * @param {?} locale
   * @param {?} currency
   * @param {?=} currencyCode
   * @param {?=} digitsInfo
   * @return {?}
   */
  function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
      /** @type {?} */
      const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);
      /** @type {?} */
      const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
      pattern.minFrac = getNumberOfCurrencyDigits((/** @type {?} */ (currencyCode)));
      pattern.maxFrac = pattern.minFrac;
      /** @type {?} */
      const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);
      return res
          .replace(CURRENCY_CHAR, currency)
          // if we have 2 time the currency character, the second one is ignored
          .replace(CURRENCY_CHAR, '');
  }
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Formats a number as a percentage according to locale rules.
   *
   * Where:
   * - `value` is a number.
   * - `locale` is a `string` defining the locale to use.
   * - `digitInfo` See {\@link DecimalPipe} for more details.
   *
   * \@publicApi
   * @param {?} value
   * @param {?} locale
   * @param {?=} digitsInfo
   * @return {?}
   */
  function formatPercent(value, locale, digitsInfo) {
      /** @type {?} */
      const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);
      /** @type {?} */
      const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
      /** @type {?} */
      const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);
      return res.replace(new RegExp(PERCENT_CHAR, 'g'), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));
  }
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Formats a number as text. Group sizing and separator and other locale-specific
   * configurations are based on the locale.
   *
   * Where:
   * - `value` is a number.
   * - `locale` is a `string` defining the locale to use.
   * - `digitInfo` See {\@link DecimalPipe} for more details.
   *
   * \@publicApi
   * @param {?} value
   * @param {?} locale
   * @param {?=} digitsInfo
   * @return {?}
   */
  function formatNumber(value, locale, digitsInfo) {
      /** @type {?} */
      const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);
      /** @type {?} */
      const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
      return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);
  }
  /**
   * @param {?} format
   * @param {?=} minusSign
   * @return {?}
   */
  function parseNumberFormat(format, minusSign = '-') {
      /** @type {?} */
      const p = {
          minInt: 1,
          minFrac: 0,
          maxFrac: 0,
          posPre: '',
          posSuf: '',
          negPre: '',
          negSuf: '',
          gSize: 0,
          lgSize: 0
      };
      /** @type {?} */
      const patternParts = format.split(PATTERN_SEP);
      /** @type {?} */
      const positive = patternParts[0];
      /** @type {?} */
      const negative = patternParts[1];
      /** @type {?} */
      const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ?
          positive.split(DECIMAL_SEP) :
          [
              positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1),
              positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)
          ];
      /** @type {?} */
      const integer = positiveParts[0];
      /** @type {?} */
      const fraction = positiveParts[1] || '';
      p.posPre = integer.substr(0, integer.indexOf(DIGIT_CHAR));
      for (let i = 0; i < fraction.length; i++) {
          /** @type {?} */
          const ch = fraction.charAt(i);
          if (ch === ZERO_CHAR) {
              p.minFrac = p.maxFrac = i + 1;
          }
          else if (ch === DIGIT_CHAR) {
              p.maxFrac = i + 1;
          }
          else {
              p.posSuf += ch;
          }
      }
      /** @type {?} */
      const groups = integer.split(GROUP_SEP);
      p.gSize = groups[1] ? groups[1].length : 0;
      p.lgSize = (groups[2] || groups[1]) ? (groups[2] || groups[1]).length : 0;
      if (negative) {
          /** @type {?} */
          const trunkLen = positive.length - p.posPre.length - p.posSuf.length;
          /** @type {?} */
          const pos = negative.indexOf(DIGIT_CHAR);
          p.negPre = negative.substr(0, pos).replace(/'/g, '');
          p.negSuf = negative.substr(pos + trunkLen).replace(/'/g, '');
      }
      else {
          p.negPre = minusSign + p.posPre;
          p.negSuf = p.posSuf;
      }
      return p;
  }
  // Transforms a parsed number into a percentage by multiplying it by 100
  /**
   * @param {?} parsedNumber
   * @return {?}
   */
  function toPercent(parsedNumber) {
      // if the number is 0, don't do anything
      if (parsedNumber.digits[0] === 0) {
          return parsedNumber;
      }
      // Getting the current number of decimals
      /** @type {?} */
      const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
      if (parsedNumber.exponent) {
          parsedNumber.exponent += 2;
      }
      else {
          if (fractionLen === 0) {
              parsedNumber.digits.push(0, 0);
          }
          else if (fractionLen === 1) {
              parsedNumber.digits.push(0);
          }
          parsedNumber.integerLen += 2;
      }
      return parsedNumber;
  }
  /**
   * Parses a number.
   * Significant bits of this parse algorithm came from https://github.com/MikeMcl/big.js/
   * @param {?} num
   * @return {?}
   */
  function parseNumber(num) {
      /** @type {?} */
      let numStr = Math.abs(num) + '';
      /** @type {?} */
      let exponent = 0;
      /** @type {?} */
      let digits;
      /** @type {?} */
      let integerLen;
      /** @type {?} */
      let i;
      /** @type {?} */
      let j;
      /** @type {?} */
      let zeros;
      // Decimal point?
      if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
      }
      // Exponential form?
      if ((i = numStr.search(/e/i)) > 0) {
          // Work out the exponent.
          if (integerLen < 0)
              integerLen = i;
          integerLen += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
      }
      else if (integerLen < 0) {
          // There was no decimal point or exponent so it is an integer.
          integerLen = numStr.length;
      }
      // Count the number of leading zeros.
      for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) { /* empty */
      }
      if (i === (zeros = numStr.length)) {
          // The digits are all zero.
          digits = [0];
          integerLen = 1;
      }
      else {
          // Count the number of trailing zeros
          zeros--;
          while (numStr.charAt(zeros) === ZERO_CHAR)
              zeros--;
          // Trailing zeros are insignificant so ignore them
          integerLen -= i;
          digits = [];
          // Convert string to array of digits without leading/trailing zeros.
          for (j = 0; i <= zeros; i++, j++) {
              digits[j] = Number(numStr.charAt(i));
          }
      }
      // If the number overflows the maximum allowed digits then use an exponent.
      if (integerLen > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = integerLen - 1;
          integerLen = 1;
      }
      return { digits, exponent, integerLen };
  }
  /**
   * Round the parsed number to the specified number of decimal places
   * This function changes the parsedNumber in-place
   * @param {?} parsedNumber
   * @param {?} minFrac
   * @param {?} maxFrac
   * @return {?}
   */
  function roundNumber(parsedNumber, minFrac, maxFrac) {
      if (minFrac > maxFrac) {
          throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
      }
      /** @type {?} */
      let digits = parsedNumber.digits;
      /** @type {?} */
      let fractionLen = digits.length - parsedNumber.integerLen;
      /** @type {?} */
      const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
      // The index of the digit to where rounding is to occur
      /** @type {?} */
      let roundAt = fractionSize + parsedNumber.integerLen;
      /** @type {?} */
      let digit = digits[roundAt];
      if (roundAt > 0) {
          // Drop fractional digits beyond `roundAt`
          digits.splice(Math.max(parsedNumber.integerLen, roundAt));
          // Set non-fractional digits beyond `roundAt` to 0
          for (let j = roundAt; j < digits.length; j++) {
              digits[j] = 0;
          }
      }
      else {
          // We rounded to zero so reset the parsedNumber
          fractionLen = Math.max(0, fractionLen);
          parsedNumber.integerLen = 1;
          digits.length = Math.max(1, roundAt = fractionSize + 1);
          digits[0] = 0;
          for (let i = 1; i < roundAt; i++)
              digits[i] = 0;
      }
      if (digit >= 5) {
          if (roundAt - 1 < 0) {
              for (let k = 0; k > roundAt; k--) {
                  digits.unshift(0);
                  parsedNumber.integerLen++;
              }
              digits.unshift(1);
              parsedNumber.integerLen++;
          }
          else {
              digits[roundAt - 1]++;
          }
      }
      // Pad out with zeros to get the required fraction length
      for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
          digits.push(0);
      /** @type {?} */
      let dropTrailingZeros = fractionSize !== 0;
      // Minimal length = nb of decimals required + current nb of integers
      // Any number besides that is optional and can be removed if it's a trailing 0
      /** @type {?} */
      const minLen = minFrac + parsedNumber.integerLen;
      // Do any carrying, e.g. a digit was rounded up to 10
      /** @type {?} */
      const carry = digits.reduceRight(function (carry, d, i, digits) {
          d = d + carry;
          digits[i] = d < 10 ? d : d - 10; // d % 10
          if (dropTrailingZeros) {
              // Do not keep meaningless fractional trailing zeros (e.g. 15.52000 --> 15.52)
              if (digits[i] === 0 && i >= minLen) {
                  digits.pop();
              }
              else {
                  dropTrailingZeros = false;
              }
          }
          return d >= 10 ? 1 : 0; // Math.floor(d / 10);
      }, 0);
      if (carry) {
          digits.unshift(carry);
          parsedNumber.integerLen++;
      }
  }
  /**
   * @param {?} text
   * @return {?}
   */
  function parseIntAutoRadix$1(text$$1) {
      /** @type {?} */
      const result = parseInt(text$$1);
      if (isNaN(result)) {
          throw new Error('Invalid integer literal when parsing ' + text$$1);
      }
      return result;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @deprecated from v5
   * @type {?}
   */
  const DEPRECATED_PLURAL_FN = new InjectionToken('UseV4Plurals');
  /**
   * \@publicApi
   * @abstract
   */
  class NgLocalization {
  }
  /**
   * Returns the plural category for a given value.
   * - "=value" when the case exists,
   * - the plural category otherwise
   * @param {?} value
   * @param {?} cases
   * @param {?} ngLocalization
   * @param {?=} locale
   * @return {?}
   */
  function getPluralCategory$1(value, cases, ngLocalization, locale) {
      /** @type {?} */
      let key = `=${value}`;
      if (cases.indexOf(key) > -1) {
          return key;
      }
      key = ngLocalization.getPluralCategory(value, locale);
      if (cases.indexOf(key) > -1) {
          return key;
      }
      if (cases.indexOf('other') > -1) {
          return 'other';
      }
      throw new Error(`No plural message found for value "${value}"`);
  }
  /**
   * Returns the plural case based on the locale
   *
   * \@publicApi
   */
  class NgLocaleLocalization extends NgLocalization {
      /**
       * @param {?} locale
       * @param {?=} deprecatedPluralFn
       */
      constructor(locale, deprecatedPluralFn) {
          super();
          this.locale = locale;
          this.deprecatedPluralFn = deprecatedPluralFn;
      }
      /**
       * @param {?} value
       * @param {?=} locale
       * @return {?}
       */
      getPluralCategory(value, locale) {
          /** @type {?} */
          const plural = this.deprecatedPluralFn ? this.deprecatedPluralFn(locale || this.locale, value) :
              getLocalePluralCase(locale || this.locale)(value);
          switch (plural) {
              case Plural$1.Zero:
                  return 'zero';
              case Plural$1.One:
                  return 'one';
              case Plural$1.Two:
                  return 'two';
              case Plural$1.Few:
                  return 'few';
              case Plural$1.Many:
                  return 'many';
              default:
                  return 'other';
          }
      }
  }
  NgLocaleLocalization.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  NgLocaleLocalization.ctorParameters = () => [
      { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
      { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DEPRECATED_PLURAL_FN,] }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @param {?} cookieStr
   * @param {?} name
   * @return {?}
   */
  function parseCookieValue(cookieStr, name) {
      name = encodeURIComponent(name);
      for (const cookie of cookieStr.split(';')) {
          /** @type {?} */
          const eqIndex = cookie.indexOf('=');
          const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
          if (cookieName.trim() === name) {
              return decodeURIComponent(cookieValue);
          }
      }
      return null;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@ngModule CommonModule
   *
   * \@usageNotes
   * ```
   *     <some-element [ngClass]="'first second'">...</some-element>
   *
   *     <some-element [ngClass]="['first', 'second']">...</some-element>
   *
   *     <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>
   *
   *     <some-element [ngClass]="stringExp|arrayExp|objExp">...</some-element>
   *
   *     <some-element [ngClass]="{'class1 class2 class3' : true}">...</some-element>
   * ```
   *
   * \@description
   *
   * Adds and removes CSS classes on an HTML element.
   *
   * The CSS classes are updated as follows, depending on the type of the expression evaluation:
   * - `string` - the CSS classes listed in the string (space delimited) are added,
   * - `Array` - the CSS classes declared as Array elements are added,
   * - `Object` - keys are CSS classes that get added when the expression given in the value
   *              evaluates to a truthy value, otherwise they are removed.
   *
   * \@publicApi
   */
  class NgClass {
      /**
       * @param {?} _iterableDiffers
       * @param {?} _keyValueDiffers
       * @param {?} _ngEl
       * @param {?} _renderer
       */
      constructor(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
          this._iterableDiffers = _iterableDiffers;
          this._keyValueDiffers = _keyValueDiffers;
          this._ngEl = _ngEl;
          this._renderer = _renderer;
          this._initialClasses = [];
      }
      /**
       * @param {?} value
       * @return {?}
       */
      set klass(value) {
          this._removeClasses(this._initialClasses);
          this._initialClasses = typeof value === 'string' ? value.split(/\s+/) : [];
          this._applyClasses(this._initialClasses);
          this._applyClasses(this._rawClass);
      }
      /**
       * @param {?} value
       * @return {?}
       */
      set ngClass(value) {
          this._removeClasses(this._rawClass);
          this._applyClasses(this._initialClasses);
          this._iterableDiffer = null;
          this._keyValueDiffer = null;
          this._rawClass = typeof value === 'string' ? value.split(/\s+/) : value;
          if (this._rawClass) {
              if (isListLikeIterable(this._rawClass)) {
                  this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create();
              }
              else {
                  this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create();
              }
          }
      }
      /**
       * @return {?}
       */
      ngDoCheck() {
          if (this._iterableDiffer) {
              /** @type {?} */
              const iterableChanges = this._iterableDiffer.diff((/** @type {?} */ (this._rawClass)));
              if (iterableChanges) {
                  this._applyIterableChanges(iterableChanges);
              }
          }
          else if (this._keyValueDiffer) {
              /** @type {?} */
              const keyValueChanges = this._keyValueDiffer.diff((/** @type {?} */ (this._rawClass)));
              if (keyValueChanges) {
                  this._applyKeyValueChanges(keyValueChanges);
              }
          }
      }
      /**
       * @private
       * @param {?} changes
       * @return {?}
       */
      _applyKeyValueChanges(changes) {
          changes.forEachAddedItem((record) => this._toggleClass(record.key, record.currentValue));
          changes.forEachChangedItem((record) => this._toggleClass(record.key, record.currentValue));
          changes.forEachRemovedItem((record) => {
              if (record.previousValue) {
                  this._toggleClass(record.key, false);
              }
          });
      }
      /**
       * @private
       * @param {?} changes
       * @return {?}
       */
      _applyIterableChanges(changes) {
          changes.forEachAddedItem((record) => {
              if (typeof record.item === 'string') {
                  this._toggleClass(record.item, true);
              }
              else {
                  throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify$1(record.item)}`);
              }
          });
          changes.forEachRemovedItem((record) => this._toggleClass(record.item, false));
      }
      /**
       * Applies a collection of CSS classes to the DOM element.
       *
       * For argument of type Set and Array CSS class names contained in those collections are always
       * added.
       * For argument of type Map CSS class name in the map's key is toggled based on the value (added
       * for truthy and removed for falsy).
       * @private
       * @param {?} rawClassVal
       * @return {?}
       */
      _applyClasses(rawClassVal) {
          if (rawClassVal) {
              if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                  ((/** @type {?} */ (rawClassVal))).forEach((klass) => this._toggleClass(klass, true));
              }
              else {
                  Object.keys(rawClassVal).forEach(klass => this._toggleClass(klass, !!rawClassVal[klass]));
              }
          }
      }
      /**
       * Removes a collection of CSS classes from the DOM element. This is mostly useful for cleanup
       * purposes.
       * @private
       * @param {?} rawClassVal
       * @return {?}
       */
      _removeClasses(rawClassVal) {
          if (rawClassVal) {
              if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
                  ((/** @type {?} */ (rawClassVal))).forEach((klass) => this._toggleClass(klass, false));
              }
              else {
                  Object.keys(rawClassVal).forEach(klass => this._toggleClass(klass, false));
              }
          }
      }
      /**
       * @private
       * @param {?} klass
       * @param {?} enabled
       * @return {?}
       */
      _toggleClass(klass, enabled) {
          klass = klass.trim();
          if (klass) {
              klass.split(/\s+/g).forEach(klass => {
                  if (enabled) {
                      this._renderer.addClass(this._ngEl.nativeElement, klass);
                  }
                  else {
                      this._renderer.removeClass(this._ngEl.nativeElement, klass);
                  }
              });
          }
      }
  }
  NgClass.decorators = [
      { type: Directive, args: [{ selector: '[ngClass]' },] }
  ];
  /** @nocollapse */
  NgClass.ctorParameters = () => [
      { type: IterableDiffers },
      { type: KeyValueDiffers },
      { type: ElementRef },
      { type: Renderer2 }
  ];
  NgClass.propDecorators = {
      klass: [{ type: Input, args: ['class',] }],
      ngClass: [{ type: Input }]
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Instantiates a single {\@link Component} type and inserts its Host View into current View.
   * `NgComponentOutlet` provides a declarative approach for dynamic component creation.
   *
   * `NgComponentOutlet` requires a component type, if a falsy value is set the view will clear and
   * any existing component will get destroyed.
   *
   * \@usageNotes
   *
   * ### Fine tune control
   *
   * You can control the component creation process by using the following optional attributes:
   *
   * * `ngComponentOutletInjector`: Optional custom {\@link Injector} that will be used as parent for
   * the Component. Defaults to the injector of the current view container.
   *
   * * `ngComponentOutletContent`: Optional list of projectable nodes to insert into the content
   * section of the component, if exists.
   *
   * * `ngComponentOutletNgModuleFactory`: Optional module factory to allow dynamically loading other
   * module, then load a component from that module.
   *
   * ### Syntax
   *
   * Simple
   * ```
   * <ng-container *ngComponentOutlet="componentTypeExpression"></ng-container>
   * ```
   *
   * Customized injector/content
   * ```
   * <ng-container *ngComponentOutlet="componentTypeExpression;
   *                                   injector: injectorExpression;
   *                                   content: contentNodesExpression;">
   * </ng-container>
   * ```
   *
   * Customized ngModuleFactory
   * ```
   * <ng-container *ngComponentOutlet="componentTypeExpression;
   *                                   ngModuleFactory: moduleFactory;">
   * </ng-container>
   * ```
   *
   * ### A simple example
   *
   * {\@example common/ngComponentOutlet/ts/module.ts region='SimpleExample'}
   *
   * A more complete example with additional options:
   *
   * {\@example common/ngComponentOutlet/ts/module.ts region='CompleteExample'}
   * A more complete example with ngModuleFactory:
   *
   * {\@example common/ngComponentOutlet/ts/module.ts region='NgModuleFactoryExample'}
   *
   * \@publicApi
   * \@ngModule CommonModule
   */
  class NgComponentOutlet {
      /**
       * @param {?} _viewContainerRef
       */
      constructor(_viewContainerRef) {
          this._viewContainerRef = _viewContainerRef;
          this._componentRef = null;
          this._moduleRef = null;
      }
      /**
       * @param {?} changes
       * @return {?}
       */
      ngOnChanges(changes) {
          this._viewContainerRef.clear();
          this._componentRef = null;
          if (this.ngComponentOutlet) {
              /** @type {?} */
              const elInjector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
              if (changes['ngComponentOutletNgModuleFactory']) {
                  if (this._moduleRef)
                      this._moduleRef.destroy();
                  if (this.ngComponentOutletNgModuleFactory) {
                      /** @type {?} */
                      const parentModule = elInjector.get(NgModuleRef);
                      this._moduleRef = this.ngComponentOutletNgModuleFactory.create(parentModule.injector);
                  }
                  else {
                      this._moduleRef = null;
                  }
              }
              /** @type {?} */
              const componentFactoryResolver = this._moduleRef ? this._moduleRef.componentFactoryResolver :
                  elInjector.get(ComponentFactoryResolver);
              /** @type {?} */
              const componentFactory = componentFactoryResolver.resolveComponentFactory(this.ngComponentOutlet);
              this._componentRef = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, elInjector, this.ngComponentOutletContent);
          }
      }
      /**
       * @return {?}
       */
      ngOnDestroy() {
          if (this._moduleRef)
              this._moduleRef.destroy();
      }
  }
  NgComponentOutlet.decorators = [
      { type: Directive, args: [{ selector: '[ngComponentOutlet]' },] }
  ];
  /** @nocollapse */
  NgComponentOutlet.ctorParameters = () => [
      { type: ViewContainerRef }
  ];
  NgComponentOutlet.propDecorators = {
      ngComponentOutlet: [{ type: Input }],
      ngComponentOutletInjector: [{ type: Input }],
      ngComponentOutletContent: [{ type: Input }],
      ngComponentOutletNgModuleFactory: [{ type: Input }]
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@publicApi
   * @template T
   */
  class NgForOfContext {
      /**
       * @param {?} $implicit
       * @param {?} ngForOf
       * @param {?} index
       * @param {?} count
       */
      constructor($implicit, ngForOf, index, count) {
          this.$implicit = $implicit;
          this.ngForOf = ngForOf;
          this.index = index;
          this.count = count;
      }
      /**
       * @return {?}
       */
      get first() { return this.index === 0; }
      /**
       * @return {?}
       */
      get last() { return this.index === this.count - 1; }
      /**
       * @return {?}
       */
      get even() { return this.index % 2 === 0; }
      /**
       * @return {?}
       */
      get odd() { return !this.even; }
  }
  /**
   * A [structural directive](guide/structural-directives) that renders
   * a template for each item in a collection.
   * The directive is placed on an element, which becomes the parent
   * of the cloned templates.
   *
   * The `ngForOf` is generally used in the
   * [shorthand form](guide/structural-directives#the-asterisk--prefix) `*ngFor`.
   * In this form, the template to be rendered for each iteration is the content
   * of an anchor element containing the directive.
   *
   * The following example shows the shorthand syntax with some options,
   * contained in an `<li>` element.
   *
   * ```
   * <li *ngFor="let item of items; index as i; trackBy: trackByFn">...</li>
   * ```
   *
   * The shorthand form expands into a long form that uses the `ngForOf` selector
   * on an `<ng-template>` element.
   * The content of the `<ng-template>` element is the `<li>` element that held the
   * short-form directive.
   *
   * Here is the expanded version of the short-form example.
   *
   * ```
   * <ng-template ngFor let-item [ngForOf]="items" let-i="index" [ngForTrackBy]="trackByFn">
   *   <li>...</li>
   * </ng-template>
   * ```
   *
   * Angular automatically expands the shorthand syntax as it compiles the template.
   * The context for each embedded view is logically merged to the current component
   * context according to its lexical position.
   *
   * When using the shorthand syntax, Angular allows only [one structural directive
   * on an element](guide/structural-directives#one-structural-directive-per-host-element).
   * If you want to iterate conditionally, for example,
   * put the `*ngIf` on a container element that wraps the `*ngFor` element.
   * For futher discussion, see
   * [Structural Directives](guide/structural-directives#one-per-element).
   *
   * \@usageNotes
   *
   * ### Local variables
   *
   * `NgForOf` provides exported values that can be aliased to local variables.
   * For example:
   *
   *  ```
   * <li *ngFor="let user of userObservable | async as users; index as i; first as isFirst">
   *    {{i}}/{{users.length}}. {{user}} <span *ngIf="isFirst">default</span>
   * </li>
   * ```
   *
   * The following exported values can be aliased to local variables:
   *
   * - `$implicit: T`: The value of the individual items in the iterable (`ngForOf`).
   * - `ngForOf: NgIterable<T>`: The value of the iterable expression. Useful when the expression is
   * more complex then a property access, for example when using the async pipe (`userStreams |
   * async`).
   * - `index: number`: The index of the current item in the iterable.
   * - `first: boolean`: True when the item is the first item in the iterable.
   * - `last: boolean`: True when the item is the last item in the iterable.
   * - `even: boolean`: True when the item has an even index in the iterable.
   * - `odd: boolean`: True when the item has an odd index in the iterable.
   *
   * ### Change propagation
   *
   * When the contents of the iterator changes, `NgForOf` makes the corresponding changes to the DOM:
   *
   * * When an item is added, a new instance of the template is added to the DOM.
   * * When an item is removed, its template instance is removed from the DOM.
   * * When items are reordered, their respective templates are reordered in the DOM.
   *
   * Angular uses object identity to track insertions and deletions within the iterator and reproduce
   * those changes in the DOM. This has important implications for animations and any stateful
   * controls that are present, such as `<input>` elements that accept user input. Inserted rows can
   * be animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state
   * such as user input.
   * For more on animations, see [Transitions and Triggers](guide/transition-and-triggers).
   *
   * The identities of elements in the iterator can change while the data does not.
   * This can happen, for example, if the iterator is produced from an RPC to the server, and that
   * RPC is re-run. Even if the data hasn't changed, the second response produces objects with
   * different identities, and Angular must tear down the entire DOM and rebuild it (as if all old
   * elements were deleted and all new elements inserted).
   *
   * To avoid this expensive operation, you can customize the default tracking algorithm.
   * by supplying the `trackBy` option to `NgForOf`.
   * `trackBy` takes a function that has two arguments: `index` and `item`.
   * If `trackBy` is given, Angular tracks changes by the return value of the function.
   *
   * @see [Structural Directives](guide/structural-directives)
   * \@ngModule CommonModule
   * \@publicApi
   * @template T
   */
  class NgForOf {
      /**
       * @param {?} _viewContainer
       * @param {?} _template
       * @param {?} _differs
       */
      constructor(_viewContainer, _template, _differs) {
          this._viewContainer = _viewContainer;
          this._template = _template;
          this._differs = _differs;
          this._ngForOfDirty = true;
          this._differ = null;
      }
      /**
       * @param {?} ngForOf
       * @return {?}
       */
      set ngForOf(ngForOf) {
          this._ngForOf = ngForOf;
          this._ngForOfDirty = true;
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      set ngForTrackBy(fn) {
          if (isDevMode() && fn != null && typeof fn !== 'function') {
              // TODO(vicb): use a log service once there is a public one available
              if ((/** @type {?} */ (console)) && (/** @type {?} */ (console.warn))) {
                  console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. ` +
                      `See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information.`);
              }
          }
          this._trackByFn = fn;
      }
      /**
       * @return {?}
       */
      get ngForTrackBy() { return this._trackByFn; }
      /**
       * @param {?} value
       * @return {?}
       */
      set ngForTemplate(value) {
          // TODO(TS2.1): make TemplateRef<Partial<NgForRowOf<T>>> once we move to TS v2.1
          // The current type is too restrictive; a template that just uses index, for example,
          // should be acceptable.
          if (value) {
              this._template = value;
          }
      }
      /**
       * @return {?}
       */
      ngDoCheck() {
          if (this._ngForOfDirty) {
              this._ngForOfDirty = false;
              // React on ngForOf changes only once all inputs have been initialized
              /** @type {?} */
              const value = this._ngForOf;
              if (!this._differ && value) {
                  try {
                      this._differ = this._differs.find(value).create(this.ngForTrackBy);
                  }
                  catch (_a) {
                      throw new Error(`Cannot find a differ supporting object '${value}' of type '${getTypeNameForDebugging$1(value)}'. NgFor only supports binding to Iterables such as Arrays.`);
                  }
              }
          }
          if (this._differ) {
              /** @type {?} */
              const changes = this._differ.diff(this._ngForOf);
              if (changes)
                  this._applyChanges(changes);
          }
      }
      /**
       * @private
       * @param {?} changes
       * @return {?}
       */
      _applyChanges(changes) {
          /** @type {?} */
          const insertTuples = [];
          changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
              if (item.previousIndex == null) {
                  /** @type {?} */
                  const view = this._viewContainer.createEmbeddedView(this._template, new NgForOfContext((/** @type {?} */ (null)), this._ngForOf, -1, -1), currentIndex);
                  /** @type {?} */
                  const tuple = new RecordViewTuple(item, view);
                  insertTuples.push(tuple);
              }
              else if (currentIndex == null) {
                  this._viewContainer.remove(adjustedPreviousIndex);
              }
              else {
                  /** @type {?} */
                  const view = (/** @type {?} */ (this._viewContainer.get(adjustedPreviousIndex)));
                  this._viewContainer.move(view, currentIndex);
                  /** @type {?} */
                  const tuple = new RecordViewTuple(item, (/** @type {?} */ (view)));
                  insertTuples.push(tuple);
              }
          });
          for (let i = 0; i < insertTuples.length; i++) {
              this._perViewChange(insertTuples[i].view, insertTuples[i].record);
          }
          for (let i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
              /** @type {?} */
              const viewRef = (/** @type {?} */ (this._viewContainer.get(i)));
              viewRef.context.index = i;
              viewRef.context.count = ilen;
              viewRef.context.ngForOf = this._ngForOf;
          }
          changes.forEachIdentityChange((record) => {
              /** @type {?} */
              const viewRef = (/** @type {?} */ (this._viewContainer.get(record.currentIndex)));
              viewRef.context.$implicit = record.item;
          });
      }
      /**
       * @private
       * @param {?} view
       * @param {?} record
       * @return {?}
       */
      _perViewChange(view, record) {
          view.context.$implicit = record.item;
      }
      /**
       * Asserts the correct type of the context for the template that `NgForOf` will render.
       *
       * The presence of this method is a signal to the Ivy template type-check compiler that the
       * `NgForOf` structural directive renders its template with a specific context type.
       * @template T
       * @param {?} dir
       * @param {?} ctx
       * @return {?}
       */
      static ngTemplateContextGuard(dir, ctx) {
          return true;
      }
  }
  NgForOf.decorators = [
      { type: Directive, args: [{ selector: '[ngFor][ngForOf]' },] }
  ];
  /** @nocollapse */
  NgForOf.ctorParameters = () => [
      { type: ViewContainerRef },
      { type: TemplateRef },
      { type: IterableDiffers }
  ];
  NgForOf.propDecorators = {
      ngForOf: [{ type: Input }],
      ngForTrackBy: [{ type: Input }],
      ngForTemplate: [{ type: Input }]
  };
  /**
   * @template T
   */
  class RecordViewTuple {
      /**
       * @param {?} record
       * @param {?} view
       */
      constructor(record, view) {
          this.record = record;
          this.view = view;
      }
  }
  /**
   * @param {?} type
   * @return {?}
   */
  function getTypeNameForDebugging$1(type) {
      return type['name'] || typeof type;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A structural directive that conditionally includes a template based on the value of
   * an expression coerced to Boolean.
   * When the expression evaluates to true, Angular renders the template
   * provided in a `then` clause, and when  false or null,
   * Angular renders the template provided in an optional `else` clause. The default
   * template for the `else` clause is blank.
   *
   * A [shorthand form](guide/structural-directives#the-asterisk--prefix) of the directive,
   * `*ngIf="condition"`, is generally used, provided
   * as an attribute of the anchor element for the inserted template.
   * Angular expands this into a more explicit version, in which the anchor element
   * is contained in an `<ng-template>` element.
   *
   * Simple form with shorthand syntax:
   *
   * ```
   * <div *ngIf="condition">Content to render when condition is true.</div>
   * ```
   *
   * Simple form with expanded syntax:
   *
   * ```
   * <ng-template [ngIf]="condition"><div>Content to render when condition is
   * true.</div></ng-template>
   * ```
   *
   * Form with an "else" block:
   *
   * ```
   * <div *ngIf="condition; else elseBlock">Content to render when condition is true.</div>
   * <ng-template #elseBlock>Content to render when condition is false.</ng-template>
   * ```
   *
   * Shorthand form with "then" and "else" blocks:
   *
   * ```
   * <div *ngIf="condition; then thenBlock else elseBlock"></div>
   * <ng-template #thenBlock>Content to render when condition is true.</ng-template>
   * <ng-template #elseBlock>Content to render when condition is false.</ng-template>
   * ```
   *
   * Form with storing the value locally:
   *
   * ```
   * <div *ngIf="condition as value; else elseBlock">{{value}}</div>
   * <ng-template #elseBlock>Content to render when value is null.</ng-template>
   * ```
   *
   * \@usageNotes
   *
   * The `*ngIf` directive is most commonly used to conditionally show an inline template,
   * as seen in the following  example.
   * The default `else` template is blank.
   *
   * {\@example common/ngIf/ts/module.ts region='NgIfSimple'}
   *
   * ### Showing an alternative template using `else`
   *
   * To display a template when `expression` evaluates to false, use an `else` template
   * binding as shown in the following example.
   * The `else` binding points to an `<ng-template>`  element labeled `#elseBlock`.
   * The template can be defined anywhere in the component view, but is typically placed right after
   * `ngIf` for readability.
   *
   * {\@example common/ngIf/ts/module.ts region='NgIfElse'}
   *
   * ### Using an external `then` template
   *
   * In the previous example, the then-clause template is specified inline, as the content of the
   * tag that contains the `ngIf` directive. You can also specify a template that is defined
   * externally, by referencing a labeled `<ng-template>` element. When you do this, you can
   * change which template to use at runtime, as shown in the following example.
   *
   * {\@example common/ngIf/ts/module.ts region='NgIfThenElse'}
   *
   * ### Storing a conditional result in a variable
   *
   * You might want to show a set of properties from the same object. If you are waiting
   * for asynchronous data, the object can be undefined.
   * In this case, you can use `ngIf` and store the result of the condition in a local
   * variable as shown in the the following example.
   *
   * {\@example common/ngIf/ts/module.ts region='NgIfAs'}
   *
   * This code uses only one `AsyncPipe`, so only one subscription is created.
   * The conditional statement stores the result of `userStream|async` in the local variable `user`.
   * You can then bind the local `user` repeatedly.
   *
   * The conditional displays the data only if `userStream` returns a value,
   * so you don't need to use the
   * [safe-navigation-operator](guide/template-syntax#safe-navigation-operator) (`?.`)
   * to guard against null values when accessing properties.
   * You can display an alternative template while waiting for the data.
   *
   * ### Shorthand syntax
   *
   * The shorthand syntax `*ngIf` expands into two separate template specifications
   * for the "then" and "else" clauses. For example, consider the following shorthand statement,
   * that is meant to show a loading page while waiting for data to be loaded.
   *
   * ```
   * <div class="hero-list" *ngIf="heroes else loading">
   *  ...
   * </div>
   *
   * <ng-template #loading>
   *  <div>Loading...</div>
   * </ng-template>
   * ```
   *
   * You can see that the "else" clause references the `<ng-template>`
   * with the `#loading` label, and the template for the "then" clause
   * is provided as the content of the anchor element.
   *
   * However, when Angular expands the shorthand syntax, it creates
   * another `<ng-template>` tag, with `ngIf` and `ngIfElse` directives.
   * The anchor element containing the template for the "then" clause becomes
   * the content of this unlabeled `<ng-template>` tag.
   *
   * ```
   * <ng-template [ngIf]="hero-list" [ngIfElse]="loading">
   *  <div class="hero-list">
   *   ...
   *  </div>
   * </ng-template>
   *
   * <ng-template #loading>
   *  <div>Loading...</div>
   * </ng-template>
   * ```
   *
   * The presence of the implicit template object has implications for the nesting of
   * structural directives. For more on this subject, see
   * [Structural Directives](https://angular.io/guide/structural-directives#one-per-element).
   *
   * \@ngModule CommonModule
   * \@publicApi
   */
  class NgIf {
      /**
       * @param {?} _viewContainer
       * @param {?} templateRef
       */
      constructor(_viewContainer, templateRef) {
          this._viewContainer = _viewContainer;
          this._context = new NgIfContext();
          this._thenTemplateRef = null;
          this._elseTemplateRef = null;
          this._thenViewRef = null;
          this._elseViewRef = null;
          this._thenTemplateRef = templateRef;
      }
      /**
       * @param {?} condition
       * @return {?}
       */
      set ngIf(condition) {
          this._context.$implicit = this._context.ngIf = condition;
          this._updateView();
      }
      /**
       * @param {?} templateRef
       * @return {?}
       */
      set ngIfThen(templateRef) {
          assertTemplate('ngIfThen', templateRef);
          this._thenTemplateRef = templateRef;
          this._thenViewRef = null; // clear previous view if any.
          this._updateView();
      }
      /**
       * @param {?} templateRef
       * @return {?}
       */
      set ngIfElse(templateRef) {
          assertTemplate('ngIfElse', templateRef);
          this._elseTemplateRef = templateRef;
          this._elseViewRef = null; // clear previous view if any.
          this._updateView();
      }
      /**
       * @private
       * @return {?}
       */
      _updateView() {
          if (this._context.$implicit) {
              if (!this._thenViewRef) {
                  this._viewContainer.clear();
                  this._elseViewRef = null;
                  if (this._thenTemplateRef) {
                      this._thenViewRef =
                          this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);
                  }
              }
          }
          else {
              if (!this._elseViewRef) {
                  this._viewContainer.clear();
                  this._thenViewRef = null;
                  if (this._elseTemplateRef) {
                      this._elseViewRef =
                          this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);
                  }
              }
          }
      }
      /**
       * Assert the correct type of the expression bound to the `ngIf` input within the template.
       *
       * The presence of this method is a signal to the Ivy template type check compiler that when the
       * `NgIf` structural directive renders its template, the type of the expression bound to `ngIf`
       * should be narrowed in some way. For `NgIf`, it is narrowed to be non-null, which allows the
       * strictNullChecks feature of TypeScript to work with `NgIf`.
       * @template E
       * @param {?} dir
       * @param {?} expr
       * @return {?}
       */
      static ngTemplateGuard_ngIf(dir, expr) { return true; }
  }
  NgIf.decorators = [
      { type: Directive, args: [{ selector: '[ngIf]' },] }
  ];
  /** @nocollapse */
  NgIf.ctorParameters = () => [
      { type: ViewContainerRef },
      { type: TemplateRef }
  ];
  NgIf.propDecorators = {
      ngIf: [{ type: Input }],
      ngIfThen: [{ type: Input }],
      ngIfElse: [{ type: Input }]
  };
  /**
   * \@publicApi
   */
  class NgIfContext {
      constructor() {
          this.$implicit = null;
          this.ngIf = null;
      }
  }
  /**
   * @param {?} property
   * @param {?} templateRef
   * @return {?}
   */
  function assertTemplate(property, templateRef) {
      /** @type {?} */
      const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
      if (!isTemplateRefOrNull) {
          throw new Error(`${property} must be a TemplateRef, but received '${stringify$1(templateRef)}'.`);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class SwitchView {
      /**
       * @param {?} _viewContainerRef
       * @param {?} _templateRef
       */
      constructor(_viewContainerRef, _templateRef) {
          this._viewContainerRef = _viewContainerRef;
          this._templateRef = _templateRef;
          this._created = false;
      }
      /**
       * @return {?}
       */
      create() {
          this._created = true;
          this._viewContainerRef.createEmbeddedView(this._templateRef);
      }
      /**
       * @return {?}
       */
      destroy() {
          this._created = false;
          this._viewContainerRef.clear();
      }
      /**
       * @param {?} created
       * @return {?}
       */
      enforceState(created) {
          if (created && !this._created) {
              this.create();
          }
          else if (!created && this._created) {
              this.destroy();
          }
      }
  }
  /**
   * \@ngModule CommonModule
   *
   * \@description A structural directive that adds or removes templates (displaying or hiding views)
   * when the next match expression matches the switch expression.
   *
   * The `[ngSwitch]` directive on a container specifies an expression to match against.
   * The expressions to match are provided by `ngSwitchCase` directives on views within the container.
   * - Every view that matches is rendered.
   * - If there are no matches, a view with the `ngSwitchDefault` directive is rendered.
   * - Elements within the `[NgSwitch]` statement but outside of any `NgSwitchCase`
   * or `ngSwitchDefault` directive are preserved at the location.
   *
   * \@usageNotes
   * Define a container element for the directive, and specify the switch expression
   * to match against as an attribute:
   *
   * ```
   * <container-element [ngSwitch]="switch_expression">
   * ```
   *
   * Within the container, `*ngSwitchCase` statements specify the match expressions
   * as attributes. Include `*ngSwitchDefault` as the final case.
   *
   * ```
   * <container-element [ngSwitch]="switch_expression">
   *    <some-element *ngSwitchCase="match_expression_1">...</some-element>
   * ...
   *    <some-element *ngSwitchDefault>...</some-element>
   * </container-element>
   * ```
   *
   * ### Usage Examples
   *
   * The following example shows how to use more than one case to display the same view:
   *
   * ```
   * <container-element [ngSwitch]="switch_expression">
   *   <!-- the same view can be shown in more than one case -->
   *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
   *   <some-element *ngSwitchCase="match_expression_2">...</some-element>
   *   <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
   *   <!--default case when there are no matches -->
   *   <some-element *ngSwitchDefault>...</some-element>
   * </container-element>
   * ```
   *
   * The following example shows how cases can be nested:
   * ```
   * <container-element [ngSwitch]="switch_expression">
   *       <some-element *ngSwitchCase="match_expression_1">...</some-element>
   *       <some-element *ngSwitchCase="match_expression_2">...</some-element>
   *       <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
   *       <ng-container *ngSwitchCase="match_expression_3">
   *         <!-- use a ng-container to group multiple root nodes -->
   *         <inner-element></inner-element>
   *         <inner-other-element></inner-other-element>
   *       </ng-container>
   *       <some-element *ngSwitchDefault>...</some-element>
   *     </container-element>
   * ```
   *
   * \@publicApi
   * @see `NgSwitchCase`
   * @see `NgSwitchDefault`
   * @see [Stuctural Directives](guide/structural-directives)
   *
   */
  class NgSwitch {
      constructor() {
          this._defaultUsed = false;
          this._caseCount = 0;
          this._lastCaseCheckIndex = 0;
          this._lastCasesMatched = false;
      }
      /**
       * @param {?} newValue
       * @return {?}
       */
      set ngSwitch(newValue) {
          this._ngSwitch = newValue;
          if (this._caseCount === 0) {
              this._updateDefaultCases(true);
          }
      }
      /**
       * \@internal
       * @return {?}
       */
      _addCase() { return this._caseCount++; }
      /**
       * \@internal
       * @param {?} view
       * @return {?}
       */
      _addDefault(view) {
          if (!this._defaultViews) {
              this._defaultViews = [];
          }
          this._defaultViews.push(view);
      }
      /**
       * \@internal
       * @param {?} value
       * @return {?}
       */
      _matchCase(value) {
          /** @type {?} */
          const matched = value == this._ngSwitch;
          this._lastCasesMatched = this._lastCasesMatched || matched;
          this._lastCaseCheckIndex++;
          if (this._lastCaseCheckIndex === this._caseCount) {
              this._updateDefaultCases(!this._lastCasesMatched);
              this._lastCaseCheckIndex = 0;
              this._lastCasesMatched = false;
          }
          return matched;
      }
      /**
       * @private
       * @param {?} useDefault
       * @return {?}
       */
      _updateDefaultCases(useDefault) {
          if (this._defaultViews && useDefault !== this._defaultUsed) {
              this._defaultUsed = useDefault;
              for (let i = 0; i < this._defaultViews.length; i++) {
                  /** @type {?} */
                  const defaultView = this._defaultViews[i];
                  defaultView.enforceState(useDefault);
              }
          }
      }
  }
  NgSwitch.decorators = [
      { type: Directive, args: [{ selector: '[ngSwitch]' },] }
  ];
  NgSwitch.propDecorators = {
      ngSwitch: [{ type: Input }]
  };
  /**
   * \@ngModule CommonModule
   *
   * \@description
   * Provides a switch case expression to match against an enclosing `ngSwitch` expression.
   * When the expressions match, the given `NgSwitchCase` template is rendered.
   * If multiple match expressions match the switch expression value, all of them are displayed.
   *
   * \@usageNotes
   *
   * Within a switch container, `*ngSwitchCase` statements specify the match expressions
   * as attributes. Include `*ngSwitchDefault` as the final case.
   *
   * ```
   * <container-element [ngSwitch]="switch_expression">
   *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
   *   ...
   *   <some-element *ngSwitchDefault>...</some-element>
   * </container-element>
   * ```
   *
   * Each switch-case statement contains an in-line HTML template or template reference
   * that defines the subtree to be selected if the value of the match expression
   * matches the value of the switch expression.
   *
   * Unlike JavaScript, which uses strict equality, Angular uses loose equality.
   * This means that the empty string, `""` matches 0.
   *
   * \@publicApi
   * @see `NgSwitch`
   * @see `NgSwitchDefault`
   *
   */
  class NgSwitchCase {
      /**
       * @param {?} viewContainer
       * @param {?} templateRef
       * @param {?} ngSwitch
       */
      constructor(viewContainer, templateRef, ngSwitch) {
          this.ngSwitch = ngSwitch;
          ngSwitch._addCase();
          this._view = new SwitchView(viewContainer, templateRef);
      }
      /**
       * Performs case matching. For internal use only.
       * @return {?}
       */
      ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)); }
  }
  NgSwitchCase.decorators = [
      { type: Directive, args: [{ selector: '[ngSwitchCase]' },] }
  ];
  /** @nocollapse */
  NgSwitchCase.ctorParameters = () => [
      { type: ViewContainerRef },
      { type: TemplateRef },
      { type: NgSwitch, decorators: [{ type: Host }] }
  ];
  NgSwitchCase.propDecorators = {
      ngSwitchCase: [{ type: Input }]
  };
  /**
   * \@ngModule CommonModule
   *
   * \@description
   *
   * Creates a view that is rendered when no `NgSwitchCase` expressions
   * match the `NgSwitch` expression.
   * This statement should be the final case in an `NgSwitch`.
   *
   * \@publicApi
   * @see `NgSwitch`
   * @see `NgSwitchCase`
   *
   */
  class NgSwitchDefault {
      /**
       * @param {?} viewContainer
       * @param {?} templateRef
       * @param {?} ngSwitch
       */
      constructor(viewContainer, templateRef, ngSwitch) {
          ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
      }
  }
  NgSwitchDefault.decorators = [
      { type: Directive, args: [{ selector: '[ngSwitchDefault]' },] }
  ];
  /** @nocollapse */
  NgSwitchDefault.ctorParameters = () => [
      { type: ViewContainerRef },
      { type: TemplateRef },
      { type: NgSwitch, decorators: [{ type: Host }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@ngModule CommonModule
   *
   * \@usageNotes
   * ```
   * <some-element [ngPlural]="value">
   *   <ng-template ngPluralCase="=0">there is nothing</ng-template>
   *   <ng-template ngPluralCase="=1">there is one</ng-template>
   *   <ng-template ngPluralCase="few">there are a few</ng-template>
   * </some-element>
   * ```
   *
   * \@description
   *
   * Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.
   *
   * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees
   * that match the switch expression's pluralization category.
   *
   * To use this directive you must provide a container element that sets the `[ngPlural]` attribute
   * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their
   * expression:
   * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value
   *   matches the switch expression exactly,
   * - otherwise, the view will be treated as a "category match", and will only display if exact
   *   value matches aren't found and the value maps to its category for the defined locale.
   *
   * See http://cldr.unicode.org/index/cldr-spec/plural-rules
   *
   * \@publicApi
   */
  class NgPlural {
      /**
       * @param {?} _localization
       */
      constructor(_localization) {
          this._localization = _localization;
          this._caseViews = {};
      }
      /**
       * @param {?} value
       * @return {?}
       */
      set ngPlural(value) {
          this._switchValue = value;
          this._updateView();
      }
      /**
       * @param {?} value
       * @param {?} switchView
       * @return {?}
       */
      addCase(value, switchView) { this._caseViews[value] = switchView; }
      /**
       * @private
       * @return {?}
       */
      _updateView() {
          this._clearViews();
          /** @type {?} */
          const cases = Object.keys(this._caseViews);
          /** @type {?} */
          const key = getPluralCategory$1(this._switchValue, cases, this._localization);
          this._activateView(this._caseViews[key]);
      }
      /**
       * @private
       * @return {?}
       */
      _clearViews() {
          if (this._activeView)
              this._activeView.destroy();
      }
      /**
       * @private
       * @param {?} view
       * @return {?}
       */
      _activateView(view) {
          if (view) {
              this._activeView = view;
              this._activeView.create();
          }
      }
  }
  NgPlural.decorators = [
      { type: Directive, args: [{ selector: '[ngPlural]' },] }
  ];
  /** @nocollapse */
  NgPlural.ctorParameters = () => [
      { type: NgLocalization }
  ];
  NgPlural.propDecorators = {
      ngPlural: [{ type: Input }]
  };
  /**
   * \@ngModule CommonModule
   *
   * \@description
   *
   * Creates a view that will be added/removed from the parent {\@link NgPlural} when the
   * given expression matches the plural expression according to CLDR rules.
   *
   * \@usageNotes
   * ```
   * <some-element [ngPlural]="value">
   *   <ng-template ngPluralCase="=0">...</ng-template>
   *   <ng-template ngPluralCase="other">...</ng-template>
   * </some-element>
   * ```
   *
   * See {\@link NgPlural} for more details and example.
   *
   * \@publicApi
   */
  class NgPluralCase {
      /**
       * @param {?} value
       * @param {?} template
       * @param {?} viewContainer
       * @param {?} ngPlural
       */
      constructor(value, template$$1, viewContainer, ngPlural) {
          this.value = value;
          /** @type {?} */
          const isANumber = !isNaN(Number(value));
          ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template$$1));
      }
  }
  NgPluralCase.decorators = [
      { type: Directive, args: [{ selector: '[ngPluralCase]' },] }
  ];
  /** @nocollapse */
  NgPluralCase.ctorParameters = () => [
      { type: String, decorators: [{ type: Attribute$1, args: ['ngPluralCase',] }] },
      { type: TemplateRef },
      { type: ViewContainerRef },
      { type: NgPlural, decorators: [{ type: Host }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@ngModule CommonModule
   *
   * \@usageNotes
   *
   * Set the font of the containing element to the result of an expression.
   *
   * ```
   * <some-element [ngStyle]="{'font-style': styleExp}">...</some-element>
   * ```
   *
   * Set the width of the containing element to a pixel value returned by an expression.
   *
   * ```
   * <some-element [ngStyle]="{'max-width.px': widthExp}">...</some-element>
   * ```
   *
   * Set a collection of style values using an expression that returns key-value pairs.
   *
   * ```
   * <some-element [ngStyle]="objExp">...</some-element>
   * ```
   *
   * \@description
   *
   * An attribute directive that updates styles for the containing HTML element.
   * Sets one or more style properties, specified as colon-separated key-value pairs.
   * The key is a style name, with an optional `.<unit>` suffix
   * (such as 'top.px', 'font-style.em').
   * The value is an expression to be evaluated.
   * The resulting non-null value, expressed in the given unit,
   * is assigned to the given style property.
   * If the result of evaluation is null, the corresponding style is removed.
   *
   * \@publicApi
   */
  class NgStyle {
      /**
       * @param {?} _differs
       * @param {?} _ngEl
       * @param {?} _renderer
       */
      constructor(_differs, _ngEl, _renderer) {
          this._differs = _differs;
          this._ngEl = _ngEl;
          this._renderer = _renderer;
      }
      /**
       * @param {?} values
       * @return {?}
       */
      set ngStyle(
      /**
       * A map of style properties, specified as colon-separated
       * key-value pairs.
       * * The key is a style name, with an optional `.<unit>` suffix
       *    (such as 'top.px', 'font-style.em').
       * * The value is an expression to be evaluated.
       */
      values) {
          this._ngStyle = values;
          if (!this._differ && values) {
              this._differ = this._differs.find(values).create();
          }
      }
      /**
       * Applies the new styles if needed.
       * @return {?}
       */
      ngDoCheck() {
          if (this._differ) {
              /** @type {?} */
              const changes = this._differ.diff(this._ngStyle);
              if (changes) {
                  this._applyChanges(changes);
              }
          }
      }
      /**
       * @private
       * @param {?} changes
       * @return {?}
       */
      _applyChanges(changes) {
          changes.forEachRemovedItem((record) => this._setStyle(record.key, null));
          changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));
          changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));
      }
      /**
       * @private
       * @param {?} nameAndUnit
       * @param {?} value
       * @return {?}
       */
      _setStyle(nameAndUnit, value) {
          const [name, unit] = nameAndUnit.split('.');
          value = value != null && unit ? `${value}${unit}` : value;
          if (value != null) {
              this._renderer.setStyle(this._ngEl.nativeElement, name, (/** @type {?} */ (value)));
          }
          else {
              this._renderer.removeStyle(this._ngEl.nativeElement, name);
          }
      }
  }
  NgStyle.decorators = [
      { type: Directive, args: [{ selector: '[ngStyle]' },] }
  ];
  /** @nocollapse */
  NgStyle.ctorParameters = () => [
      { type: KeyValueDiffers },
      { type: ElementRef },
      { type: Renderer2 }
  ];
  NgStyle.propDecorators = {
      ngStyle: [{ type: Input }]
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@ngModule CommonModule
   *
   * \@description
   *
   * Inserts an embedded view from a prepared `TemplateRef`.
   *
   * You can attach a context object to the `EmbeddedViewRef` by setting `[ngTemplateOutletContext]`.
   * `[ngTemplateOutletContext]` should be an object, the object's keys will be available for binding
   * by the local template `let` declarations.
   *
   * \@usageNotes
   * ```
   * <ng-container *ngTemplateOutlet="templateRefExp; context: contextExp"></ng-container>
   * ```
   *
   * Using the key `$implicit` in the context object will set its value as default.
   *
   * ### Example
   *
   * {\@example common/ngTemplateOutlet/ts/module.ts region='NgTemplateOutlet'}
   *
   * \@publicApi
   */
  class NgTemplateOutlet {
      /**
       * @param {?} _viewContainerRef
       */
      constructor(_viewContainerRef) {
          this._viewContainerRef = _viewContainerRef;
      }
      /**
       * @param {?} changes
       * @return {?}
       */
      ngOnChanges(changes) {
          /** @type {?} */
          const recreateView = this._shouldRecreateView(changes);
          if (recreateView) {
              if (this._viewRef) {
                  this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
              }
              if (this.ngTemplateOutlet) {
                  this._viewRef = this._viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext);
              }
          }
          else {
              if (this._viewRef && this.ngTemplateOutletContext) {
                  this._updateExistingContext(this.ngTemplateOutletContext);
              }
          }
      }
      /**
       * We need to re-create existing embedded view if:
       * - templateRef has changed
       * - context has changes
       *
       * We mark context object as changed when the corresponding object
       * shape changes (new properties are added or existing properties are removed).
       * In other words we consider context with the same properties as "the same" even
       * if object reference changes (see https://github.com/angular/angular/issues/13407).
       * @private
       * @param {?} changes
       * @return {?}
       */
      _shouldRecreateView(changes) {
          /** @type {?} */
          const ctxChange = changes['ngTemplateOutletContext'];
          return !!changes['ngTemplateOutlet'] || (ctxChange && this._hasContextShapeChanged(ctxChange));
      }
      /**
       * @private
       * @param {?} ctxChange
       * @return {?}
       */
      _hasContextShapeChanged(ctxChange) {
          /** @type {?} */
          const prevCtxKeys = Object.keys(ctxChange.previousValue || {});
          /** @type {?} */
          const currCtxKeys = Object.keys(ctxChange.currentValue || {});
          if (prevCtxKeys.length === currCtxKeys.length) {
              for (let propName of currCtxKeys) {
                  if (prevCtxKeys.indexOf(propName) === -1) {
                      return true;
                  }
              }
              return false;
          }
          else {
              return true;
          }
      }
      /**
       * @private
       * @param {?} ctx
       * @return {?}
       */
      _updateExistingContext(ctx) {
          for (let propName of Object.keys(ctx)) {
              ((/** @type {?} */ (this._viewRef.context)))[propName] = ((/** @type {?} */ (this.ngTemplateOutletContext)))[propName];
          }
      }
  }
  NgTemplateOutlet.decorators = [
      { type: Directive, args: [{ selector: '[ngTemplateOutlet]' },] }
  ];
  /** @nocollapse */
  NgTemplateOutlet.ctorParameters = () => [
      { type: ViewContainerRef }
  ];
  NgTemplateOutlet.propDecorators = {
      ngTemplateOutletContext: [{ type: Input }],
      ngTemplateOutlet: [{ type: Input }]
  };

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A collection of Angular directives that are likely to be used in each and every Angular
   * application.
   * @type {?}
   */
  const COMMON_DIRECTIVES = [
      NgClass,
      NgComponentOutlet,
      NgForOf,
      NgIf,
      NgTemplateOutlet,
      NgStyle,
      NgSwitch,
      NgSwitchCase,
      NgSwitchDefault,
      NgPlural,
      NgPluralCase,
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} type
   * @param {?} value
   * @return {?}
   */
  function invalidPipeArgumentError(type, value) {
      return Error(`InvalidPipeArgument: '${value}' for pipe '${stringify$1(type)}'`);
  }
  /** @type {?} */
  const PATTERN_ALIASES = {
      // Keys are quoted so they do not get renamed during closure compilation.
      'yMMMdjms': datePartGetterFactory(combine([
          digitCondition('year', 1),
          nameCondition('month', 3),
          digitCondition('day', 1),
          digitCondition('hour', 1),
          digitCondition('minute', 1),
          digitCondition('second', 1),
      ])),
      'yMdjm': datePartGetterFactory(combine([
          digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
          digitCondition('hour', 1), digitCondition('minute', 1)
      ])),
      'yMMMMEEEEd': datePartGetterFactory(combine([
          digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
          digitCondition('day', 1)
      ])),
      'yMMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
      'yMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
      'yMd': datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
      'jms': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
      'jm': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
  };
  /** @type {?} */
  const DATE_FORMATS$1 = {
      // Keys are quoted so they do not get renamed.
      'yyyy': datePartGetterFactory(digitCondition('year', 4)),
      'yy': datePartGetterFactory(digitCondition('year', 2)),
      'y': datePartGetterFactory(digitCondition('year', 1)),
      'MMMM': datePartGetterFactory(nameCondition('month', 4)),
      'MMM': datePartGetterFactory(nameCondition('month', 3)),
      'MM': datePartGetterFactory(digitCondition('month', 2)),
      'M': datePartGetterFactory(digitCondition('month', 1)),
      'LLLL': datePartGetterFactory(nameCondition('month', 4)),
      'L': datePartGetterFactory(nameCondition('month', 1)),
      'dd': datePartGetterFactory(digitCondition('day', 2)),
      'd': datePartGetterFactory(digitCondition('day', 1)),
      'HH': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
      'H': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
      'hh': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
      'h': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
      'jj': datePartGetterFactory(digitCondition('hour', 2)),
      'j': datePartGetterFactory(digitCondition('hour', 1)),
      'mm': digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
      'm': datePartGetterFactory(digitCondition('minute', 1)),
      'ss': digitModifier(datePartGetterFactory(digitCondition('second', 2))),
      's': datePartGetterFactory(digitCondition('second', 1)),
      // while ISO 8601 requires fractions to be prefixed with `.` or `,`
      // we can be just safely rely on using `sss` since we currently don't support single or two digit
      // fractions
      'sss': datePartGetterFactory(digitCondition('second', 3)),
      'EEEE': datePartGetterFactory(nameCondition('weekday', 4)),
      'EEE': datePartGetterFactory(nameCondition('weekday', 3)),
      'EE': datePartGetterFactory(nameCondition('weekday', 2)),
      'E': datePartGetterFactory(nameCondition('weekday', 1)),
      'a': hourClockExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
      'Z': timeZoneGetter$1('short'),
      'z': timeZoneGetter$1('long'),
      'ww': datePartGetterFactory({}),
      // Week of year, padded (00-53). Week 01 is the week with the
      // first Thursday of the year. not support ?
      'w': datePartGetterFactory({}),
      // Week of year (0-53). Week 1 is the week with the first Thursday
      // of the year not support ?
      'G': datePartGetterFactory(nameCondition('era', 1)),
      'GG': datePartGetterFactory(nameCondition('era', 2)),
      'GGG': datePartGetterFactory(nameCondition('era', 3)),
      'GGGG': datePartGetterFactory(nameCondition('era', 4))
  };
  /**
   * @param {?} inner
   * @return {?}
   */
  function digitModifier(inner) {
      return function (date, locale) {
          /** @type {?} */
          const result = inner(date, locale);
          return result.length == 1 ? '0' + result : result;
      };
  }
  /**
   * @param {?} inner
   * @return {?}
   */
  function hourClockExtractor(inner) {
      return function (date, locale) { return inner(date, locale).split(' ')[1]; };
  }
  /**
   * @param {?} inner
   * @return {?}
   */
  function hourExtractor(inner) {
      return function (date, locale) { return inner(date, locale).split(' ')[0]; };
  }
  /**
   * @param {?} date
   * @param {?} locale
   * @param {?} options
   * @return {?}
   */
  function intlDateFormat(date, locale, options) {
      return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
  }
  /**
   * @param {?} timezone
   * @return {?}
   */
  function timeZoneGetter$1(timezone) {
      // To workaround `Intl` API restriction for single timezone let format with 24 hours
      /** @type {?} */
      const options = { hour: '2-digit', hour12: false, timeZoneName: timezone };
      return function (date, locale) {
          /** @type {?} */
          const result = intlDateFormat(date, locale, options);
          // Then extract first 3 letters that related to hours
          return result ? result.substring(3) : '';
      };
  }
  /**
   * @param {?} options
   * @param {?} value
   * @return {?}
   */
  function hour12Modify(options, value) {
      options.hour12 = value;
      return options;
  }
  /**
   * @param {?} prop
   * @param {?} len
   * @return {?}
   */
  function digitCondition(prop, len) {
      /** @type {?} */
      const result = {};
      result[prop] = len === 2 ? '2-digit' : 'numeric';
      return result;
  }
  /**
   * @param {?} prop
   * @param {?} len
   * @return {?}
   */
  function nameCondition(prop, len) {
      /** @type {?} */
      const result = {};
      if (len < 4) {
          result[prop] = len > 1 ? 'short' : 'narrow';
      }
      else {
          result[prop] = 'long';
      }
      return result;
  }
  /**
   * @param {?} options
   * @return {?}
   */
  function combine(options) {
      return options.reduce((merged, opt) => (Object.assign({}, merged, opt)), {});
  }
  /**
   * @param {?} ret
   * @return {?}
   */
  function datePartGetterFactory(ret) {
      return (date, locale) => intlDateFormat(date, locale, ret);
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class ObservableStrategy {
      /**
       * @param {?} async
       * @param {?} updateLatestValue
       * @return {?}
       */
      createSubscription(async, updateLatestValue) {
          return async.subscribe({ next: updateLatestValue, error: (e) => { throw e; } });
      }
      /**
       * @param {?} subscription
       * @return {?}
       */
      dispose(subscription) { subscription.unsubscribe(); }
      /**
       * @param {?} subscription
       * @return {?}
       */
      onDestroy(subscription) { subscription.unsubscribe(); }
  }
  class PromiseStrategy {
      /**
       * @param {?} async
       * @param {?} updateLatestValue
       * @return {?}
       */
      createSubscription(async, updateLatestValue) {
          return async.then(updateLatestValue, e => { throw e; });
      }
      /**
       * @param {?} subscription
       * @return {?}
       */
      dispose(subscription) { }
      /**
       * @param {?} subscription
       * @return {?}
       */
      onDestroy(subscription) { }
  }
  /** @type {?} */
  const _promiseStrategy = new PromiseStrategy();
  /** @type {?} */
  const _observableStrategy = new ObservableStrategy();
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Unwraps a value from an asynchronous primitive.
   *
   * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
   * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
   * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
   * potential memory leaks.
   *
   * \@usageNotes
   *
   * ### Examples
   *
   * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
   * promise.
   *
   * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
   *
   * It's also possible to use `async` with Observables. The example below binds the `time` Observable
   * to the view. The Observable continuously updates the view with the current time.
   *
   * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
   *
   * \@publicApi
   */
  class AsyncPipe {
      /**
       * @param {?} _ref
       */
      constructor(_ref) {
          this._ref = _ref;
          this._latestValue = null;
          this._latestReturnedValue = null;
          this._subscription = null;
          this._obj = null;
          this._strategy = (/** @type {?} */ (null));
      }
      /**
       * @return {?}
       */
      ngOnDestroy() {
          if (this._subscription) {
              this._dispose();
          }
      }
      /**
       * @param {?} obj
       * @return {?}
       */
      transform(obj) {
          if (!this._obj) {
              if (obj) {
                  this._subscribe(obj);
              }
              this._latestReturnedValue = this._latestValue;
              return this._latestValue;
          }
          if (obj !== this._obj) {
              this._dispose();
              return this.transform((/** @type {?} */ (obj)));
          }
          if (this._latestValue === this._latestReturnedValue) {
              return this._latestReturnedValue;
          }
          this._latestReturnedValue = this._latestValue;
          return WrappedValue.wrap(this._latestValue);
      }
      /**
       * @private
       * @param {?} obj
       * @return {?}
       */
      _subscribe(obj) {
          this._obj = obj;
          this._strategy = this._selectStrategy(obj);
          this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));
      }
      /**
       * @private
       * @param {?} obj
       * @return {?}
       */
      _selectStrategy(obj) {
          if (isPromise$2(obj)) {
              return _promiseStrategy;
          }
          if (isObservable$1(obj)) {
              return _observableStrategy;
          }
          throw invalidPipeArgumentError(AsyncPipe, obj);
      }
      /**
       * @private
       * @return {?}
       */
      _dispose() {
          this._strategy.dispose((/** @type {?} */ (this._subscription)));
          this._latestValue = null;
          this._latestReturnedValue = null;
          this._subscription = null;
          this._obj = null;
      }
      /**
       * @private
       * @param {?} async
       * @param {?} value
       * @return {?}
       */
      _updateLatestValue(async, value) {
          if (async === this._obj) {
              this._latestValue = value;
              this._ref.markForCheck();
          }
      }
  }
  AsyncPipe.decorators = [
      { type: Pipe, args: [{ name: 'async', pure: false },] }
  ];
  /** @nocollapse */
  AsyncPipe.ctorParameters = () => [
      { type: ChangeDetectorRef }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Transforms text to all lower case.
   *
   * @see `UpperCasePipe`
   * @see `TitleCasePipe`
   * \@usageNotes
   *
   * The following example defines a view that allows the user to enter
   * text, and then uses the pipe to convert the input text to all lower case.
   *
   * <code-example path="common/pipes/ts/lowerupper_pipe.ts" region='LowerUpperPipe'></code-example>
   *
   * \@ngModule CommonModule
   * \@publicApi
   */
  class LowerCasePipe {
      /**
       * @param {?} value The string to transform to lower case.
       * @return {?}
       */
      transform(value) {
          if (!value)
              return value;
          if (typeof value !== 'string') {
              throw invalidPipeArgumentError(LowerCasePipe, value);
          }
          return value.toLowerCase();
      }
  }
  LowerCasePipe.decorators = [
      { type: Pipe, args: [{ name: 'lowercase' },] }
  ];
  //
  // Regex below matches any Unicode word and compatible with ES5. In ES2018 the same result
  // can be achieved by using /\p{L}\S*/gu and also known as Unicode Property Escapes
  // (http://2ality.com/2017/07/regexp-unicode-property-escapes.html). Since there is no
  // transpilation of this functionality down to ES5 without external tool, the only solution is
  // to use already transpiled form. Example can be found here -
  // https://mothereff.in/regexpu#input=var+regex+%3D+/%5Cp%7BL%7D/u%3B&unicodePropertyEscape=1
  //
  /** @type {?} */
  const unicodeWordMatch = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D])\S*/g;
  /**
   * Transforms text to title case.
   * Capitalizes the first letter of each word, and transforms the
   * rest of the word to lower case.
   * Words are delimited by any whitespace character, such as a space, tab, or line-feed character.
   *
   * @see `LowerCasePipe`
   * @see `UpperCasePipe`
   *
   * \@usageNotes
   * The following example shows the result of transforming various strings into title case.
   *
   * <code-example path="common/pipes/ts/titlecase_pipe.ts" region='TitleCasePipe'></code-example>
   *
   * \@ngModule CommonModule
   * \@publicApi
   */
  class TitleCasePipe {
      /**
       * @param {?} value The string to transform to title case.
       * @return {?}
       */
      transform(value) {
          if (!value)
              return value;
          if (typeof value !== 'string') {
              throw invalidPipeArgumentError(TitleCasePipe, value);
          }
          return value.replace(unicodeWordMatch, (txt => txt[0].toUpperCase() + txt.substr(1).toLowerCase()));
      }
  }
  TitleCasePipe.decorators = [
      { type: Pipe, args: [{ name: 'titlecase' },] }
  ];
  /**
   * Transforms text to all upper case.
   * @see `LowerCasePipe`
   * @see `TitleCasePipe`
   *
   * \@ngModule CommonModule
   * \@publicApi
   */
  class UpperCasePipe {
      /**
       * @param {?} value The string to transform to upper case.
       * @return {?}
       */
      transform(value) {
          if (!value)
              return value;
          if (typeof value !== 'string') {
              throw invalidPipeArgumentError(UpperCasePipe, value);
          }
          return value.toUpperCase();
      }
  }
  UpperCasePipe.decorators = [
      { type: Pipe, args: [{ name: 'uppercase' },] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // clang-format off
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Formats a date value according to locale rules.
   *
   * Only the `en-US` locale data comes with Angular. To localize dates
   * in another language, you must import the corresponding locale data.
   * See the [I18n guide](guide/i18n#i18n-pipes) for more information.
   *
   * @see `formatDate()`
   *
   *
   * \@usageNotes
   *
   * The result of this pipe is not reevaluated when the input is mutated. To avoid the need to
   * reformat the date on every change-detection cycle, treat the date as an immutable object
   * and change the reference when the pipe needs to run again.
   *
   * ### Pre-defined format options
   *
   * Examples are given in `en-US` locale.
   *
   * - `'short'`: equivalent to `'M/d/yy, h:mm a'` (`6/15/15, 9:03 AM`).
   * - `'medium'`: equivalent to `'MMM d, y, h:mm:ss a'` (`Jun 15, 2015, 9:03:01 AM`).
   * - `'long'`: equivalent to `'MMMM d, y, h:mm:ss a z'` (`June 15, 2015 at 9:03:01 AM
   * GMT+1`).
   * - `'full'`: equivalent to `'EEEE, MMMM d, y, h:mm:ss a zzzz'` (`Monday, June 15, 2015 at
   * 9:03:01 AM GMT+01:00`).
   * - `'shortDate'`: equivalent to `'M/d/yy'` (`6/15/15`).
   * - `'mediumDate'`: equivalent to `'MMM d, y'` (`Jun 15, 2015`).
   * - `'longDate'`: equivalent to `'MMMM d, y'` (`June 15, 2015`).
   * - `'fullDate'`: equivalent to `'EEEE, MMMM d, y'` (`Monday, June 15, 2015`).
   * - `'shortTime'`: equivalent to `'h:mm a'` (`9:03 AM`).
   * - `'mediumTime'`: equivalent to `'h:mm:ss a'` (`9:03:01 AM`).
   * - `'longTime'`: equivalent to `'h:mm:ss a z'` (`9:03:01 AM GMT+1`).
   * - `'fullTime'`: equivalent to `'h:mm:ss a zzzz'` (`9:03:01 AM GMT+01:00`).
   *
   * ### Custom format options
   *
   * You can construct a format string using symbols to specify the components
   * of a date-time value, as described in the following table.
   * Format details depend on the locale.
   * Fields marked with (*) are only available in the extra data set for the given locale.
   *
   *  | Field type         | Format      | Description                                                   | Example Value                                              |
   *  |--------------------|-------------|---------------------------------------------------------------|------------------------------------------------------------|
   *  | Era                | G, GG & GGG | Abbreviated                                                   | AD                                                         |
   *  |                    | GGGG        | Wide                                                          | Anno Domini                                                |
   *  |                    | GGGGG       | Narrow                                                        | A                                                          |
   *  | Year               | y           | Numeric: minimum digits                                       | 2, 20, 201, 2017, 20173                                    |
   *  |                    | yy          | Numeric: 2 digits + zero padded                               | 02, 20, 01, 17, 73                                         |
   *  |                    | yyy         | Numeric: 3 digits + zero padded                               | 002, 020, 201, 2017, 20173                                 |
   *  |                    | yyyy        | Numeric: 4 digits or more + zero padded                       | 0002, 0020, 0201, 2017, 20173                              |
   *  | Month              | M           | Numeric: 1 digit                                              | 9, 12                                                      |
   *  |                    | MM          | Numeric: 2 digits + zero padded                               | 09, 12                                                     |
   *  |                    | MMM         | Abbreviated                                                   | Sep                                                        |
   *  |                    | MMMM        | Wide                                                          | September                                                  |
   *  |                    | MMMMM       | Narrow                                                        | S                                                          |
   *  | Month standalone   | L           | Numeric: 1 digit                                              | 9, 12                                                      |
   *  |                    | LL          | Numeric: 2 digits + zero padded                               | 09, 12                                                     |
   *  |                    | LLL         | Abbreviated                                                   | Sep                                                        |
   *  |                    | LLLL        | Wide                                                          | September                                                  |
   *  |                    | LLLLL       | Narrow                                                        | S                                                          |
   *  | Week of year       | w           | Numeric: minimum digits                                       | 1... 53                                                    |
   *  |                    | ww          | Numeric: 2 digits + zero padded                               | 01... 53                                                   |
   *  | Week of month      | W           | Numeric: 1 digit                                              | 1... 5                                                     |
   *  | Day of month       | d           | Numeric: minimum digits                                       | 1                                                          |
   *  |                    | dd          | Numeric: 2 digits + zero padded                               | 01                                                          |
   *  | Week day           | E, EE & EEE | Abbreviated                                                   | Tue                                                        |
   *  |                    | EEEE        | Wide                                                          | Tuesday                                                    |
   *  |                    | EEEEE       | Narrow                                                        | T                                                          |
   *  |                    | EEEEEE      | Short                                                         | Tu                                                         |
   *  | Period             | a, aa & aaa | Abbreviated                                                   | am/pm or AM/PM                                             |
   *  |                    | aaaa        | Wide (fallback to `a` when missing)                           | ante meridiem/post meridiem                                |
   *  |                    | aaaaa       | Narrow                                                        | a/p                                                        |
   *  | Period*            | B, BB & BBB | Abbreviated                                                   | mid.                                                       |
   *  |                    | BBBB        | Wide                                                          | am, pm, midnight, noon, morning, afternoon, evening, night |
   *  |                    | BBBBB       | Narrow                                                        | md                                                         |
   *  | Period standalone* | b, bb & bbb | Abbreviated                                                   | mid.                                                       |
   *  |                    | bbbb        | Wide                                                          | am, pm, midnight, noon, morning, afternoon, evening, night |
   *  |                    | bbbbb       | Narrow                                                        | md                                                         |
   *  | Hour 1-12          | h           | Numeric: minimum digits                                       | 1, 12                                                      |
   *  |                    | hh          | Numeric: 2 digits + zero padded                               | 01, 12                                                     |
   *  | Hour 0-23          | H           | Numeric: minimum digits                                       | 0, 23                                                      |
   *  |                    | HH          | Numeric: 2 digits + zero padded                               | 00, 23                                                     |
   *  | Minute             | m           | Numeric: minimum digits                                       | 8, 59                                                      |
   *  |                    | mm          | Numeric: 2 digits + zero padded                               | 08, 59                                                     |
   *  | Second             | s           | Numeric: minimum digits                                       | 0... 59                                                    |
   *  |                    | ss          | Numeric: 2 digits + zero padded                               | 00... 59                                                   |
   *  | Fractional seconds | S           | Numeric: 1 digit                                              | 0... 9                                                     |
   *  |                    | SS          | Numeric: 2 digits + zero padded                               | 00... 99                                                   |
   *  |                    | SSS         | Numeric: 3 digits + zero padded (= milliseconds)              | 000... 999                                                 |
   *  | Zone               | z, zz & zzz | Short specific non location format (fallback to O)            | GMT-8                                                      |
   *  |                    | zzzz        | Long specific non location format (fallback to OOOO)          | GMT-08:00                                                  |
   *  |                    | Z, ZZ & ZZZ | ISO8601 basic format                                          | -0800                                                      |
   *  |                    | ZZZZ        | Long localized GMT format                                     | GMT-8:00                                                   |
   *  |                    | ZZZZZ       | ISO8601 extended format + Z indicator for offset 0 (= XXXXX)  | -08:00                                                     |
   *  |                    | O, OO & OOO | Short localized GMT format                                    | GMT-8                                                      |
   *  |                    | OOOO        | Long localized GMT format                                     | GMT-08:00                                                  |
   *
   * Note that timezone correction is not applied to an ISO string that has no time component, such as "2016-09-19"
   *
   * ### Format examples
   *
   * These examples transform a date into various formats,
   * assuming that `dateObj` is a JavaScript `Date` object for
   * year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11,
   * given in the local time for the `en-US` locale.
   *
   * ```
   * {{ dateObj | date }}               // output is 'Jun 15, 2015'
   * {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
   * {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
   * {{ dateObj | date:'mmss' }}        // output is '43:11'
   * ```
   *
   * ### Usage example
   *
   * The following component uses a date pipe to display the current date in different formats.
   *
   * ```
   * \@Component({
   *  selector: 'date-pipe',
   *  template: `<div>
   *    <p>Today is {{today | date}}</p>
   *    <p>Or if you prefer, {{today | date:'fullDate'}}</p>
   *    <p>The time is {{today | date:'h:mm a z'}}</p>
   *  </div>`
   * })
   * // Get the current date and time as a date-time value.
   * export class DatePipeComponent {
   *   today: number = Date.now();
   * }
   * ```
   *
   * \@publicApi
   */
  // clang-format on
  class DatePipe {
      /**
       * @param {?} locale
       */
      constructor(locale) {
          this.locale = locale;
      }
      /**
       * @param {?} value The date expression: a `Date` object,  a number
       * (milliseconds since UTC epoch), or an ISO string (https://www.w3.org/TR/NOTE-datetime).
       * @param {?=} format The date/time components to include, using predefined options or a
       * custom format string.
       * @param {?=} timezone A timezone offset (such as `'+0430'`), or a standard
       * UTC/GMT or continental US timezone abbreviation. Default is
       * the local system timezone of the end-user's machine.
       * @param {?=} locale A locale code for the locale format rules to use.
       * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
       * See [Setting your app locale](guide/i18n#setting-up-the-locale-of-your-app).
       * @return {?} A date string in the desired format.
       */
      transform(value, format = 'mediumDate', timezone, locale) {
          if (value == null || value === '' || value !== value)
              return null;
          try {
              return formatDate(value, format, locale || this.locale, timezone);
          }
          catch (error) {
              throw invalidPipeArgumentError(DatePipe, error.message);
          }
      }
  }
  DatePipe.decorators = [
      { type: Pipe, args: [{ name: 'date', pure: true },] }
  ];
  /** @nocollapse */
  DatePipe.ctorParameters = () => [
      { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const _INTERPOLATION_REGEXP = /#/g;
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Maps a value to a string that pluralizes the value according to locale rules.
   *
   * \@usageNotes
   *
   * ### Example
   *
   * {\@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}
   *
   * \@publicApi
   */
  class I18nPluralPipe {
      /**
       * @param {?} _localization
       */
      constructor(_localization) {
          this._localization = _localization;
      }
      /**
       * @param {?} value the number to be formatted
       * @param {?} pluralMap an object that mimics the ICU format, see
       * http://userguide.icu-project.org/formatparse/messages.
       * @param {?=} locale a `string` defining the locale to use (uses the current {\@link LOCALE_ID} by
       * default).
       * @return {?}
       */
      transform(value, pluralMap, locale) {
          if (value == null)
              return '';
          if (typeof pluralMap !== 'object' || pluralMap === null) {
              throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
          }
          /** @type {?} */
          const key = getPluralCategory$1(value, Object.keys(pluralMap), this._localization, locale);
          return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
      }
  }
  I18nPluralPipe.decorators = [
      { type: Pipe, args: [{ name: 'i18nPlural', pure: true },] }
  ];
  /** @nocollapse */
  I18nPluralPipe.ctorParameters = () => [
      { type: NgLocalization }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Generic selector that displays the string that matches the current value.
   *
   * If none of the keys of the `mapping` match the `value`, then the content
   * of the `other` key is returned when present, otherwise an empty string is returned.
   *
   * \@usageNotes
   *
   * ### Example
   *
   * {\@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}
   *
   * \@publicApi
   */
  class I18nSelectPipe {
      /**
       * @param {?} value a string to be internationalized.
       * @param {?} mapping an object that indicates the text that should be displayed
       * for different values of the provided `value`.
       * @return {?}
       */
      transform(value, mapping) {
          if (value == null)
              return '';
          if (typeof mapping !== 'object' || typeof value !== 'string') {
              throw invalidPipeArgumentError(I18nSelectPipe, mapping);
          }
          if (mapping.hasOwnProperty(value)) {
              return mapping[value];
          }
          if (mapping.hasOwnProperty('other')) {
              return mapping['other'];
          }
          return '';
      }
  }
  I18nSelectPipe.decorators = [
      { type: Pipe, args: [{ name: 'i18nSelect', pure: true },] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Converts a value into its JSON-format representation.  Useful for debugging.
   *
   * \@usageNotes
   *
   * The following component uses a JSON pipe to convert an object
   * to JSON format, and displays the string in both formats for comparison.
   *
   * {\@example common/pipes/ts/json_pipe.ts region='JsonPipe'}
   *
   * \@publicApi
   */
  class JsonPipe {
      /**
       * @param {?} value A value of any type to convert into a JSON-format string.
       * @return {?}
       */
      transform(value) { return JSON.stringify(value, null, 2); }
  }
  JsonPipe.decorators = [
      { type: Pipe, args: [{ name: 'json', pure: false },] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @template K, V
   * @param {?} key
   * @param {?} value
   * @return {?}
   */
  function makeKeyValuePair(key, value) {
      return { key: key, value: value };
  }
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Transforms Object or Map into an array of key value pairs.
   *
   * The output array will be ordered by keys.
   * By default the comparator will be by Unicode point value.
   * You can optionally pass a compareFn if your keys are complex types.
   *
   * \@usageNotes
   * ### Examples
   *
   * This examples show how an Object or a Map can be iterated by ngFor with the use of this keyvalue
   * pipe.
   *
   * {\@example common/pipes/ts/keyvalue_pipe.ts region='KeyValuePipe'}
   *
   * \@publicApi
   */
  class KeyValuePipe {
      /**
       * @param {?} differs
       */
      constructor(differs) {
          this.differs = differs;
          this.keyValues = [];
      }
      /**
       * @template K, V
       * @param {?} input
       * @param {?=} compareFn
       * @return {?}
       */
      transform(input, compareFn = defaultComparator) {
          if (!input || (!(input instanceof Map) && typeof input !== 'object')) {
              return null;
          }
          if (!this.differ) {
              // make a differ for whatever type we've been passed in
              this.differ = this.differs.find(input).create();
          }
          /** @type {?} */
          const differChanges = this.differ.diff((/** @type {?} */ (input)));
          if (differChanges) {
              this.keyValues = [];
              differChanges.forEachItem((r) => {
                  this.keyValues.push(makeKeyValuePair(r.key, (/** @type {?} */ (r.currentValue))));
              });
              this.keyValues.sort(compareFn);
          }
          return this.keyValues;
      }
  }
  KeyValuePipe.decorators = [
      { type: Pipe, args: [{ name: 'keyvalue', pure: false },] }
  ];
  /** @nocollapse */
  KeyValuePipe.ctorParameters = () => [
      { type: KeyValueDiffers }
  ];
  /**
   * @template K, V
   * @param {?} keyValueA
   * @param {?} keyValueB
   * @return {?}
   */
  function defaultComparator(keyValueA, keyValueB) {
      /** @type {?} */
      const a = keyValueA.key;
      /** @type {?} */
      const b = keyValueB.key;
      // if same exit with 0;
      if (a === b)
          return 0;
      // make sure that undefined are at the end of the sort.
      if (a === undefined)
          return 1;
      if (b === undefined)
          return -1;
      // make sure that nulls are at the end of the sort.
      if (a === null)
          return 1;
      if (b === null)
          return -1;
      if (typeof a == 'string' && typeof b == 'string') {
          return a < b ? -1 : 1;
      }
      if (typeof a == 'number' && typeof b == 'number') {
          return a - b;
      }
      if (typeof a == 'boolean' && typeof b == 'boolean') {
          return a < b ? -1 : 1;
      }
      // `a` and `b` are of different types. Compare their string values.
      /** @type {?} */
      const aString = String(a);
      /** @type {?} */
      const bString = String(b);
      return aString == bString ? 0 : aString < bString ? -1 : 1;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Transforms a number into a string,
   * formatted according to locale rules that determine group sizing and
   * separator, decimal-point character, and other locale-specific
   * configurations.
   *
   * If no parameters are specified, the function rounds off to the nearest value using this
   * [rounding method](https://en.wikibooks.org/wiki/Arithmetic/Rounding).
   * The behavior differs from that of the JavaScript ```Math.round()``` function.
   * In the following case for example, the pipe rounds down where
   * ```Math.round()``` rounds up:
   *
   * ```html
   * -2.5 | number:'1.0-0'
   * > -3
   * Math.round(-2.5)
   * > -2
   * ```
   *
   * @see `formatNumber()`
   *
   * \@usageNotes
   * The following code shows how the pipe transforms numbers
   * into text strings, according to various format specifications,
   * where the caller's default locale is `en-US`.
   *
   * ### Example
   *
   * <code-example path="common/pipes/ts/number_pipe.ts" region='NumberPipe'></code-example>
   *
   * \@publicApi
   */
  class DecimalPipe {
      /**
       * @param {?} _locale
       */
      constructor(_locale) {
          this._locale = _locale;
      }
      /**
       * @param {?} value The number to be formatted.
       * @param {?=} digitsInfo Decimal representation options, specified by a string
       * in the following format:<br>
       * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
       *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
       * Default is `1`.
       *   - `minFractionDigits`: The minimum number of digits after the decimal point.
       * Default is `0`.
       *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
       * Default is `3`.
       * @param {?=} locale A locale code for the locale format rules to use.
       * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
       * See [Setting your app locale](guide/i18n#setting-up-the-locale-of-your-app).
       * @return {?}
       */
      transform(value, digitsInfo, locale) {
          if (isEmpty$1(value))
              return null;
          locale = locale || this._locale;
          try {
              /** @type {?} */
              const num = strToNumber(value);
              return formatNumber(num, locale, digitsInfo);
          }
          catch (error) {
              throw invalidPipeArgumentError(DecimalPipe, error.message);
          }
      }
  }
  DecimalPipe.decorators = [
      { type: Pipe, args: [{ name: 'number' },] }
  ];
  /** @nocollapse */
  DecimalPipe.ctorParameters = () => [
      { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
  ];
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Transforms a number to a percentage
   * string, formatted according to locale rules that determine group sizing and
   * separator, decimal-point character, and other locale-specific
   * configurations.
   *
   * @see `formatPercent()`
   *
   * \@usageNotes
   * The following code shows how the pipe transforms numbers
   * into text strings, according to various format specifications,
   * where the caller's default locale is `en-US`.
   *
   * <code-example path="common/pipes/ts/percent_pipe.ts" region='PercentPipe'></code-example>
   *
   * \@publicApi
   */
  class PercentPipe {
      /**
       * @param {?} _locale
       */
      constructor(_locale) {
          this._locale = _locale;
      }
      /**
       *
       * @param {?} value The number to be formatted as a percentage.
       * @param {?=} digitsInfo Decimal representation options, specified by a string
       * in the following format:<br>
       * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
       *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
       * Default is `1`.
       *   - `minFractionDigits`: The minimum number of digits after the decimal point.
       * Default is `0`.
       *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
       * Default is `0`.
       * @param {?=} locale A locale code for the locale format rules to use.
       * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
       * See [Setting your app locale](guide/i18n#setting-up-the-locale-of-your-app).
       * @return {?}
       */
      transform(value, digitsInfo, locale) {
          if (isEmpty$1(value))
              return null;
          locale = locale || this._locale;
          try {
              /** @type {?} */
              const num = strToNumber(value);
              return formatPercent(num, locale, digitsInfo);
          }
          catch (error) {
              throw invalidPipeArgumentError(PercentPipe, error.message);
          }
      }
  }
  PercentPipe.decorators = [
      { type: Pipe, args: [{ name: 'percent' },] }
  ];
  /** @nocollapse */
  PercentPipe.ctorParameters = () => [
      { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
  ];
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Transforms a number to a currency string, formatted according to locale rules
   * that determine group sizing and separator, decimal-point character,
   * and other locale-specific configurations.
   *
   * @see `getCurrencySymbol()`
   * @see `formatCurrency()`
   *
   * \@usageNotes
   * The following code shows how the pipe transforms numbers
   * into text strings, according to various format specifications,
   * where the caller's default locale is `en-US`.
   *
   * <code-example path="common/pipes/ts/currency_pipe.ts" region='CurrencyPipe'></code-example>
   *
   * \@publicApi
   */
  class CurrencyPipe {
      /**
       * @param {?} _locale
       */
      constructor(_locale) {
          this._locale = _locale;
      }
      /**
       *
       * @param {?} value The number to be formatted as currency.
       * @param {?=} currencyCode The [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code,
       * such as `USD` for the US dollar and `EUR` for the euro.
       * @param {?=} display The format for the currency indicator. One of the following:
       *   - `code`: Show the code (such as `USD`).
       *   - `symbol`(default): Show the symbol (such as `$`).
       *   - `symbol-narrow`: Use the narrow symbol for locales that have two symbols for their
       * currency.
       * For example, the Canadian dollar CAD has the symbol `CA$` and the symbol-narrow `$`. If the
       * locale has no narrow symbol, uses the standard symbol for the locale.
       *   - String: Use the given string value instead of a code or a symbol.
       * For example, an empty string will suppress the currency & symbol.
       *   - Boolean (marked deprecated in v5): `true` for symbol and false for `code`.
       *
       * @param {?=} digitsInfo Decimal representation options, specified by a string
       * in the following format:<br>
       * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.
       *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.
       * Default is `1`.
       *   - `minFractionDigits`: The minimum number of digits after the decimal point.
       * Default is `2`.
       *   - `maxFractionDigits`: The maximum number of digits after the decimal point.
       * Default is `2`.
       * If not provided, the number will be formatted with the proper amount of digits,
       * depending on what the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) specifies.
       * For example, the Canadian dollar has 2 digits, whereas the Chilean peso has none.
       * @param {?=} locale A locale code for the locale format rules to use.
       * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.
       * See [Setting your app locale](guide/i18n#setting-up-the-locale-of-your-app).
       * @return {?}
       */
      transform(value, currencyCode, display = 'symbol', digitsInfo, locale) {
          if (isEmpty$1(value))
              return null;
          locale = locale || this._locale;
          if (typeof display === 'boolean') {
              if ((/** @type {?} */ (console)) && (/** @type {?} */ (console.warn))) {
                  console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".`);
              }
              display = display ? 'symbol' : 'code';
          }
          /** @type {?} */
          let currency = currencyCode || 'USD';
          if (display !== 'code') {
              if (display === 'symbol' || display === 'symbol-narrow') {
                  currency = getCurrencySymbol(currency, display === 'symbol' ? 'wide' : 'narrow', locale);
              }
              else {
                  currency = display;
              }
          }
          try {
              /** @type {?} */
              const num = strToNumber(value);
              return formatCurrency(num, locale, currency, currencyCode, digitsInfo);
          }
          catch (error) {
              throw invalidPipeArgumentError(CurrencyPipe, error.message);
          }
      }
  }
  CurrencyPipe.decorators = [
      { type: Pipe, args: [{ name: 'currency' },] }
  ];
  /** @nocollapse */
  CurrencyPipe.ctorParameters = () => [
      { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
  ];
  /**
   * @param {?} value
   * @return {?}
   */
  function isEmpty$1(value) {
      return value == null || value === '' || value !== value;
  }
  /**
   * Transforms a string into a number (if needed).
   * @param {?} value
   * @return {?}
   */
  function strToNumber(value) {
      // Convert strings to numbers
      if (typeof value === 'string' && !isNaN(Number(value) - parseFloat(value))) {
          return Number(value);
      }
      if (typeof value !== 'number') {
          throw new Error(`${value} is not a number`);
      }
      return value;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@ngModule CommonModule
   * \@description
   *
   * Creates a new `Array` or `String` containing a subset (slice) of the elements.
   *
   * \@usageNotes
   *
   * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`
   * and `String.prototype.slice()`.
   *
   * When operating on an `Array`, the returned `Array` is always a copy even when all
   * the elements are being returned.
   *
   * When operating on a blank value, the pipe returns the blank value.
   *
   * ### List Example
   *
   * This `ngFor` example:
   *
   * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}
   *
   * produces the following:
   *
   * ```html
   * <li>b</li>
   * <li>c</li>
   * ```
   *
   * ### String Examples
   *
   * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}
   *
   * \@publicApi
   */
  class SlicePipe {
      /**
       * @param {?} value a list or a string to be sliced.
       * @param {?} start the starting index of the subset to return:
       *   - **a positive integer**: return the item at `start` index and all items after
       *     in the list or string expression.
       *   - **a negative integer**: return the item at `start` index from the end and all items after
       *     in the list or string expression.
       *   - **if positive and greater than the size of the expression**: return an empty list or
       * string.
       *   - **if negative and greater than the size of the expression**: return entire list or string.
       * @param {?=} end the ending index of the subset to return:
       *   - **omitted**: return all items until the end.
       *   - **if positive**: return all items before `end` index of the list or string.
       *   - **if negative**: return all items before `end` index from the end of the list or string.
       * @return {?}
       */
      transform(value, start, end) {
          if (value == null)
              return value;
          if (!this.supports(value)) {
              throw invalidPipeArgumentError(SlicePipe, value);
          }
          return value.slice(start, end);
      }
      /**
       * @private
       * @param {?} obj
       * @return {?}
       */
      supports(obj) { return typeof obj === 'string' || Array.isArray(obj); }
  }
  SlicePipe.decorators = [
      { type: Pipe, args: [{ name: 'slice', pure: false },] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A collection of Angular pipes that are likely to be used in each and every application.
   * @type {?}
   */
  const COMMON_PIPES = [
      AsyncPipe,
      UpperCasePipe,
      LowerCasePipe,
      JsonPipe,
      SlicePipe,
      DecimalPipe,
      PercentPipe,
      TitleCasePipe,
      CurrencyPipe,
      DatePipe,
      I18nPluralPipe,
      I18nSelectPipe,
      KeyValuePipe,
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  // Note: This does not contain the location providers,
  // as they need some platform specific implementations to work.
  /**
   * Exports all the basic Angular directives and pipes,
   * such as `NgIf`, `NgForOf`, `DecimalPipe`, and so on.
   * Re-exported by `BrowserModule`, which is included automatically in the root
   * `AppModule` when you create a new app with the CLI `new` command.
   *
   * * The `providers` options configure the NgModule's injector to provide
   * localization dependencies to members.
   * * The `exports` options make the declared directives and pipes available for import
   * by other NgModules.
   *
   * \@publicApi
   */
  class CommonModule {
  }
  CommonModule.decorators = [
      { type: NgModule, args: [{
                  declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
                  exports: [COMMON_DIRECTIVES, COMMON_PIPES],
                  providers: [
                      { provide: NgLocalization, useClass: NgLocaleLocalization },
                  ],
              },] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A DI Token representing the main rendering context. In a browser this is the DOM Document.
   *
   * Note: Document might not be available in the Application Context when Application and Rendering
   * Contexts are not the same (e.g. when running the application into a Web Worker).
   *
   * \@publicApi
   * @type {?}
   */
  const DOCUMENT = new InjectionToken('DocumentToken');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @type {?} */
  const PLATFORM_BROWSER_ID = 'browser';
  /** @type {?} */
  const PLATFORM_SERVER_ID = 'server';
  /**
   * Returns whether a platform id represents a server platform.
   * \@publicApi
   * @param {?} platformId
   * @return {?}
   */
  function isPlatformServer(platformId) {
      return platformId === PLATFORM_SERVER_ID;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@publicApi
   * @type {?}
   */
  const VERSION$3 = new Version$1('7.2.8');

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Defines a scroll position manager. Implemented by `BrowserViewportScroller`.
   *
   * \@publicApi
   * @abstract
   */
  class ViewportScroller {
  }
  // De-sugared tree-shakable injection
  // See #23917
  /** @nocollapse */
  /** @nocollapse */ ViewportScroller.ngInjectableDef = defineInjectable({ providedIn: 'root', factory: () => new BrowserViewportScroller(inject(DOCUMENT), window) });
  /**
   * Manages the scroll position for a browser window.
   */
  class BrowserViewportScroller {
      /**
       * @param {?} document
       * @param {?} window
       */
      constructor(document, window) {
          this.document = document;
          this.window = window;
          this.offset = () => [0, 0];
      }
      /**
       * Configures the top offset used when scrolling to an anchor.
       * @param {?} offset A position in screen coordinates (a tuple with x and y values)
       * or a function that returns the top offset position.
       *
       * @return {?}
       */
      setOffset(offset) {
          if (Array.isArray(offset)) {
              this.offset = () => offset;
          }
          else {
              this.offset = offset;
          }
      }
      /**
       * Retrieves the current scroll position.
       * @return {?} The position in screen coordinates.
       */
      getScrollPosition() {
          if (this.supportScrollRestoration()) {
              return [this.window.scrollX, this.window.scrollY];
          }
          else {
              return [0, 0];
          }
      }
      /**
       * Sets the scroll position.
       * @param {?} position The new position in screen coordinates.
       * @return {?}
       */
      scrollToPosition(position) {
          if (this.supportScrollRestoration()) {
              this.window.scrollTo(position[0], position[1]);
          }
      }
      /**
       * Scrolls to an anchor element.
       * @param {?} anchor The ID of the anchor element.
       * @return {?}
       */
      scrollToAnchor(anchor) {
          if (this.supportScrollRestoration()) {
              /** @type {?} */
              const elSelectedById = this.document.querySelector(`#${anchor}`);
              if (elSelectedById) {
                  this.scrollToElement(elSelectedById);
                  return;
              }
              /** @type {?} */
              const elSelectedByName = this.document.querySelector(`[name='${anchor}']`);
              if (elSelectedByName) {
                  this.scrollToElement(elSelectedByName);
                  return;
              }
          }
      }
      /**
       * Disables automatic scroll restoration provided by the browser.
       * @param {?} scrollRestoration
       * @return {?}
       */
      setHistoryScrollRestoration(scrollRestoration) {
          if (this.supportScrollRestoration()) {
              /** @type {?} */
              const history = this.window.history;
              if (history && history.scrollRestoration) {
                  history.scrollRestoration = scrollRestoration;
              }
          }
      }
      /**
       * @private
       * @param {?} el
       * @return {?}
       */
      scrollToElement(el) {
          /** @type {?} */
          const rect = el.getBoundingClientRect();
          /** @type {?} */
          const left = rect.left + this.window.pageXOffset;
          /** @type {?} */
          const top = rect.top + this.window.pageYOffset;
          /** @type {?} */
          const offset = this.offset();
          this.window.scrollTo(left - offset[0], top - offset[1]);
      }
      /**
       * We only support scroll restoration when we can get a hold of window.
       * This means that we do not support this behavior when running in a web worker.
       *
       * Lifting this restriction right now would require more changes in the dom adapter.
       * Since webworkers aren't widely used, we will lift it once RouterScroller is
       * battle-tested.
       * @private
       * @return {?}
       */
      supportScrollRestoration() {
          try {
              return !!this.window && !!this.window.scrollTo;
          }
          catch (_a) {
              return false;
          }
      }
  }

  /**
   * @license Angular v7.2.8
   * (c) 2010-2019 Google LLC. https://angular.io/
   * License: MIT
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /** @type {?} */
  let _DOM = (/** @type {?} */ (null));
  /**
   * @return {?}
   */
  function getDOM() {
      return _DOM;
  }
  /**
   * @param {?} adapter
   * @return {?}
   */
  function setRootDomAdapter(adapter) {
      if (!_DOM) {
          _DOM = adapter;
      }
  }
  /* tslint:disable:requireParameterType */
  /**
   * Provides DOM operations in an environment-agnostic way.
   *
   * \@security Tread carefully! Interacting with the DOM directly is dangerous and
   * can introduce XSS risks.
   * @abstract
   */
  class DomAdapter {
      constructor() {
          this.resourceLoaderType = (/** @type {?} */ (null));
      }
      /**
       * Maps attribute names to their corresponding property names for cases
       * where attribute name doesn't match property name.
       * @return {?}
       */
      get attrToPropMap() { return this._attrToPropMap; }
      /**
       * @param {?} value
       * @return {?}
       */
      set attrToPropMap(value) { this._attrToPropMap = value; }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Provides DOM operations in any browser environment.
   *
   * \@security Tread carefully! Interacting with the DOM directly is dangerous and
   * can introduce XSS risks.
   * @abstract
   */
  class GenericBrowserDomAdapter extends DomAdapter {
      constructor() {
          super();
          this._animationPrefix = null;
          this._transitionEnd = null;
          try {
              /** @type {?} */
              const element$$1 = this.createElement('div', document);
              if (this.getStyle(element$$1, 'animationName') != null) {
                  this._animationPrefix = '';
              }
              else {
                  /** @type {?} */
                  const domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
                  for (let i = 0; i < domPrefixes.length; i++) {
                      if (this.getStyle(element$$1, domPrefixes[i] + 'AnimationName') != null) {
                          this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
                          break;
                      }
                  }
              }
              /** @type {?} */
              const transEndEventNames = {
                  WebkitTransition: 'webkitTransitionEnd',
                  MozTransition: 'transitionend',
                  OTransition: 'oTransitionEnd otransitionend',
                  transition: 'transitionend'
              };
              Object.keys(transEndEventNames).forEach((key) => {
                  if (this.getStyle(element$$1, key) != null) {
                      this._transitionEnd = transEndEventNames[key];
                  }
              });
          }
          catch (_a) {
              this._animationPrefix = null;
              this._transitionEnd = null;
          }
      }
      /**
       * @param {?} el
       * @return {?}
       */
      getDistributedNodes(el) { return ((/** @type {?} */ (el))).getDistributedNodes(); }
      /**
       * @param {?} el
       * @param {?} baseUrl
       * @param {?} href
       * @return {?}
       */
      resolveAndSetHref(el, baseUrl, href) {
          el.href = href == null ? baseUrl : baseUrl + '/../' + href;
      }
      /**
       * @return {?}
       */
      supportsDOMEvents() { return true; }
      /**
       * @return {?}
       */
      supportsNativeShadowDOM() {
          return typeof ((/** @type {?} */ (document.body))).createShadowRoot === 'function';
      }
      /**
       * @return {?}
       */
      getAnimationPrefix() { return this._animationPrefix ? this._animationPrefix : ''; }
      /**
       * @return {?}
       */
      getTransitionEnd() { return this._transitionEnd ? this._transitionEnd : ''; }
      /**
       * @return {?}
       */
      supportsAnimation() {
          return this._animationPrefix != null && this._transitionEnd != null;
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const _attrToPropMap = {
      'class': 'className',
      'innerHtml': 'innerHTML',
      'readonly': 'readOnly',
      'tabindex': 'tabIndex',
  };
  /** @type {?} */
  const DOM_KEY_LOCATION_NUMPAD = 3;
  // Map to convert some key or keyIdentifier values to what will be returned by getEventKey
  /** @type {?} */
  const _keyMap = {
      // The following values are here for cross-browser compatibility and to match the W3C standard
      // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
      '\b': 'Backspace',
      '\t': 'Tab',
      '\x7F': 'Delete',
      '\x1B': 'Escape',
      'Del': 'Delete',
      'Esc': 'Escape',
      'Left': 'ArrowLeft',
      'Right': 'ArrowRight',
      'Up': 'ArrowUp',
      'Down': 'ArrowDown',
      'Menu': 'ContextMenu',
      'Scroll': 'ScrollLock',
      'Win': 'OS'
  };
  // There is a bug in Chrome for numeric keypad keys:
  // https://code.google.com/p/chromium/issues/detail?id=155654
  // 1, 2, 3 ... are reported as A, B, C ...
  /** @type {?} */
  const _chromeNumKeyPadMap = {
      'A': '1',
      'B': '2',
      'C': '3',
      'D': '4',
      'E': '5',
      'F': '6',
      'G': '7',
      'H': '8',
      'I': '9',
      'J': '*',
      'K': '+',
      'M': '-',
      'N': '.',
      'O': '/',
      '\x60': '0',
      '\x90': 'NumLock'
  };
  /** @type {?} */
  let nodeContains;
  if (_global$1['Node']) {
      nodeContains = _global$1['Node'].prototype.contains || function (node) {
          return !!(this.compareDocumentPosition(node) & 16);
      };
  }
  /**
   * A `DomAdapter` powered by full browser DOM APIs.
   *
   * \@security Tread carefully! Interacting with the DOM directly is dangerous and
   * can introduce XSS risks.
   */
  /* tslint:disable:requireParameterType no-console */
  class BrowserDomAdapter extends GenericBrowserDomAdapter {
      /**
       * @param {?} templateHtml
       * @return {?}
       */
      parse(templateHtml) { throw new Error('parse not implemented'); }
      /**
       * @return {?}
       */
      static makeCurrent() { setRootDomAdapter(new BrowserDomAdapter()); }
      /**
       * @param {?} element
       * @param {?} name
       * @return {?}
       */
      hasProperty(element$$1, name) { return name in element$$1; }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?} value
       * @return {?}
       */
      setProperty(el, name, value) { ((/** @type {?} */ (el)))[name] = value; }
      /**
       * @param {?} el
       * @param {?} name
       * @return {?}
       */
      getProperty(el, name) { return ((/** @type {?} */ (el)))[name]; }
      /**
       * @param {?} el
       * @param {?} methodName
       * @param {?} args
       * @return {?}
       */
      invoke(el, methodName, args) { ((/** @type {?} */ (el)))[methodName](...args); }
      // TODO(tbosch): move this into a separate environment class once we have it
      /**
       * @param {?} error
       * @return {?}
       */
      logError(error) {
          if (window.console) {
              if (console.error) {
                  console.error(error);
              }
              else {
                  console.log(error);
              }
          }
      }
      /**
       * @param {?} error
       * @return {?}
       */
      log(error) {
          if (window.console) {
              window.console.log && window.console.log(error);
          }
      }
      /**
       * @param {?} error
       * @return {?}
       */
      logGroup(error) {
          if (window.console) {
              window.console.group && window.console.group(error);
          }
      }
      /**
       * @return {?}
       */
      logGroupEnd() {
          if (window.console) {
              window.console.groupEnd && window.console.groupEnd();
          }
      }
      /**
       * @return {?}
       */
      get attrToPropMap() { return _attrToPropMap; }
      /**
       * @param {?} nodeA
       * @param {?} nodeB
       * @return {?}
       */
      contains(nodeA, nodeB) { return nodeContains.call(nodeA, nodeB); }
      /**
       * @param {?} el
       * @param {?} selector
       * @return {?}
       */
      querySelector(el, selector) { return el.querySelector(selector); }
      /**
       * @param {?} el
       * @param {?} selector
       * @return {?}
       */
      querySelectorAll(el, selector) { return el.querySelectorAll(selector); }
      /**
       * @param {?} el
       * @param {?} evt
       * @param {?} listener
       * @return {?}
       */
      on(el, evt, listener$$1) { el.addEventListener(evt, listener$$1, false); }
      /**
       * @param {?} el
       * @param {?} evt
       * @param {?} listener
       * @return {?}
       */
      onAndCancel(el, evt, listener$$1) {
          el.addEventListener(evt, listener$$1, false);
          // Needed to follow Dart's subscription semantic, until fix of
          // https://code.google.com/p/dart/issues/detail?id=17406
          return () => { el.removeEventListener(evt, listener$$1, false); };
      }
      /**
       * @param {?} el
       * @param {?} evt
       * @return {?}
       */
      dispatchEvent(el, evt) { el.dispatchEvent(evt); }
      /**
       * @param {?} eventType
       * @return {?}
       */
      createMouseEvent(eventType) {
          /** @type {?} */
          const evt = this.getDefaultDocument().createEvent('MouseEvent');
          evt.initEvent(eventType, true, true);
          return evt;
      }
      /**
       * @param {?} eventType
       * @return {?}
       */
      createEvent(eventType) {
          /** @type {?} */
          const evt = this.getDefaultDocument().createEvent('Event');
          evt.initEvent(eventType, true, true);
          return evt;
      }
      /**
       * @param {?} evt
       * @return {?}
       */
      preventDefault(evt) {
          evt.preventDefault();
          evt.returnValue = false;
      }
      /**
       * @param {?} evt
       * @return {?}
       */
      isPrevented(evt) {
          return evt.defaultPrevented || evt.returnValue != null && !evt.returnValue;
      }
      /**
       * @param {?} el
       * @return {?}
       */
      getInnerHTML(el) { return el.innerHTML; }
      /**
       * @param {?} el
       * @return {?}
       */
      getTemplateContent(el) {
          return 'content' in el && this.isTemplateElement(el) ? ((/** @type {?} */ (el))).content : null;
      }
      /**
       * @param {?} el
       * @return {?}
       */
      getOuterHTML(el) { return el.outerHTML; }
      /**
       * @param {?} node
       * @return {?}
       */
      nodeName(node) { return node.nodeName; }
      /**
       * @param {?} node
       * @return {?}
       */
      nodeValue(node) { return node.nodeValue; }
      /**
       * @param {?} node
       * @return {?}
       */
      type(node) { return node.type; }
      /**
       * @param {?} node
       * @return {?}
       */
      content(node) {
          if (this.hasProperty(node, 'content')) {
              return ((/** @type {?} */ (node))).content;
          }
          else {
              return node;
          }
      }
      /**
       * @param {?} el
       * @return {?}
       */
      firstChild(el) { return el.firstChild; }
      /**
       * @param {?} el
       * @return {?}
       */
      nextSibling(el) { return el.nextSibling; }
      /**
       * @param {?} el
       * @return {?}
       */
      parentElement(el) { return el.parentNode; }
      /**
       * @param {?} el
       * @return {?}
       */
      childNodes(el) { return el.childNodes; }
      /**
       * @param {?} el
       * @return {?}
       */
      childNodesAsList(el) {
          /** @type {?} */
          const childNodes = el.childNodes;
          /** @type {?} */
          const res = new Array(childNodes.length);
          for (let i = 0; i < childNodes.length; i++) {
              res[i] = childNodes[i];
          }
          return res;
      }
      /**
       * @param {?} el
       * @return {?}
       */
      clearNodes(el) {
          while (el.firstChild) {
              el.removeChild(el.firstChild);
          }
      }
      /**
       * @param {?} el
       * @param {?} node
       * @return {?}
       */
      appendChild(el, node) { el.appendChild(node); }
      /**
       * @param {?} el
       * @param {?} node
       * @return {?}
       */
      removeChild(el, node) { el.removeChild(node); }
      /**
       * @param {?} el
       * @param {?} newChild
       * @param {?} oldChild
       * @return {?}
       */
      replaceChild(el, newChild, oldChild) { el.replaceChild(newChild, oldChild); }
      /**
       * @param {?} node
       * @return {?}
       */
      remove(node) {
          if (node.parentNode) {
              node.parentNode.removeChild(node);
          }
          return node;
      }
      /**
       * @param {?} parent
       * @param {?} ref
       * @param {?} node
       * @return {?}
       */
      insertBefore(parent, ref, node) { parent.insertBefore(node, ref); }
      /**
       * @param {?} parent
       * @param {?} ref
       * @param {?} nodes
       * @return {?}
       */
      insertAllBefore(parent, ref, nodes) {
          nodes.forEach((n) => parent.insertBefore(n, ref));
      }
      /**
       * @param {?} parent
       * @param {?} ref
       * @param {?} node
       * @return {?}
       */
      insertAfter(parent, ref, node) { parent.insertBefore(node, ref.nextSibling); }
      /**
       * @param {?} el
       * @param {?} value
       * @return {?}
       */
      setInnerHTML(el, value) { el.innerHTML = value; }
      /**
       * @param {?} el
       * @return {?}
       */
      getText(el) { return el.textContent; }
      /**
       * @param {?} el
       * @param {?} value
       * @return {?}
       */
      setText(el, value) { el.textContent = value; }
      /**
       * @param {?} el
       * @return {?}
       */
      getValue(el) { return el.value; }
      /**
       * @param {?} el
       * @param {?} value
       * @return {?}
       */
      setValue(el, value) { el.value = value; }
      /**
       * @param {?} el
       * @return {?}
       */
      getChecked(el) { return el.checked; }
      /**
       * @param {?} el
       * @param {?} value
       * @return {?}
       */
      setChecked(el, value) { el.checked = value; }
      /**
       * @param {?} text
       * @return {?}
       */
      createComment(text$$1) { return this.getDefaultDocument().createComment(text$$1); }
      /**
       * @param {?} html
       * @return {?}
       */
      createTemplate(html) {
          /** @type {?} */
          const t = this.getDefaultDocument().createElement('template');
          t.innerHTML = html;
          return t;
      }
      /**
       * @param {?} tagName
       * @param {?=} doc
       * @return {?}
       */
      createElement(tagName, doc) {
          doc = doc || this.getDefaultDocument();
          return doc.createElement(tagName);
      }
      /**
       * @param {?} ns
       * @param {?} tagName
       * @param {?=} doc
       * @return {?}
       */
      createElementNS(ns, tagName, doc) {
          doc = doc || this.getDefaultDocument();
          return doc.createElementNS(ns, tagName);
      }
      /**
       * @param {?} text
       * @param {?=} doc
       * @return {?}
       */
      createTextNode(text$$1, doc) {
          doc = doc || this.getDefaultDocument();
          return doc.createTextNode(text$$1);
      }
      /**
       * @param {?} attrName
       * @param {?} attrValue
       * @param {?=} doc
       * @return {?}
       */
      createScriptTag(attrName, attrValue, doc) {
          doc = doc || this.getDefaultDocument();
          /** @type {?} */
          const el = (/** @type {?} */ (doc.createElement('SCRIPT')));
          el.setAttribute(attrName, attrValue);
          return el;
      }
      /**
       * @param {?} css
       * @param {?=} doc
       * @return {?}
       */
      createStyleElement(css, doc) {
          doc = doc || this.getDefaultDocument();
          /** @type {?} */
          const style = (/** @type {?} */ (doc.createElement('style')));
          this.appendChild(style, this.createTextNode(css, doc));
          return style;
      }
      /**
       * @param {?} el
       * @return {?}
       */
      createShadowRoot(el) { return ((/** @type {?} */ (el))).createShadowRoot(); }
      /**
       * @param {?} el
       * @return {?}
       */
      getShadowRoot(el) { return ((/** @type {?} */ (el))).shadowRoot; }
      /**
       * @param {?} el
       * @return {?}
       */
      getHost(el) { return ((/** @type {?} */ (el))).host; }
      /**
       * @param {?} node
       * @return {?}
       */
      clone(node) { return node.cloneNode(true); }
      /**
       * @param {?} element
       * @param {?} name
       * @return {?}
       */
      getElementsByClassName(element$$1, name) {
          return element$$1.getElementsByClassName(name);
      }
      /**
       * @param {?} element
       * @param {?} name
       * @return {?}
       */
      getElementsByTagName(element$$1, name) {
          return element$$1.getElementsByTagName(name);
      }
      /**
       * @param {?} element
       * @return {?}
       */
      classList(element$$1) { return Array.prototype.slice.call(element$$1.classList, 0); }
      /**
       * @param {?} element
       * @param {?} className
       * @return {?}
       */
      addClass(element$$1, className) { element$$1.classList.add(className); }
      /**
       * @param {?} element
       * @param {?} className
       * @return {?}
       */
      removeClass(element$$1, className) { element$$1.classList.remove(className); }
      /**
       * @param {?} element
       * @param {?} className
       * @return {?}
       */
      hasClass(element$$1, className) {
          return element$$1.classList.contains(className);
      }
      /**
       * @param {?} element
       * @param {?} styleName
       * @param {?} styleValue
       * @return {?}
       */
      setStyle(element$$1, styleName, styleValue) {
          element$$1.style[styleName] = styleValue;
      }
      /**
       * @param {?} element
       * @param {?} stylename
       * @return {?}
       */
      removeStyle(element$$1, stylename) {
          // IE requires '' instead of null
          // see https://github.com/angular/angular/issues/7916
          element$$1.style[stylename] = '';
      }
      /**
       * @param {?} element
       * @param {?} stylename
       * @return {?}
       */
      getStyle(element$$1, stylename) { return element$$1.style[stylename]; }
      /**
       * @param {?} element
       * @param {?} styleName
       * @param {?=} styleValue
       * @return {?}
       */
      hasStyle(element$$1, styleName, styleValue) {
          /** @type {?} */
          const value = this.getStyle(element$$1, styleName) || '';
          return styleValue ? value == styleValue : value.length > 0;
      }
      /**
       * @param {?} element
       * @return {?}
       */
      tagName(element$$1) { return element$$1.tagName; }
      /**
       * @param {?} element
       * @return {?}
       */
      attributeMap(element$$1) {
          /** @type {?} */
          const res = new Map();
          /** @type {?} */
          const elAttrs = element$$1.attributes;
          for (let i = 0; i < elAttrs.length; i++) {
              /** @type {?} */
              const attrib = elAttrs.item(i);
              res.set(attrib.name, attrib.value);
          }
          return res;
      }
      /**
       * @param {?} element
       * @param {?} attribute
       * @return {?}
       */
      hasAttribute(element$$1, attribute) {
          return element$$1.hasAttribute(attribute);
      }
      /**
       * @param {?} element
       * @param {?} ns
       * @param {?} attribute
       * @return {?}
       */
      hasAttributeNS(element$$1, ns, attribute) {
          return element$$1.hasAttributeNS(ns, attribute);
      }
      /**
       * @param {?} element
       * @param {?} attribute
       * @return {?}
       */
      getAttribute(element$$1, attribute) {
          return element$$1.getAttribute(attribute);
      }
      /**
       * @param {?} element
       * @param {?} ns
       * @param {?} name
       * @return {?}
       */
      getAttributeNS(element$$1, ns, name) {
          return element$$1.getAttributeNS(ns, name);
      }
      /**
       * @param {?} element
       * @param {?} name
       * @param {?} value
       * @return {?}
       */
      setAttribute(element$$1, name, value) { element$$1.setAttribute(name, value); }
      /**
       * @param {?} element
       * @param {?} ns
       * @param {?} name
       * @param {?} value
       * @return {?}
       */
      setAttributeNS(element$$1, ns, name, value) {
          element$$1.setAttributeNS(ns, name, value);
      }
      /**
       * @param {?} element
       * @param {?} attribute
       * @return {?}
       */
      removeAttribute(element$$1, attribute) { element$$1.removeAttribute(attribute); }
      /**
       * @param {?} element
       * @param {?} ns
       * @param {?} name
       * @return {?}
       */
      removeAttributeNS(element$$1, ns, name) {
          element$$1.removeAttributeNS(ns, name);
      }
      /**
       * @param {?} el
       * @return {?}
       */
      templateAwareRoot(el) { return this.isTemplateElement(el) ? this.content(el) : el; }
      /**
       * @return {?}
       */
      createHtmlDocument() {
          return document.implementation.createHTMLDocument('fakeTitle');
      }
      /**
       * @return {?}
       */
      getDefaultDocument() { return document; }
      /**
       * @param {?} el
       * @return {?}
       */
      getBoundingClientRect(el) {
          try {
              return el.getBoundingClientRect();
          }
          catch (_a) {
              return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
          }
      }
      /**
       * @param {?} doc
       * @return {?}
       */
      getTitle(doc) { return doc.title; }
      /**
       * @param {?} doc
       * @param {?} newTitle
       * @return {?}
       */
      setTitle(doc, newTitle) { doc.title = newTitle || ''; }
      /**
       * @param {?} n
       * @param {?} selector
       * @return {?}
       */
      elementMatches(n, selector) {
          if (this.isElementNode(n)) {
              return n.matches && n.matches(selector) ||
                  n.msMatchesSelector && n.msMatchesSelector(selector) ||
                  n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
          }
          return false;
      }
      /**
       * @param {?} el
       * @return {?}
       */
      isTemplateElement(el) {
          return this.isElementNode(el) && el.nodeName === 'TEMPLATE';
      }
      /**
       * @param {?} node
       * @return {?}
       */
      isTextNode(node) { return node.nodeType === Node.TEXT_NODE; }
      /**
       * @param {?} node
       * @return {?}
       */
      isCommentNode(node) { return node.nodeType === Node.COMMENT_NODE; }
      /**
       * @param {?} node
       * @return {?}
       */
      isElementNode(node) { return node.nodeType === Node.ELEMENT_NODE; }
      /**
       * @param {?} node
       * @return {?}
       */
      hasShadowRoot(node) {
          return node.shadowRoot != null && node instanceof HTMLElement;
      }
      /**
       * @param {?} node
       * @return {?}
       */
      isShadowRoot(node) { return node instanceof DocumentFragment; }
      /**
       * @param {?} node
       * @return {?}
       */
      importIntoDoc(node) { return document.importNode(this.templateAwareRoot(node), true); }
      /**
       * @param {?} node
       * @return {?}
       */
      adoptNode(node) { return document.adoptNode(node); }
      /**
       * @param {?} el
       * @return {?}
       */
      getHref(el) { return (/** @type {?} */ (el.getAttribute('href'))); }
      /**
       * @param {?} event
       * @return {?}
       */
      getEventKey(event) {
          /** @type {?} */
          let key = event.key;
          if (key == null) {
              key = event.keyIdentifier;
              // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
              // Safari cf
              // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
              if (key == null) {
                  return 'Unidentified';
              }
              if (key.startsWith('U+')) {
                  key = String.fromCharCode(parseInt(key.substring(2), 16));
                  if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
                      // There is a bug in Chrome for numeric keypad keys:
                      // https://code.google.com/p/chromium/issues/detail?id=155654
                      // 1, 2, 3 ... are reported as A, B, C ...
                      key = ((/** @type {?} */ (_chromeNumKeyPadMap)))[key];
                  }
              }
          }
          return _keyMap[key] || key;
      }
      /**
       * @param {?} doc
       * @param {?} target
       * @return {?}
       */
      getGlobalEventTarget(doc, target) {
          if (target === 'window') {
              return window;
          }
          if (target === 'document') {
              return doc;
          }
          if (target === 'body') {
              return doc.body;
          }
          return null;
      }
      /**
       * @return {?}
       */
      getHistory() { return window.history; }
      /**
       * @return {?}
       */
      getLocation() { return window.location; }
      /**
       * @param {?} doc
       * @return {?}
       */
      getBaseHref(doc) {
          /** @type {?} */
          const href = getBaseElementHref();
          return href == null ? null : relativePath(href);
      }
      /**
       * @return {?}
       */
      resetBaseElement() { baseElement = null; }
      /**
       * @return {?}
       */
      getUserAgent() { return window.navigator.userAgent; }
      /**
       * @param {?} element
       * @param {?} name
       * @param {?} value
       * @return {?}
       */
      setData(element$$1, name, value) {
          this.setAttribute(element$$1, 'data-' + name, value);
      }
      /**
       * @param {?} element
       * @param {?} name
       * @return {?}
       */
      getData(element$$1, name) {
          return this.getAttribute(element$$1, 'data-' + name);
      }
      /**
       * @param {?} element
       * @return {?}
       */
      getComputedStyle(element$$1) { return getComputedStyle(element$$1); }
      // TODO(tbosch): move this into a separate environment class once we have it
      /**
       * @return {?}
       */
      supportsWebAnimation() {
          return typeof ((/** @type {?} */ (Element))).prototype['animate'] === 'function';
      }
      /**
       * @return {?}
       */
      performanceNow() {
          // performance.now() is not available in all browsers, see
          // http://caniuse.com/#search=performance.now
          return window.performance && window.performance.now ? window.performance.now() :
              new Date().getTime();
      }
      /**
       * @return {?}
       */
      supportsCookies() { return true; }
      /**
       * @param {?} name
       * @return {?}
       */
      getCookie(name) { return parseCookieValue(document.cookie, name); }
      /**
       * @param {?} name
       * @param {?} value
       * @return {?}
       */
      setCookie(name, value) {
          // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
          // not clear other cookies.
          document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
      }
  }
  /** @type {?} */
  let baseElement = null;
  /**
   * @return {?}
   */
  function getBaseElementHref() {
      if (!baseElement) {
          baseElement = (/** @type {?} */ (document.querySelector('base')));
          if (!baseElement) {
              return null;
          }
      }
      return baseElement.getAttribute('href');
  }
  // based on urlUtils.js in AngularJS 1
  /** @type {?} */
  let urlParsingNode;
  /**
   * @param {?} url
   * @return {?}
   */
  function relativePath(url) {
      if (!urlParsingNode) {
          urlParsingNode = document.createElement('a');
      }
      urlParsingNode.setAttribute('href', url);
      return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
          '/' + urlParsingNode.pathname;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A DI Token representing the main rendering context. In a browser this is the DOM Document.
   *
   * Note: Document might not be available in the Application Context when Application and Rendering
   * Contexts are not the same (e.g. when running the application into a Web Worker).
   *
   * @deprecated import from `\@angular/common` instead.
   * \@publicApi
   * @type {?}
   */
  const DOCUMENT$1 = DOCUMENT;

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  /**
   * @return {?}
   */
  function supportsState() {
      return !!window.history.pushState;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
   * This class should not be used directly by an application developer. Instead, use
   * {\@link Location}.
   */
  class BrowserPlatformLocation extends PlatformLocation {
      /**
       * @param {?} _doc
       */
      constructor(_doc) {
          super();
          this._doc = _doc;
          this._init();
      }
      // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it
      /**
       * \@internal
       * @return {?}
       */
      _init() {
          ((/** @type {?} */ (this))).location = getDOM().getLocation();
          this._history = getDOM().getHistory();
      }
      /**
       * @return {?}
       */
      getBaseHrefFromDOM() { return (/** @type {?} */ (getDOM().getBaseHref(this._doc))); }
      /**
       * @param {?} fn
       * @return {?}
       */
      onPopState(fn) {
          getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);
      }
      /**
       * @param {?} fn
       * @return {?}
       */
      onHashChange(fn) {
          getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);
      }
      /**
       * @return {?}
       */
      get pathname() { return this.location.pathname; }
      /**
       * @return {?}
       */
      get search() { return this.location.search; }
      /**
       * @return {?}
       */
      get hash() { return this.location.hash; }
      /**
       * @param {?} newPath
       * @return {?}
       */
      set pathname(newPath) { this.location.pathname = newPath; }
      /**
       * @param {?} state
       * @param {?} title
       * @param {?} url
       * @return {?}
       */
      pushState(state, title, url) {
          if (supportsState()) {
              this._history.pushState(state, title, url);
          }
          else {
              this.location.hash = url;
          }
      }
      /**
       * @param {?} state
       * @param {?} title
       * @param {?} url
       * @return {?}
       */
      replaceState(state, title, url) {
          if (supportsState()) {
              this._history.replaceState(state, title, url);
          }
          else {
              this.location.hash = url;
          }
      }
      /**
       * @return {?}
       */
      forward() { this._history.forward(); }
      /**
       * @return {?}
       */
      back() { this._history.back(); }
  }
  BrowserPlatformLocation.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  BrowserPlatformLocation.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * An id that identifies a particular application being bootstrapped, that should
   * match across the client/server boundary.
   * @type {?}
   */
  const TRANSITION_ID = new InjectionToken('TRANSITION_ID');
  /**
   * @param {?} transitionId
   * @param {?} document
   * @param {?} injector
   * @return {?}
   */
  function appInitializerFactory(transitionId, document, injector) {
      return () => {
          // Wait for all application initializers to be completed before removing the styles set by
          // the server.
          injector.get(ApplicationInitStatus).donePromise.then(() => {
              /** @type {?} */
              const dom = getDOM();
              /** @type {?} */
              const styles = Array.prototype.slice.apply(dom.querySelectorAll(document, `style[ng-transition]`));
              styles.filter(el => dom.getAttribute(el, 'ng-transition') === transitionId)
                  .forEach(el => dom.remove(el));
          });
      };
  }
  /** @type {?} */
  const SERVER_TRANSITION_PROVIDERS = [
      {
          provide: APP_INITIALIZER,
          useFactory: appInitializerFactory,
          deps: [TRANSITION_ID, DOCUMENT$1, Injector],
          multi: true
      },
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class BrowserGetTestability {
      /**
       * @return {?}
       */
      static init() { setTestabilityGetter(new BrowserGetTestability()); }
      /**
       * @param {?} registry
       * @return {?}
       */
      addToWindow(registry) {
          _global$1['getAngularTestability'] = (elem, findInAncestors = true) => {
              /** @type {?} */
              const testability = registry.findTestabilityInTree(elem, findInAncestors);
              if (testability == null) {
                  throw new Error('Could not find testability for element.');
              }
              return testability;
          };
          _global$1['getAllAngularTestabilities'] = () => registry.getAllTestabilities();
          _global$1['getAllAngularRootElements'] = () => registry.getAllRootElements();
          /** @type {?} */
          const whenAllStable = (callback /** TODO #9100 */) => {
              /** @type {?} */
              const testabilities = _global$1['getAllAngularTestabilities']();
              /** @type {?} */
              let count = testabilities.length;
              /** @type {?} */
              let didWork = false;
              /** @type {?} */
              const decrement = function (didWork_ /** TODO #9100 */) {
                  didWork = didWork || didWork_;
                  count--;
                  if (count == 0) {
                      callback(didWork);
                  }
              };
              testabilities.forEach(function (testability /** TODO #9100 */) {
                  testability.whenStable(decrement);
              });
          };
          if (!_global$1['frameworkStabilizers']) {
              _global$1['frameworkStabilizers'] = [];
          }
          _global$1['frameworkStabilizers'].push(whenAllStable);
      }
      /**
       * @param {?} registry
       * @param {?} elem
       * @param {?} findInAncestors
       * @return {?}
       */
      findTestabilityInTree(registry, elem, findInAncestors) {
          if (elem == null) {
              return null;
          }
          /** @type {?} */
          const t = registry.getTestability(elem);
          if (t != null) {
              return t;
          }
          else if (!findInAncestors) {
              return null;
          }
          if (getDOM().isShadowRoot(elem)) {
              return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
          }
          return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if
   * `name` is `'probe'`.
   * @param {?} name Name under which it will be exported. Keep in mind this will be a property of the
   * global `ng` object.
   * @param {?} value The value to export.
   * @return {?}
   */
  function exportNgVar(name, value) {
      if (typeof COMPILED === 'undefined' || !COMPILED) {
          // Note: we can't export `ng` when using closure enhanced optimization as:
          // - closure declares globals itself for minified names, which sometimes clobber our `ng` global
          // - we can't declare a closure extern as the namespace `ng` is already used within Google
          //   for typings for angularJS (via `goog.provide('ng....')`).
          /** @type {?} */
          const ng = _global$1['ng'] = ((/** @type {?} */ (_global$1['ng']))) || {};
          ng[name] = value;
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const CORE_TOKENS = {
      'ApplicationRef': ApplicationRef,
      'NgZone': NgZone,
  };
  /** @type {?} */
  const INSPECT_GLOBAL_NAME = 'probe';
  /** @type {?} */
  const CORE_TOKENS_GLOBAL_NAME = 'coreTokens';
  /**
   * Returns a {\@link DebugElement} for the given native DOM element, or
   * null if the given native element does not have an Angular view associated
   * with it.
   * @param {?} element
   * @return {?}
   */
  function inspectNativeElement(element$$1) {
      return getDebugNode(element$$1);
  }
  /**
   * @param {?} coreTokens
   * @return {?}
   */
  function _createNgProbe(coreTokens) {
      exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
      exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign({}, CORE_TOKENS, _ngProbeTokensToMap(coreTokens || [])));
      return () => inspectNativeElement;
  }
  /**
   * @param {?} tokens
   * @return {?}
   */
  function _ngProbeTokensToMap(tokens) {
      return tokens.reduce((prev, t) => (prev[t.name] = t.token, prev), {});
  }
  /**
   * Providers which support debugging Angular applications (e.g. via `ng.probe`).
   * @type {?}
   */
  const ELEMENT_PROBE_PROVIDERS = [
      {
          provide: APP_INITIALIZER,
          useFactory: _createNgProbe,
          deps: [
              [NgProbeToken, new Optional()],
          ],
          multi: true,
      },
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * The injection token for the event-manager plug-in service.
   *
   * \@publicApi
   * @type {?}
   */
  const EVENT_MANAGER_PLUGINS = new InjectionToken('EventManagerPlugins');
  /**
   * An injectable service that provides event management for Angular
   * through a browser plug-in.
   *
   * \@publicApi
   */
  class EventManager {
      /**
       * Initializes an instance of the event-manager service.
       * @param {?} plugins
       * @param {?} _zone
       */
      constructor(plugins, _zone) {
          this._zone = _zone;
          this._eventNameToPlugin = new Map();
          plugins.forEach(p => p.manager = this);
          this._plugins = plugins.slice().reverse();
      }
      /**
       * Registers a handler for a specific element and event.
       *
       * @param {?} element The HTML element to receive event notifications.
       * @param {?} eventName The name of the event to listen for.
       * @param {?} handler A function to call when the notification occurs. Receives the
       * event object as an argument.
       * @return {?} A callback function that can be used to remove the handler.
       */
      addEventListener(element$$1, eventName, handler) {
          /** @type {?} */
          const plugin = this._findPluginFor(eventName);
          return plugin.addEventListener(element$$1, eventName, handler);
      }
      /**
       * Registers a global handler for an event in a target view.
       *
       * @param {?} target A target for global event notifications. One of "window", "document", or "body".
       * @param {?} eventName The name of the event to listen for.
       * @param {?} handler A function to call when the notification occurs. Receives the
       * event object as an argument.
       * @return {?} A callback function that can be used to remove the handler.
       */
      addGlobalEventListener(target, eventName, handler) {
          /** @type {?} */
          const plugin = this._findPluginFor(eventName);
          return plugin.addGlobalEventListener(target, eventName, handler);
      }
      /**
       * Retrieves the compilation zone in which event listeners are registered.
       * @return {?}
       */
      getZone() { return this._zone; }
      /**
       * \@internal
       * @param {?} eventName
       * @return {?}
       */
      _findPluginFor(eventName) {
          /** @type {?} */
          const plugin = this._eventNameToPlugin.get(eventName);
          if (plugin) {
              return plugin;
          }
          /** @type {?} */
          const plugins = this._plugins;
          for (let i = 0; i < plugins.length; i++) {
              /** @type {?} */
              const plugin = plugins[i];
              if (plugin.supports(eventName)) {
                  this._eventNameToPlugin.set(eventName, plugin);
                  return plugin;
              }
          }
          throw new Error(`No event manager plugin found for event ${eventName}`);
      }
  }
  EventManager.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  EventManager.ctorParameters = () => [
      { type: Array, decorators: [{ type: Inject, args: [EVENT_MANAGER_PLUGINS,] }] },
      { type: NgZone }
  ];
  /**
   * @abstract
   */
  class EventManagerPlugin {
      /**
       * @param {?} _doc
       */
      constructor(_doc) {
          this._doc = _doc;
      }
      /**
       * @param {?} element
       * @param {?} eventName
       * @param {?} handler
       * @return {?}
       */
      addGlobalEventListener(element$$1, eventName, handler) {
          /** @type {?} */
          const target = getDOM().getGlobalEventTarget(this._doc, element$$1);
          if (!target) {
              throw new Error(`Unsupported event target ${target} for event ${eventName}`);
          }
          return this.addEventListener(target, eventName, handler);
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class SharedStylesHost {
      constructor() {
          /**
           * \@internal
           */
          this._stylesSet = new Set();
      }
      /**
       * @param {?} styles
       * @return {?}
       */
      addStyles(styles) {
          /** @type {?} */
          const additions = new Set();
          styles.forEach(style => {
              if (!this._stylesSet.has(style)) {
                  this._stylesSet.add(style);
                  additions.add(style);
              }
          });
          this.onStylesAdded(additions);
      }
      /**
       * @param {?} additions
       * @return {?}
       */
      onStylesAdded(additions) { }
      /**
       * @return {?}
       */
      getAllStyles() { return Array.from(this._stylesSet); }
  }
  SharedStylesHost.decorators = [
      { type: Injectable }
  ];
  class DomSharedStylesHost extends SharedStylesHost {
      /**
       * @param {?} _doc
       */
      constructor(_doc) {
          super();
          this._doc = _doc;
          this._hostNodes = new Set();
          this._styleNodes = new Set();
          this._hostNodes.add(_doc.head);
      }
      /**
       * @private
       * @param {?} styles
       * @param {?} host
       * @return {?}
       */
      _addStylesToHost(styles, host) {
          styles.forEach((style) => {
              /** @type {?} */
              const styleEl = this._doc.createElement('style');
              styleEl.textContent = style;
              this._styleNodes.add(host.appendChild(styleEl));
          });
      }
      /**
       * @param {?} hostNode
       * @return {?}
       */
      addHost(hostNode) {
          this._addStylesToHost(this._stylesSet, hostNode);
          this._hostNodes.add(hostNode);
      }
      /**
       * @param {?} hostNode
       * @return {?}
       */
      removeHost(hostNode) { this._hostNodes.delete(hostNode); }
      /**
       * @param {?} additions
       * @return {?}
       */
      onStylesAdded(additions) {
          this._hostNodes.forEach(hostNode => this._addStylesToHost(additions, hostNode));
      }
      /**
       * @return {?}
       */
      ngOnDestroy() { this._styleNodes.forEach(styleNode => getDOM().remove(styleNode)); }
  }
  DomSharedStylesHost.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  DomSharedStylesHost.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const NAMESPACE_URIS = {
      'svg': 'http://www.w3.org/2000/svg',
      'xhtml': 'http://www.w3.org/1999/xhtml',
      'xlink': 'http://www.w3.org/1999/xlink',
      'xml': 'http://www.w3.org/XML/1998/namespace',
      'xmlns': 'http://www.w3.org/2000/xmlns/',
  };
  /** @type {?} */
  const COMPONENT_REGEX = /%COMP%/g;
  /** @type {?} */
  const COMPONENT_VARIABLE$1 = '%COMP%';
  /** @type {?} */
  const HOST_ATTR$1 = `_nghost-${COMPONENT_VARIABLE$1}`;
  /** @type {?} */
  const CONTENT_ATTR$1 = `_ngcontent-${COMPONENT_VARIABLE$1}`;
  /**
   * @param {?} componentShortId
   * @return {?}
   */
  function shimContentAttribute(componentShortId) {
      return CONTENT_ATTR$1.replace(COMPONENT_REGEX, componentShortId);
  }
  /**
   * @param {?} componentShortId
   * @return {?}
   */
  function shimHostAttribute(componentShortId) {
      return HOST_ATTR$1.replace(COMPONENT_REGEX, componentShortId);
  }
  /**
   * @param {?} compId
   * @param {?} styles
   * @param {?} target
   * @return {?}
   */
  function flattenStyles(compId, styles, target) {
      for (let i = 0; i < styles.length; i++) {
          /** @type {?} */
          let style = styles[i];
          if (Array.isArray(style)) {
              flattenStyles(compId, style, target);
          }
          else {
              style = style.replace(COMPONENT_REGEX, compId);
              target.push(style);
          }
      }
      return target;
  }
  /**
   * @param {?} eventHandler
   * @return {?}
   */
  function decoratePreventDefault(eventHandler) {
      return (event) => {
          /** @type {?} */
          const allowDefaultBehavior = eventHandler(event);
          if (allowDefaultBehavior === false) {
              // TODO(tbosch): move preventDefault into event plugins...
              event.preventDefault();
              event.returnValue = false;
          }
      };
  }
  class DomRendererFactory2 {
      /**
       * @param {?} eventManager
       * @param {?} sharedStylesHost
       */
      constructor(eventManager, sharedStylesHost) {
          this.eventManager = eventManager;
          this.sharedStylesHost = sharedStylesHost;
          this.rendererByCompId = new Map();
          this.defaultRenderer = new DefaultDomRenderer2(eventManager);
      }
      /**
       * @param {?} element
       * @param {?} type
       * @return {?}
       */
      createRenderer(element$$1, type) {
          if (!element$$1 || !type) {
              return this.defaultRenderer;
          }
          switch (type.encapsulation) {
              case ViewEncapsulation$1.Emulated: {
                  /** @type {?} */
                  let renderer = this.rendererByCompId.get(type.id);
                  if (!renderer) {
                      renderer =
                          new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type);
                      this.rendererByCompId.set(type.id, renderer);
                  }
                  ((/** @type {?} */ (renderer))).applyToHost(element$$1);
                  return renderer;
              }
              case ViewEncapsulation$1.Native:
              case ViewEncapsulation$1.ShadowDom:
                  return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element$$1, type);
              default: {
                  if (!this.rendererByCompId.has(type.id)) {
                      /** @type {?} */
                      const styles = flattenStyles(type.id, type.styles, []);
                      this.sharedStylesHost.addStyles(styles);
                      this.rendererByCompId.set(type.id, this.defaultRenderer);
                  }
                  return this.defaultRenderer;
              }
          }
      }
      /**
       * @return {?}
       */
      begin() { }
      /**
       * @return {?}
       */
      end() { }
  }
  DomRendererFactory2.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  DomRendererFactory2.ctorParameters = () => [
      { type: EventManager },
      { type: DomSharedStylesHost }
  ];
  class DefaultDomRenderer2 {
      /**
       * @param {?} eventManager
       */
      constructor(eventManager) {
          this.eventManager = eventManager;
          this.data = Object.create(null);
      }
      /**
       * @return {?}
       */
      destroy() { }
      /**
       * @param {?} name
       * @param {?=} namespace
       * @return {?}
       */
      createElement(name, namespace) {
          if (namespace) {
              return document.createElementNS(NAMESPACE_URIS[namespace], name);
          }
          return document.createElement(name);
      }
      /**
       * @param {?} value
       * @return {?}
       */
      createComment(value) { return document.createComment(value); }
      /**
       * @param {?} value
       * @return {?}
       */
      createText(value) { return document.createTextNode(value); }
      /**
       * @param {?} parent
       * @param {?} newChild
       * @return {?}
       */
      appendChild(parent, newChild) { parent.appendChild(newChild); }
      /**
       * @param {?} parent
       * @param {?} newChild
       * @param {?} refChild
       * @return {?}
       */
      insertBefore(parent, newChild, refChild) {
          if (parent) {
              parent.insertBefore(newChild, refChild);
          }
      }
      /**
       * @param {?} parent
       * @param {?} oldChild
       * @return {?}
       */
      removeChild(parent, oldChild) {
          if (parent) {
              parent.removeChild(oldChild);
          }
      }
      /**
       * @param {?} selectorOrNode
       * @param {?=} preserveContent
       * @return {?}
       */
      selectRootElement(selectorOrNode, preserveContent) {
          /** @type {?} */
          let el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) :
              selectorOrNode;
          if (!el) {
              throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
          }
          if (!preserveContent) {
              el.textContent = '';
          }
          return el;
      }
      /**
       * @param {?} node
       * @return {?}
       */
      parentNode(node) { return node.parentNode; }
      /**
       * @param {?} node
       * @return {?}
       */
      nextSibling(node) { return node.nextSibling; }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?} value
       * @param {?=} namespace
       * @return {?}
       */
      setAttribute(el, name, value, namespace) {
          if (namespace) {
              name = `${namespace}:${name}`;
              /** @type {?} */
              const namespaceUri = NAMESPACE_URIS[namespace];
              if (namespaceUri) {
                  el.setAttributeNS(namespaceUri, name, value);
              }
              else {
                  el.setAttribute(name, value);
              }
          }
          else {
              el.setAttribute(name, value);
          }
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?=} namespace
       * @return {?}
       */
      removeAttribute(el, name, namespace) {
          if (namespace) {
              /** @type {?} */
              const namespaceUri = NAMESPACE_URIS[namespace];
              if (namespaceUri) {
                  el.removeAttributeNS(namespaceUri, name);
              }
              else {
                  el.removeAttribute(`${namespace}:${name}`);
              }
          }
          else {
              el.removeAttribute(name);
          }
      }
      /**
       * @param {?} el
       * @param {?} name
       * @return {?}
       */
      addClass(el, name) { el.classList.add(name); }
      /**
       * @param {?} el
       * @param {?} name
       * @return {?}
       */
      removeClass(el, name) { el.classList.remove(name); }
      /**
       * @param {?} el
       * @param {?} style
       * @param {?} value
       * @param {?} flags
       * @return {?}
       */
      setStyle(el, style, value, flags) {
          if (flags & RendererStyleFlags2.DashCase) {
              el.style.setProperty(style, value, !!(flags & RendererStyleFlags2.Important) ? 'important' : '');
          }
          else {
              el.style[style] = value;
          }
      }
      /**
       * @param {?} el
       * @param {?} style
       * @param {?} flags
       * @return {?}
       */
      removeStyle(el, style, flags) {
          if (flags & RendererStyleFlags2.DashCase) {
              el.style.removeProperty(style);
          }
          else {
              // IE requires '' instead of null
              // see https://github.com/angular/angular/issues/7916
              el.style[style] = '';
          }
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?} value
       * @return {?}
       */
      setProperty(el, name, value) {
          checkNoSyntheticProp(name, 'property');
          el[name] = value;
      }
      /**
       * @param {?} node
       * @param {?} value
       * @return {?}
       */
      setValue(node, value) { node.nodeValue = value; }
      /**
       * @param {?} target
       * @param {?} event
       * @param {?} callback
       * @return {?}
       */
      listen(target, event, callback) {
          checkNoSyntheticProp(event, 'listener');
          if (typeof target === 'string') {
              return (/** @type {?} */ (this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback))));
          }
          return (/** @type {?} */ ((/** @type {?} */ (this.eventManager.addEventListener(target, event, decoratePreventDefault(callback))))));
      }
  }
  /** @type {?} */
  const AT_CHARCODE = '@'.charCodeAt(0);
  /**
   * @param {?} name
   * @param {?} nameKind
   * @return {?}
   */
  function checkNoSyntheticProp(name, nameKind) {
      if (name.charCodeAt(0) === AT_CHARCODE) {
          throw new Error(`Found the synthetic ${nameKind} ${name}. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.`);
      }
  }
  class EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {
      /**
       * @param {?} eventManager
       * @param {?} sharedStylesHost
       * @param {?} component
       */
      constructor(eventManager, sharedStylesHost, component) {
          super(eventManager);
          this.component = component;
          /** @type {?} */
          const styles = flattenStyles(component.id, component.styles, []);
          sharedStylesHost.addStyles(styles);
          this.contentAttr = shimContentAttribute(component.id);
          this.hostAttr = shimHostAttribute(component.id);
      }
      /**
       * @param {?} element
       * @return {?}
       */
      applyToHost(element$$1) { super.setAttribute(element$$1, this.hostAttr, ''); }
      /**
       * @param {?} parent
       * @param {?} name
       * @return {?}
       */
      createElement(parent, name) {
          /** @type {?} */
          const el = super.createElement(parent, name);
          super.setAttribute(el, this.contentAttr, '');
          return el;
      }
  }
  class ShadowDomRenderer extends DefaultDomRenderer2 {
      /**
       * @param {?} eventManager
       * @param {?} sharedStylesHost
       * @param {?} hostEl
       * @param {?} component
       */
      constructor(eventManager, sharedStylesHost, hostEl, component) {
          super(eventManager);
          this.sharedStylesHost = sharedStylesHost;
          this.hostEl = hostEl;
          this.component = component;
          if (component.encapsulation === ViewEncapsulation$1.ShadowDom) {
              this.shadowRoot = ((/** @type {?} */ (hostEl))).attachShadow({ mode: 'open' });
          }
          else {
              this.shadowRoot = ((/** @type {?} */ (hostEl))).createShadowRoot();
          }
          this.sharedStylesHost.addHost(this.shadowRoot);
          /** @type {?} */
          const styles = flattenStyles(component.id, component.styles, []);
          for (let i = 0; i < styles.length; i++) {
              /** @type {?} */
              const styleEl = document.createElement('style');
              styleEl.textContent = styles[i];
              this.shadowRoot.appendChild(styleEl);
          }
      }
      /**
       * @private
       * @param {?} node
       * @return {?}
       */
      nodeOrShadowRoot(node) { return node === this.hostEl ? this.shadowRoot : node; }
      /**
       * @return {?}
       */
      destroy() { this.sharedStylesHost.removeHost(this.shadowRoot); }
      /**
       * @param {?} parent
       * @param {?} newChild
       * @return {?}
       */
      appendChild(parent, newChild) {
          return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
      }
      /**
       * @param {?} parent
       * @param {?} newChild
       * @param {?} refChild
       * @return {?}
       */
      insertBefore(parent, newChild, refChild) {
          return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
      }
      /**
       * @param {?} parent
       * @param {?} oldChild
       * @return {?}
       */
      removeChild(parent, oldChild) {
          return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);
      }
      /**
       * @param {?} node
       * @return {?}
       */
      parentNode(node) {
          return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  const ɵ0$1 = function (v) {
      return '__zone_symbol__' + v;
  };
  /**
   * Detect if Zone is present. If it is then use simple zone aware 'addEventListener'
   * since Angular can do much more
   * efficient bookkeeping than Zone can, because we have additional information. This speeds up
   * addEventListener by 3x.
   * @type {?}
   */
  const __symbol__ = (typeof Zone !== 'undefined') && ((/** @type {?} */ (Zone)))['__symbol__'] || ɵ0$1;
  /** @type {?} */
  const ADD_EVENT_LISTENER = __symbol__('addEventListener');
  /** @type {?} */
  const REMOVE_EVENT_LISTENER = __symbol__('removeEventListener');
  /** @type {?} */
  const symbolNames = {};
  /** @type {?} */
  const FALSE = 'FALSE';
  /** @type {?} */
  const ANGULAR = 'ANGULAR';
  /** @type {?} */
  const NATIVE_ADD_LISTENER = 'addEventListener';
  /** @type {?} */
  const NATIVE_REMOVE_LISTENER = 'removeEventListener';
  // use the same symbol string which is used in zone.js
  /** @type {?} */
  const stopSymbol = '__zone_symbol__propagationStopped';
  /** @type {?} */
  const stopMethodSymbol = '__zone_symbol__stopImmediatePropagation';
  /** @type {?} */
  const blackListedEvents = (typeof Zone !== 'undefined') && ((/** @type {?} */ (Zone)))[__symbol__('BLACK_LISTED_EVENTS')];
  /** @type {?} */
  let blackListedMap;
  if (blackListedEvents) {
      blackListedMap = {};
      blackListedEvents.forEach(eventName => { blackListedMap[eventName] = eventName; });
  }
  /** @type {?} */
  const isBlackListedEvent = function (eventName) {
      if (!blackListedMap) {
          return false;
      }
      return blackListedMap.hasOwnProperty(eventName);
  };
  // a global listener to handle all dom event,
  // so we do not need to create a closure every time
  /** @type {?} */
  const globalListener = function (event) {
      /** @type {?} */
      const symbolName = symbolNames[event.type];
      if (!symbolName) {
          return;
      }
      /** @type {?} */
      const taskDatas = this[symbolName];
      if (!taskDatas) {
          return;
      }
      /** @type {?} */
      const args = [event];
      if (taskDatas.length === 1) {
          // if taskDatas only have one element, just invoke it
          /** @type {?} */
          const taskData = taskDatas[0];
          if (taskData.zone !== Zone.current) {
              // only use Zone.run when Zone.current not equals to stored zone
              return taskData.zone.run(taskData.handler, this, args);
          }
          else {
              return taskData.handler.apply(this, args);
          }
      }
      else {
          // copy tasks as a snapshot to avoid event handlers remove
          // itself or others
          /** @type {?} */
          const copiedTasks = taskDatas.slice();
          for (let i = 0; i < copiedTasks.length; i++) {
              // if other listener call event.stopImmediatePropagation
              // just break
              if (((/** @type {?} */ (event)))[stopSymbol] === true) {
                  break;
              }
              /** @type {?} */
              const taskData = copiedTasks[i];
              if (taskData.zone !== Zone.current) {
                  // only use Zone.run when Zone.current not equals to stored zone
                  taskData.zone.run(taskData.handler, this, args);
              }
              else {
                  taskData.handler.apply(this, args);
              }
          }
      }
  };
  class DomEventsPlugin extends EventManagerPlugin {
      /**
       * @param {?} doc
       * @param {?} ngZone
       * @param {?} platformId
       */
      constructor(doc, ngZone, platformId) {
          super(doc);
          this.ngZone = ngZone;
          if (!platformId || !isPlatformServer(platformId)) {
              this.patchEvent();
          }
      }
      /**
       * @private
       * @return {?}
       */
      patchEvent() {
          if (typeof Event === 'undefined' || !Event || !Event.prototype) {
              return;
          }
          if (((/** @type {?} */ (Event.prototype)))[stopMethodSymbol]) {
              // already patched by zone.js
              return;
          }
          /** @type {?} */
          const delegate = ((/** @type {?} */ (Event.prototype)))[stopMethodSymbol] =
              Event.prototype.stopImmediatePropagation;
          Event.prototype.stopImmediatePropagation = function () {
              if (this) {
                  this[stopSymbol] = true;
              }
              // should call native delegate in case
              // in some environment part of the application
              // will not use the patched Event
              delegate && delegate.apply(this, arguments);
          };
      }
      // This plugin should come last in the list of plugins, because it accepts all
      // events.
      /**
       * @param {?} eventName
       * @return {?}
       */
      supports(eventName) { return true; }
      /**
       * @param {?} element
       * @param {?} eventName
       * @param {?} handler
       * @return {?}
       */
      addEventListener(element$$1, eventName, handler) {
          /** @type {?} */
          const zoneJsLoaded = element$$1[ADD_EVENT_LISTENER];
          /** @type {?} */
          let callback = (/** @type {?} */ (handler));
          // if zonejs is loaded and current zone is not ngZone
          // we keep Zone.current on target for later restoration.
          if (zoneJsLoaded && (!NgZone.isInAngularZone() || isBlackListedEvent(eventName))) {
              /** @type {?} */
              let symbolName = symbolNames[eventName];
              if (!symbolName) {
                  symbolName = symbolNames[eventName] = __symbol__(ANGULAR + eventName + FALSE);
              }
              /** @type {?} */
              let taskDatas = ((/** @type {?} */ (element$$1)))[symbolName];
              /** @type {?} */
              const globalListenerRegistered = taskDatas && taskDatas.length > 0;
              if (!taskDatas) {
                  taskDatas = ((/** @type {?} */ (element$$1)))[symbolName] = [];
              }
              /** @type {?} */
              const zone = isBlackListedEvent(eventName) ? Zone.root : Zone.current;
              if (taskDatas.length === 0) {
                  taskDatas.push({ zone: zone, handler: callback });
              }
              else {
                  /** @type {?} */
                  let callbackRegistered = false;
                  for (let i = 0; i < taskDatas.length; i++) {
                      if (taskDatas[i].handler === callback) {
                          callbackRegistered = true;
                          break;
                      }
                  }
                  if (!callbackRegistered) {
                      taskDatas.push({ zone: zone, handler: callback });
                  }
              }
              if (!globalListenerRegistered) {
                  element$$1[ADD_EVENT_LISTENER](eventName, globalListener, false);
              }
          }
          else {
              element$$1[NATIVE_ADD_LISTENER](eventName, callback, false);
          }
          return () => this.removeEventListener(element$$1, eventName, callback);
      }
      /**
       * @param {?} target
       * @param {?} eventName
       * @param {?} callback
       * @return {?}
       */
      removeEventListener(target, eventName, callback) {
          /** @type {?} */
          let underlyingRemove = target[REMOVE_EVENT_LISTENER];
          // zone.js not loaded, use native removeEventListener
          if (!underlyingRemove) {
              return target[NATIVE_REMOVE_LISTENER].apply(target, [eventName, callback, false]);
          }
          /** @type {?} */
          let symbolName = symbolNames[eventName];
          /** @type {?} */
          let taskDatas = symbolName && target[symbolName];
          if (!taskDatas) {
              // addEventListener not using patched version
              // just call native removeEventListener
              return target[NATIVE_REMOVE_LISTENER].apply(target, [eventName, callback, false]);
          }
          // fix issue 20532, should be able to remove
          // listener which was added inside of ngZone
          /** @type {?} */
          let found = false;
          for (let i = 0; i < taskDatas.length; i++) {
              // remove listener from taskDatas if the callback equals
              if (taskDatas[i].handler === callback) {
                  found = true;
                  taskDatas.splice(i, 1);
                  break;
              }
          }
          if (found) {
              if (taskDatas.length === 0) {
                  // all listeners are removed, we can remove the globalListener from target
                  underlyingRemove.apply(target, [eventName, globalListener, false]);
              }
          }
          else {
              // not found in taskDatas, the callback may be added inside of ngZone
              // use native remove listener to remove the callback
              target[NATIVE_REMOVE_LISTENER].apply(target, [eventName, callback, false]);
          }
      }
  }
  DomEventsPlugin.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  DomEventsPlugin.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] }] },
      { type: NgZone },
      { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [PLATFORM_ID,] }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Supported HammerJS recognizer event names.
   * @type {?}
   */
  const EVENT_NAMES = {
      // pan
      'pan': true,
      'panstart': true,
      'panmove': true,
      'panend': true,
      'pancancel': true,
      'panleft': true,
      'panright': true,
      'panup': true,
      'pandown': true,
      // pinch
      'pinch': true,
      'pinchstart': true,
      'pinchmove': true,
      'pinchend': true,
      'pinchcancel': true,
      'pinchin': true,
      'pinchout': true,
      // press
      'press': true,
      'pressup': true,
      // rotate
      'rotate': true,
      'rotatestart': true,
      'rotatemove': true,
      'rotateend': true,
      'rotatecancel': true,
      // swipe
      'swipe': true,
      'swipeleft': true,
      'swiperight': true,
      'swipeup': true,
      'swipedown': true,
      // tap
      'tap': true,
  };
  /**
   * DI token for providing [HammerJS](http://hammerjs.github.io/) support to Angular.
   * @see `HammerGestureConfig`
   *
   * \@publicApi
   * @type {?}
   */
  const HAMMER_GESTURE_CONFIG = new InjectionToken('HammerGestureConfig');
  /**
   * Injection token used to provide a {\@link HammerLoader} to Angular.
   *
   * \@publicApi
   * @type {?}
   */
  const HAMMER_LOADER = new InjectionToken('HammerLoader');
  /**
   * An injectable [HammerJS Manager](http://hammerjs.github.io/api/#hammer.manager)
   * for gesture recognition. Configures specific event recognition.
   * \@publicApi
   */
  class HammerGestureConfig {
      constructor() {
          /**
           * A set of supported event names for gestures to be used in Angular.
           * Angular supports all built-in recognizers, as listed in
           * [HammerJS documentation](http://hammerjs.github.io/).
           */
          this.events = [];
          /**
           * Maps gesture event names to a set of configuration options
           * that specify overrides to the default values for specific properties.
           *
           * The key is a supported event name to be configured,
           * and the options object contains a set of properties, with override values
           * to be applied to the named recognizer event.
           * For example, to disable recognition of the rotate event, specify
           *  `{"rotate": {"enable": false}}`.
           *
           * Properties that are not present take the HammerJS default values.
           * For information about which properties are supported for which events,
           * and their allowed and default values, see
           * [HammerJS documentation](http://hammerjs.github.io/).
           *
           */
          this.overrides = {};
      }
      /**
       * Creates a [HammerJS Manager](http://hammerjs.github.io/api/#hammer.manager)
       * and attaches it to a given HTML element.
       * @param {?} element The element that will recognize gestures.
       * @return {?} A HammerJS event-manager object.
       */
      buildHammer(element$$1) {
          /** @type {?} */
          const mc = new (/** @type {?} */ (Hammer))(element$$1, this.options);
          mc.get('pinch').set({ enable: true });
          mc.get('rotate').set({ enable: true });
          for (const eventName in this.overrides) {
              mc.get(eventName).set(this.overrides[eventName]);
          }
          return mc;
      }
  }
  HammerGestureConfig.decorators = [
      { type: Injectable }
  ];
  class HammerGesturesPlugin extends EventManagerPlugin {
      /**
       * @param {?} doc
       * @param {?} _config
       * @param {?} console
       * @param {?=} loader
       */
      constructor(doc, _config, console, loader) {
          super(doc);
          this._config = _config;
          this.console = console;
          this.loader = loader;
      }
      /**
       * @param {?} eventName
       * @return {?}
       */
      supports(eventName) {
          if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
              return false;
          }
          if (!((/** @type {?} */ (window))).Hammer && !this.loader) {
              this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not ` +
                  `loaded and no custom loader has been specified.`);
              return false;
          }
          return true;
      }
      /**
       * @param {?} element
       * @param {?} eventName
       * @param {?} handler
       * @return {?}
       */
      addEventListener(element$$1, eventName, handler) {
          /** @type {?} */
          const zone = this.manager.getZone();
          eventName = eventName.toLowerCase();
          // If Hammer is not present but a loader is specified, we defer adding the event listener
          // until Hammer is loaded.
          if (!((/** @type {?} */ (window))).Hammer && this.loader) {
              // This `addEventListener` method returns a function to remove the added listener.
              // Until Hammer is loaded, the returned function needs to *cancel* the registration rather
              // than remove anything.
              /** @type {?} */
              let cancelRegistration = false;
              /** @type {?} */
              let deregister = () => { cancelRegistration = true; };
              this.loader()
                  .then(() => {
                  // If Hammer isn't actually loaded when the custom loader resolves, give up.
                  if (!((/** @type {?} */ (window))).Hammer) {
                      this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
                      deregister = () => { };
                      return;
                  }
                  if (!cancelRegistration) {
                      // Now that Hammer is loaded and the listener is being loaded for real,
                      // the deregistration function changes from canceling registration to removal.
                      deregister = this.addEventListener(element$$1, eventName, handler);
                  }
              })
                  .catch(() => {
                  this.console.warn(`The "${eventName}" event cannot be bound because the custom ` +
                      `Hammer.JS loader failed.`);
                  deregister = () => { };
              });
              // Return a function that *executes* `deregister` (and not `deregister` itself) so that we
              // can change the behavior of `deregister` once the listener is added. Using a closure in
              // this way allows us to avoid any additional data structures to track listener removal.
              return () => { deregister(); };
          }
          return zone.runOutsideAngular(() => {
              // Creating the manager bind events, must be done outside of angular
              /** @type {?} */
              const mc = this._config.buildHammer(element$$1);
              /** @type {?} */
              const callback = function (eventObj) {
                  zone.runGuarded(function () { handler(eventObj); });
              };
              mc.on(eventName, callback);
              return () => {
                  mc.off(eventName, callback);
                  // destroy mc to prevent memory leak
                  if (typeof mc.destroy === 'function') {
                      mc.destroy();
                  }
              };
          });
      }
      /**
       * @param {?} eventName
       * @return {?}
       */
      isCustomEvent(eventName) { return this._config.events.indexOf(eventName) > -1; }
  }
  HammerGesturesPlugin.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  HammerGesturesPlugin.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] }] },
      { type: HammerGestureConfig, decorators: [{ type: Inject, args: [HAMMER_GESTURE_CONFIG,] }] },
      { type: Console },
      { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [HAMMER_LOADER,] }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Defines supported modifiers for key events.
   * @type {?}
   */
  const MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
  const ɵ0$1$1 = (event) => event.altKey, ɵ1$1 = (event) => event.ctrlKey, ɵ2$1 = (event) => event.metaKey, ɵ3 = (event) => event.shiftKey;
  /**
   * Retrieves modifiers from key-event objects.
   * @type {?}
   */
  const MODIFIER_KEY_GETTERS = {
      'alt': ɵ0$1$1,
      'control': ɵ1$1,
      'meta': ɵ2$1,
      'shift': ɵ3
  };
  /**
   * \@publicApi
   * A browser plug-in that provides support for handling of key events in Angular.
   */
  class KeyEventsPlugin extends EventManagerPlugin {
      /**
       * Initializes an instance of the browser plug-in.
       * @param {?} doc The document in which key events will be detected.
       */
      constructor(doc) { super(doc); }
      /**
       * Reports whether a named key event is supported.
       * @param {?} eventName The event name to query.
       * @return {?} True if the named key event is supported.
       */
      supports(eventName) { return KeyEventsPlugin.parseEventName(eventName) != null; }
      /**
       * Registers a handler for a specific element and key event.
       * @param {?} element The HTML element to receive event notifications.
       * @param {?} eventName The name of the key event to listen for.
       * @param {?} handler A function to call when the notification occurs. Receives the
       * event object as an argument.
       * @return {?} The key event that was registered.
       */
      addEventListener(element$$1, eventName, handler) {
          /** @type {?} */
          const parsedEvent = (/** @type {?} */ (KeyEventsPlugin.parseEventName(eventName)));
          /** @type {?} */
          const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
          return this.manager.getZone().runOutsideAngular(() => {
              return getDOM().onAndCancel(element$$1, parsedEvent['domEventName'], outsideHandler);
          });
      }
      /**
       * @param {?} eventName
       * @return {?}
       */
      static parseEventName(eventName) {
          /** @type {?} */
          const parts = eventName.toLowerCase().split('.');
          /** @type {?} */
          const domEventName = parts.shift();
          if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {
              return null;
          }
          /** @type {?} */
          const key = KeyEventsPlugin._normalizeKey((/** @type {?} */ (parts.pop())));
          /** @type {?} */
          let fullKey = '';
          MODIFIER_KEYS.forEach(modifierName => {
              /** @type {?} */
              const index = parts.indexOf(modifierName);
              if (index > -1) {
                  parts.splice(index, 1);
                  fullKey += modifierName + '.';
              }
          });
          fullKey += key;
          if (parts.length != 0 || key.length === 0) {
              // returning null instead of throwing to let another plugin process the event
              return null;
          }
          /** @type {?} */
          const result = {};
          result['domEventName'] = domEventName;
          result['fullKey'] = fullKey;
          return result;
      }
      /**
       * @param {?} event
       * @return {?}
       */
      static getEventFullKey(event) {
          /** @type {?} */
          let fullKey = '';
          /** @type {?} */
          let key = getDOM().getEventKey(event);
          key = key.toLowerCase();
          if (key === ' ') {
              key = 'space'; // for readability
          }
          else if (key === '.') {
              key = 'dot'; // because '.' is used as a separator in event names
          }
          MODIFIER_KEYS.forEach(modifierName => {
              if (modifierName != key) {
                  /** @type {?} */
                  const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
                  if (modifierGetter(event)) {
                      fullKey += modifierName + '.';
                  }
              }
          });
          fullKey += key;
          return fullKey;
      }
      /**
       * Configures a handler callback for a key event.
       * @param {?} fullKey The event name that combines all simultaneous keystrokes.
       * @param {?} handler The function that responds to the key event.
       * @param {?} zone The zone in which the event occurred.
       * @return {?} A callback function.
       */
      static eventCallback(fullKey, handler, zone) {
          return (event /** TODO #9100 */) => {
              if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
                  zone.runGuarded(() => handler(event));
              }
          };
      }
      /**
       * \@internal
       * @param {?} keyName
       * @return {?}
       */
      static _normalizeKey(keyName) {
          // TODO: switch to a Map if the mapping grows too much
          switch (keyName) {
              case 'esc':
                  return 'escape';
              default:
                  return keyName;
          }
      }
  }
  KeyEventsPlugin.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  KeyEventsPlugin.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
   * values to be safe to use in the different DOM contexts.
   *
   * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
   * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
   * the website.
   *
   * In specific situations, it might be necessary to disable sanitization, for example if the
   * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
   * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
   * methods, and then binding to that value from the template.
   *
   * These situations should be very rare, and extraordinary care must be taken to avoid creating a
   * Cross Site Scripting (XSS) security bug!
   *
   * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
   * close as possible to the source of the value, to make it easy to verify no security bug is
   * created by its use.
   *
   * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
   * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
   * code. The sanitizer leaves safe values intact.
   *
   * \@security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
   * sanitization for the value passed in. Carefully check and audit all values and code paths going
   * into this call. Make sure any user data is appropriately escaped for this security context.
   * For more detail, see the [Security Guide](http://g.co/ng/security).
   *
   * \@publicApi
   * @abstract
   */
  class DomSanitizer {
  }
  class DomSanitizerImpl extends DomSanitizer {
      /**
       * @param {?} _doc
       */
      constructor(_doc) {
          super();
          this._doc = _doc;
      }
      /**
       * @param {?} ctx
       * @param {?} value
       * @return {?}
       */
      sanitize(ctx, value) {
          if (value == null)
              return null;
          switch (ctx) {
              case SecurityContext$1.NONE:
                  return (/** @type {?} */ (value));
              case SecurityContext$1.HTML:
                  if (value instanceof SafeHtmlImpl)
                      return value.changingThisBreaksApplicationSecurity;
                  this.checkNotSafeValue(value, 'HTML');
                  return _sanitizeHtml(this._doc, String(value));
              case SecurityContext$1.STYLE:
                  if (value instanceof SafeStyleImpl)
                      return value.changingThisBreaksApplicationSecurity;
                  this.checkNotSafeValue(value, 'Style');
                  return _sanitizeStyle((/** @type {?} */ (value)));
              case SecurityContext$1.SCRIPT:
                  if (value instanceof SafeScriptImpl)
                      return value.changingThisBreaksApplicationSecurity;
                  this.checkNotSafeValue(value, 'Script');
                  throw new Error('unsafe value used in a script context');
              case SecurityContext$1.URL:
                  if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
                      // Allow resource URLs in URL contexts, they are strictly more trusted.
                      return value.changingThisBreaksApplicationSecurity;
                  }
                  this.checkNotSafeValue(value, 'URL');
                  return _sanitizeUrl(String(value));
              case SecurityContext$1.RESOURCE_URL:
                  if (value instanceof SafeResourceUrlImpl) {
                      return value.changingThisBreaksApplicationSecurity;
                  }
                  this.checkNotSafeValue(value, 'ResourceURL');
                  throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
              default:
                  throw new Error(`Unexpected SecurityContext ${ctx} (see http://g.co/ng/security#xss)`);
          }
      }
      /**
       * @private
       * @param {?} value
       * @param {?} expectedType
       * @return {?}
       */
      checkNotSafeValue(value, expectedType) {
          if (value instanceof SafeValueImpl) {
              throw new Error(`Required a safe ${expectedType}, got a ${value.getTypeName()} ` +
                  `(see http://g.co/ng/security#xss)`);
          }
      }
      /**
       * @param {?} value
       * @return {?}
       */
      bypassSecurityTrustHtml(value) { return new SafeHtmlImpl(value); }
      /**
       * @param {?} value
       * @return {?}
       */
      bypassSecurityTrustStyle(value) { return new SafeStyleImpl(value); }
      /**
       * @param {?} value
       * @return {?}
       */
      bypassSecurityTrustScript(value) { return new SafeScriptImpl(value); }
      /**
       * @param {?} value
       * @return {?}
       */
      bypassSecurityTrustUrl(value) { return new SafeUrlImpl(value); }
      /**
       * @param {?} value
       * @return {?}
       */
      bypassSecurityTrustResourceUrl(value) {
          return new SafeResourceUrlImpl(value);
      }
  }
  DomSanitizerImpl.decorators = [
      { type: Injectable }
  ];
  /** @nocollapse */
  DomSanitizerImpl.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] }] }
  ];
  /**
   * @abstract
   */
  class SafeValueImpl {
      /**
       * @param {?} changingThisBreaksApplicationSecurity
       */
      constructor(changingThisBreaksApplicationSecurity) {
          this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
          // empty
      }
      /**
       * @return {?}
       */
      toString() {
          return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +
              ` (see http://g.co/ng/security#xss)`;
      }
  }
  class SafeHtmlImpl extends SafeValueImpl {
      /**
       * @return {?}
       */
      getTypeName() { return 'HTML'; }
  }
  class SafeStyleImpl extends SafeValueImpl {
      /**
       * @return {?}
       */
      getTypeName() { return 'Style'; }
  }
  class SafeScriptImpl extends SafeValueImpl {
      /**
       * @return {?}
       */
      getTypeName() { return 'Script'; }
  }
  class SafeUrlImpl extends SafeValueImpl {
      /**
       * @return {?}
       */
      getTypeName() { return 'URL'; }
  }
  class SafeResourceUrlImpl extends SafeValueImpl {
      /**
       * @return {?}
       */
      getTypeName() { return 'ResourceURL'; }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
      { provide: PLATFORM_ID, useValue: PLATFORM_BROWSER_ID },
      { provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
      { provide: PlatformLocation, useClass: BrowserPlatformLocation, deps: [DOCUMENT$1] },
      { provide: DOCUMENT$1, useFactory: _document, deps: [] },
  ];
  /**
   * \@security Replacing built-in sanitization providers exposes the application to XSS risks.
   * Attacker-controlled data introduced by an unsanitized provider could expose your
   * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
   * \@publicApi
   * @type {?}
   */
  const BROWSER_SANITIZATION_PROVIDERS = [
      { provide: Sanitizer, useExisting: DomSanitizer },
      { provide: DomSanitizer, useClass: DomSanitizerImpl, deps: [DOCUMENT$1] },
  ];
  /**
   * \@publicApi
   * @type {?}
   */
  const platformBrowser = createPlatformFactory(platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
  /**
   * @return {?}
   */
  function initDomAdapter() {
      BrowserDomAdapter.makeCurrent();
      BrowserGetTestability.init();
  }
  /**
   * @return {?}
   */
  function errorHandler() {
      return new ErrorHandler();
  }
  /**
   * @return {?}
   */
  function _document() {
      return document;
  }
  /** @type {?} */
  const BROWSER_MODULE_PROVIDERS = [
      BROWSER_SANITIZATION_PROVIDERS,
      { provide: APP_ROOT, useValue: true },
      { provide: ErrorHandler, useFactory: errorHandler, deps: [] },
      {
          provide: EVENT_MANAGER_PLUGINS,
          useClass: DomEventsPlugin,
          multi: true,
          deps: [DOCUMENT$1, NgZone, PLATFORM_ID]
      },
      { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [DOCUMENT$1] },
      {
          provide: EVENT_MANAGER_PLUGINS,
          useClass: HammerGesturesPlugin,
          multi: true,
          deps: [DOCUMENT$1, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]
      },
      { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] },
      {
          provide: DomRendererFactory2,
          useClass: DomRendererFactory2,
          deps: [EventManager, DomSharedStylesHost]
      },
      { provide: RendererFactory2, useExisting: DomRendererFactory2 },
      { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
      { provide: DomSharedStylesHost, useClass: DomSharedStylesHost, deps: [DOCUMENT$1] },
      { provide: Testability, useClass: Testability, deps: [NgZone] },
      { provide: EventManager, useClass: EventManager, deps: [EVENT_MANAGER_PLUGINS, NgZone] },
      ELEMENT_PROBE_PROVIDERS,
  ];
  /**
   * Exports required infrastructure for all Angular apps.
   * Included by default in all Angular apps created with the CLI
   * `new` command.
   * Re-exports `CommonModule` and `ApplicationModule`, making their
   * exports and providers available to all apps.
   *
   * \@publicApi
   */
  class BrowserModule {
      /**
       * @param {?} parentModule
       */
      constructor(parentModule) {
          if (parentModule) {
              throw new Error(`BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);
          }
      }
      /**
       * Configures a browser-based app to transition from a server-rendered app, if
       * one is present on the page.
       *
       * @param {?} params An object containing an identifier for the app to transition.
       * The ID must match between the client and server versions of the app.
       * @return {?} The reconfigured `BrowserModule` to import into the app's root `AppModule`.
       */
      static withServerTransition(params) {
          return {
              ngModule: BrowserModule,
              providers: [
                  { provide: APP_ID, useValue: params.appId },
                  { provide: TRANSITION_ID, useExisting: APP_ID },
                  SERVER_TRANSITION_PROVIDERS,
              ],
          };
      }
  }
  BrowserModule.decorators = [
      { type: NgModule, args: [{ providers: BROWSER_MODULE_PROVIDERS, exports: [CommonModule, ApplicationModule] },] }
  ];
  /** @nocollapse */
  BrowserModule.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Optional }, { type: SkipSelf }, { type: Inject, args: [BrowserModule,] }] }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Factory to create Meta service.
   * @return {?}
   */
  function createMeta() {
      return new Meta(inject(DOCUMENT$1));
  }
  /**
   * A service that can be used to get and add meta tags.
   *
   * \@publicApi
   */
  class Meta {
      /**
       * @param {?} _doc
       */
      constructor(_doc) {
          this._doc = _doc;
          this._dom = getDOM();
      }
      /**
       * @param {?} tag
       * @param {?=} forceCreation
       * @return {?}
       */
      addTag(tag, forceCreation = false) {
          if (!tag)
              return null;
          return this._getOrCreateElement(tag, forceCreation);
      }
      /**
       * @param {?} tags
       * @param {?=} forceCreation
       * @return {?}
       */
      addTags(tags, forceCreation = false) {
          if (!tags)
              return [];
          return tags.reduce((result, tag) => {
              if (tag) {
                  result.push(this._getOrCreateElement(tag, forceCreation));
              }
              return result;
          }, []);
      }
      /**
       * @param {?} attrSelector
       * @return {?}
       */
      getTag(attrSelector) {
          if (!attrSelector)
              return null;
          return this._dom.querySelector(this._doc, `meta[${attrSelector}]`) || null;
      }
      /**
       * @param {?} attrSelector
       * @return {?}
       */
      getTags(attrSelector) {
          if (!attrSelector)
              return [];
          /** @type {?} */
          const list /*NodeList*/ = this._dom.querySelectorAll(this._doc, `meta[${attrSelector}]`);
          return list ? [].slice.call(list) : [];
      }
      /**
       * @param {?} tag
       * @param {?=} selector
       * @return {?}
       */
      updateTag(tag, selector) {
          if (!tag)
              return null;
          selector = selector || this._parseSelector(tag);
          /** @type {?} */
          const meta = (/** @type {?} */ (this.getTag(selector)));
          if (meta) {
              return this._setMetaElementAttributes(tag, meta);
          }
          return this._getOrCreateElement(tag, true);
      }
      /**
       * @param {?} attrSelector
       * @return {?}
       */
      removeTag(attrSelector) { this.removeTagElement((/** @type {?} */ (this.getTag(attrSelector)))); }
      /**
       * @param {?} meta
       * @return {?}
       */
      removeTagElement(meta) {
          if (meta) {
              this._dom.remove(meta);
          }
      }
      /**
       * @private
       * @param {?} meta
       * @param {?=} forceCreation
       * @return {?}
       */
      _getOrCreateElement(meta, forceCreation = false) {
          if (!forceCreation) {
              /** @type {?} */
              const selector = this._parseSelector(meta);
              /** @type {?} */
              const elem = (/** @type {?} */ (this.getTag(selector)));
              // It's allowed to have multiple elements with the same name so it's not enough to
              // just check that element with the same name already present on the page. We also need to
              // check if element has tag attributes
              if (elem && this._containsAttributes(meta, elem))
                  return elem;
          }
          /** @type {?} */
          const element$$1 = (/** @type {?} */ (this._dom.createElement('meta')));
          this._setMetaElementAttributes(meta, element$$1);
          /** @type {?} */
          const head = this._dom.getElementsByTagName(this._doc, 'head')[0];
          this._dom.appendChild(head, element$$1);
          return element$$1;
      }
      /**
       * @private
       * @param {?} tag
       * @param {?} el
       * @return {?}
       */
      _setMetaElementAttributes(tag, el) {
          Object.keys(tag).forEach((prop) => this._dom.setAttribute(el, prop, tag[prop]));
          return el;
      }
      /**
       * @private
       * @param {?} tag
       * @return {?}
       */
      _parseSelector(tag) {
          /** @type {?} */
          const attr = tag.name ? 'name' : 'property';
          return `${attr}="${tag[attr]}"`;
      }
      /**
       * @private
       * @param {?} tag
       * @param {?} elem
       * @return {?}
       */
      _containsAttributes(tag, elem) {
          return Object.keys(tag).every((key) => this._dom.getAttribute(elem, key) === tag[key]);
      }
  }
  Meta.decorators = [
      { type: Injectable, args: [{ providedIn: 'root', useFactory: createMeta, deps: [] },] }
  ];
  /** @nocollapse */
  Meta.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] }] }
  ];
  /** @nocollapse */ Meta.ngInjectableDef = defineInjectable({ factory: createMeta, token: Meta, providedIn: "root" });

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Factory to create Title service.
   * @return {?}
   */
  function createTitle() {
      return new Title(inject(DOCUMENT$1));
  }
  /**
   * A service that can be used to get and set the title of a current HTML document.
   *
   * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)
   * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
   * (representing the `<title>` tag). Instead, this service can be used to set and get the current
   * title value.
   *
   * \@publicApi
   */
  class Title {
      /**
       * @param {?} _doc
       */
      constructor(_doc) {
          this._doc = _doc;
      }
      /**
       * Get the title of the current HTML document.
       * @return {?}
       */
      getTitle() { return getDOM().getTitle(this._doc); }
      /**
       * Set the title of the current HTML document.
       * @param {?} newTitle
       * @return {?}
       */
      setTitle(newTitle) { getDOM().setTitle(this._doc, newTitle); }
  }
  Title.decorators = [
      { type: Injectable, args: [{ providedIn: 'root', useFactory: createTitle, deps: [] },] }
  ];
  /** @nocollapse */
  Title.ctorParameters = () => [
      { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] }] }
  ];
  /** @nocollapse */ Title.ngInjectableDef = defineInjectable({ factory: createTitle, token: Title, providedIn: "root" });

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@publicApi
   * @type {?}
   */
  const VERSION$4 = new Version$1('7.2.8');

  /**
   * @license Angular v7.2.8
   * (c) 2010-2019 Google LLC. https://angular.io/
   * License: MIT
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const MODULE_SUFFIX = '';
  /** @type {?} */
  const builtinExternalReferences = createBuiltinExternalReferencesMap();
  class JitReflector {
      constructor() {
          this.reflectionCapabilities = new ReflectionCapabilities();
      }
      /**
       * @param {?} type
       * @param {?} cmpMetadata
       * @return {?}
       */
      componentModuleUrl(type, cmpMetadata) {
          /** @type {?} */
          const moduleId = cmpMetadata.moduleId;
          if (typeof moduleId === 'string') {
              /** @type {?} */
              const scheme = getUrlScheme(moduleId);
              return scheme ? moduleId : `package:${moduleId}${MODULE_SUFFIX}`;
          }
          else if (moduleId !== null && moduleId !== void 0) {
              throw syntaxError(`moduleId should be a string in "${stringify$1(type)}". See https://goo.gl/wIDDiL for more information.\n` +
                  `If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.`);
          }
          return `./${stringify$1(type)}`;
      }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      parameters(typeOrFunc) {
          return this.reflectionCapabilities.parameters(typeOrFunc);
      }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      tryAnnotations(typeOrFunc) { return this.annotations(typeOrFunc); }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      annotations(typeOrFunc) {
          return this.reflectionCapabilities.annotations(typeOrFunc);
      }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      shallowAnnotations(typeOrFunc) {
          throw new Error('Not supported in JIT mode');
      }
      /**
       * @param {?} typeOrFunc
       * @return {?}
       */
      propMetadata(typeOrFunc) {
          return this.reflectionCapabilities.propMetadata(typeOrFunc);
      }
      /**
       * @param {?} type
       * @param {?} lcProperty
       * @return {?}
       */
      hasLifecycleHook(type, lcProperty) {
          return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
      }
      /**
       * @param {?} type
       * @return {?}
       */
      guards(type) { return this.reflectionCapabilities.guards(type); }
      /**
       * @param {?} ref
       * @return {?}
       */
      resolveExternalReference(ref) {
          return builtinExternalReferences.get(ref) || ref.runtime;
      }
  }
  /**
   * @return {?}
   */
  function createBuiltinExternalReferencesMap() {
      /** @type {?} */
      const map = new Map();
      map.set(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS, ANALYZE_FOR_ENTRY_COMPONENTS);
      map.set(Identifiers.ElementRef, ElementRef);
      map.set(Identifiers.NgModuleRef, NgModuleRef);
      map.set(Identifiers.ViewContainerRef, ViewContainerRef);
      map.set(Identifiers.ChangeDetectorRef, ChangeDetectorRef);
      map.set(Identifiers.Renderer2, Renderer2);
      map.set(Identifiers.QueryList, QueryList$1);
      map.set(Identifiers.TemplateRef, TemplateRef);
      map.set(Identifiers.CodegenComponentFactoryResolver, CodegenComponentFactoryResolver);
      map.set(Identifiers.ComponentFactoryResolver, ComponentFactoryResolver);
      map.set(Identifiers.ComponentFactory, ComponentFactory);
      map.set(Identifiers.ComponentRef, ComponentRef);
      map.set(Identifiers.NgModuleFactory, NgModuleFactory);
      map.set(Identifiers.createModuleFactory, createNgModuleFactory);
      map.set(Identifiers.moduleDef, moduleDef);
      map.set(Identifiers.moduleProviderDef, moduleProvideDef);
      map.set(Identifiers.RegisterModuleFactoryFn, registerModuleFactory);
      map.set(Identifiers.Injector, Injector);
      map.set(Identifiers.ViewEncapsulation, ViewEncapsulation$1);
      map.set(Identifiers.ChangeDetectionStrategy, ChangeDetectionStrategy$1);
      map.set(Identifiers.SecurityContext, SecurityContext$1);
      map.set(Identifiers.LOCALE_ID, LOCALE_ID);
      map.set(Identifiers.TRANSLATIONS_FORMAT, TRANSLATIONS_FORMAT);
      map.set(Identifiers.inlineInterpolate, inlineInterpolate);
      map.set(Identifiers.interpolate, interpolate$1);
      map.set(Identifiers.EMPTY_ARRAY, EMPTY_ARRAY$4);
      map.set(Identifiers.EMPTY_MAP, EMPTY_MAP);
      map.set(Identifiers.Renderer, Renderer);
      map.set(Identifiers.viewDef, viewDef);
      map.set(Identifiers.elementDef, elementDef);
      map.set(Identifiers.anchorDef, anchorDef);
      map.set(Identifiers.textDef, textDef);
      map.set(Identifiers.directiveDef, directiveDef);
      map.set(Identifiers.providerDef, providerDef$1);
      map.set(Identifiers.queryDef, queryDef);
      map.set(Identifiers.pureArrayDef, pureArrayDef);
      map.set(Identifiers.pureObjectDef, pureObjectDef);
      map.set(Identifiers.purePipeDef, purePipeDef);
      map.set(Identifiers.pipeDef, pipeDef);
      map.set(Identifiers.nodeValue, nodeValue);
      map.set(Identifiers.ngContentDef, ngContentDef);
      map.set(Identifiers.unwrapValue, unwrapValue$1);
      map.set(Identifiers.createRendererType2, createRendererType2);
      map.set(Identifiers.createComponentFactory, createComponentFactory);
      return map;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const ERROR_COLLECTOR_TOKEN = new InjectionToken('ErrorCollector');
  /**
   * A default provider for {\@link PACKAGE_ROOT_URL} that maps to '/'.
   * @type {?}
   */
  const DEFAULT_PACKAGE_URL_PROVIDER = {
      provide: PACKAGE_ROOT_URL,
      useValue: '/'
  };
  /** @type {?} */
  const _NO_RESOURCE_LOADER = {
      /**
       * @param {?} url
       * @return {?}
       */
      get(url) {
          throw new Error(`No ResourceLoader implementation has been provided. Can't read the url "${url}"`);
      }
  };
  /** @type {?} */
  const baseHtmlParser = new InjectionToken('HtmlParser');
  class CompilerImpl {
      /**
       * @param {?} injector
       * @param {?} _metadataResolver
       * @param {?} templateParser
       * @param {?} styleCompiler
       * @param {?} viewCompiler
       * @param {?} ngModuleCompiler
       * @param {?} summaryResolver
       * @param {?} compileReflector
       * @param {?} compilerConfig
       * @param {?} console
       */
      constructor(injector, _metadataResolver, templateParser, styleCompiler, viewCompiler, ngModuleCompiler, summaryResolver, compileReflector, compilerConfig, console) {
          this._metadataResolver = _metadataResolver;
          this._delegate = new JitCompiler(_metadataResolver, templateParser, styleCompiler, viewCompiler, ngModuleCompiler, summaryResolver, compileReflector, compilerConfig, console, this.getExtraNgModuleProviders.bind(this));
          this.injector = injector;
      }
      /**
       * @private
       * @return {?}
       */
      getExtraNgModuleProviders() {
          return [this._metadataResolver.getProviderMetadata(new ProviderMeta(Compiler, { useValue: this }))];
      }
      /**
       * @template T
       * @param {?} moduleType
       * @return {?}
       */
      compileModuleSync(moduleType) {
          return (/** @type {?} */ (this._delegate.compileModuleSync(moduleType)));
      }
      /**
       * @template T
       * @param {?} moduleType
       * @return {?}
       */
      compileModuleAsync(moduleType) {
          return (/** @type {?} */ (this._delegate.compileModuleAsync(moduleType)));
      }
      /**
       * @template T
       * @param {?} moduleType
       * @return {?}
       */
      compileModuleAndAllComponentsSync(moduleType) {
          /** @type {?} */
          const result = this._delegate.compileModuleAndAllComponentsSync(moduleType);
          return {
              ngModuleFactory: (/** @type {?} */ (result.ngModuleFactory)),
              componentFactories: (/** @type {?} */ (result.componentFactories)),
          };
      }
      /**
       * @template T
       * @param {?} moduleType
       * @return {?}
       */
      compileModuleAndAllComponentsAsync(moduleType) {
          return this._delegate.compileModuleAndAllComponentsAsync(moduleType)
              .then((result) => ({
              ngModuleFactory: (/** @type {?} */ (result.ngModuleFactory)),
              componentFactories: (/** @type {?} */ (result.componentFactories)),
          }));
      }
      /**
       * @param {?} summaries
       * @return {?}
       */
      loadAotSummaries(summaries) { this._delegate.loadAotSummaries(summaries); }
      /**
       * @param {?} ref
       * @return {?}
       */
      hasAotSummary(ref) { return this._delegate.hasAotSummary(ref); }
      /**
       * @template T
       * @param {?} component
       * @return {?}
       */
      getComponentFactory(component) {
          return (/** @type {?} */ (this._delegate.getComponentFactory(component)));
      }
      /**
       * @return {?}
       */
      clearCache() { this._delegate.clearCache(); }
      /**
       * @param {?} type
       * @return {?}
       */
      clearCacheFor(type) { this._delegate.clearCacheFor(type); }
      /**
       * @param {?} moduleType
       * @return {?}
       */
      getModuleId(moduleType) {
          /** @type {?} */
          const meta = this._metadataResolver.getNgModuleMetadata(moduleType);
          return meta && meta.id || undefined;
      }
  }
  /**
   * A set of providers that provide `JitCompiler` and its dependencies to use for
   * template compilation.
   * @type {?}
   */
  const COMPILER_PROVIDERS = (/** @type {?} */ ([
      { provide: CompileReflector, useValue: new JitReflector() },
      { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },
      { provide: JitSummaryResolver, deps: [] },
      { provide: SummaryResolver, useExisting: JitSummaryResolver },
      { provide: Console, deps: [] },
      { provide: Lexer, deps: [] },
      { provide: Parser, deps: [Lexer] },
      {
          provide: baseHtmlParser,
          useClass: HtmlParser,
          deps: [],
      },
      {
          provide: I18NHtmlParser,
          useFactory: (parser, translations, format, config, console) => {
              translations = translations || '';
              /** @type {?} */
              const missingTranslation = translations ? (/** @type {?} */ (config.missingTranslation)) : MissingTranslationStrategy$1.Ignore;
              return new I18NHtmlParser(parser, translations, format, missingTranslation, console);
          },
          deps: [
              baseHtmlParser,
              [new Optional(), new Inject(TRANSLATIONS)],
              [new Optional(), new Inject(TRANSLATIONS_FORMAT)],
              [CompilerConfig],
              [Console],
          ]
      },
      {
          provide: HtmlParser,
          useExisting: I18NHtmlParser,
      },
      {
          provide: TemplateParser, deps: [CompilerConfig, CompileReflector,
              Parser, ElementSchemaRegistry,
              I18NHtmlParser, Console]
      },
      { provide: DirectiveNormalizer, deps: [ResourceLoader, UrlResolver, HtmlParser, CompilerConfig] },
      { provide: CompileMetadataResolver, deps: [CompilerConfig, HtmlParser, NgModuleResolver,
              DirectiveResolver, PipeResolver,
              SummaryResolver,
              ElementSchemaRegistry,
              DirectiveNormalizer, Console,
              [Optional, StaticSymbolCache],
              CompileReflector,
              [Optional, ERROR_COLLECTOR_TOKEN]] },
      DEFAULT_PACKAGE_URL_PROVIDER,
      { provide: StyleCompiler, deps: [UrlResolver] },
      { provide: ViewCompiler, deps: [CompileReflector] },
      { provide: NgModuleCompiler, deps: [CompileReflector] },
      { provide: CompilerConfig, useValue: new CompilerConfig() },
      { provide: Compiler, useClass: CompilerImpl, deps: [Injector, CompileMetadataResolver,
              TemplateParser, StyleCompiler,
              ViewCompiler, NgModuleCompiler,
              SummaryResolver, CompileReflector, CompilerConfig,
              Console] },
      { provide: DomElementSchemaRegistry, deps: [] },
      { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },
      { provide: UrlResolver, deps: [PACKAGE_ROOT_URL] },
      { provide: DirectiveResolver, deps: [CompileReflector] },
      { provide: PipeResolver, deps: [CompileReflector] },
      { provide: NgModuleResolver, deps: [CompileReflector] },
  ]));
  /**
   * \@publicApi
   */
  class JitCompilerFactory {
      /* @internal */
      /**
       * @param {?} defaultOptions
       */
      constructor(defaultOptions) {
          /** @type {?} */
          const compilerOptions = {
              useJit: true,
              defaultEncapsulation: ViewEncapsulation$1.Emulated,
              missingTranslation: MissingTranslationStrategy$1.Warning,
          };
          this._defaultOptions = [compilerOptions, ...defaultOptions];
      }
      /**
       * @param {?=} options
       * @return {?}
       */
      createCompiler(options = []) {
          /** @type {?} */
          const opts = _mergeOptions(this._defaultOptions.concat(options));
          /** @type {?} */
          const injector = Injector.create([
              COMPILER_PROVIDERS, {
                  provide: CompilerConfig,
                  useFactory: () => {
                      return new CompilerConfig({
                          // let explicit values from the compiler options overwrite options
                          // from the app providers
                          useJit: opts.useJit,
                          jitDevMode: isDevMode(),
                          // let explicit values from the compiler options overwrite options
                          // from the app providers
                          defaultEncapsulation: opts.defaultEncapsulation,
                          missingTranslation: opts.missingTranslation,
                          preserveWhitespaces: opts.preserveWhitespaces,
                      });
                  },
                  deps: []
              },
              (/** @type {?} */ (opts.providers))
          ]);
          return injector.get(Compiler);
      }
  }
  /**
   * @param {?} optionsArr
   * @return {?}
   */
  function _mergeOptions(optionsArr) {
      return {
          useJit: _lastDefined(optionsArr.map(options => options.useJit)),
          defaultEncapsulation: _lastDefined(optionsArr.map(options => options.defaultEncapsulation)),
          providers: _mergeArrays(optionsArr.map(options => (/** @type {?} */ (options.providers)))),
          missingTranslation: _lastDefined(optionsArr.map(options => options.missingTranslation)),
          preserveWhitespaces: _lastDefined(optionsArr.map(options => options.preserveWhitespaces)),
      };
  }
  /**
   * @template T
   * @param {?} args
   * @return {?}
   */
  function _lastDefined(args) {
      for (let i = args.length - 1; i >= 0; i--) {
          if (args[i] !== undefined) {
              return args[i];
          }
      }
      return undefined;
  }
  /**
   * @param {?} parts
   * @return {?}
   */
  function _mergeArrays(parts) {
      /** @type {?} */
      const result = [];
      parts.forEach((part) => part && result.push(...part));
      return result;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * A platform that included corePlatform and the compiler.
   *
   * \@publicApi
   * @type {?}
   */
  const platformCoreDynamic = createPlatformFactory(platformCore, 'coreDynamic', [
      { provide: COMPILER_OPTIONS, useValue: {}, multi: true },
      { provide: CompilerFactory, useClass: JitCompilerFactory, deps: [COMPILER_OPTIONS] },
  ]);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  class ResourceLoaderImpl extends ResourceLoader {
      /**
       * @param {?} url
       * @return {?}
       */
      get(url) {
          /** @type {?} */
          let resolve;
          /** @type {?} */
          let reject;
          /** @type {?} */
          const promise = new Promise((res, rej) => {
              resolve = res;
              reject = rej;
          });
          /** @type {?} */
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'text';
          xhr.onload = function () {
              // responseText is the old-school way of retrieving response (supported by IE8 & 9)
              // response/responseType properties were introduced in ResourceLoader Level2 spec (supported
              // by IE10)
              /** @type {?} */
              const response = xhr.response || xhr.responseText;
              // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
              /** @type {?} */
              let status = xhr.status === 1223 ? 204 : xhr.status;
              // fix status code when it is 0 (0 status is undocumented).
              // Occurs when accessing file resources or on Android 4.1 stock browser
              // while retrieving files from application cache.
              if (status === 0) {
                  status = response ? 200 : 0;
              }
              if (200 <= status && status <= 300) {
                  resolve(response);
              }
              else {
                  reject(`Failed to load ${url}`);
              }
          };
          xhr.onerror = function () { reject(`Failed to load ${url}`); };
          xhr.send();
          return promise;
      }
  }
  ResourceLoaderImpl.decorators = [
      { type: Injectable }
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@publicApi
   * @type {?}
   */
  const INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [
      INTERNAL_BROWSER_PLATFORM_PROVIDERS,
      {
          provide: COMPILER_OPTIONS,
          useValue: { providers: [{ provide: ResourceLoader, useClass: ResourceLoaderImpl, deps: [] }] },
          multi: true
      },
      { provide: PLATFORM_ID, useValue: PLATFORM_BROWSER_ID },
  ];

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@publicApi
   * @type {?}
   */
  const VERSION$5 = new Version$1('7.2.8');
  /**
   * \@publicApi
   * @type {?}
   */
  const platformBrowserDynamic = createPlatformFactory(platformCoreDynamic, 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);

  /**
   * @license Angular v7.2.8
   * (c) 2010-2019 Google LLC. https://angular.io/
   * License: MIT
   */

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /** @type {?} */
  const elProto = (/** @type {?} */ (Element.prototype));
  /** @type {?} */
  const matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector ||
      elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector;
  /**
   * Provide methods for scheduling the execution of a callback.
   * @type {?}
   */
  const scheduler = {
      /**
       * Schedule a callback to be called after some delay.
       *
       * Returns a function that when executed will cancel the scheduled function.
       * @param {?} taskFn
       * @param {?} delay
       * @return {?}
       */
      schedule(taskFn, delay$$1) { /** @type {?} */
      const id = setTimeout(taskFn, delay$$1); return () => clearTimeout(id); },
      /**
       * Schedule a callback to be called before the next render.
       * (If `window.requestAnimationFrame()` is not available, use `scheduler.schedule()` instead.)
       *
       * Returns a function that when executed will cancel the scheduled function.
       * @param {?} taskFn
       * @return {?}
       */
      scheduleBeforeRender(taskFn) {
          // TODO(gkalpak): Implement a better way of accessing `requestAnimationFrame()`
          //                (e.g. accounting for vendor prefix, SSR-compatibility, etc).
          if (typeof window === 'undefined') {
              // For SSR just schedule immediately.
              return scheduler.schedule(taskFn, 0);
          }
          if (typeof window.requestAnimationFrame === 'undefined') {
              /** @type {?} */
              const frameMs = 16;
              return scheduler.schedule(taskFn, frameMs);
          }
          /** @type {?} */
          const id = window.requestAnimationFrame(taskFn);
          return () => window.cancelAnimationFrame(id);
      },
  };
  /**
   * Convert a camelCased string to kebab-cased.
   * @param {?} input
   * @return {?}
   */
  function camelToDashCase(input) {
      return input.replace(/[A-Z]/g, char => `-${char.toLowerCase()}`);
  }
  /**
   * Create a `CustomEvent` (even on browsers where `CustomEvent` is not a constructor).
   * @param {?} doc
   * @param {?} name
   * @param {?} detail
   * @return {?}
   */
  function createCustomEvent(doc, name, detail) {
      /** @type {?} */
      const bubbles = false;
      /** @type {?} */
      const cancelable = false;
      // On IE9-11, `CustomEvent` is not a constructor.
      if (typeof CustomEvent !== 'function') {
          /** @type {?} */
          const event = doc.createEvent('CustomEvent');
          event.initCustomEvent(name, bubbles, cancelable, detail);
          return event;
      }
      return new CustomEvent(name, { bubbles, cancelable, detail });
  }
  /**
   * Check whether the input is an `Element`.
   * @param {?} node
   * @return {?}
   */
  function isElement(node) {
      return !!node && node.nodeType === Node.ELEMENT_NODE;
  }
  /**
   * Check whether the input is a function.
   * @param {?} value
   * @return {?}
   */
  function isFunction$1(value) {
      return typeof value === 'function';
  }
  /**
   * Check whether an `Element` matches a CSS selector.
   * @param {?} element
   * @param {?} selector
   * @return {?}
   */
  function matchesSelector(element$$1, selector) {
      return matches.call(element$$1, selector);
  }
  /**
   * Test two values for strict equality, accounting for the fact that `NaN !== NaN`.
   * @param {?} value1
   * @param {?} value2
   * @return {?}
   */
  function strictEquals(value1, value2) {
      return value1 === value2 || (value1 !== value1 && value2 !== value2);
  }
  /**
   * Gets a map of default set of attributes to observe and the properties they affect.
   * @param {?} inputs
   * @return {?}
   */
  function getDefaultAttributeToPropertyInputs(inputs) {
      /** @type {?} */
      const attributeToPropertyInputs = {};
      inputs.forEach(({ propName, templateName }) => {
          attributeToPropertyInputs[camelToDashCase(templateName)] = propName;
      });
      return attributeToPropertyInputs;
  }
  /**
   * Gets a component's set of inputs. Uses the injector to get the component factory where the inputs
   * are defined.
   * @param {?} component
   * @param {?} injector
   * @return {?}
   */
  function getComponentInputs(component, injector) {
      /** @type {?} */
      const componentFactoryResolver = injector.get(ComponentFactoryResolver);
      /** @type {?} */
      const componentFactory = componentFactoryResolver.resolveComponentFactory(component);
      return componentFactory.inputs;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * @param {?} host
   * @param {?} ngContentSelectors
   * @return {?}
   */
  function extractProjectableNodes(host, ngContentSelectors) {
      /** @type {?} */
      const nodes = host.childNodes;
      /** @type {?} */
      const projectableNodes = ngContentSelectors.map(() => []);
      /** @type {?} */
      let wildcardIndex = -1;
      ngContentSelectors.some((selector, i) => {
          if (selector === '*') {
              wildcardIndex = i;
              return true;
          }
          return false;
      });
      for (let i = 0, ii = nodes.length; i < ii; ++i) {
          /** @type {?} */
          const node = nodes[i];
          /** @type {?} */
          const ngContentIndex = findMatchingIndex(node, ngContentSelectors, wildcardIndex);
          if (ngContentIndex !== -1) {
              projectableNodes[ngContentIndex].push(node);
          }
      }
      return projectableNodes;
  }
  /**
   * @param {?} node
   * @param {?} selectors
   * @param {?} defaultIndex
   * @return {?}
   */
  function findMatchingIndex(node, selectors, defaultIndex) {
      /** @type {?} */
      let matchingIndex = defaultIndex;
      if (isElement(node)) {
          selectors.some((selector, i) => {
              if ((selector !== '*') && matchesSelector(node, selector)) {
                  matchingIndex = i;
                  return true;
              }
              return false;
          });
      }
      return matchingIndex;
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Time in milliseconds to wait before destroying the component ref when disconnected.
   * @type {?}
   */
  const DESTROY_DELAY = 10;
  /**
   * Factory that creates new ComponentNgElementStrategy instance. Gets the component factory with the
   * constructor's injector's factory resolver and passes that factory to each strategy.
   *
   * \@publicApi
   */
  class ComponentNgElementStrategyFactory {
      /**
       * @param {?} component
       * @param {?} injector
       */
      constructor(component, injector) {
          this.component = component;
          this.injector = injector;
          this.componentFactory =
              injector.get(ComponentFactoryResolver).resolveComponentFactory(component);
      }
      /**
       * @param {?} injector
       * @return {?}
       */
      create(injector) {
          return new ComponentNgElementStrategy(this.componentFactory, injector);
      }
  }
  /**
   * Creates and destroys a component ref using a component factory and handles change detection
   * in response to input changes.
   *
   * \@publicApi
   */
  class ComponentNgElementStrategy {
      /**
       * @param {?} componentFactory
       * @param {?} injector
       */
      constructor(componentFactory, injector) {
          this.componentFactory = componentFactory;
          this.injector = injector;
          /**
           * Changes that have been made to the component ref since the last time onChanges was called.
           */
          this.inputChanges = null;
          /**
           * Whether the created component implements the onChanges function.
           */
          this.implementsOnChanges = false;
          /**
           * Whether a change detection has been scheduled to run on the component.
           */
          this.scheduledChangeDetectionFn = null;
          /**
           * Callback function that when called will cancel a scheduled destruction on the component.
           */
          this.scheduledDestroyFn = null;
          /**
           * Initial input values that were set before the component was created.
           */
          this.initialInputValues = new Map();
          /**
           * Set of inputs that were not initially set when the component was created.
           */
          this.uninitializedInputs = new Set();
      }
      /**
       * Initializes a new component if one has not yet been created and cancels any scheduled
       * destruction.
       * @param {?} element
       * @return {?}
       */
      connect(element$$1) {
          // If the element is marked to be destroyed, cancel the task since the component was reconnected
          if (this.scheduledDestroyFn !== null) {
              this.scheduledDestroyFn();
              this.scheduledDestroyFn = null;
              return;
          }
          if (!this.componentRef) {
              this.initializeComponent(element$$1);
          }
      }
      /**
       * Schedules the component to be destroyed after some small delay in case the element is just
       * being moved across the DOM.
       * @return {?}
       */
      disconnect() {
          // Return if there is no componentRef or the component is already scheduled for destruction
          if (!this.componentRef || this.scheduledDestroyFn !== null) {
              return;
          }
          // Schedule the component to be destroyed after a small timeout in case it is being
          // moved elsewhere in the DOM
          this.scheduledDestroyFn = scheduler.schedule(() => {
              if (this.componentRef) {
                  (/** @type {?} */ (this.componentRef)).destroy();
                  this.componentRef = null;
              }
          }, DESTROY_DELAY);
      }
      /**
       * Returns the component property value. If the component has not yet been created, the value is
       * retrieved from the cached initialization values.
       * @param {?} property
       * @return {?}
       */
      getInputValue(property) {
          if (!this.componentRef) {
              return this.initialInputValues.get(property);
          }
          return ((/** @type {?} */ (this.componentRef.instance)))[property];
      }
      /**
       * Sets the input value for the property. If the component has not yet been created, the value is
       * cached and set when the component is created.
       * @param {?} property
       * @param {?} value
       * @return {?}
       */
      setInputValue(property, value) {
          if (strictEquals(value, this.getInputValue(property))) {
              return;
          }
          if (!this.componentRef) {
              this.initialInputValues.set(property, value);
              return;
          }
          this.recordInputChange(property, value);
          ((/** @type {?} */ (this.componentRef.instance)))[property] = value;
          this.scheduleDetectChanges();
      }
      /**
       * Creates a new component through the component factory with the provided element host and
       * sets up its initial inputs, listens for outputs changes, and runs an initial change detection.
       * @protected
       * @param {?} element
       * @return {?}
       */
      initializeComponent(element$$1) {
          /** @type {?} */
          const childInjector = Injector.create({ providers: [], parent: this.injector });
          /** @type {?} */
          const projectableNodes = extractProjectableNodes(element$$1, this.componentFactory.ngContentSelectors);
          this.componentRef = this.componentFactory.create(childInjector, projectableNodes, element$$1);
          this.implementsOnChanges =
              isFunction$1(((/** @type {?} */ ((/** @type {?} */ (this.componentRef.instance))))).ngOnChanges);
          this.initializeInputs();
          this.initializeOutputs();
          this.detectChanges();
          /** @type {?} */
          const applicationRef = this.injector.get(ApplicationRef);
          applicationRef.attachView(this.componentRef.hostView);
      }
      /**
       * Set any stored initial inputs on the component's properties.
       * @protected
       * @return {?}
       */
      initializeInputs() {
          this.componentFactory.inputs.forEach(({ propName }) => {
              /** @type {?} */
              const initialValue = this.initialInputValues.get(propName);
              if (initialValue) {
                  this.setInputValue(propName, initialValue);
              }
              else {
                  // Keep track of inputs that were not initialized in case we need to know this for
                  // calling ngOnChanges with SimpleChanges
                  this.uninitializedInputs.add(propName);
              }
          });
          this.initialInputValues.clear();
      }
      /**
       * Sets up listeners for the component's outputs so that the events stream emits the events.
       * @protected
       * @return {?}
       */
      initializeOutputs() {
          /** @type {?} */
          const eventEmitters = this.componentFactory.outputs.map(({ propName, templateName }) => {
              /** @type {?} */
              const emitter = (/** @type {?} */ (((/** @type {?} */ ((/** @type {?} */ (this.componentRef)).instance)))[propName]));
              return emitter.pipe(map((value) => ({ name: templateName, value })));
          });
          this.events = merge(...eventEmitters);
      }
      /**
       * Calls ngOnChanges with all the inputs that have changed since the last call.
       * @protected
       * @return {?}
       */
      callNgOnChanges() {
          if (!this.implementsOnChanges || this.inputChanges === null) {
              return;
          }
          // Cache the changes and set inputChanges to null to capture any changes that might occur
          // during ngOnChanges.
          /** @type {?} */
          const inputChanges = this.inputChanges;
          this.inputChanges = null;
          ((/** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ (this.componentRef)).instance))))).ngOnChanges(inputChanges);
      }
      /**
       * Schedules change detection to run on the component.
       * Ignores subsequent calls if already scheduled.
       * @protected
       * @return {?}
       */
      scheduleDetectChanges() {
          if (this.scheduledChangeDetectionFn) {
              return;
          }
          this.scheduledChangeDetectionFn = scheduler.scheduleBeforeRender(() => {
              this.scheduledChangeDetectionFn = null;
              this.detectChanges();
          });
      }
      /**
       * Records input changes so that the component receives SimpleChanges in its onChanges function.
       * @protected
       * @param {?} property
       * @param {?} currentValue
       * @return {?}
       */
      recordInputChange(property, currentValue) {
          // Do not record the change if the component does not implement `OnChanges`.
          if (this.componentRef && !this.implementsOnChanges) {
              return;
          }
          if (this.inputChanges === null) {
              this.inputChanges = {};
          }
          // If there already is a change, modify the current value to match but leave the values for
          // previousValue and isFirstChange.
          /** @type {?} */
          const pendingChange = this.inputChanges[property];
          if (pendingChange) {
              pendingChange.currentValue = currentValue;
              return;
          }
          /** @type {?} */
          const isFirstChange = this.uninitializedInputs.has(property);
          this.uninitializedInputs.delete(property);
          /** @type {?} */
          const previousValue = isFirstChange ? undefined : this.getInputValue(property);
          this.inputChanges[property] = new SimpleChange(previousValue, currentValue, isFirstChange);
      }
      /**
       * Runs change detection on the component.
       * @protected
       * @return {?}
       */
      detectChanges() {
          if (!this.componentRef) {
              return;
          }
          this.callNgOnChanges();
          (/** @type {?} */ (this.componentRef)).changeDetectorRef.detectChanges();
      }
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * Implements the functionality needed for a custom element.
   *
   * \@publicApi
   * @abstract
   */
  class NgElement extends HTMLElement {
      constructor() {
          super(...arguments);
          /**
           * A subscription to change, connect, and disconnect events in the custom element.
           */
          this.ngElementEventsSubscription = null;
      }
  }
  /**
   * \@description Creates a custom element class based on an Angular component.
   *
   * Builds a class that encapsulates the functionality of the provided component and
   * uses the configuration information to provide more context to the class.
   * Takes the component factory's inputs and outputs to convert them to the proper
   * custom element API and add hooks to input changes.
   *
   * The configuration's injector is the initial injector set on the class,
   * and used by default for each created instance.This behavior can be overridden with the
   * static property to affect all newly created instances, or as a constructor argument for
   * one-off creations.
   *
   * \@publicApi
   * @template P
   * @param {?} component The component to transform.
   * @param {?} config A configuration that provides initialization information to the created class.
   * @return {?} The custom-element construction class, which can be registered with
   * a browser's `CustomElementRegistry`.
   *
   */
  function createCustomElement(component, config$$1) {
      /** @type {?} */
      const inputs = getComponentInputs(component, config$$1.injector);
      /** @type {?} */
      const strategyFactory = config$$1.strategyFactory || new ComponentNgElementStrategyFactory(component, config$$1.injector);
      /** @type {?} */
      const attributeToPropertyInputs = getDefaultAttributeToPropertyInputs(inputs);
      class NgElementImpl extends NgElement {
          /**
           * @param {?=} injector
           */
          constructor(injector) {
              super();
              // Note that some polyfills (e.g. document-register-element) do not call the constructor.
              // Do not assume this strategy has been created.
              // TODO(andrewseguin): Add e2e tests that cover cases where the constructor isn't called. For
              // now this is tested using a Google internal test suite.
              this.ngElementStrategy = strategyFactory.create(injector || config$$1.injector);
          }
          /**
           * @param {?} attrName
           * @param {?} oldValue
           * @param {?} newValue
           * @param {?=} namespace
           * @return {?}
           */
          attributeChangedCallback(attrName, oldValue, newValue, namespace) {
              if (!this.ngElementStrategy) {
                  this.ngElementStrategy = strategyFactory.create(config$$1.injector);
              }
              /** @type {?} */
              const propName = (/** @type {?} */ (attributeToPropertyInputs[attrName]));
              this.ngElementStrategy.setInputValue(propName, newValue);
          }
          /**
           * @return {?}
           */
          connectedCallback() {
              if (!this.ngElementStrategy) {
                  this.ngElementStrategy = strategyFactory.create(config$$1.injector);
              }
              this.ngElementStrategy.connect(this);
              // Listen for events from the strategy and dispatch them as custom events
              this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {
                  /** @type {?} */
                  const customEvent = createCustomEvent((/** @type {?} */ (this.ownerDocument)), e.name, e.value);
                  this.dispatchEvent(customEvent);
              });
          }
          /**
           * @return {?}
           */
          disconnectedCallback() {
              if (this.ngElementStrategy) {
                  this.ngElementStrategy.disconnect();
              }
              if (this.ngElementEventsSubscription) {
                  this.ngElementEventsSubscription.unsubscribe();
                  this.ngElementEventsSubscription = null;
              }
          }
      }
      // Work around a bug in closure typed optimizations(b/79557487) where it is not honoring static
      // field externs. So using quoted access to explicitly prevent renaming.
      NgElementImpl['observedAttributes'] = Object.keys(attributeToPropertyInputs);
      // Add getters and setters to the prototype for each property input. If the config does not
      // contain property inputs, use all inputs by default.
      inputs.map(({ propName }) => propName).forEach(property => {
          Object.defineProperty(NgElementImpl.prototype, property, {
              get: function () { return this.ngElementStrategy.getInputValue(property); },
              set: function (newValue) { this.ngElementStrategy.setInputValue(property, newValue); },
              configurable: true,
              enumerable: true,
          });
      });
      return (/** @type {?} */ (((/** @type {?} */ (NgElementImpl)))));
  }

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
   */
  /**
   * \@publicApi
   * @type {?}
   */
  const VERSION$6 = new Version$1('7.2.8');

  class MyButtonComponent {
      constructor() { }
      onClick(e) {
          console.log(e);
      }
  }
  MyButtonComponent.decorators = [
      { type: Component, args: [{
                  selector: 'my-button',
                  template: `
  <span>{{model}}</span>
  `,
                  styles: [`
  :host {
    background: rgba(24, 24, 24, 1);
    cursor: pointer;
    color: white;
    font-weight: 400;
    padding-top: 4px;
    padding-bottom: 4px;
    padding-left: 8px;
    padding-right: 8px;
    border-radius: 4px;
    min-width: 120px;
    text-align: center;
    user-select: none;
  }
  `],
                  encapsulation: ViewEncapsulation$1.Native
              },] },
  ];
  MyButtonComponent.ctorParameters = () => [];
  MyButtonComponent.propDecorators = {
      model: [{ type: Input }],
      onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
  };

  class AppModule {
      constructor(injector) {
          this.injector = injector;
          const customElement = createCustomElement(MyButtonComponent, { injector });
          customElements.define('my-button', customElement);
      }
      ngDoBootstrap() { }
  }
  AppModule.decorators = [
      { type: NgModule, args: [{
                  imports: [
                      BrowserModule
                  ],
                  declarations: [
                      MyButtonComponent
                  ],
                  entryComponents: [
                      MyButtonComponent
                  ],
                  providers: []
              },] },
  ];
  AppModule.ctorParameters = () => [
      { type: Injector }
  ];

  platformBrowserDynamic().bootstrapModule(AppModule);

}());
